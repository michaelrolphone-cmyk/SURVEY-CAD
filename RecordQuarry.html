<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>RecordQuarry — Ada County Survey Context Lookup (Standalone)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- pdf.js (UMD build defining window.pdfjsLib) -->
  <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
 <link rel="stylesheet" href="/assets/styles/shared-ui.css" />


  <style>
    :root{
      --bg:#0b1020;
      --panel:#101834;
      --panel2:#0e1630;
      --text:#e7ecff;
      --muted:#b6c0ff;
      --line:rgba(255,255,255,.12);
      --good:#24d18f;
      --warn:#ffcc66;
      --bad:#ff5a7a;
      --btn:#2a3dff;
      --btn2:#1a255f;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;min-height:100dvh;margin:0;background:var(--bg);color:var(--text);font-family:var(--sans)}
    /* hide page scrollbar */
    html { scrollbar-width: none; } /* Firefox */
    body { -ms-overflow-style: none; } /* IE and Edge */
    body::-webkit-scrollbar, body::-webkit-scrollbar-button { display: none; } /* Chrome */
    /* end hide page scrollbar */
    a{color:#9ab0ff;text-decoration:none}
    a:hover{text-decoration:underline}

    .app{
      height:100%;
      min-height:100dvh;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    header{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:none;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0));
    }
    header .title{font-weight:700;letter-spacing:.2px;}
    header .subtitle{color:var(--muted);font-size:12px;}

    .main{
      flex:1;
      min-height:0;
      display:grid;
      grid-template-columns: 430px 1fr;
      gap:10px;
      /* padding:10px; */
    }
    @media (max-width: 980px){
      .main{grid-template-columns:1fr; grid-template-rows: 460px 1fr;}
    }

    .panel{
      background:rgba(255,255,255,.03);
      border:1px solid var(--line);
      /* padding: 12px !important; */
      /* border-radius:12px; */
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
      position: relative;
    }
    .panel .phead{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background:rgba(255,255,255,.03);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex:0 0 auto;
    }
    .panel .phead .h{font-weight:700;font-size:13px;}

    /* IMPORTANT: make panel bodies expand so Leaflet has real height */
    .panel .pbody{
      padding:12px;
      overflow:auto;
      min-height:0;
      flex:1 1 auto;   /* <-- KEY FIX */
    }

    .row{display:flex;gap:10px;align-items:center}
    .row.wrap{flex-wrap:wrap}
    label{font-size:12px;color:var(--muted)}
    input[type="text"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.2);
      color:var(--text);
      outline:none;
    }
    input[type="file"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px dashed var(--line);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      outline:none;
    }

    input[type="range"]{
      width:100%;
      margin-top:8px;
    }
    button{
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg, rgba(42,61,255,.9), rgba(26,37,95,.9));
      color:white;
      font-weight:700;
      cursor:pointer;
      white-space:nowrap;
    }
    button.secondary{
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--text);
      font-weight:600;
    }
    button.workflowPrimary{
      background:linear-gradient(180deg, rgba(42,61,255,1), rgba(26,37,95,.96));
      border:1px solid rgba(116,140,255,.85);
      box-shadow:0 0 0 1px rgba(255,255,255,.16) inset, 0 10px 26px rgba(42,61,255,.28);
    }
    button:disabled{opacity:.5;cursor:not-allowed}

    #btnExportPointForge {
      position: absolute;
      right: 20px;
      top: 20px;
      z-index: 10000;
    }
    
    .workflowAction{
      margin-left:auto;
    }

    .small{font-size:12px;color:var(--muted)}
    .mono{font-family:var(--mono);font-size:12px}
    .hr{height:1px;background:var(--line);margin:10px 0}

    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:5px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.2);
      font-size:12px;
      color:var(--muted);
      margin:2px 6px 2px 0;
    }
    .pill .dot{width:8px;height:8px;border-radius:99px;background:var(--muted);opacity:.9}
    .pill.good .dot{background:var(--good)}
    .pill.warn .dot{background:var(--warn)}
    .pill.bad  .dot{background:var(--bad)}

    .hint{
      padding:10px;
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:12px;
    }

    .log{
      font-family:var(--mono);
      font-size:12px;
      line-height:1.35;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
      white-space:pre-wrap;
      overflow-wrap:anywhere;
      word-break:break-word;
      max-height:260px;
      overflow:auto;
    }

    .list{display:flex;flex-direction:column;gap:10px;}
    .card{
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(0,0,0,.14);
      overflow:hidden;
      position:relative;
    }
    .rq-star-btn{
      position:absolute;
      top:0.3rem;
      right:0.45rem;
      background:none;
      border:none;
      cursor:pointer;
      font-size:1.05rem;
      line-height:1;
      padding:2px;
      color:#64748b;
      opacity:0.65;
      transition:color 150ms ease,opacity 150ms ease;
    }
    .rq-star-btn:hover:not(:disabled){
      opacity:1;
      color:#e2e8f0;
    }
    .rq-star-btn[aria-pressed="true"]{
      color:#eab308;
      opacity:1;
    }
    .rq-star-btn:disabled{
      cursor:not-allowed;
      opacity:0.35;
    }
    .card.clickable{
      cursor:pointer;
      transition:border-color .16s ease, box-shadow .16s ease, transform .16s ease;
    }
    .card.clickable:hover,
    .card.clickable:focus-visible{
      border-color:rgba(106,169,255,.7);
      box-shadow:0 0 0 2px rgba(106,169,255,.25);
      transform:translateY(-1px);
      outline:none;
    }
    .card .chead{
      padding:10px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:flex-start;
    }

    /* Prevent star button from overlapping distance badge in card headers */
    .card.aliquot-card > .chead,
    .card.ros-card > .chead,
    .card.subdivision-card > .chead{
      padding-right:44px;
    }
    .card .cbody{padding:10px;}
    .kv{
      display:grid;
      grid-template-columns: 130px 1fr;
      gap:6px 10px;
      font-size:12px;
      color:var(--muted);
    }
    .kv div:nth-child(2n){
      color:var(--text);
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Right side: ensure map gets height */
    .rightBody{
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden; /* prevent nested scrollbars */
    }
    .mapWrap{
      flex:1 1 auto;
      min-height:320px; /* <-- map always has real height */
      position:relative;
    }
    #map{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      border-radius:12px;
    }
    @media (max-width: 980px){
      .mapWrap{min-height:420px;}
    }

    @media (max-width: 760px){
      header{
        flex-direction:column;
        align-items:flex-start;
      }
      header .row,
      .panel .phead .row{
        width:100%;
        flex-wrap:wrap;
      }
      .panel .phead{
        flex-direction:column;
        align-items:flex-start;
      }
      .panel .phead .row button{
        flex:1 1 140px;
      }
      .main{
        grid-template-rows:minmax(460px, auto) minmax(420px, 1fr);
      }
      .mapWrap{
        min-height:360px;
      }
    }

    .cpf-collapsed{display:flex;gap:8px;align-items:flex-start}
    .cpf-thumb{width:60px;height:76px;object-fit:cover;border-radius:4px;border:1px solid var(--line);flex-shrink:0;background:rgba(0,0,0,.3);cursor:pointer}
    .cpf-collapsed-info{flex:1;min-width:0}
    .cpf-expand-btn{font-size:11px;padding:3px 8px;margin-top:5px}
    .cpf-record-row{margin-top:8px;padding-top:8px;border-top:1px solid var(--line);cursor:pointer}
    .cpf-record-row:hover{background:rgba(255,255,255,.03)}
    .cpf-inst{display:inline-block;max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}


    /* Aliquot distance badge & collapsible cards */
    .dist-badge{font-size:10px;color:var(--muted);background:rgba(255,255,255,.07);border-radius:4px;padding:1px 6px;flex-shrink:0;white-space:nowrap}
    .dist-badge.is-far{color:var(--warn)}
    .chead-chevron{font-size:10px;opacity:.55;transition:transform .18s ease;flex-shrink:0;margin-left:2px}
    .card.aliquot-card > .chead{cursor:pointer;user-select:none}
    .card.aliquot-card.is-far > .cbody{display:none}
    .card.aliquot-card.is-far.is-expanded > .cbody{display:block}
    .card.aliquot-card.is-far:not(.is-expanded) .chead-chevron{transform:rotate(-90deg)}
    .card.ros-card > .chead{cursor:default;user-select:auto}
    .card.ros-card.is-far > .cbody{display:none}
    .card.ros-card.is-far.is-expanded > .cbody{display:none}
    .card.ros-card.is-far:not(.is-expanded) .chead-chevron{transform:rotate(-90deg)}
    .card.ros-card .cbody {
      /* display:none; */
    }
     .ros-scan-thumb{
      display:flex;
       max-width:100%;
       width:120px;
       border-radius:8px;
       border:1px solid var(--line);
       margin:6px 0;
       background:rgba(0,0,0,.2);
      padding: 2px;
      margin: 5px;
     float:left;
     }
    /* ROS card compact layout */
    .ros-thumb-float{
      float:left;
      padding:10px 0 10px 10px;
    }
    .subdivision-thumb-float{
      float:left;
      padding:10px 0 10px 10px;
    }
    
    /* Address card: parcel geometry thumbnail (aligned right) */
    .card.address-card > .chead,
    .card.address-card > .cbody{
      padding-right:120px;
    }
    .card.address-card .addr-parcel-thumb{
      position:absolute;
      top:10px;
      right:10px;
      width:92px;
      height:92px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }
    .card.address-card .addr-parcel-thumb svg{
      width:100%;
      height:100%;
      display:block;
      color:var(--text);
    }
    .card.address-card .addr-parcel-thumb path{
      fill:none;
      stroke:currentColor;
      stroke-width:2;
      vector-effect:non-scaling-stroke;
    }
.ros-thumb-float > .ros-scan-thumb{
      float:none;
      display:block;
      margin:0;
    }
.subdivision-thumb-float > .subdivision-plat-thumb{
      float:none;
      display:block;
      margin:0;
    }
    /* Hide ROS card body for now (content is preserved in DOM, just collapsed). */
.card.ros-card > .cbody{ display:none !important; }
.card.ros-card.is-expanded > .cbody{ display:none !important; }
.card.ros-card .chead-chevron{ display:none !important; }
.card.ros-card .chead > div > div:first-child{ font-size:10pt; }
.rq-hover-preview-tooltip{
      position:fixed;
      pointer-events:none;
      opacity:0;
      z-index:12000;
      border-radius:10px;
      overflow:hidden;
      border:1px solid var(--line);
      background:rgba(4,8,24,.96);
      box-shadow:0 18px 48px rgba(0,0,0,.48);
      transition:opacity .12s ease;
    }
    .rq-hover-preview-tooltip.visible{opacity:1}
    .rq-hover-preview-image{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
      background:rgba(0,0,0,.3);
    }

    /* Distance-group collapse ("See More") */
    .rq-distance-group{border-style:dashed;background:rgba(255,255,255,.03)}
    .rq-distance-group .chead{border-bottom:0}
    .rq-distance-group-title{font-weight:700;letter-spacing:.2px}
    .rq-distance-group-sub{font-size:12px;color:var(--muted);margin-top:2px}
    .rq-see-more-btn{white-space:nowrap}


    .busyModal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(1, 5, 20, 0.74);
      backdrop-filter: blur(1px);
      z-index:9999;
      padding:16px;
    }
    .busyModal.is-open{display:flex;}
    .busyModalCard{
      width:min(460px, 100%);
      border-radius:14px;
      border:1px solid var(--line);
      background:var(--panel2);
      box-shadow:0 18px 46px rgba(0,0,0,.42);
      padding:18px 16px;
      text-align:center;
    }
    .busySpinner{
      width:34px;
      height:34px;
      margin:0 auto 10px;
      border-radius:50%;
      border:3px solid rgba(255,255,255,.2);
      border-top-color:var(--good);
      animation:spinBusy .85s linear infinite;
    }
    @keyframes spinBusy {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
  <script type="module" src="/src/browser-localstorage-sync.js"></script>
</head>

<body>
<div class="app">
  <header><div class="title">RecordQuarry — Ada County Survey Context Lookup (Standalone)</div></header>
  <div class="main">
    <!-- LEFT -->
    <div class="panel">
      <div class="phead" style="display:none;">
        <div class="h">Lookup</div>
        <div class="row">
          <button id="btnLookup">Lookup</button>
          <button id="btnClear" class="secondary">Clear</button>
          <button id="btnExportParcelCSV" class="secondary" disabled title="Exports unique parcel, subdivision, and aliquot vertices as P,N,E,Z,D in EPSG:2243 (ID West ftUS)">Export CSV</button>
        </div>
      </div>
      <div class="pbody">
        <label for="addr">Address (Ada County, ID)</label>
        <input id="addr" type="text" placeholder="e.g. 5707 W Castle Dr, Boise ID" value=""/>

        <div class="hr" style="display:none"></div>

        <div class="phead" style="padding:0;border:0;background:transparent;justify-content:flex-start;display:none">
          <div class="h">PDF Basis of Bearing (local upload)</div>
        </div>
        <input id="pdfFile" type="file" accept="application/pdf" style="display:none"/>
        <button id="btnScanPdf" class="secondary" style="width:100%;margin-top:10px;display:none">Scan Uploaded PDF</button>
        <div id="pdfFindings" class="log" style="margin-top:10px;display:none"></div>

        <div class="hr" style="display:none"></div>

        <div class="phead" style="padding:0;border:0;background:transparent;justify-content:flex-start">
          <div class="h">Summary</div>
        </div>
        <div id="summary" class="list" style="margin-top:10px"></div>

        <div class="hr" style="display:none"></div>

        <div class="phead" style="padding:0;border:0;background:transparent;justify-content:flex-start;display:none">
          <div class="h">Diagnostics</div>
        </div>
        <div id="log" class="log" style="margin-top:10px;display:none"></div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="panel">
      <button id="btnExportPointForge" class="workflowPrimary workflowAction" disabled title="Sends aliquot corner coordinates to PointForge">Export to PointForge</button>
      <label style="display:flex;align-items:center;gap:8px;margin:8px 0 2px;color:var(--muted);font-size:12px;">
        <input id="overwriteEvidenceRecords" type="checkbox" style="margin:0"/>
        Overwrite CP&amp;F, Record of Survey, and Subdivision records in EvidenceDesk on export
      </label>
      <div class="pbody rightBody">
        <div class="mapWrap">
          <div id="map"></div>
        </div>
      </div>
    </div>

  </div>
</div>

<div id="busyModal" class="busyModal" role="status" aria-live="polite" aria-hidden="true">
  <div class="busyModalCard">
    <div class="busySpinner" aria-hidden="true"></div>
    <div id="busyModalMessage">Processing export…</div>
    <div id="busyModalDetail" class="small" style="margin-top:8px">Gathering CPNF instrument numbers for exported points.</div>
  </div>
</div>

<script type="module">
(async () => {
  // --- module deps (robust paths) ---
  let lookupByAddress, fetchParcelNearPoint, loadAliquotsAtPoint, loadSubdivisionAtPoint, loadUtilitiesByAddress, buildRosPdfProxyUrl;
  let buildAliquotSelectionKey, buildPointMarkerCsvRowsPNEZD, buildPowerUtilityMarkersForPointForge, buildRosBoundaryCsvRowsPNEZD, filterAliquotFeaturesForExport, filterParcelFeatureForExport;

  try {
    const [surveyClientMod, rosExportMod] = await Promise.all([
      import('/src/browser-survey-client.js').catch(() => import('./src/browser-survey-client.js')),
      import('/src/ros-export.js').catch(() => import('./src/ros-export.js')),
    ]);

    ({
      lookupByAddress,
      findParcelNearPoint: fetchParcelNearPoint,
      loadAliquotsAtPoint,
      loadSubdivisionAtPoint,
      loadUtilitiesByAddress,
      buildRosPdfProxyUrl,
    } = surveyClientMod);

    ({
      buildAliquotSelectionKey,
      buildPointMarkerCsvRowsPNEZD,
      buildPowerUtilityMarkersForPointForge,
      buildRosBoundaryCsvRowsPNEZD,
      filterAliquotFeaturesForExport,
      filterParcelFeatureForExport,
    } = rosExportMod);
  } catch (e) {
    console.error(e);
    alert("RecordQuarry failed to load required modules (/src/browser-survey-client.js, /src/ros-export.js). Check network paths.");
    return;
  }
  // -----------------------------
  // Configuration (Ada County)
  // -----------------------------
  const BASE = "https://adacountyassessor.org/arcgis/rest/services/External/ExternalMap/MapServer";
  const LAYERS = {
    address: 16,
    ros: 17,
    subdivisions: 18,
    townships: 19,
    sections: 20,
    parcels: 24,
  };

  // EPSG:2243 (NAD83 / Idaho West ftUS) for export.
  // We do NOT client-project; we request outSR=2243 from the server (no CORS via JSONP).
  const EXPORT_OUT_SR = 2243;

  // Ada County CP&F record lookup (used when clicking corner markers).
  const ADA_PORTAL_BASE = "https://gisprod.adacounty.id.gov/arcgis";
  const ADA_CPF_WEBMAP_ITEM_ID = "019521c7932442f0b4b581f641cbf236";
  const ADA_CPF_PDF_BASE = "https://gisprod.adacounty.id.gov/apps/acdscpf/CpfPdfs/";
  const POINTFORGE_ROS_IMPORT_STORAGE_KEY = "pointforgeRosImport";
  const PROJECT_LOOKUP_STORAGE_PREFIX = "surveyfoundryProjectLookup";
  const ADDRESS_LOOKUP_STORAGE_PREFIX = "surveyfoundryAddressLookup";
  const PROJECT_FILE_STORAGE_PREFIX = "surveyfoundryProjectFile";
  const LAST_LOOKUP_ADDRESS_STORAGE_KEY = "surveyfoundryLastLookupAddress";
  const SUBDIVISION_NEARBY_RADIUS_FT = 666;
  const SUBDIVISION_NEARBY_RADIUS_M = SUBDIVISION_NEARBY_RADIUS_FT * 0.3048;
  const SUBDIVISION_NEARBY_MAX_RESULTS = 18;
  const SUBDIVISION_DRAW_MAX_VERTICES = 1200;
  const SUBDIVISION_PLAT_LIST_URL = '/api/recordquarry/subdivision-plats/page-list';
  const SUBDIVISION_PLAT_BASE_URL = 'https://adacountyassessor.org/docs/subdivisionplats/';
  const SUBDIVISION_THUMB_PLACEHOLDER_DATA_URL = `data:image/svg+xml;utf8,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="240" height="160" viewBox="0 0 240 160"><defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="#1f2e48"/><stop offset="1" stop-color="#121923"/></linearGradient></defs><rect width="240" height="160" rx="12" fill="url(#g)"/><rect x="12" y="12" width="216" height="136" rx="8" fill="none" stroke="#5b6a81" stroke-width="1.5"/><g fill="#d8e0ee" opacity="0.94"><path d="M56 114h128v10H56z"/><path d="M56 98h96v8H56z"/><path d="M56 50h128v40H56z" fill="none" stroke="#d8e0ee" stroke-width="2"/><path d="M66 82l22-18 18 14 22-20 46 36z"/></g><text x="120" y="138" text-anchor="middle" font-family="Arial,sans-serif" font-size="11" fill="#d8e0ee">Generating plat thumbnail…</text></svg>')}`;

  // pdf.js worker
  if (!window.pdfjsLib) {
    alert("pdf.js failed to load (pdfjsLib missing). Check network access.");
  } else {
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
  }

  // -----------------------------
  // UI helpers
  // -----------------------------
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  function ts() {
    const d = new Date();
    return d.toISOString().replace("T"," ").replace("Z","");
  }
  function log(line, kind="info") {
    const prefix = kind === "bad" ? "✖" : kind === "warn" ? "⚠" : "•";
    logEl.textContent += `[${ts()}] ${prefix} ${line}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function clearLog() { logEl.textContent = ""; }

  function setBusyModalOpen(isOpen, message = 'Processing export…', detail = 'Gathering CPNF instrument numbers for exported points.') {
    const modal = $("busyModal");
    const msg = $("busyModalMessage");
    const detailEl = $("busyModalDetail");
    msg.textContent = message;
    detailEl.textContent = detail;
    modal.classList.toggle('is-open', !!isOpen);
    modal.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
  }

  function getProjectContext() {
    const params = new URLSearchParams(window.location.search || "");
    const projectId = params.get("projectId") || params.get("activeProjectId") || "";
    const launchProject = loadLaunchProject(projectId);
    const address = launchProject?.address
      || params.get("address")
      || params.get("activeAddress")
      || "";
    const projectName = launchProject?.name
      || params.get("projectName")
      || params.get("activeProjectName")
      || "";
    const client = launchProject?.client
      || params.get("client")
      || params.get("activeClient")
      || "";
    const autostart = params.get("autostart") === "1";
    return { projectId, address, projectName, client, autostart };
  }

  function loadLaunchProject(projectId) {
    const normalizedProjectId = String(projectId || '').trim();
    if (!normalizedProjectId) return null;
    try {
      const raw = localStorage.getItem('surveyfoundryProjects');
      if (!raw) return null;
      const projects = JSON.parse(raw);
      if (!Array.isArray(projects)) return null;
      return projects.find((entry) => String(entry?.id || '') === normalizedProjectId) || null;
    } catch {
      return null;
    }
  }

  function projectLookupStorageKey(projectId) {
    return `${PROJECT_LOOKUP_STORAGE_PREFIX}:${projectId}`;
  }

  function projectFileStorageKey(projectId) {
    return `${PROJECT_FILE_STORAGE_PREFIX}:${projectId}`;
  }

  function normalizeAddressStorageKey(address) {
    return String(address || '').trim().toLowerCase().replace(/\s+/g, ' ');
  }

  function addressLookupStorageKey(address) {
    return `${ADDRESS_LOOKUP_STORAGE_PREFIX}:${normalizeAddressStorageKey(address)}`;
  }

  async function loadProjectLookupSnapshot(projectId) {
    if (!projectId) return null;
    try {
      const resp = await fetch(`/api/projects/${encodeURIComponent(projectId)}/record-quarry-cache`);
      if (resp.ok) {
        const data = await resp.json();
        if (data?.cache?.lookup) return data.cache;
      }
    } catch {}
    try {
      const raw = localStorage.getItem(projectLookupStorageKey(projectId));
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object" || !parsed.lookup) return null;
      return parsed;
    } catch {
      return null;
    }
  }

  async function saveProjectLookupSnapshot(projectId, snapshot) {
    if (!projectId || !snapshot) return;
    try {
      await fetch(`/api/projects/${encodeURIComponent(projectId)}/record-quarry-cache`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(snapshot),
      });
    } catch {}
    try {
      localStorage.setItem(projectLookupStorageKey(projectId), JSON.stringify(snapshot));
    } catch {}
  }

  function loadAddressLookupSnapshot(address) {
    const normalized = normalizeAddressStorageKey(address);
    if (!normalized) return null;
    try {
      const raw = localStorage.getItem(addressLookupStorageKey(normalized));
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object' || !parsed.lookup) return null;
      return parsed;
    } catch {
      return null;
    }
  }

  async function saveAddressLookupSnapshot(address, snapshot) {
    const normalized = normalizeAddressStorageKey(address);
    if (!normalized || !snapshot) return;
    try {
      await fetch(`/api/record-quarry-cache?address=${encodeURIComponent(normalized)}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...snapshot, address: normalized }),
      });
    } catch {}
    try {
      localStorage.setItem(addressLookupStorageKey(normalized), JSON.stringify(snapshot));
      localStorage.setItem(LAST_LOOKUP_ADDRESS_STORAGE_KEY, normalized);
    } catch {}
  }

  function loadMostRecentAddressLookupSnapshot() {
    const recentAddress = normalizeAddressStorageKey(localStorage.getItem(LAST_LOOKUP_ADDRESS_STORAGE_KEY));
    if (!recentAddress) return null;
    return loadAddressLookupSnapshot(recentAddress);
  }

  function applySelectionByMode(targetSet, allKeys, selectedKeys, deselectedKeys, defaultSelected = false) {
    targetSet.clear();
    if (Array.isArray(selectedKeys) && selectedKeys.length) {
      for (const key of selectedKeys) {
        if (allKeys.has(key)) targetSet.add(key);
      }
      return;
    }
    if (Array.isArray(deselectedKeys)) {
      const excluded = new Set(deselectedKeys);
      for (const key of allKeys) {
        if (!excluded.has(key)) targetSet.add(key);
      }
      return;
    }
    if (defaultSelected) {
      for (const key of allKeys) targetSet.add(key);
    }
  }

  function readSelectionSnapshot() {
    const allAliquotKeys = buildAllSelectedAliquotKeys(state.aliquotFeatures);
    const selectedAliquotKeys = [...state.selectedAliquotKeys];
    const deselectedAliquotKeys = [...allAliquotKeys].filter((key) => !state.selectedAliquotKeys.has(key));
    const allRosKeys = buildAllRosSelectionKeys(state.rosFeatures);
    const selectedRosKeys = [...state.selectedRosKeys];
    const deselectedRosKeys = [...allRosKeys].filter((key) => !state.selectedRosKeys.has(key));
    const allSubdivisionKeys = buildAllSubdivisionSelectionKeys(state.nearbySubdivisions);
    const selectedSubdivisionKeys = [...state.selectedSubdivisionKeys];
    const deselectedSubdivisionKeys = [...allSubdivisionKeys].filter((key) => !state.selectedSubdivisionKeys.has(key));
    return {
      selectedParcel: Boolean(state.selectedParcel),
      selectedAliquotKeys,
      deselectedAliquotKeys,
      selectedRosKeys,
      deselectedRosKeys,
      selectedSubdivisionKeys,
      deselectedSubdivisionKeys,
    };
  }

  function isFiniteCoordinate(value) {
    return Number.isFinite(Number(value));
  }

  function summarizeLookupForAddressCache(lookup = null) {
    if (!lookup || typeof lookup !== 'object') {
      return { location: null, geocode: null };
    }
    const locationLon = isFiniteCoordinate(lookup?.location?.lon)
      ? Number(lookup.location.lon)
      : (isFiniteCoordinate(lookup?.geocode?.lon)
        ? Number(lookup.geocode.lon)
        : (isFiniteCoordinate(lookup?.addressFeature?.geometry?.x) ? Number(lookup.addressFeature.geometry.x) : null));
    const locationLat = isFiniteCoordinate(lookup?.location?.lat)
      ? Number(lookup.location.lat)
      : (isFiniteCoordinate(lookup?.geocode?.lat)
        ? Number(lookup.geocode.lat)
        : (isFiniteCoordinate(lookup?.addressFeature?.geometry?.y) ? Number(lookup.addressFeature.geometry.y) : null));

    const hasCoordinates = Number.isFinite(locationLon) && Number.isFinite(locationLat);
    const display = typeof lookup?.geocode?.display === 'string' && lookup.geocode.display.trim()
      ? lookup.geocode.display.trim()
      : null;

    return {
      location: hasCoordinates ? { lon: locationLon, lat: locationLat } : null,
      geocode: hasCoordinates
        ? {
          lat: locationLat,
          lon: locationLon,
          display,
        }
        : null,
    };
  }

  function canUseCachedLookupPayload(lookup = null) {
    if (!lookup || typeof lookup !== 'object') return false;
    return !!lookup.parcel;
  }

  function applySelectionSnapshot(selection = null) {
    const selectedParcel = selection?.selectedParcel;
    setParcelSelected(selectedParcel == null ? true : Boolean(selectedParcel));

    applySelectionByMode(
      state.selectedAliquotKeys,
      buildAllSelectedAliquotKeys(state.aliquotFeatures),
      selection?.selectedAliquotKeys,
      selection?.deselectedAliquotKeys,
      false
    );

    applySelectionByMode(
      state.selectedRosKeys,
      buildAllRosSelectionKeys(state.rosFeatures),
      selection?.selectedRosKeys,
      selection?.deselectedRosKeys,
      false
    );

    applySelectionByMode(
      state.selectedSubdivisionKeys,
      buildAllSubdivisionSelectionKeys(state.nearbySubdivisions),
      selection?.selectedSubdivisionKeys,
      selection?.deselectedSubdivisionKeys,
      false
    );
  }

  async function saveLookupSnapshotsForCurrentState(address) {
    const normalizedAddress = normalizeAddressStorageKey(address);
    if (!normalizedAddress || !state.lastLookupPayload) return;
    const snapshot = {
      savedAt: new Date().toISOString(),
      address: normalizedAddress,
      lookup: summarizeLookupForAddressCache(state.lastLookupPayload),
      selection: readSelectionSnapshot(),
    };
    await saveAddressLookupSnapshot(normalizedAddress, snapshot);
  }

  function slugify(value, fallback = 'resource') {
    const slug = String(value || '')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
    return slug || fallback;
  }

  function createProjectFileFolder(key, label, description) {
    return { key, label, description, index: [] };
  }

  function defaultProjectFile(context = {}) {
    const projectId = context.projectId || `project-${Date.now()}`;
    const projectName = context.projectName || 'Untitled Project';
    return {
      schemaVersion: '1.0.0',
      generatedAt: new Date().toISOString(),
      project: {
        id: projectId,
        name: projectName,
        client: context.client || '',
        address: context.address || '',
      },
      archive: {
        type: 'zip',
        rootFolderName: `${slugify(projectName, 'surveyfoundry-project')}-${slugify(projectId, 'project')}`,
      },
      folders: [
        createProjectFileFolder('drawings', 'Drawings', 'LineSmith drawing packages generated from linked point files.'),
        createProjectFileFolder('ros', 'RoS', 'Record of Survey source files and exports.'),
        createProjectFileFolder('cpfs', 'CP&Fs', 'Corner Perpetuation & Filing references resolved by instrument number.'),
        createProjectFileFolder('point-files', 'Point Files', 'PointForge-managed points exported as CSV.'),
        createProjectFileFolder('deeds', 'Deeds', 'Deed references and exported documents.'),
        createProjectFileFolder('plats', 'Plats', 'Subdivision plats and plat-related exhibits.'),
        createProjectFileFolder('invoices', 'Invoices', 'Billing artifacts and project invoices.'),
        createProjectFileFolder('other', 'Other', 'Future expansion area for additional project evidence types.'),
      ],
    };
  }

  function loadProjectFileSnapshot(projectContext = {}) {
    const projectId = projectContext.projectId || '';
    if (!projectId) return null;
    try {
      const raw = localStorage.getItem(projectFileStorageKey(projectId));
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object' || !Array.isArray(parsed.folders)) return null;
      return parsed;
    } catch {
      return null;
    }
  }

  function saveProjectFileSnapshot(projectContext = {}, projectFile) {
    const projectId = projectContext.projectId || '';
    if (!projectId || !projectFile) return;
    localStorage.setItem(projectFileStorageKey(projectId), JSON.stringify(projectFile));
  }

  function ensureProjectFileFolder(projectFile, folderKey) {
    if (!projectFile || !Array.isArray(projectFile.folders)) return null;
    const existing = projectFile.folders.find((folder) => folder.key === folderKey);
    if (existing) {
      if (!Array.isArray(existing.index)) existing.index = [];
      return existing;
    }
    const fallback = createProjectFileFolder(folderKey, folderKey, '');
    projectFile.folders.push(fallback);
    return fallback;
  }

  function parseCpfInstrumentsFromNotesMap(notesByCoordinate = new Map()) {
    const instruments = new Set();
    for (const note of notesByCoordinate.values()) {
      const raw = String(note || '').trim();
      if (!raw) continue;
      const normalized = raw.replace(/^CPNFS?:\s*/i, '');
      const parts = normalized.split(/(?:\.{3}|…|,|;|\n)+/g);
      for (const item of parts) {
        const instrument = normalizeCpInstrumentNumber(item);
        if (instrument) instruments.add(instrument);
      }
    }
    return [...instruments].sort();
  }

  function normalizeCpInstrumentNumber(value) {
    return String(value || '')
      .trim()
      .replace(/\s+/g, ' ')
      .toUpperCase();
  }

  function addProjectFileResource(projectFile, resource) {
    const folder = ensureProjectFileFolder(projectFile, resource.folder);
    if (!folder) return;
    const referenceType = String(resource?.reference?.type ?? '').trim();
    const referenceValue = referenceType === 'instrument-number'
      ? normalizeCpInstrumentNumber(resource?.reference?.value)
      : String(resource?.reference?.value ?? '');
    if (!referenceType || !referenceValue) return;

    const exists = folder.index.some((item) => (
      String(item?.reference?.type ?? '').trim() === referenceType
      && (
        referenceType === 'instrument-number'
          ? normalizeCpInstrumentNumber(item?.reference?.value) === referenceValue
          : String(item?.reference?.value ?? '') === referenceValue
      )
    ));
    if (!exists) {
      folder.index.push({
        ...resource,
        reference: {
          ...(resource.reference || {}),
          type: referenceType,
          value: referenceValue,
        },
      });
    }
  }


  function replaceProjectFileFolderResources(projectFile, folderKey, resources = []) {
    const folder = ensureProjectFileFolder(projectFile, folderKey);
    if (!folder) return;
    folder.index = [];
    for (const resource of resources) addProjectFileResource(projectFile, resource);
  }

  function resolveProjectContextForProjectFile(projectContext = {}) {
    if (projectContext?.projectId) return projectContext;
    const runtimeContext = getProjectContext();
    if (runtimeContext?.projectId) {
      return {
        ...projectContext,
        ...runtimeContext,
      };
    }
    return projectContext;
  }

  async function persistPointForgeExportProjectFile({ projectContext = {}, notesByCoordinate, csv, pointCount, overwriteEvidenceRecords = false }) {
    const resolvedProjectContext = resolveProjectContextForProjectFile(projectContext);
    if (!resolvedProjectContext.projectId) return null;

    const projectFile = loadProjectFileSnapshot(resolvedProjectContext) || defaultProjectFile(resolvedProjectContext);
    const exportTimestamp = new Date().toISOString();
    const cpfInstruments = parseCpfInstrumentsFromNotesMap(notesByCoordinate);
    const selectedRos = (state.rosFeatures || [])
      .map((feature, index) => ({ feature, index }))
      .filter(({ feature, index }) => isRosSelected(feature, index));
    const selectedSubdivisions = getSelectedSubdivisionEntries(state.nearbySubdivisions)
      .map((entry, index) => ({ entry, index }));
    const platsPayload = [];
    const cpfResources = [];
    const platResources = [];
    const rosResources = [];

    for (const instrument of cpfInstruments) {
      const resource = {
        id: `cpf-${slugify(instrument, 'instrument')}`,
        folder: 'cpfs',
        title: `CP&F ${instrument}`,
        exportFormat: 'pdf',
        reference: {
          type: 'instrument-number',
          value: instrument,
          resolverHint: 'lookup-cpf-pdf',
          metadata: { instrument },
        },
      };
      cpfResources.push(resource);
      addProjectFileResource(projectFile, resource);
    }

    for (const { entry, index } of selectedSubdivisions) {

      const feature = entry?.feature || null;
      if (!feature) continue;
      const attrs = feature.attributes || {};
      const subdivisionName = String(entry?.name || getSubdivisionNameFromAttrs(attrs) || `Subdivision ${index + 1}`).trim();
      const platUrl = String(entry?.plat?.platUrl || '').trim();
      const thumbnailUrl = String(entry?.plat?.thumbnailUrl || '').trim();
      const subdivisionMetadata = buildSubdivisionMetadataForExport(entry, index);
      const sourceId = String(subdivisionMetadata.sourceId || `${index + 1}`).trim();
      const platId = slugify(`${subdivisionName}-${sourceId}`, `subdivision-${index + 1}`);
      const resource = {
        id: `plat-${platId}`,
        folder: 'plats',
        title: subdivisionName,
        exportFormat: 'pdf',
        reference: {
          type: 'external',
          value: platUrl || subdivisionName,
          resolverHint: 'subdivision-plat',
          metadata: subdivisionMetadata,
        },
      };
      platResources.push(resource);
      addProjectFileResource(projectFile, resource);
      platsPayload.push({
        platId,
        subdivisionName,
        title: subdivisionName,
        source: 'RecordQuarry',
        platUrl: platUrl || null,
        thumbnailUrl: thumbnailUrl || null,
        metadata: subdivisionMetadata,
        starredInFieldBook: true,
      });
    }

    const rosPayload = [];
    for (const { feature, index } of selectedRos) {
      const attrs = feature?.attributes || {};
      const rosNumber = String(attrs.ROS || attrs.RS || attrs.SurveyNo || attrs.SURVEYNO || '').trim() || `UNLISTED-${index + 1}`;
      const imageMeta = deriveRosImageMeta(attrs);
      const rosName = await resolveRosNameForExport(attrs, imageMeta);
      const label = rosName || bestRosLabel(attrs) || `Record of Survey #${index + 1}`;
      const mapImageUrl = imageMeta?.fullSizeUrl || null;
      const thumbnailUrl = mapImageUrl
        ? `/api/project-files/ros-thumbnail?${new URLSearchParams({ source: mapImageUrl })}`
        : null;
      const metadata = buildRosMetadataForExport(attrs, rosName);
      const geolocation = deriveRosGeolocationForExport(feature);
      if (geolocation) metadata.geolocation = geolocation;
      const rosId = slugify(rosNumber, `ros-${index + 1}`);
      const resource = {
        id: `ros-${rosId}`,
        folder: 'ros',
        title: label,
        exportFormat: 'pdf',
        reference: {
          type: 'ros-number',
          value: rosNumber,
          resolverHint: 'lookup-ros',
          metadata: {
            rosId,
            rosNumber,
            title: label,
            source: 'RecordQuarry',
            mapImageUrl,
            thumbnailUrl,
            geolocation,
            ...metadata,
            starredInFieldBook: true,
          },
        },
      };
      rosResources.push(resource);
      addProjectFileResource(projectFile, resource);
      rosPayload.push({
        rosId,
        rosNumber,
        title: label,
        source: 'RecordQuarry',
        mapImageUrl,
        thumbnailUrl,
        metadata,
        geolocation,
        starredInFieldBook: true,
      });
    }

    if (overwriteEvidenceRecords) {
      replaceProjectFileFolderResources(projectFile, 'cpfs', cpfResources);
      replaceProjectFileFolderResources(projectFile, 'plats', platResources);
      replaceProjectFileFolderResources(projectFile, 'ros', rosResources);
    }

    addProjectFileResource(projectFile, {
      id: `pointforge-export-${Date.now()}`,
      folder: 'point-files',
      title: `PointForge export ${exportTimestamp}`,
      exportFormat: 'csv',
      reference: {
        type: 'local-storage',
        value: POINTFORGE_ROS_IMPORT_STORAGE_KEY,
        resolverHint: 'local-pointforge-export',
        metadata: {
          source: 'RecordQuarry',
          exportedAt: exportTimestamp,
          pointCount: Number(pointCount) || 0,
          csvLength: String(csv || '').length,
        },
      },
    });

    projectFile.generatedAt = exportTimestamp;
    saveProjectFileSnapshot(resolvedProjectContext, projectFile);

    // Persist CP&F records server-side so EvidenceDesk can display them.
    if (resolvedProjectContext.projectId && (overwriteEvidenceRecords || cpfInstruments.length)) {
      try {
        const cpfsPayload = cpfInstruments.map((instrument) => ({
          instrument,
          title: `CP&F ${instrument}`,
          source: 'RecordQuarry',
        }));
        await fetch(`/api/projects/${encodeURIComponent(resolvedProjectContext.projectId)}/cpfs`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ cpfs: cpfsPayload, overwrite: overwriteEvidenceRecords }),
        });
      } catch {
        // Non-fatal: server sync is best-effort; local snapshot was already saved.
      }
    }

    if (resolvedProjectContext.projectId && (overwriteEvidenceRecords || platsPayload.length)) {
      try {
        await fetch(`/api/projects/${encodeURIComponent(resolvedProjectContext.projectId)}/plats`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ plats: platsPayload, overwrite: overwriteEvidenceRecords }),
        });
      } catch {
        // Non-fatal: server sync is best-effort; local snapshot was already saved.
      }
    }

    if (resolvedProjectContext.projectId && (overwriteEvidenceRecords || rosPayload.length)) {
      try {
        await fetch(`/api/projects/${encodeURIComponent(resolvedProjectContext.projectId)}/ros`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ros: rosPayload, overwrite: overwriteEvidenceRecords }),
        });
      } catch {
        // Non-fatal: server sync is best-effort; local snapshot was already saved.
      }
    }

    return { projectFile, cpfCount: cpfInstruments.length, rosCount: rosPayload.length, subdivisionCount: selectedSubdivisions.length };
  }

  // -----------------------------
  // JSONP for ArcGIS (no CORS)
  // -----------------------------
  function toQuery(params) {
    const parts = [];
    for (const [k,v] of Object.entries(params)) {
      if (v === undefined || v === null) continue;
      const value = typeof v === 'object' ? JSON.stringify(v) : String(v);
      parts.push(encodeURIComponent(k) + "=" + encodeURIComponent(value));
    }
    return parts.join("&");
  }

  function arcJsonp(url, params, timeoutMs=20000) {
    return new Promise((resolve, reject) => {
      const cb = "__arc_cb_" + Math.random().toString(36).slice(2);
      const script = document.createElement("script");
      const timer = setTimeout(() => {
        cleanup();
        reject(new Error("JSONP timeout"));
      }, timeoutMs);

      function cleanup() {
        clearTimeout(timer);
        try { delete window[cb]; } catch {}
        if (script.parentNode) script.parentNode.removeChild(script);
      }

      window[cb] = (data) => {
        cleanup();
        resolve(data);
      };

      const fullParams = Object.assign({}, params, { f: "json", callback: cb });
      script.src = url + (url.includes("?") ? "&" : "?") + toQuery(fullParams);
      script.onerror = () => {
        cleanup();
        reject(new Error("JSONP script load failed"));
      };
      document.head.appendChild(script);
    });
  }

  async function arcQuery(layerId, params) {
    const url = `${BASE}/${layerId}/query`;
    const data = await arcJsonp(url, params);
    if (data && data.error) {
      const msg = data.error.message || "ArcGIS error";
      throw new Error(`${msg}${data.error.details ? " :: " + data.error.details.join(" | ") : ""}`);
    }
    return data;
  }

  // -----------------------------
  // CP&F corner record lookup helpers
  // -----------------------------
  let cpfLayerInfo = null;
  let cpfLayerInfoPromise = null;
  const cpfCornerRecordsCache = new Map();
  const cpfCornerRecordsInFlight = new Map();

  function canonicalizeUrl(url) {
    try {
      const u = new URL(url);
      u.hash = '';
      return `${u.origin}${u.pathname}`.toLowerCase() + (u.search ? u.search.toLowerCase() : '');
    } catch {
      return String(url || '').trim().toLowerCase();
    }
  }

  function pickField(attrs, layerMeta, patterns) {
    const keys = Object.keys(attrs || {});
    const fields = layerMeta?.fields || [];
    for (const re of patterns) {
      const key = keys.find((k) => re.test(k));
      if (key) return key;
      const field = fields.find((f) => re.test(f.name || '') || re.test(f.alias || ''));
      if (field && attrs[field.name] !== undefined) return field.name;
    }
    return null;
  }

  function buildCpfPdfLinks(instrument, maybeUrl, maybeFileName) {
    const out = [];
    const seen = new Set();

    function add(url) {
      if (!url) return;
      const text = String(url).trim();
      if (!text) return;
      const key = canonicalizeUrl(text);
      if (seen.has(key)) return;
      seen.add(key);
      out.push(text);
    }

    if (maybeUrl) {
      const text = String(maybeUrl).trim();
      if (/^https?:\/\//i.test(text)) add(text);
      else if (/\.pdf$/i.test(text)) add(ADA_CPF_PDF_BASE + text.replace(/^\/+/, ''));
    }

    if (maybeFileName) {
      const text = String(maybeFileName).trim();
      if (/^https?:\/\//i.test(text)) add(text);
      else if (/\.pdf$/i.test(text)) add(ADA_CPF_PDF_BASE + text.replace(/^\/+/, ''));
      else add(ADA_CPF_PDF_BASE + encodeURIComponent(text) + '.pdf');
    }

    if (instrument != null && instrument !== '') {
      add(ADA_CPF_PDF_BASE + encodeURIComponent(String(instrument).trim()) + '.pdf');
    }

    return out;
  }

  async function discoverAdaCpfLayerViaJsonp() {
    const itemDataUrl = `${ADA_PORTAL_BASE}/sharing/rest/content/items/${ADA_CPF_WEBMAP_ITEM_ID}/data`;
    const webmap = await arcJsonp(itemDataUrl, { f: 'pjson' }, 25000);

    const candidates = [];
    function walk(entries) {
      if (!Array.isArray(entries)) return;
      for (const entry of entries) {
        if (entry?.url) candidates.push(entry.url);
        if (entry?.layers) walk(entry.layers);
      }
    }
    walk(webmap?.operationalLayers);
    if (!candidates.length) throw new Error('CP&F web map has no operational layer URLs.');

    async function readMeta(url) {
      return arcJsonp(String(url).replace(/\?+.*$/, ''), { f: 'pjson' }, 25000);
    }
    function hasInstrumentField(fields = []) {
      return fields.some((f) => /instr|instrument/i.test(f.name || '') || /instr|instrument/i.test(f.alias || ''));
    }

    for (const baseUrlRaw of candidates) {
      const baseUrl = String(baseUrlRaw).replace(/\/+$/, '');
      const meta = await readMeta(baseUrl).catch(() => null);
      if (!meta) continue;

      if (Array.isArray(meta.layers) && meta.layers.length) {
        for (const layer of meta.layers) {
          const layerUrl = `${baseUrl}/${layer.id}`;
          const layerMeta = await readMeta(layerUrl).catch(() => null);
          if (!layerMeta) continue;
          if (/esriGeometryPoint/i.test(layerMeta.geometryType || '') && hasInstrumentField(layerMeta.fields || [])) {
            return { layerUrl, layerMeta };
          }
        }
      }

      if (/esriGeometryPoint/i.test(meta.geometryType || '') && hasInstrumentField(meta.fields || [])) {
        return { layerUrl: baseUrl, layerMeta: meta };
      }
    }

    throw new Error('Could not identify CP&F point layer with instrument fields.');
  }

  async function ensureCpfLayerInfo() {
    if (cpfLayerInfo) return cpfLayerInfo;
    if (!cpfLayerInfoPromise) {
      cpfLayerInfoPromise = discoverAdaCpfLayerViaJsonp()
        .then((info) => {
          cpfLayerInfo = info;
          return info;
        })
        .finally(() => { cpfLayerInfoPromise = null; });
    }
    return cpfLayerInfoPromise;
  }

  async function queryCpfRecordsNearCorner(north, east, maxMeters = 250, inSR = 4326) {
    const key = [inSR, Number(north).toFixed(7), Number(east).toFixed(7), Number(maxMeters)].join('|');
    if (cpfCornerRecordsCache.has(key)) return cpfCornerRecordsCache.get(key);
    if (cpfCornerRecordsInFlight.has(key)) return cpfCornerRecordsInFlight.get(key);

    const lookupPromise = (async () => {
      const { layerUrl, layerMeta } = await ensureCpfLayerInfo();
      const payload = await arcJsonp(`${layerUrl.replace(/\/+$/, '')}/query`, {
        f: 'pjson',
        where: '1=1',
        geometry: { x: east, y: north, spatialReference: { wkid: inSR } },
        geometryType: 'esriGeometryPoint',
        inSR,
        spatialRel: 'esriSpatialRelIntersects',
        distance: maxMeters,
        units: 'esriSRUnit_Meter',
        outFields: '*',
        returnGeometry: true,
        outSR: 4326,
      }, 25000);

      const features = payload?.features || [];
      if (!features.length) {
        cpfCornerRecordsCache.set(key, []);
        return [];
      }

      const instrumentKey = pickField(features[0]?.attributes || {}, layerMeta, [/^instrument$/i, /instr/i, /instrument_?no/i, /inst_?no/i]);
      const pdfUrlKey = pickField(features[0]?.attributes || {}, layerMeta, [/pdf/i, /doc/i, /document/i, /hyperlink/i, /url/i, /link/i]);
      const pdfNameKey = pickField(features[0]?.attributes || {}, layerMeta, [/file/i, /filename/i, /pdfname/i]);
      const monsetKey = pickField(features[0]?.attributes || {}, layerMeta, [/^monset$/i, /monument.*set/i]);
      const surveyorKey = pickField(features[0]?.attributes || {}, layerMeta, [/^surveyor$/i]);
      const townshipKey = pickField(features[0]?.attributes || {}, layerMeta, [/^township$/i]);
      const rangeKey = pickField(features[0]?.attributes || {}, layerMeta, [/^range$/i]);
      const sectionKey = pickField(features[0]?.attributes || {}, layerMeta, [/^section$/i]);
      const indexNumberKey = pickField(features[0]?.attributes || {}, layerMeta, [/^index_?number$/i, /^index$/i]);

      const records = features.map((feature) => {
        const x = Number(feature?.geometry?.x);
        const y = Number(feature?.geometry?.y);
        const distanceMeters = inSR === 4326 && Number.isFinite(x) && Number.isFinite(y)
          ? haversineMeters(north, east, y, x)
          : null;
        const attrs = feature.attributes || {};
        const instrument = instrumentKey ? attrs[instrumentKey] : null;
        const pdfUrl = pdfUrlKey ? attrs[pdfUrlKey] : null;
        const pdfName = pdfNameKey ? attrs[pdfNameKey] : null;
        const monset = monsetKey ? attrs[monsetKey] : null;
        const surveyor = surveyorKey ? attrs[surveyorKey] : null;
        const township = townshipKey ? attrs[townshipKey] : null;
        const range = rangeKey ? attrs[rangeKey] : null;
        const section = sectionKey ? attrs[sectionKey] : null;
        const indexNumber = indexNumberKey ? attrs[indexNumberKey] : null;
        return {
          distanceMeters,
          instrument,
          pdfUrl,
          pdfName,
          monset,
          surveyor,
          township,
          range,
          section,
          indexNumber,
          links: buildCpfPdfLinks(instrument, pdfUrl, pdfName),
        };
      }).filter((record) => record.links.length && (record.distanceMeters == null || record.distanceMeters <= (maxMeters + 0.5)));

      cpfCornerRecordsCache.set(key, records);
      return records;
    })();

    cpfCornerRecordsInFlight.set(key, lookupPromise);
    try {
      return await lookupPromise;
    } finally {
      cpfCornerRecordsInFlight.delete(key);
    }
  }

  function extractInstrumentFromCpfIdentifier(rawValue) {
    const raw = String(rawValue || '').trim();
    if (!raw) return '';
    const withoutQuery = raw.split(/[?#]/, 1)[0];
    const decoded = (() => {
      try {
        return decodeURIComponent(withoutQuery);
      } catch {
        return withoutQuery;
      }
    })();
    const baseName = decoded.split('/').pop() || decoded;
    const withoutExtension = baseName.replace(/\.pdf$/i, '');
    return normalizeCpInstrumentNumber(withoutExtension);
  }

  function resolveCpfRecordInstrument(record = {}) {
    const direct = normalizeCpInstrumentNumber(record?.instrument);
    if (direct) return direct;

    const fromName = extractInstrumentFromCpfIdentifier(record?.pdfName);
    if (fromName) return fromName;

    const fromUrl = extractInstrumentFromCpfIdentifier(record?.pdfUrl);
    if (fromUrl) return fromUrl;

    for (const link of (record?.links || [])) {
      const fromLink = extractInstrumentFromCpfIdentifier(link);
      if (fromLink) return fromLink;
    }
    return '';
  }

  function cpfLinksHtml(records = []) {
    if (!records.length) return '<span class="small">No CP&amp;F PDF links found near this corner.</span>';
    return records.slice(0, 8).map((record, idx) => {
      const resolvedInstrument = resolveCpfRecordInstrument(record);
      const instrument = resolvedInstrument
        ? escapeHtml(resolvedInstrument)
        : `Record ${idx + 1}`;
      const links = record.links.map((url, i) => (
        `<a target="_blank" rel="noopener" href="${escapeHtml(buildRosPdfProxyUrl(url))}">CP&amp;F PDF${record.links.length > 1 ? ` ${i + 1}` : ''}</a>`
      )).join('<br/>');
      const monsetHtml = record.monset != null && String(record.monset).trim()
        ? `<div style="margin-top:2px;color:var(--muted)">Monument Set: <span style="color:var(--text)">${escapeHtml(String(record.monset).trim())}</span></div>`
        : '';
      const surveyorHtml = record.surveyor != null && String(record.surveyor).trim()
        ? `<div style="color:var(--muted)">Surveyor: <span style="color:var(--text)">${escapeHtml(String(record.surveyor).trim())}</span></div>`
        : '';
      return `<div style="margin:6px 0"><b>${instrument}</b>${monsetHtml}${surveyorHtml}<div style="margin-top:2px">${links}</div></div>`;
    }).join('');
  }

  function uniqueCpInstrumentNote(records = []) {
    const values = [];
    const seen = new Set();
    for (const record of records) {
      const inst = resolveCpfRecordInstrument(record);
      if (!inst || seen.has(inst)) continue;
      seen.add(inst);
      values.push(inst);
    }
    if (!values.length) return '';
    return `CPNFS: ${values.join('...')}`;
  }

  async function buildCpfNotesByCoordinate(plssPointsMap) {
    const notes = new Map();
    for (const [key, point] of (plssPointsMap || new Map()).entries()) {
      try {
        const records = await queryCpfRecordsNearCorner(point.north, point.east, 250, EXPORT_OUT_SR);
        const note = uniqueCpInstrumentNote(records);
        if (note) notes.set(key, note);
      } catch (e) {
        log(`CP&F export note lookup failed for ${point.north.toFixed(3)}, ${point.east.toFixed(3)}: ${e.message || e}`, 'warn');
      }
    }
    return notes;
  }

  // -----------------------------
  // Geometry helpers
  // -----------------------------
  function arcPointToLatLng(g) {
    if (!g) return null;
    return [g.y, g.x];
  }

  function arcPolygonToGeoJSON(geom) {
    return {
      type: "Feature",
      properties: {},
      geometry: {
        type: "Polygon",
        coordinates: (geom?.rings || []).map(ring => ring.map(([x,y]) => [x,y]))
      }
    };
  }

  function arcExtentFromPolygon(geom) {
    const rings = geom?.rings || [];
    let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;

    for (const ring of rings) {
      if (!ring) continue;
      for (const pt of ring) {
        if (!pt || pt.length < 2) continue;
        const x = pt[0], y = pt[1];
        if (x < xmin) xmin = x;
        if (y < ymin) ymin = y;
        if (x > xmax) xmax = x;
        if (y > ymax) ymax = y;
      }
    }

    if (!isFinite(xmin) || !isFinite(ymin) || !isFinite(xmax) || !isFinite(ymax)) return null;
    return { xmin, ymin, xmax, ymax };
  }

  function createParcelGeometryThumbSvg(geom, size=92, pad=8) {
    const rings = geom?.rings || [];
    if (!rings.length) return null;

    const ext = arcExtentFromPolygon(geom);
    if (!ext) return null;

    const w = Math.max(1e-12, ext.xmax - ext.xmin);
    const h = Math.max(1e-12, ext.ymax - ext.ymin);
    const scale = (size - 2*pad) / Math.max(w, h);

    const parts = [];
    for (const ring of rings) {
      if (!ring || ring.length < 2) continue;
      for (let i=0;i<ring.length;i++) {
        const pt = ring[i];
        if (!pt || pt.length < 2) continue;
        const x = pad + (pt[0] - ext.xmin) * scale;
        const y = pad + (ext.ymax - pt[1]) * scale; // invert Y for screen
        parts.push((i===0 ? 'M' : 'L') + x.toFixed(2) + ' ' + y.toFixed(2));
      }
      parts.push('Z');
    }

    const d = parts.join(' ');
    if (!d.trim()) return null;

    const ns = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(ns, 'svg');
    svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
    svg.setAttribute('role', 'img');
    svg.setAttribute('aria-label', 'Parcel geometry thumbnail');

    const path = document.createElementNS(ns, 'path');
    path.setAttribute('d', d);
    svg.appendChild(path);
    return svg;
  }


  function arcExtentFromGeometry(geom) {
    if (!geom) return null;
    if (geom.x != null && geom.y != null) {
      return { xmin: geom.x, ymin: geom.y, xmax: geom.x, ymax: geom.y };
    }
    if (Array.isArray(geom.paths)) {
      let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
      for (const path of geom.paths) {
        for (const [x, y] of (path || [])) {
          if (x < xmin) xmin = x;
          if (y < ymin) ymin = y;
          if (x > xmax) xmax = x;
          if (y > ymax) ymax = y;
        }
      }
      if (isFinite(xmin)) return { xmin, ymin, xmax, ymax };
    }
    return arcExtentFromPolygon(geom);
  }

  function centerMapOnFeature(feature, layerGroup, label = 'feature') {
    const ext = arcExtentFromGeometry(feature?.geometry);
    if (!ext) return;
    const samePoint = Math.abs(ext.xmax - ext.xmin) < 1e-12 && Math.abs(ext.ymax - ext.ymin) < 1e-12;
    if (samePoint) {
      map.setView([ext.ymin, ext.xmin], Math.max(map.getZoom(), 19));
    } else {
      map.fitBounds(L.latLngBounds([ext.ymin, ext.xmin], [ext.ymax, ext.xmax]).pad(0.2));
    }
    if (layerGroup?.getLayers) {
      for (const item of layerGroup.getLayers()) {
        if (typeof item.getBounds === 'function') {
          const b = item.getBounds();
          if (b?.isValid?.() && b.contains([ext.ymin, ext.xmin])) {
            item.openPopup?.();
            break;
          }
        } else if (typeof item.getLatLng === 'function') {
          const ll = item.getLatLng();
          if (ll && Math.abs(ll.lat - ext.ymin) < 1e-10 && Math.abs(ll.lng - ext.xmin) < 1e-10) {
            item.openPopup?.();
            break;
          }
        }
      }
    }
    invalidateMapSoon(`summary select: ${label}`);
  }

  function centroidOfPolygon(geom) {
    const ring = geom?.rings?.[0] || [];
    if (!ring.length) return null;
    let sx=0, sy=0, n=0;
    for (const [x,y] of ring) { sx += x; sy += y; n++; }
    return { x: sx/n, y: sy/n };
  }

  function haversineMeters(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2-lat1);
    const dLon = toRad(lon2-lon1);
    const a =
      Math.sin(dLat/2)**2 +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.min(1, Math.sqrt(a)));
  }

  function pointInRing(pointXY, ring) {
    let inside = false;
    const [x, y] = pointXY;
    for (let i=0, j=ring.length-1; i<ring.length; j=i++) {
      const xi = ring[i][0], yi = ring[i][1];
      const xj = ring[j][0], yj = ring[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-30) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function pointInPolygon(pointXY, geom) {
    const rings = geom?.rings || [];
    if (!rings.length) return false;
    if (!pointInRing(pointXY, rings[0])) return false;
    for (let i=1; i<rings.length; i++) {
      if (pointInRing(pointXY, rings[i])) return false;
    }
    return true;
  }

  function normalizedAliquotLabel(feature, sectionFeature) {
    const attrs = feature?.attributes || {};
    if (attrs.ALIQUOT) return String(attrs.ALIQUOT).toUpperCase();

    const ring = feature?.geometry?.rings?.[0] || [];
    const secRing = sectionFeature?.geometry?.rings?.[0] || [];
    if (!ring.length || !secRing.length) return 'ALIQUOT';

    const center = centroidOfPolygon(feature.geometry);
    if (!center) return 'ALIQUOT';

    let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
    for (const [x, y] of secRing) {
      xmin = Math.min(xmin, x);
      ymin = Math.min(ymin, y);
      xmax = Math.max(xmax, x);
      ymax = Math.max(ymax, y);
    }
    if (!isFinite(xmin) || !isFinite(ymin) || !isFinite(xmax) || !isFinite(ymax)) return 'ALIQUOT';

    const nx = (center.x - xmin) / Math.max(1e-9, xmax - xmin);
    const ny = (center.y - ymin) / Math.max(1e-9, ymax - ymin);

    const h = nx >= 0.5 ? 'E' : 'W';
    const v = ny >= 0.5 ? 'N' : 'S';
    return `${v}${h}`;
  }

  function buildAllSelectedAliquotKeys(aliquotFeatures) {
    return new Set((aliquotFeatures || []).map((feature, index) => buildAliquotSelectionKey(feature, index)));
  }

  // Parse Township, Range, Section, and Index from BLM aliquot attributes.
  // PLSSID format: {ST(2)}{PM(2)}{TWP(3)}{zone(1)}{TWPDIR(1)}{RNG(3)}{zone(1)}{RNGDIR(1)}{extra}
  // e.g. "ID080030N0020E0" → T3N R2E
  // FRSTDIVID appends "SN{sec*10}" e.g. "SN150" → Section 15
  // SECDIVNO / SECDIVLAB is the Index e.g. "SWNE"
  function parsePlssFromAliquot(feature) {
    const attrs = feature?.attributes || {};
    const plssid = String(attrs.PLSSID || '');
    const frstdivid = String(attrs.FRSTDIVID || '');
    const index = String(attrs.SECDIVNO || attrs.SECDIVLAB || '').trim();

    let township = '', range = '';
    const plssMatch = plssid.match(/^[A-Z]{2}\d{2}(\d{3})\d([NS])(\d{3})\d([EW])/);
    if (plssMatch) {
      const twpNum = parseInt(plssMatch[1], 10);
      if (twpNum) township = `T${twpNum}${plssMatch[2]}`;
      const rngNum = parseInt(plssMatch[3], 10);
      if (rngNum) range = `R${rngNum}${plssMatch[4]}`;
    }

    let section = '';
    const suffix = plssid ? frstdivid.slice(plssid.length) : '';
    const secMatch = suffix.match(/^SN(\d+)/);
    if (secMatch) {
      const secNum = Math.round(parseInt(secMatch[1], 10) / 10);
      if (secNum >= 1 && secNum <= 36) section = String(secNum);
    }

    return { township, range, section, index };
  }

  function isAliquotSelected(feature, index) {
    return state.selectedAliquotKeys.has(buildAliquotSelectionKey(feature, index));
  }

  function setAliquotSelected(feature, index, selected) {
    const key = buildAliquotSelectionKey(feature, index);
    if (selected) state.selectedAliquotKeys.add(key);
    else state.selectedAliquotKeys.delete(key);
    document.querySelectorAll(`[data-aliquot-select-key="${key}"]`).forEach((node) => {
      node.checked = selected;
    });
    // Sync the star button in the list card (bidirectional map ↔ list).
    document.querySelectorAll(`button[data-aliquot-star-key="${key}"]`).forEach((btn) => {
      btn.textContent = selected ? '★' : '☆';
      btn.title = selected ? 'Exclude from export' : 'Include in export';
      btn.setAttribute('aria-pressed', selected ? 'true' : 'false');
    });
    // Expand a far aliquot card when selected; re-collapse it when deselected.
    document.querySelectorAll('.aliquot-card.is-far').forEach((cardEl) => {
      if (cardEl.dataset.aliquotCardKey === key) cardEl.classList.toggle('is-expanded', selected);
    });
  }

  function setParcelSelected(selected) {
    state.selectedParcel = Boolean(selected);
    document.querySelectorAll('[data-parcel-include-export]').forEach((node) => {
      node.checked = state.selectedParcel;
    });
  }

  function buildParcelStyle() {
    return {
      color: state.selectedParcel ? '#24d18f' : '#4a7c66',
      weight: state.selectedParcel ? 3 : 2,
      fillOpacity: state.selectedParcel ? 0.08 : 0.03,
      dashArray: state.selectedParcel ? null : '4 4',
      pane: 'selectablePolygons',
    };
  }

  function drawParcel() {
    layers.parcel.clearLayers();
    if (!state.parcelFeature) return;
    const layer = drawPolygonFeature(state.parcelFeature, layers.parcel, { pane: 'selectablePolygons', style: () => buildParcelStyle() }, 'Parcel');
    layer.eachLayer((polygonLayer) => {
      polygonLayer.on('click', () => {
        const nextSelected = !state.selectedParcel;
        setParcelSelected(nextSelected);
        drawParcel();
        drawCornerMarkers(buildCornerMarkerEntries());
        log(`${nextSelected ? 'Included' : 'Excluded'} parcel in export.`);
      });
    });
  }


  function drawSubdivisionPolygons(subdivisionEntries = []) {
    layers.subdivision.clearLayers();
    for (const [idx, entry] of (subdivisionEntries || []).entries()) {
      const feature = entry?.feature;
      if (!feature) continue;
      const displayFeature = simplifyPolygonForDisplay(feature, SUBDIVISION_DRAW_MAX_VERTICES);
      const selected = isSubdivisionSelected(entry, idx);
      drawPolygonFeature(
        displayFeature,
        layers.subdivision,
        {
          style: () => ({
            color: selected ? '#9ab0ff' : '#64748b',
            weight: selected ? 2.5 : 1.5,
            fillOpacity: selected ? 0.08 : 0.02,
            dashArray: selected ? '' : '4 6',
          })
        },
        'Subdivision'
      );
    }
  }

  function simplifyPolygonForDisplay(feature, maxVertices = SUBDIVISION_DRAW_MAX_VERTICES) {
    const rings = feature?.geometry?.rings;
    if (!Array.isArray(rings) || !rings.length) return feature;

    let totalVertices = 0;
    for (const ring of rings) totalVertices += Array.isArray(ring) ? ring.length : 0;
    if (totalVertices <= maxVertices) return feature;

    const safeMax = Math.max(200, Number(maxVertices) || SUBDIVISION_DRAW_MAX_VERTICES);
    const stride = Math.max(1, Math.ceil(totalVertices / safeMax));
    const simplifiedRings = rings.map((ring) => {
      if (!Array.isArray(ring) || ring.length <= 4 || stride <= 1) return ring;
      const sampled = [];
      for (let i = 0; i < ring.length; i += stride) {
        sampled.push(ring[i]);
      }
      const first = ring[0];
      const last = ring[ring.length - 1];
      const sampledLast = sampled[sampled.length - 1];
      if (!sampled.length || sampled[0] !== first) sampled.unshift(first);
      if (sampledLast !== last) sampled.push(last);
      return sampled.length >= 4 ? sampled : ring;
    });

    return {
      ...feature,
      geometry: {
        ...feature.geometry,
        rings: simplifiedRings,
      },
    };
  }

  function drawAliquots(aliquotFeatures, sectionFeature) {
    layers.aliquots.clearLayers();
    for (const [index, feature] of (aliquotFeatures || []).entries()) {
      const gj = arcPolygonToGeoJSON(feature.geometry);
      const label = normalizedAliquotLabel(feature, sectionFeature);
      const popupHtml = buildAliquotPopupHtml(feature, label);
      const selected = isAliquotSelected(feature, index);
      const layer = L.geoJSON(gj, {
        pane: 'aliquotPolygons',
        style: {
          color: selected ? '#6aa9ff' : '#4b5f8a',
          weight: selected ? 1.8 : 1.3,
          fillOpacity: selected ? 0.14 : 0.03,
          dashArray: selected ? null : '4 4',
        },
      });
      layer.eachLayer((l) => {
        l.bindPopup(popupHtml);
        l.on('click', () => {
          state.selectedAliquot = feature;
          const nextSelected = !isAliquotSelected(feature, index);
          setAliquotSelected(feature, index, nextSelected);
          drawAliquots(state.aliquotFeatures, sectionFeature);
          drawCornerMarkers(buildCornerMarkerEntries());
          log(`${nextSelected ? 'Included' : 'Excluded'} aliquot in export: ${label}`);
        });
      });
      layers.aliquots.addLayer(layer);
    }
  }



  function getPolygonCornerMarkers(feature, role, options = {}) {
    const rings = feature?.geometry?.rings || [];
    const points = [];
    for (let ringIndex = 0; ringIndex < rings.length; ringIndex++) {
      const ring = rings[ringIndex] || [];
      const trimmed = ring.length > 1 && ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]
        ? ring.slice(0, -1)
        : ring;
      for (let vertexIndex = 0; vertexIndex < trimmed.length; vertexIndex++) {
        const vertex = trimmed[vertexIndex];
        const x = Number(vertex[0]);
        const y = Number(vertex[1]);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        points.push({
          east: x,
          north: y,
          label: `${role.toUpperCase()}_CORNER R${ringIndex + 1} V${vertexIndex + 1}`,
          color: options.color || '#ffffff',
        });
      }
    }
    return points;
  }

  function buildCornerMarkerEntries() {
    return [
      { role: 'aliquot', features: state.aliquotFeatures || [], color: '#6aa9ff' },
      { role: 'subdivision', features: state.subdivisionFeature ? [state.subdivisionFeature] : [], color: '#9ab0ff' },
      { role: 'parcel', features: state.parcelFeature ? [state.parcelFeature] : [], color: '#24d18f' },
    ];
  }

  function drawCornerMarkers(featuresByRole = []) {
    layers.cornerMarkers.clearLayers();
    for (const entry of featuresByRole) {
      const role = entry.role;
      const featureList = entry.features || [];
      for (const [featureIndex, feature] of featureList.entries()) {
        const corners = getPolygonCornerMarkers(feature, role, entry);
        const aliquotSelected = role === 'aliquot' ? isAliquotSelected(feature, featureIndex) : null;
        const roleSelected = role === 'aliquot' ? aliquotSelected : role === 'parcel' ? state.selectedParcel : true;
        for (const corner of corners) {
          const marker = L.circleMarker([corner.north, corner.east], {
            radius: roleSelected ? 5 : 3,
            weight: roleSelected ? 2 : 1,
            color: roleSelected ? '#ffcc66' : '#101834',
            fillColor: corner.color,
            fillOpacity: roleSelected ? 1 : 0.95,
          });
          marker.bindPopup(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px">Loading CP&amp;F records…</div>`);
          marker.on('click', async () => {
            if (role === 'aliquot') {
              const nextSelected = !isAliquotSelected(feature, featureIndex);
              setAliquotSelected(feature, featureIndex, nextSelected);
              drawAliquots(state.aliquotFeatures, state.sectionFeature);
              log(`${nextSelected ? 'Included' : 'Excluded'} aliquot in export via corner: ${normalizedAliquotLabel(feature, state.sectionFeature)}`);
            } else if (role === 'parcel') {
              const nextSelected = !state.selectedParcel;
              setParcelSelected(nextSelected);
              drawParcel();
              log(`${nextSelected ? 'Included' : 'Excluded'} parcel in export via corner selection.`);
            }
            drawCornerMarkers(featuresByRole);
            marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px">Loading CP&amp;F records…</div>`);
            try {
              const cpfRecords = await queryCpfRecordsNearCorner(corner.north, corner.east);
              marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="hr"></div>${cpfLinksHtml(cpfRecords)}`);
              if (cpfRecords.length) log(`Loaded CP&F PDF links for ${role} corner ${corner.label}.`);
              else log(`No CP&F PDF links found for ${role} corner ${corner.label}.`, 'warn');
            } catch (e) {
              marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px;color:#ffb3b3">CP&amp;F lookup failed: ${escapeHtml(e.message || e)}</div>`);
              log(`CP&F corner lookup failed: ${e.message || e}`, 'warn');
            }
          });
          layers.cornerMarkers.addLayer(marker);
        }
      }
    }
  }

  // -----------------------------
  // Address parsing
  // -----------------------------
  const DIRS = new Set(["N","S","E","W","NE","NW","SE","SW"]);
  const SUFFIXES = new Set(["ST","AVE","AV","DR","RD","LN","CT","PL","WAY","BLVD","CIR","PKWY","TRL","TER","HWY"]);
  function normalizeSpaces(s){ return (s||"").trim().replace(/\s+/g," "); }

  function parseAddress(raw) {
    raw = normalizeSpaces(raw);
    const parts = raw.split(",").map(s => s.trim()).filter(Boolean);
    const streetPart = parts[0] || "";
    const cityPart = parts[1] || "";

    const toks = streetPart.toUpperCase().split(/\s+/).filter(Boolean);
    const out = { AddNum: null, StPreDir: null, StName: null, StSuffix: null, City: null };

    if (toks.length && /^\d+$/.test(toks[0])) {
      out.AddNum = parseInt(toks[0], 10);
      toks.shift();
    }
    if (toks.length && DIRS.has(toks[0])) {
      out.StPreDir = toks.shift();
    }
    let suffix = null;
    if (toks.length && SUFFIXES.has(toks[toks.length-1])) {
      suffix = toks.pop();
    }
    out.StSuffix = suffix;
    out.StName = toks.length ? toks.join(" ") : null;

    if (cityPart) out.City = cityPart.toUpperCase().split(/\s+/)[0];
    return out;
  }

  // -----------------------------
  // Map setup
  // -----------------------------
  const map = L.map("map", { zoomControl: true });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 20,
    attribution: "&copy; OpenStreetMap contributors"
  }).addTo(map);
  map.setView([43.615, -116.202], 12);

  map.createPane('contextPolygons');
  map.getPane('contextPolygons').style.zIndex = '320';
  map.createPane('aliquotPolygons');
  map.getPane('aliquotPolygons').style.zIndex = '380';
  map.createPane('selectablePolygons');
  map.getPane('selectablePolygons').style.zIndex = '430';

  const layers = {
    address: L.layerGroup().addTo(map),
    parcel: L.layerGroup().addTo(map),
    subdivision: L.layerGroup().addTo(map),
    section: L.layerGroup().addTo(map),
    township: L.layerGroup().addTo(map),
    ros: L.layerGroup().addTo(map),
    utilities: L.layerGroup().addTo(map),
    aliquots: L.layerGroup().addTo(map),
    cornerMarkers: L.layerGroup().addTo(map),
  };

  function clearMapLayers() {
    Object.values(layers).forEach(g => g.clearLayers());
  }

  // ---- Leaflet display fix helpers ----
  function invalidateMapSoon(reason="") {
    requestAnimationFrame(() => map.invalidateSize());
    setTimeout(() => map.invalidateSize(), 50);
    setTimeout(() => map.invalidateSize(), 250);
    if (reason) log(`map.invalidateSize() (${reason})`);
  }
  window.addEventListener("load", () => invalidateMapSoon("window load"));
  window.addEventListener("resize", () => invalidateMapSoon("window resize"));
  try {
    const ro = new ResizeObserver(() => map.invalidateSize());
    ro.observe($("map"));
    ro.observe(document.querySelector(".mapWrap"));
  } catch {}

  // -----------------------------
  // Results state
  // -----------------------------
  const initialProjectContext = getProjectContext();
  if (!normalizeAddressStorageKey(initialProjectContext.address) && initialProjectContext.projectId) {
    const launchAddress = String(loadLaunchProject(initialProjectContext.projectId)?.address || '').trim();
    if (launchAddress) {
      initialProjectContext.address = launchAddress;
    }
  }

  const state = {
    addressFeature: null,
    parcelFeature: null,        // displayed (outSR 4326)
    parcelFeature2243: null,    // export geometry (outSR 2243)
    subdivisionFeature2243: null,
    subdivisionFeature: null,
    nearbySubdivisions: [],
    sectionFeature: null,
    sectionFeature2243: null,
    aliquotFeatures2243: [],
    townshipFeature: null,
    rosFeatures: [],
    aliquotFeatures: [],
    selectedParcel: true,
    selectedAliquot: null,
    selectedAliquotKeys: new Set(),
    selectedRosKeys: new Set(),
    selectedSubdivisionKeys: new Set(),
    lastLookupPayload: null,
    lastLookupAddress: '',
    exportGeoJSON: null,
    lastLonLat: null,
    utilityLocations: [],
    utilityRadiusM: 500,
    utilityMinDistToParcelCornerM: [],
    utilityIncludedIdx: new Set(),
    utilityMarkers: [],
    parcelCornerLatLngs: [],
    projectContext: initialProjectContext
  };

  const SUMMARY_RENDER_BATCH_SIZE = 24;
  const UTILITY_LOOKUP_TIMEOUT_MS = 4500;

  function yieldToBrowserFrame() {
    return new Promise((resolve) => {
      if (typeof requestAnimationFrame === 'function') {
        requestAnimationFrame(() => resolve());
        return;
      }
      setTimeout(resolve, 0);
    });
  }

  async function setSummaryCards(cards) {
    const root = $("summary");
    root.innerHTML = "";
    if (!cards.length) {
      root.innerHTML = `<div class="small">No results yet.</div>`;
      return;
    }

    const fragment = document.createDocumentFragment();
    const shouldChunk = cards.length > SUMMARY_RENDER_BATCH_SIZE;

    for (let i = 0; i < cards.length; i++) {
      fragment.appendChild(cards[i]);
      const reachedBatchEnd = (i + 1) % SUMMARY_RENDER_BATCH_SIZE === 0;
      const atTail = i === cards.length - 1;

      if (!atTail && shouldChunk && reachedBatchEnd) {
        root.appendChild(fragment);
        await yieldToBrowserFrame();
      }
    }

    root.appendChild(fragment);
  }

  // Collapse distance-threshold cards as a group under a single "See More" control.
  // This preserves per-card collapse (the cards keep their own .is-far / .is-expanded behavior).
  function applyDistanceGroupSeeMore(cards, startIndex, cardClass, labelPlural, cutoffMeters = 500) {
    if (!Array.isArray(cards) || !cards.length) return;
    const farIndices = [];
    for (let i = Math.max(0, startIndex || 0); i < cards.length; i++) {
      const el = cards[i];
      if (!el || !el.classList) continue;
      if (el.classList.contains(cardClass) && el.classList.contains('is-far')) farIndices.push(i);
    }
    if (!farIndices.length) return;

    const firstFarIndex = farIndices[0];
    const farEls = farIndices.map((i) => cards[i]);

    const toggleCard = createDistanceGroupToggleCard(labelPlural, farEls.length, cutoffMeters);
    cards.splice(firstFarIndex, 0, toggleCard);

    // Hide far cards by default (group-collapsed).
    for (const el of farEls) el.style.display = 'none';

    let expanded = false;
    const btn = toggleCard.querySelector('[data-rq-see-more-btn]');
    const sub = toggleCard.querySelector('[data-rq-see-more-sub]');
    const sync = () => {
      if (btn) {
        btn.textContent = expanded ? `Hide (${farEls.length})` : `See More (${farEls.length})`;
        btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
      }
      if (sub) sub.textContent = `${farEls.length} ${labelPlural} beyond ${fmtDist(cutoffMeters)}`;
    };
    sync();

    if (btn) {
      btn.addEventListener('click', (evt) => {
        evt.stopPropagation();
        expanded = !expanded;
        for (const el of farEls) el.style.display = expanded ? '' : 'none';
        sync();
      });
    }
  }

  function createDistanceGroupToggleCard(labelPlural, count, cutoffMeters) {
    const el = document.createElement('div');
    el.className = 'card rq-distance-group';
    el.innerHTML = `
      <div class="chead" style="align-items:center">
        <div style="min-width:0">
          <div class="rq-distance-group-title">See More</div>
          <div class="rq-distance-group-sub" data-rq-see-more-sub>${count} ${labelPlural} beyond ${fmtDist(cutoffMeters)}</div>
        </div>
        <button type="button" class="secondary rq-see-more-btn" data-rq-see-more-btn aria-expanded="false">See More (${count})</button>
      </div>
    `;
    return el;
  }

  function createResultCategoryHeader(label, detail = '') {
    const el = document.createElement('div');
    el.className = 'card rq-result-category';
    el.innerHTML = `
      <div class="chead" style="align-items:center">
        <div style="min-width:0">
          <div class="rq-distance-group-title">${escapeHtml(label)}</div>
          <div class="rq-distance-group-sub">${escapeHtml(detail || '')}</div>
        </div>
      </div>
    `;
    return el;
  }

  function fmtDist(m) {
    const mi = m / 1609.344;
    const decimals = mi < 0.1 ? 3 : 2;
    return `${mi.toFixed(decimals)} mi`;
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replace(/&/g,"&amp;").replace(/</g,"&lt;")
      .replace(/>/g,"&gt;").replace(/"/g,"&quot;")
      .replace(/'/g,"&#039;");
  }

  function card(title, subtitle, kvPairs, links=[], options={}) {
    const el = document.createElement("div");
    el.className = "card";
    if (typeof options.onSelect === 'function') {
      el.classList.add('clickable');
      el.tabIndex = 0;
      el.addEventListener('click', options.onSelect);
      el.addEventListener('keydown', (evt) => {
        if (evt.key === 'Enter' || evt.key === ' ') {
          evt.preventDefault();
          options.onSelect();
        }
      });
    }
    const head = document.createElement("div");
    head.className = "chead";
    head.innerHTML = `
      <div>
        <div style="font-weight:800">${escapeHtml(title)}</div>
        <div class="small">${escapeHtml(subtitle || "")}</div>
      </div>
    `;
    const body = document.createElement("div");
    body.className = "cbody";

    if (Array.isArray(kvPairs) && kvPairs.length) {
      const kv = document.createElement("div");
      kv.className = "kv";
      for (const [k,v] of kvPairs) {
        const kdiv = document.createElement("div");
        kdiv.textContent = k;
        const vdiv = document.createElement("div");
        vdiv.innerHTML = v;
        kv.appendChild(kdiv);
        kv.appendChild(vdiv);
      }
      body.appendChild(kv);
    }

    if (options.extraHtml) {
      const extra = document.createElement('div');
      extra.innerHTML = options.extraHtml;
      body.appendChild(extra);
    }

    if (links.length) {
      const hr = document.createElement("div");
      hr.className = "hr";
      body.appendChild(hr);
      const ldiv = document.createElement("div");
      ldiv.className = "small";
      ldiv.innerHTML = links.map(h => `• ${h}`).join("<br/>");
      body.appendChild(ldiv);
    }

    el.appendChild(head);
    el.appendChild(body);
    if (typeof options.onRender === 'function') {
      options.onRender(el);
    }
    return el;
  }

  // -----------------------------
  // Address lookup
  // -----------------------------
  function buildAddressWhere(p) {
    const clauses = ["1=1"];
    if (p.AddNum != null) clauses.push(`AddNum = ${p.AddNum}`);
    if (p.StName) clauses.push(`UPPER(StName) LIKE '%${p.StName.replace(/'/g,"''")}%'`);
    if (p.StPreDir) clauses.push(`UPPER(StPreDir) = '${p.StPreDir.replace(/'/g,"''")}'`);
    if (p.StSuffix) clauses.push(`UPPER(StSuffix) = '${p.StSuffix.replace(/'/g,"''")}'`);
    if (p.City) clauses.push(`UPPER(CommName) LIKE '%${p.City.replace(/'/g,"''")}%'`);
    return clauses.join(" AND ");
  }

  function scoreAddressCandidate(p, attrs) {
    let s = 0;
    if (p.AddNum != null && attrs.AddNum == p.AddNum) s += 10;
    if (p.StPreDir && String(attrs.StPreDir||"").toUpperCase() === p.StPreDir) s += 4;
    if (p.StSuffix && String(attrs.StSuffix||"").toUpperCase() === p.StSuffix) s += 4;
    if (p.City && String(attrs.CommName||"").toUpperCase().includes(p.City)) s += 2;
    if (p.StName && String(attrs.StName||"").toUpperCase().includes(p.StName.split(" ")[0])) s += 2;
    return s;
  }

  async function findBestAddressFeature(rawAddr) {
    const parsed = parseAddress(rawAddr);
    log(`Parsed address: AddNum=${parsed.AddNum ?? "-"} PreDir=${parsed.StPreDir ?? "-"} StName=${parsed.StName ?? "-"} Suffix=${parsed.StSuffix ?? "-"} City=${parsed.City ?? "-"}`);

    const where = buildAddressWhere(parsed);
    log(`Address query WHERE: ${where}`);

    const resp = await arcQuery(LAYERS.address, {
      where,
      outFields: "*",
      returnGeometry: true,
      outSR: 4326
    });
    const feats = resp?.features || [];
    log(`Address query returned ${feats.length} feature(s).`);
    if (!feats.length) return { best: null, candidates: [] };

    const scored = feats
      .map(f => ({ f, score: scoreAddressCandidate(parsed, f.attributes || {}) }))
      .sort((a,b) => b.score - a.score);

    return { best: scored[0].f, candidates: scored.map(x => x.f) };
  }

  // -----------------------------
  // Parcel query (point+distance)
  // -----------------------------
  async function findParcelNearPoint(lon, lat, outSR=4326) {
    const distances = [0, 10, 30, 150];
    let best = null;

    for (const d of distances) {
      const params = {
        where: "1=1",
        outFields: "*",
        returnGeometry: true,
        outSR,
        geometry: `${lon},${lat}`,
        geometryType: "esriGeometryPoint",
        inSR: 4326,
        spatialRel: "esriSpatialRelIntersects",
      };
      if (d > 0) {
        params.distance = d;
        params.units = "esriSRUnit_Meter";
      }

      log(`Parcel search: point+distance ${d}m (outSR=${outSR})`);
      const resp = await arcQuery(LAYERS.parcels, params);
      const feats = resp?.features || [];
      log(`Parcel candidates @ ${d}m: ${feats.length}`);

      if (feats.length) {
        if (outSR === 4326) {
          const pointXY = [lon, lat];
          const containing = feats.find(f => pointInPolygon(pointXY, f.geometry));
          if (containing) { best = containing; break; }

          let nearest = null;
          let bestDist = Infinity;
          for (const f of feats) {
            const c = centroidOfPolygon(f.geometry);
            if (!c) continue;
            const meters = haversineMeters(lat, lon, c.y, c.x);
            if (meters < bestDist) { bestDist = meters; nearest = f; }
          }
          best = nearest || feats[0];
          break;
        } else {
          best = feats[0];
          break;
        }
      }
    }
    return best;
  }

  async function findContainingPolygon(layerId, lon, lat, searchMeters, outSR = 4326) {
    const resp = await arcQuery(layerId, {
      where: "1=1",
      outFields: "*",
      returnGeometry: true,
      outSR,
      geometry: `${lon},${lat}`,
      geometryType: "esriGeometryPoint",
      inSR: 4326,
      spatialRel: "esriSpatialRelIntersects",
      distance: searchMeters,
      units: "esriSRUnit_Meter"
    });
    const feats = resp?.features || [];
    if (!feats.length) return null;

    if (outSR !== 4326) return feats[0];

    const pointXY = [lon, lat];
    const containing = feats.find(f => pointInPolygon(pointXY, f.geometry));
    if (containing) return containing;

    let nearest = null;
    let bestDist = Infinity;
    for (const f of feats) {
      const c = centroidOfPolygon(f.geometry);
      if (!c) continue;
      const meters = haversineMeters(lat, lon, c.y, c.x);
      if (meters < bestDist) { bestDist = meters; nearest = f; }
    }
    return nearest || feats[0];
  }

  function getSubdivisionNameFromAttrs(attrs = {}) {
    const pick = (keys = [], regex = null) => {
      for (const key of keys) {
        const cleaned = String(attrs?.[key] || '').trim();
        if (cleaned) return cleaned;
      }
      if (regex instanceof RegExp) {
        for (const [key, value] of Object.entries(attrs || {})) {
          if (!regex.test(String(key || ''))) continue;
          const cleaned = String(value || '').trim();
          if (cleaned) return cleaned;
        }
      }
      return '';
    };

    const candidates = [
      attrs.SUBDIVNAME,
      attrs.SUBDIVISION,
      attrs.SUBDIV,
      attrs.NAME,
      attrs.SUB_NAME,
      attrs.PLATNAME,
      attrs.SUBDIVISIO,
    ];
    for (const value of candidates) {
      const cleaned = String(value || '').trim();
      if (cleaned) return cleaned;
    }
    return pick(
      [
        'SubdivisionName',
        'SUBDIVISIONNAME',
        'SubDivisionName',
        'Subdivision',
        'SUBDIVISION_NAME',
        'Subdivision_Name',
        'PlatName',
        'PLAT_NAME',
      ],
      /(subdiv(ision)?|plat).*(name)|name.*(subdiv(ision)?|plat)/i,
    );
  }

  function getSubdivisionNameCandidates(attrs = {}, explicitName = '') {
    const names = [
      explicitName,
      getSubdivisionNameFromAttrs(attrs),
      attrs.SUBDIVNAME,
      attrs.SUBDIVISION,
      attrs.SUBDIV,
      attrs.NAME,
      attrs.SUB_NAME,
      attrs.PLATNAME,
      attrs.LEGALDESC,
      attrs.LEGAL_DESC,
      attrs.DESCRIPTION,
    ];
    const out = [];
    const seen = new Set();
    for (const rawName of names) {
      const normalized = sanitizeSubdivisionName(rawName);
      if (!normalized || seen.has(normalized)) continue;
      seen.add(normalized);
      out.push(normalized);
    }
    return out;
  }

  function sanitizeSubdivisionName(value) {
    return String(value || '')
      .toUpperCase()
      .replace(/[^A-Z0-9]+/g, ' ')
      .replace(/\b(UNIT|PHASE|NO|NUMBER|SUBDIVISION|SUBDIV|LOT|BLOCK|BLK|TRACT|FILED|IN|BOOK|PAGE|PG|MAP|PLAT|RECORDED|RECORDS|AMENDED)\b/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  function tokenizeSubdivisionName(value = '') {
    return sanitizeSubdivisionName(value)
      .split(' ')
      .map((token) => token.trim())
      .filter((token) => token.length > 1);
  }

  function subdivisionTokenOverlapScore(a = '', b = '') {
    const left = new Set(tokenizeSubdivisionName(a));
    const right = new Set(tokenizeSubdivisionName(b));
    if (!left.size || !right.size) return 0;
    let overlap = 0;
    for (const token of left) {
      if (right.has(token)) overlap += 1;
    }
    return overlap / Math.max(left.size, right.size);
  }

  function buildSubdivisionPlatUrl(rawPath = '') {
    const trimmed = String(rawPath || '').trim();
    if (!trimmed) return null;
    if (/^https?:\/\//i.test(trimmed)) return trimmed;
    const normalizedPath = trimmed
      .replace(/\\+/g, '/')
      .replace(/^\/+/, '');
    if (!normalizedPath) return null;
    return `${SUBDIVISION_PLAT_BASE_URL}${normalizedPath}`;
  }

  function buildSubdivisionPlatThumbnailUrl(platUrl = '') {
    const sourceUrl = String(platUrl || '').trim();
    if (!sourceUrl) return null;
    if (/\.tiff?($|\?)/i.test(sourceUrl)) {
      return `/api/project-files/ros-thumbnail?${new URLSearchParams({ source: sourceUrl })}`;
    }
    if (/\.pdf($|\?)/i.test(sourceUrl)) {
      const pdfProxyUrl = (typeof buildRosPdfProxyUrl === 'function')
        ? buildRosPdfProxyUrl(sourceUrl)
        : `/api/ros-pdf?${new URLSearchParams({ url: sourceUrl })}`;
      return `/api/project-files/pdf-thumbnail?${new URLSearchParams({ source: pdfProxyUrl })}`;
    }
    return sourceUrl;
  }

  function buildSubdivisionThumbnailMarkup(subdivisionName = '', thumbnailUrl = '') {
    const safeName = escapeHtml(String(subdivisionName || 'Subdivision plat'));
    const normalized = String(thumbnailUrl || '').trim();
    if (!normalized) return '';
    if (isDeferredApiThumbnailUrl(normalized)) {
      return `<img class="ros-scan-thumb subdivision-plat-thumb" loading="lazy" src="${escapeHtml(SUBDIVISION_THUMB_PLACEHOLDER_DATA_URL)}" alt="${safeName} plat thumbnail" data-ros-thumbnail="${escapeHtml(normalized)}" data-keep-placeholder="1"/>`;
    }
    return `<img class="ros-scan-thumb subdivision-plat-thumb" loading="lazy" src="${escapeHtml(normalized)}" alt="${safeName} plat thumbnail"/>`;
  }

  function isDeferredApiThumbnailUrl(url = '') {
    const value = String(url || '').trim();
    return value.startsWith('/api/project-files/ros-thumbnail?') || value.startsWith('/api/project-files/pdf-thumbnail?');
  }

  function parseSubdivisionPlatListLine(line) {
    const raw = String(line || '').trim();
    if (!raw || raw.startsWith('#') || raw.startsWith('//')) return null;

    const parts = raw.split(/[|	,]+/).map((part) => part.trim()).filter(Boolean);
    const urlMatch = raw.match(/https?:\/\/[^\s]+/i);
    const fileMatch = raw.match(/[A-Za-z0-9._\\/ -]+\.(?:pdf|jpe?g|png|tiff?)/i);
    const resolvedPath = urlMatch?.[0] || fileMatch?.[0] || '';

    let titlePart = raw;
    if (resolvedPath) {
      titlePart = titlePart.replace(resolvedPath, ' ');
    }
    titlePart = titlePart
      .replace(/[|,	]+/g, ' ')
      .replace(/\bS\d{4,}\d{0,2}\b/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

    if (!titlePart) {
      const titleCandidates = parts.filter((part) => part && part !== resolvedPath && !/\.(?:pdf|jpe?g|png|tiff?)$/i.test(part));
      titlePart = titleCandidates.sort((a, b) => b.length - a.length)[0] || parts[0] || '';
    }

    if (!resolvedPath || !titlePart) return null;

    const normalizedName = sanitizeSubdivisionName(titlePart);
    if (!normalizedName) return null;

    const platUrl = buildSubdivisionPlatUrl(resolvedPath);
    if (!platUrl) return null;

    const platDocMatch = String(resolvedPath).match(/\b(S\d{4,})(\d{2})?\.(?:pdf|jpe?g|png|tiff?)\b/i);
    const platDocId = platDocMatch ? String(platDocMatch[1]).toUpperCase() : null;
    const platPage = platDocMatch?.[2] ? Number.parseInt(platDocMatch[2], 10) : null;

    return {
      name: titlePart,
      normalizedName,
      sourceLine: raw,
      sourcePath: resolvedPath,
      platDocId,
      platPage,
      platUrl,
      thumbnailUrl: buildSubdivisionPlatThumbnailUrl(platUrl),
    };
  }

  function extractSubdivisionSourceIdentifiers(attrs = {}) {
    const keys = [
      'SUBDIVNO', 'SUBDIVNUM', 'SUBDIVISIONNO', 'SUBDIVISIONNUM',
      'PLATID', 'PLAT_NO', 'PLATNO', 'BOOKPAGE', 'MAPNUMBER',
      'SUBDIV', 'SUBDIVNAME', 'SUBDIVISION', 'NAME',
    ];
    const out = new Set();
    for (const key of keys) {
      const v = String(attrs?.[key] || '').trim();
      if (!v) continue;
      out.add(v.toUpperCase().replace(/[^A-Z0-9]/g, ''));
      const sMatch = v.toUpperCase().match(/\bS\d{4,}\b/);
      if (sMatch) out.add(sMatch[0]);
    }
    return out;
  }

  let subdivisionPlatListPromise = null;

  async function loadSubdivisionPlatLookup() {
    if (subdivisionPlatListPromise) return subdivisionPlatListPromise;
    subdivisionPlatListPromise = (async () => {
      const resp = await fetch(SUBDIVISION_PLAT_LIST_URL, { cache: 'no-store' });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const text = await resp.text();
      const byName = new Map();
      const byDocId = new Map();
      for (const line of text.split(/\r?\n/)) {
        const parsed = parseSubdivisionPlatListLine(line);
        if (!parsed) continue;
        if (!byName.has(parsed.normalizedName)) byName.set(parsed.normalizedName, []);
        byName.get(parsed.normalizedName).push(parsed);
        const docIdKey = String(parsed.platDocId || '').trim().toUpperCase();
        if (docIdKey && !byDocId.has(docIdKey)) byDocId.set(docIdKey, parsed);
      }
      return {
        byName,
        byDocId,
        byNameKeys: [...byName.keys()],
      };
    })().catch((error) => {
      subdivisionPlatListPromise = null;
      throw error;
    });
    return subdivisionPlatListPromise;
  }

  function matchSubdivisionPlatEntry(subdivisionName, lookupMap, attrs = {}) {
    const byName = lookupMap?.byName;
    const byDocId = lookupMap?.byDocId;
    if (!byName || !byName.size) return null;
    const normalizedCandidates = getSubdivisionNameCandidates(attrs, subdivisionName);

    for (const normalized of normalizedCandidates) {
      const direct = byName.get(normalized);
      if (direct?.length) return direct[0];
    }

    const sourceIds = extractSubdivisionSourceIdentifiers(attrs);
    if (sourceIds.size) {
      for (const sourceId of sourceIds) {
        const byId = byDocId?.get(String(sourceId || '').trim().toUpperCase());
        if (byId) return byId;
      }
    }

    if (!normalizedCandidates.length) return null;

    for (const normalized of normalizedCandidates) {
      for (const key of (lookupMap?.byNameKeys || [])) {
        const entries = byName.get(key);
        if (key.includes(normalized) || normalized.includes(key)) return entries[0];
      }
    }

    let bestEntry = null;
    let bestScore = 0;
    for (const normalized of normalizedCandidates) {
      for (const key of (lookupMap?.byNameKeys || [])) {
        const score = subdivisionTokenOverlapScore(normalized, key);
        if (score > bestScore) {
          const entries = byName.get(key);
          if (entries?.length) {
            bestScore = score;
            bestEntry = entries[0];
          }
        }
      }
    }
    if (bestEntry && bestScore >= 0.67) return bestEntry;

    return null;
  }

  function limitNearbySubdivisionEntries(entries = [], parcelFeature = null, maxResults = SUBDIVISION_NEARBY_MAX_RESULTS) {
    const source = Array.isArray(entries) ? entries : [];
    const maxCount = Number.isFinite(Number(maxResults)) ? Math.max(1, Number(maxResults)) : SUBDIVISION_NEARBY_MAX_RESULTS;
    if (source.length <= maxCount) return source;

    const centroid = centroidOfPolygon(parcelFeature?.geometry || null);
    if (!centroid || !Number.isFinite(Number(centroid.x)) || !Number.isFinite(Number(centroid.y))) {
      return source.slice(0, maxCount);
    }

    return source
      .map((entry, index) => {
        const featureCentroid = centroidOfPolygon(entry?.feature?.geometry || null);
        const distance = featureCentroid
          ? haversineMeters(centroid.y, centroid.x, featureCentroid.y, featureCentroid.x)
          : Number.POSITIVE_INFINITY;
        return { entry, index, distance };
      })
      .sort((a, b) => a.distance - b.distance || a.index - b.index)
      .slice(0, maxCount)
      .map((item) => item.entry);
  }

  async function findNearbySubdivisions(parcelFeature, outSR = 4326) {
    const centroid = centroidOfPolygon(parcelFeature?.geometry || null);
    if (!centroid || !Number.isFinite(Number(centroid.x)) || !Number.isFinite(Number(centroid.y))) return [];

    const resp = await arcQuery(LAYERS.subdivisions, {
      where: '1=1',
      outFields: '*',
      returnGeometry: true,
      outSR,
      inSR: 4326,
      geometryType: 'esriGeometryPoint',
      geometry: `${centroid.x},${centroid.y}`,
      spatialRel: 'esriSpatialRelIntersects',
      distance: SUBDIVISION_NEARBY_RADIUS_M,
      units: 'esriSRUnit_Meter',
    });

    return resp?.features || [];
  }

  function dedupeNearbySubdivisionEntries(entries = [], parcelFeature = null) {
    const source = Array.isArray(entries) ? entries : [];
    if (!source.length) return [];

    const centroid = centroidOfPolygon(parcelFeature?.geometry || null);
    const byKey = new Map();

    for (const entry of source) {
      const feature = entry?.feature;
      if (!feature) continue;
      const attrs = feature?.attributes || {};
      const normalizedName = sanitizeSubdivisionName(entry?.name || getSubdivisionNameFromAttrs(attrs));
      const objectId = String(attrs.OBJECTID ?? attrs.ObjectID ?? attrs.FID ?? '').trim();
      const key = normalizedName ? `name:${normalizedName}` : (objectId ? `oid:${objectId}` : 'unknown');

      const featureCentroid = centroidOfPolygon(feature?.geometry || null);
      const distance = (centroid && featureCentroid)
        ? haversineMeters(centroid.y, centroid.x, featureCentroid.y, featureCentroid.x)
        : Number.POSITIVE_INFINITY;

      const current = byKey.get(key);
      if (!current || distance < current.distance) {
        byKey.set(key, { entry, distance });
      }
    }

    return [...byKey.values()]
      .sort((a, b) => a.distance - b.distance)
      .map((item) => item.entry);
  }

  async function attachSubdivisionPlatData(features = [], parcelFeature = null) {
    const out = [];
    let lookupMap = null;
    try {
      lookupMap = await loadSubdivisionPlatLookup();
    } catch (error) {
      log(`Subdivision plat lookup failed: ${error.message || error}`, 'warn');
    }

    const parcelCentroid = centroidOfPolygon(parcelFeature?.geometry || null);

    for (const feature of features) {
      const attrs = feature?.attributes || {};
      const name = getSubdivisionNameFromAttrs(attrs);
      const plat = lookupMap ? matchSubdivisionPlatEntry(name, lookupMap, attrs) : null;
      const featureCentroid = centroidOfPolygon(feature?.geometry || null);
      const distanceMeters = (parcelCentroid && featureCentroid)
        ? haversineMeters(parcelCentroid.y, parcelCentroid.x, featureCentroid.y, featureCentroid.x)
        : null;
      out.push({ feature, name, plat, distanceMeters });
    }

    return out;
  }

  async function findRosNearPoint(lon, lat, searchMeters=1600) {
    const resp = await arcQuery(LAYERS.ros, {
      where: "1=1",
      outFields: "*",
      returnGeometry: true,
      outSR: 4326,
      geometry: `${lon},${lat}`,
      geometryType: "esriGeometryPoint",
      inSR: 4326,
      spatialRel: "esriSpatialRelIntersects",
      distance: searchMeters,
      units: "esriSRUnit_Meter"
    });
    return resp?.features || [];
  }

  // -----------------------------
  // Draw
  // -----------------------------
  function formatAddressAttrs(a) {
    const parts = [];
    if (a.AddNum) parts.push(a.AddNum);
    if (a.StPreDir) parts.push(a.StPreDir);
    if (a.StName) parts.push(a.StName);
    if (a.StSuffix) parts.push(a.StSuffix);
    const line1 = parts.join(" ");
    const line2 = [a.CommName, a.State, a.Zip4].filter(Boolean).join(" ");
    return [line1, line2].filter(Boolean).join(", ");
  }

  function drawAddressPoint(f) {
    const ll = arcPointToLatLng(f.geometry);
    if (!ll) return null;
    const m = L.circleMarker(ll, { radius: 7, weight: 2, color: "#ffffff", fillColor: "#2a3dff", fillOpacity: 0.9 });
    m.bindPopup(`<b>Address</b><br/>${escapeHtml(formatAddressAttrs(f.attributes || {}))}`);
    layers.address.addLayer(m);
    return m;
  }

  function drawUtilityLocations(utilities = []) {
    layers.utilities.clearLayers();
    state.utilityMarkers = [];

    for (let i = 0; i < (utilities || []).length; i++) {
      const utility = utilities[i];
      const ll = getUtilityLatLon(utility);
      if (!ll) continue;

      const label = utility?.code || utility?.name || utility?.provider || 'Utility';

      const marker = L.circleMarker([ll.lat, ll.lon], {
        radius: 6,
        weight: 2,
        color: '#ffffff',
        fillColor: '#ffcc66',
        fillOpacity: 0.9
      });

      marker._rqUtilityIndex = i;
      marker.bindPopup(`<b>Utility</b><br/>${escapeHtml(label)}<br/><span class="small">${escapeHtml(utility?.provider || 'Idaho Power')}</span>`);
      layers.utilities.addLayer(marker);
      state.utilityMarkers[i] = marker;
    }

  }

  /* ---------- Utilities export radius (parcel-corner distance) ---------- */

  const FEET_TO_M = 0.3048;
  const UTIL_RADIUS_MAX_FT = 600;
  const UTIL_RADIUS_DEFAULT_FT = 100;
  const UTIL_RADIUS_DEFAULT_M = UTIL_RADIUS_DEFAULT_FT * FEET_TO_M;

  function getUtilityLatLon(utility) {
    const lon = Number(utility?.location?.lon ?? utility?.location?.x ?? utility?.lon ?? utility?.x);
    const lat = Number(utility?.location?.lat ?? utility?.location?.y ?? utility?.lat ?? utility?.y);
    if (Number.isFinite(lon) && Number.isFinite(lat)) return { lon, lat };
    return null;
  }

  function getParcelCornerLatLngs(parcelFeature) {
    const rings = parcelFeature?.geometry?.rings || [];
    if (!rings.length) return [];
    const ring = rings[0] || [];
    if (!ring.length) return [];

    // Remove duplicated closing vertex if present
    const pts = (ring.length > 1 && ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1])
      ? ring.slice(0, -1)
      : ring.slice();

    // Filter obvious duplicates
    const out = [];
    const seen = new Set();
    for (const [x, y] of pts) {
      const lon = Number(x);
      const lat = Number(y);
      if (!Number.isFinite(lon) || !Number.isFinite(lat)) continue;
      const key = `${lon.toFixed(7)},${lat.toFixed(7)}`;
      if (seen.has(key)) continue;
      seen.add(key);
      out.push({ lon, lat });
    }
    return out;
  }

  function recomputeUtilityMinDistances() {
    state.parcelCornerLatLngs = getParcelCornerLatLngs(state.parcelFeature);
    const corners = state.parcelCornerLatLngs;

    const utils = state.utilityLocations || [];
    const minDists = new Array(utils.length).fill(Infinity);

    if (!corners.length || !utils.length) {
      state.utilityMinDistToParcelCornerM = minDists;
      return;
    }

    for (let i = 0; i < utils.length; i++) {
      const ll = getUtilityLatLon(utils[i]);
      if (!ll) continue;
      let best = Infinity;
      for (let j = 0; j < corners.length; j++) {
        const c = corners[j];
        const d = haversineMeters(c.lat, c.lon, ll.lat, ll.lon);
        if (d < best) best = d;
        if (best <= 0.5) break;
      }
      minDists[i] = best;
    }

    state.utilityMinDistToParcelCornerM = minDists;
  }

  function setUtilityRadiusEnabled(enabled) {
    const utilRadiusEl = $("utilRadius");
    if (utilRadiusEl) utilRadiusEl.disabled = !enabled;
    if (!enabled) {
      state.utilityIncludedIdx = new Set();
      state.utilityMinDistToParcelCornerM = [];
      state.parcelCornerLatLngs = [];
      syncUtilityRadiusUi(0, 0, UTIL_RADIUS_DEFAULT_M);
    }
  }

  function syncUtilityRadiusUi(selectedCount, totalCount, radiusM) {
    const valEl = $("utilRadiusVal");
    const countEl = $("utilRadiusCount");
    if (valEl) valEl.textContent = String(Math.round((Number(radiusM) || 0) / FEET_TO_M));
    if (countEl) countEl.textContent = String(Number(selectedCount) || 0);
    const help = $("utilRadiusHelp");
    if (help && totalCount != null) {
      // keep the existing copy but ensure it stays correct if radius is NaN
      // (text nodes are already wired via spans)
    }
  }

  function updateUtilitySelectionAndMap() {
    const utilRadiusEl = $("utilRadius");
    const radiusFt = utilRadiusEl ? Number(utilRadiusEl.value) : Math.round((Number(state.utilityRadiusM) || UTIL_RADIUS_DEFAULT_M) / FEET_TO_M);
    const radiusM = radiusFt * FEET_TO_M;
    state.utilityRadiusM = Number.isFinite(radiusM) ? radiusM : UTIL_RADIUS_DEFAULT_M;

    const utils = state.utilityLocations || [];
    const minDists = state.utilityMinDistToParcelCornerM || [];
    const included = new Set();

    for (let i = 0; i < utils.length; i++) {
      const d = Number(minDists[i]);
      if (Number.isFinite(d) && d <= state.utilityRadiusM) included.add(i);
    }

    state.utilityIncludedIdx = included;

    // Update UI count
    syncUtilityRadiusUi(included.size, utils.length, state.utilityRadiusM);

    // Highlight included markers on map
    const markers = state.utilityMarkers || [];
    for (let i = 0; i < markers.length; i++) {
      const marker = markers[i];
      if (!marker) continue;
      if (included.has(i)) {
        marker.setStyle({ color: '#ffffff', fillColor: '#ffcc66', fillOpacity: 0.95, weight: 2 });
        if (typeof marker.setRadius === 'function') marker.setRadius(7);
      } else {
        marker.setStyle({ color: 'rgba(255,255,255,0.25)', fillColor: 'rgba(100,116,139,0.35)', fillOpacity: 0.25, weight: 1 });
        if (typeof marker.setRadius === 'function') marker.setRadius(6);
      }
    }
  }

  function getUtilityLocationsForExport() {
    const utils = state.utilityLocations || [];
    const minDists = state.utilityMinDistToParcelCornerM || [];
    const radius = Number(state.utilityRadiusM);
    if (!utils.length) return [];
    if (!Number.isFinite(radius) || minDists.length !== utils.length) return utils; // preserve prior behavior as fallback
    return utils.filter((_, i) => Number(minDists[i]) <= radius);
  }

  function initUtilityRadiusUiOnce() {
    const utilRadiusEl = $("utilRadius");
    if (!utilRadiusEl || utilRadiusEl.dataset.rqBound === '1') return;

    utilRadiusEl.value = String(Math.round((state.utilityRadiusM || UTIL_RADIUS_DEFAULT_M) / FEET_TO_M));
    utilRadiusEl.addEventListener('input', () => updateUtilitySelectionAndMap());
    utilRadiusEl.dataset.rqBound = '1';
  }

  function resetUtilitiesRadiusUiAndState() {
    initUtilityRadiusUiOnce();
    const utilRadiusEl = $("utilRadius");
    if (utilRadiusEl) {
      utilRadiusEl.value = String(UTIL_RADIUS_DEFAULT_FT);
      utilRadiusEl.max = String(UTIL_RADIUS_MAX_FT);
      utilRadiusEl.min = '0';
      utilRadiusEl.step = '1';
      utilRadiusEl.disabled = true;
    }
    state.utilityRadiusM = UTIL_RADIUS_DEFAULT_M;
    state.utilityMinDistToParcelCornerM = [];
    state.utilityIncludedIdx = new Set();
    state.utilityMarkers = [];
    state.parcelCornerLatLngs = [];
    syncUtilityRadiusUi(0, 0, UTIL_RADIUS_DEFAULT_M);
  }

  function afterUtilitiesLoadedOrUpdated() {
    initUtilityRadiusUiOnce();
    recomputeUtilityMinDistances();
    const enabled = Boolean(state.parcelFeature && (state.utilityLocations || []).length);
    setUtilityRadiusEnabled(enabled);
    updateUtilitySelectionAndMap();
  }

  function drawPolygonFeature(f, group, geojsonOptions, label) {
    const gj = arcPolygonToGeoJSON(f.geometry);
    const options = geojsonOptions || {};
    if (!options.pane) options.pane = 'contextPolygons';
    const layer = L.geoJSON(gj, options);
    layer.bindPopup(`<b>${escapeHtml(label)}</b>`);
    group.addLayer(layer);
    return layer;
  }

  function bestRosLabel(a = {}) {
    const pick = (fields = []) => {
      for (const field of fields) {
        const value = a?.[field];
        if (value == null) continue;
        const normalized = String(value).trim();
        if (normalized) return normalized;
      }
      return '';
    };

    const rosNumber = pick(['ROS', 'RS', 'SurveyNo', 'SURVEYNO', 'Survey', 'SURVEY']);
    const pickByKeyPattern = (regex) => {
      for (const [key, value] of Object.entries(a || {})) {
        if (!regex.test(String(key || ''))) continue;
        const normalized = String(value == null ? '' : value).trim();
        if (normalized) return normalized;
      }
      return '';
    };

    const recorderBook = pick(['RecorderBook', 'RECORDERBOOK', 'Book', 'BOOK', 'BookNo', 'BOOKNO', 'Recorder_Book', 'RECORDER_BOOK', 'BookNumber', 'BOOKNUMBER'])
      || pickByKeyPattern(/record(er)?[_\s-]*book|book[_\s-]*(no|num|number)/i);
    const recorderPage = pick(['RecorderPage', 'RECORDERPAGE', 'Page', 'PAGE', 'Pg', 'PG', 'Recorder_Page', 'RECORDER_PAGE', 'PageNo', 'PAGENO', 'PageNumber', 'PAGENUMBER'])
      || pickByKeyPattern(/record(er)?[_\s-]*page|page[_\s-]*(no|num|number)/i);
    const documentNo = pick(['Document', 'DOC', 'DocNo', 'DOCNO', 'InstrumentNo', 'INSTRUMENTNO']);
    const description = pick(['Description', 'DESC', 'Name', 'NAME']);

    const parts = [];
    if (rosNumber) parts.push(`ROS ${rosNumber}`);
    if (recorderBook && recorderPage) parts.push(`Book ${recorderBook} Page ${recorderPage}`);
    else if (recorderBook) parts.push(`Book ${recorderBook}`);
    else if (recorderPage) parts.push(`Page ${recorderPage}`);
    if (documentNo) parts.push(`Doc ${documentNo}`);
    if (description) parts.push(description);

    if (parts.length) return parts.slice(0, 3).join(' · ');
    for (const [, value] of Object.entries(a || {})) {
      if (typeof value === 'string' && value.trim()) return value.trim();
    }
    return 'ROS feature';
  }

  function sanitizeRosAttributesForExport(attributes = {}) {
    const safe = {};
    for (const [key, value] of Object.entries(attributes || {})) {
      if (value == null) continue;
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (trimmed) safe[key] = trimmed;
        continue;
      }
      if (typeof value === 'number') {
        if (Number.isFinite(value)) safe[key] = value;
        continue;
      }
      if (typeof value === 'boolean') {
        safe[key] = value;
      }
    }
    return safe;
  }

  function buildRosMetadataForExport(attributes = {}, rosNameOverride = null) {
    const attrs = sanitizeRosAttributesForExport(attributes);
    const rosName = String(rosNameOverride || attrs.Name || attrs.NAME || attrs.Description || attrs.DESC || attrs.SUB_NAME || attrs.SUBDIVISION || '').trim() || null;
    const rosSourceId = String(attrs.OBJECTID ?? attrs.ObjectID ?? attrs.OBJECTID_1 ?? attrs.FID ?? attrs.GlobalID ?? attrs.GLOBALID ?? '').trim() || null;
    const aliquot = String(attrs.ALIQUOT || attrs.ALIQUOT_LABEL || '').trim() || null;

    return {
      rosName,
      rosSourceId,
      aliquot,
      sourceAttributes: attrs,
    };
  }

  function buildSubdivisionMetadataForExport(entry = {}, index = 0) {
    const feature = entry?.feature || {};
    const attrs = feature?.attributes || {};
    const plat = entry?.plat || {};
    const sourceId = String(attrs.OBJECTID ?? attrs.ObjectID ?? attrs.FID ?? `${index + 1}`).trim();

    return {
      source: 'RecordQuarry',
      sourceId,
      subdivisionName: String(entry?.name || getSubdivisionNameFromAttrs(attrs) || `Subdivision ${index + 1}`).trim(),
      plat: {
        sourcePath: String(plat?.sourcePath || '').trim() || null,
        sourceLine: String(plat?.sourceLine || '').trim() || null,
        platDocId: String(plat?.platDocId || '').trim() || null,
        platPage: Number.isFinite(Number(plat?.platPage)) ? Number(plat.platPage) : null,
        platUrl: String(plat?.platUrl || '').trim() || null,
        thumbnailUrl: String(plat?.thumbnailUrl || '').trim() || null,
      },
      geometry: feature?.geometry || null,
      attributes: attrs,
      starredInFieldBook: true,
    };
  }

  function deriveRosGeolocationForExport(feature = {}) {
    const geometry = feature?.geometry || null;
    if (!geometry) return null;

    if (Number.isFinite(Number(geometry.x)) && Number.isFinite(Number(geometry.y))) {
      return {
        lat: Number(geometry.y),
        lon: Number(geometry.x),
        source: 'point',
      };
    }

    if (Array.isArray(geometry.rings) && geometry.rings.length) {
      const center = centroidOfPolygon(geometry);
      if (center && Number.isFinite(Number(center.y)) && Number.isFinite(Number(center.x))) {
        return {
          lat: Number(center.y),
          lon: Number(center.x),
          source: 'polygon-centroid',
        };
      }
    }

    if (Array.isArray(geometry.paths) && geometry.paths.length && Array.isArray(geometry.paths[0]) && geometry.paths[0].length) {
      const [lonRaw, latRaw] = geometry.paths[0][0] || [];
      if (Number.isFinite(Number(latRaw)) && Number.isFinite(Number(lonRaw))) {
        return {
          lat: Number(latRaw),
          lon: Number(lonRaw),
          source: 'line-first-vertex',
        };
      }
    }

    return null;
  }

  async function resolveRosNameForExport(attributes = {}, imageMeta = null) {
    const attrs = sanitizeRosAttributesForExport(attributes);
    const attrName = String(attrs.Name || attrs.NAME || attrs.Description || attrs.DESC || attrs.SUB_NAME || attrs.SUBDIVISION || '').trim();
    if (attrName) return attrName;
    const tifName = extractRosTifNameFromUrl(imageMeta?.fullSizeUrl || '');
    if (!tifName) return null;
    try {
      const idx = await loadRosSurveyPageListIndex();
      return String(idx.get(tifName) || '').trim() || null;
    } catch {
      return null;
    }
  }

  function normalizeRosFeatures(rosItems = []) {
    return rosItems
      .map((item) => (item?.feature?.geometry ? item.feature : item))
      .filter((f) => f?.geometry);
  }

  function buildSubdivisionSelectionKey(entry, index = 0) {
    const feature = entry?.feature || entry;
    const attrs = feature?.attributes || {};
    const objectId = String(attrs.OBJECTID ?? attrs.ObjectID ?? attrs.FID ?? '').trim();
    if (objectId) return `subdivision:oid:${objectId}`;
    const byName = sanitizeSubdivisionName(entry?.name || getSubdivisionNameFromAttrs(attrs));
    if (byName) return `subdivision:name:${byName}`;
    return `subdivision:index:${Number(index)}`;
  }

  function buildAllSubdivisionSelectionKeys(subdivisionEntries = []) {
    const keys = new Set();
    (subdivisionEntries || []).forEach((entry, index) => {
      keys.add(buildSubdivisionSelectionKey(entry, index));
    });
    return keys;
  }

  function isSubdivisionSelected(entry, index = 0) {
    return state.selectedSubdivisionKeys.has(buildSubdivisionSelectionKey(entry, index));
  }

  function setSubdivisionSelected(entry, index, selected) {
    const key = buildSubdivisionSelectionKey(entry, index);
    if (selected) state.selectedSubdivisionKeys.add(key);
    else state.selectedSubdivisionKeys.delete(key);
  }

  function getSelectedSubdivisionEntries(entries = state.nearbySubdivisions || []) {
    return (entries || []).filter((entry, index) => isSubdivisionSelected(entry, index));
  }

  function buildRosSelectionKey(feature, index = 0) {
    const attrs = feature?.attributes || {};
    const best = String(attrs.ROS || attrs.RS || attrs.SurveyNo || attrs.SURVEYNO || attrs.DOC || attrs.Document || '').trim();
    return best ? `ros:${best.toUpperCase()}` : `ros-index:${Number(index)}`;
  }

  function buildAllRosSelectionKeys(rosFeatures = []) {
    const keys = new Set();
    (rosFeatures || []).forEach((feature, index) => {
      keys.add(buildRosSelectionKey(feature, index));
    });
    return keys;
  }

  function isRosSelected(feature, index = 0) {
    return state.selectedRosKeys.has(buildRosSelectionKey(feature, index));
  }

  function setRosSelected(feature, index, selected) {
    const key = buildRosSelectionKey(feature, index);
    if (selected) state.selectedRosKeys.add(key);
    else state.selectedRosKeys.delete(key);
  }

  function rosIntersectsSection(rosFeature, sectionFeature) {
    if (!sectionFeature?.geometry) return true;
    const g = rosFeature?.geometry;
    if (!g) return false;
    if (g.x != null && g.y != null) {
      return pointInPolygon([g.x, g.y], sectionFeature.geometry);
    }
    if (g.rings?.length) {
      const c = centroidOfPolygon(g);
      return c ? pointInPolygon([c.x, c.y], sectionFeature.geometry) : false;
    }
    if (g.paths?.[0]?.length) {
      return g.paths[0].some(([x, y]) => pointInPolygon([x, y], sectionFeature.geometry));
    }
    return false;
  }

  function filterRosFeaturesForSection(rosFeatures, sectionFeature) {
    return (rosFeatures || []).filter((feature) => rosIntersectsSection(feature, sectionFeature));
  }

  function summarizeAttrs(attrs) {
    if (!attrs) return [["(no attrs)",""]];
    const picks = [];
    const prefer = ["PARCEL","PIN","RP","AIN","SUB","TOWNSHIP","RANGE","SECTION","BOOK","PAGE","RS","ROS","DOC","URL","PDF","LINK","NAME","DESC"];
    const keys = Object.keys(attrs);
    const used = new Set();

    // Hide verbose/low-signal division identifiers and internal IDs (per current UI needs).
    const BLOCK = new Set([
      "FRSTDIVID",
      "OBJECTID",
      "OBJECTID_1",
      "PLSSID",
      "SECDIVID",
      "SECDIVTYP",
      "SECDIVTXT",
      "SECDIVNO",
      "SECDIVLAB"
    ]);

    function add(k) {
      const up = String(k || '').toUpperCase();
      if (BLOCK.has(up)) return;
      if (used.has(k)) return;
      const v = attrs[k];
      if (v === null || v === undefined || v === "") return;
      used.add(k);
      picks.push([k, escapeHtml(v)]);
    }

    for (const token of prefer) {
      for (const k of keys) {
        if (k.toUpperCase().includes(token)) add(k);
        if (picks.length >= 10) break;
      }
      if (picks.length >= 10) break;
    }
    if (!picks.length) for (const k of keys.slice(0, 10)) add(k);
    return picks;
  }

  function findPdfLinks(attrs) {
    const links = [];
    for (const [k,v] of Object.entries(attrs || {})) {
      if (!v) continue;
      const sv = String(v);
      if (/^https?:\/\//i.test(sv) && /\.pdf(\?|$)/i.test(sv)) links.push({ key: k, url: sv });
      if (!/^https?:\/\//i.test(sv) && /\.pdf(\?|$)/i.test(sv)) {
        links.push({ key: k, url: new URL(sv, BASE).toString() });
      }
    }
    const seen = new Set();
    return links.filter(l => (seen.has(l.url) ? false : (seen.add(l.url), true)));
  }

  function buildPdfProxyLinks(attrs, linkText = "Open PDF (API)") {
    const pdfs = findPdfLinks(attrs || {});
    return pdfs.map((p) => (
      `<a target="_blank" rel="noopener" href="${escapeHtml(buildRosPdfProxyUrl(p.url))}">${escapeHtml(linkText)}</a> <span class="small">(${escapeHtml(p.key)})</span>`
    ));
  }
  function buildRosPopupHtml(attrs = {}) {
    const desc = bestRosLabel(attrs);
    const links = buildPdfProxyLinks(attrs, "Open PDF (API)");
    const linkHtml = links.length ? links.map((l, i) => `${i + 1}. ${l}`).join("<br/>") : "No PDF links found";
    const imageHtml = buildRosImageHtml(attrs);

    const meta = buildAdaCountyRosImageMeta(attrs);
    const tifName = meta?.fullSizeUrl ? extractRosTifNameFromUrl(meta.fullSizeUrl) : null;
    const titleHtml = tifName
      ? `<span data-ros-title-tif="${escapeHtml(tifName)}">Record of Survey</span>`
      : "Record of Survey";

    return `<b>${titleHtml}</b><br/>${escapeHtml(desc)}${imageHtml}<div class="hr"></div><div class="small"><b>PDFs</b><br/>${linkHtml}</div>`;
  }



  function buildAdaCountyRosImageMeta(attrs = {}) {
    const values = Object.values(attrs || {});
    let rosNumber = null;
    for (const value of values) {
      const s = String(value || '').trim();
      if (!s) continue;
      const tagged = s.match(/\bRS_(\d{4,6})\b/i);
      if (tagged) {
        rosNumber = Number(tagged[1]);
        break;
      }
      const plain = s.match(/\b(?:ROS|RS)\D*(\d{4,6})\b/i);
      if (plain) {
        rosNumber = Number(plain[1]);
        break;
      }
    }
    if (!Number.isInteger(rosNumber) || rosNumber < 1) return null;

    const versionCandidates = ['VERSION', 'VER', 'REVISION', 'SHEET', 'DRAWING'];
    let version = 1;
    for (const key of versionCandidates) {
      for (const [attrKey, attrVal] of Object.entries(attrs || {})) {
        if (!String(attrKey).toUpperCase().includes(key)) continue;
        const n = Number.parseInt(String(attrVal || '').match(/\d+/)?.[0] || '', 10);
        if (Number.isInteger(n) && n >= 1 && n <= 99) {
          version = n;
          break;
        }
      }
    }

    const rangeBase = Math.floor(rosNumber / 1000) * 1000;
    // Ada County ROS images are bucketed by 1000s using a 4-digit folder suffix (e.g., surv0000, surv1000, ...)
    // and the file name uses a 5-digit, zero-padded ROS number followed by a 2-digit version (e.g., R00463 + 01).
    const folder = `surv${String(rangeBase).padStart(4, '0')}`;
    const rosPart = String(rosNumber).padStart(5, '0');
    const fullSizeUrl = `https://adacountyassessor.org/docs/recordsofsurvey/${folder}/R${rosPart}${String(version).padStart(2, '0')}.tif`;
    return { rosNumber, version, fullSizeUrl };
  }

  function deriveRosImageMeta(attrs = {}) {
    return buildAdaCountyRosImageMeta(attrs);
  }

  function buildRosImageHtml(attrs = {}) {
    const meta = buildAdaCountyRosImageMeta(attrs);
    if (!meta?.fullSizeUrl) return '';
    const thumbnailUrl = `/api/project-files/ros-thumbnail?${new URLSearchParams({ source: meta.fullSizeUrl })}`;
    return `<div class="small" style="margin-top:8px"><b>Record image</b><br/><a target="_blank" rel="noopener" href="${escapeHtml(meta.fullSizeUrl)}">Open full-size ROS image</a><img class="ros-scan-thumb" loading="lazy" alt="ROS ${escapeHtml(String(meta.rosNumber))} thumbnail" data-ros-thumbnail="${escapeHtml(thumbnailUrl)}"/></div>`;
  }


  // -----------------------------
  // Ada County SurveysPageList ROS titles
  // -----------------------------
  const ADA_ROS_SURVEYS_PAGE_LIST_URL = '/api/recordquarry/records-of-survey/page-list';
  let _rosSurveyPageListIndexPromise = null;

  function extractRosTifNameFromUrl(url) {
    const s = String(url || "");
    const m = s.match(/\/((?:R\d{7})\.(?:tif|TIF))(?:\?|$)/);
    return m ? String(m[1]).toUpperCase() : null;
  }

  function parseRosNameFromSurveysPageListLine(line) {
    // User rule: split on township-range-section token like "1N1E01" and take everything after it.
    const parts = String(line || "").split(/\b\d+[NS]\d+[EW]\d{2}\b/);
    if (parts.length < 2) return null;
    const name = parts.slice(1).join("").trim();
    return name || null;
  }

  function buildRosSurveyPageListIndex(text) {
    const idx = new Map();
    const lines = String(text || "").split(/\r?\n/);
    for (const line of lines) {
      const m = line.match(/\bR\d{7}\.(?:tif|TIF)\b/);
      if (!m) continue;
      const tifName = String(m[0]).toUpperCase();
      if (idx.has(tifName)) continue;
      const name = parseRosNameFromSurveysPageListLine(line);
      if (name) idx.set(tifName, name);
    }
    return idx;
  }

  async function fetchRosSurveysPageListText() {
    try {
      const resp = await fetch(ADA_ROS_SURVEYS_PAGE_LIST_URL, { cache: "force-cache" });
      if (resp.ok) return await resp.text();
    } catch {}
    return null;
  }

  async function loadRosSurveyPageListIndex() {
    if (_rosSurveyPageListIndexPromise) return _rosSurveyPageListIndexPromise;
    _rosSurveyPageListIndexPromise = (async () => {
      const text = await fetchRosSurveysPageListText();
      if (!text) return new Map();
      return buildRosSurveyPageListIndex(text);
    })();
    return _rosSurveyPageListIndexPromise;
  }

  function applyRosTitlesInNode(rootNode) {
    const container = rootNode || document;
    const nodes = Array.from(container.querySelectorAll("[data-ros-title-tif]"));
    if (!nodes.length) return;

    loadRosSurveyPageListIndex().then((idx) => {
      for (const node of nodes) {
        if (!node || node.dataset.rosTitleResolved === "1") continue;
        const tif = String(node.getAttribute("data-ros-title-tif") || "").toUpperCase();
        if (!tif) continue;
        const name = idx.get(tif);
        if (!name) continue;
        node.textContent = name;
        node.dataset.rosTitleResolved = "1";
      }
    }).catch(() => {});
  }

  const ROS_THUMBNAIL_MAX_CONCURRENCY = 4;
  const rosThumbnailLoadQueue = [];
  let rosThumbnailLoadsActive = 0;

  async function loadRosThumbnailWithRetry(imgEl, thumbnailUrl, maxAttempts = 9) {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      if (attempt > 0) {
        await new Promise((r) => setTimeout(r, Math.min(600 * Math.pow(2, attempt - 1), 10000)));
      }
      try {
        const resp = await fetch(thumbnailUrl);
        if (resp.ok && resp.headers.get('content-type')?.startsWith('image/')) {
          const blob = await resp.blob();
          if (imgEl.dataset.thumbObjectUrl) {
            try { URL.revokeObjectURL(imgEl.dataset.thumbObjectUrl); } catch {}
          }
          const objectUrl = URL.createObjectURL(blob);
          imgEl.dataset.thumbObjectUrl = objectUrl;
          imgEl.src = objectUrl;
          imgEl.style.display = '';
          bindRqHoverPreview(imgEl, imgEl.alt || 'ROS preview');
          return true;
        }
        if (resp.status === 202) continue;
        break;
      } catch {
        break;
      }
    }
    return false;
  }

  function drainRosThumbnailLoadQueue() {
    while (rosThumbnailLoadsActive < ROS_THUMBNAIL_MAX_CONCURRENCY && rosThumbnailLoadQueue.length) {
      const { imgEl, thumbnailUrl, resolve } = rosThumbnailLoadQueue.shift();
      rosThumbnailLoadsActive += 1;
      loadRosThumbnailWithRetry(imgEl, thumbnailUrl)
        .then((ok) => resolve(ok))
        .catch(() => resolve(false))
        .finally(() => {
          rosThumbnailLoadsActive = Math.max(0, rosThumbnailLoadsActive - 1);
          drainRosThumbnailLoadQueue();
        });
    }
  }

  function enqueueRosThumbnailLoad(imgEl, thumbnailUrl) {
    return new Promise((resolve) => {
      rosThumbnailLoadQueue.push({ imgEl, thumbnailUrl, resolve });
      drainRosThumbnailLoadQueue();
    });
  }

  function lazyLoadRosScanThumbnails() {
    const thumbs = Array.from(document.querySelectorAll('img.ros-scan-thumb[data-ros-thumbnail]'));
    if (!thumbs.length) return;
    const loadThumb = async (img) => {
      if (!img || img.dataset.thumbLoaded === '1' || img.dataset.thumbLoading === '1') return;
      const thumbnailUrl = img.getAttribute('data-ros-thumbnail');
      if (!thumbnailUrl) return;
      img.dataset.thumbLoading = '1';
      const ok = await enqueueRosThumbnailLoad(img, thumbnailUrl);
      delete img.dataset.thumbLoading;
      img.dataset.thumbLoaded = '1';
      if (!ok && img.dataset.keepPlaceholder !== '1') img.style.display = 'none';
    };

    if (!('IntersectionObserver' in window)) {
      thumbs.forEach((img) => loadThumb(img));
      return;
    }

    const observer = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        if (!entry.isIntersecting) continue;
        observer.unobserve(entry.target);
        loadThumb(entry.target);
      }
    }, { rootMargin: '120px 0px' });

    for (const img of thumbs) observer.observe(img);
  }

  // Load ROS thumbnails inside a specific DOM node (Leaflet popups/tooltips are injected after initial render).
  function loadRosScanThumbnailsInNode(rootNode) {
    const container = rootNode || document;
    const thumbs = Array.from(container.querySelectorAll('img.ros-scan-thumb[data-ros-thumbnail]'));
    if (!thumbs.length) return;
    for (const img of thumbs) {
      if (!img || img.dataset.thumbLoaded === '1' || img.dataset.thumbLoading === '1') continue;
      const thumbnailUrl = img.getAttribute('data-ros-thumbnail');
      if (!thumbnailUrl) continue;
      img.dataset.thumbLoading = '1';
      // Keep hidden until we have a real src to avoid broken-image glyphs in Leaflet UI.
      if (img.dataset.keepPlaceholder !== '1') img.style.display = 'none';
      enqueueRosThumbnailLoad(img, thumbnailUrl).then((ok) => {
        delete img.dataset.thumbLoading;
        img.dataset.thumbLoaded = '1';
        if (!ok && img.dataset.keepPlaceholder !== '1') img.style.display = 'none';
      });
    }
  }

  // Ensure ROS thumbnails load when Leaflet popups/tooltips open (they are not present during initial lazy-load scan).
  function bindRosMapPopupThumbnailLoader() {
    if (!map || map.__rqRosThumbLoaderBound) return;
    map.__rqRosThumbLoaderBound = true;

    map.on('popupopen', (evt) => {
      try {
        const el = evt?.popup?.getElement?.();
        if (el) { loadRosScanThumbnailsInNode(el); applyRosTitlesInNode(el); }
      } catch {}
    });

    map.on('tooltipopen', (evt) => {
      try {
        const el = evt?.tooltip?.getElement?.();
        if (el) { loadRosScanThumbnailsInNode(el); applyRosTitlesInNode(el); }
      } catch {}
    });
  }

  bindRosMapPopupThumbnailLoader();


  const RQ_HOVER_MARGIN = 16;
  const RQ_HOVER_GAP = 14;
  let rqHoverPreviewTooltip = null;

  function ensureRqHoverPreviewTooltip() {
    if (rqHoverPreviewTooltip && document.body.contains(rqHoverPreviewTooltip)) {
      return rqHoverPreviewTooltip;
    }
    const tooltip = document.createElement('div');
    tooltip.className = 'rq-hover-preview-tooltip';
    tooltip.setAttribute('aria-hidden', 'true');

    const image = document.createElement('img');
    image.className = 'rq-hover-preview-image';
    image.alt = '';
    tooltip.appendChild(image);
    document.body.appendChild(tooltip);
    rqHoverPreviewTooltip = tooltip;
    return tooltip;
  }

  function hideRqHoverPreviewTooltip() {
    if (!rqHoverPreviewTooltip) return;
    rqHoverPreviewTooltip.classList.remove('visible');
    rqHoverPreviewTooltip.style.width = '';
    rqHoverPreviewTooltip.style.height = '';
    rqHoverPreviewTooltip.style.left = '';
    rqHoverPreviewTooltip.style.top = '';
  }

  function showRqHoverPreviewTooltip(anchor, imageSrc, altText = 'Record preview', sourceDimensions = null) {
    if (!anchor || !imageSrc) return;

    const tooltip = ensureRqHoverPreviewTooltip();
    const previewImage = tooltip.querySelector('.rq-hover-preview-image');
    if (!previewImage) return;

    previewImage.src = imageSrc;
    previewImage.alt = altText;

    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const anchorRect = anchor.getBoundingClientRect();

    const imageNaturalWidth = Number(sourceDimensions?.width || previewImage.naturalWidth || anchor.naturalWidth || 0);
    const imageNaturalHeight = Number(sourceDimensions?.height || previewImage.naturalHeight || anchor.naturalHeight || 0);
    const safeImageHeight = imageNaturalHeight > 0 ? imageNaturalHeight : 1;
    const imageAspectRatio = imageNaturalWidth > 0 ? (imageNaturalWidth / safeImageHeight) : (8.5 / 11);

    const maxBoxWidth = Math.max(180, viewportWidth - (RQ_HOVER_MARGIN * 2));
    const maxBoxHeight = Math.max(220, Math.floor(viewportHeight * 0.9));

    const availableRight = Math.max(0, viewportWidth - anchorRect.right - RQ_HOVER_GAP - RQ_HOVER_MARGIN);
    const availableLeft = Math.max(0, anchorRect.left - RQ_HOVER_GAP - RQ_HOVER_MARGIN);
    const availableBelow = Math.max(0, viewportHeight - anchorRect.bottom - RQ_HOVER_GAP - RQ_HOVER_MARGIN);
    const availableAbove = Math.max(0, anchorRect.top - RQ_HOVER_GAP - RQ_HOVER_MARGIN);
    const minVisible = 88;

    const estimateSide = (sideWidth) => {
      const width = Math.min(maxBoxWidth, sideWidth);
      if (width <= 0) return { score: 0, width: 0, height: 0 };
      const height = Math.min(maxBoxHeight, Math.max(minVisible, Math.floor(width / imageAspectRatio)));
      const finalWidth = Math.min(width, Math.max(minVisible, Math.floor(height * imageAspectRatio)));
      const finalHeight = Math.min(maxBoxHeight, Math.max(minVisible, Math.floor(finalWidth / imageAspectRatio)));
      return { score: finalWidth * finalHeight, width: finalWidth, height: finalHeight };
    };

    const estimateVertical = (verticalHeight) => {
      const height = Math.min(maxBoxHeight, verticalHeight);
      if (height <= 0) return { score: 0, width: 0, height: 0 };
      const width = Math.min(maxBoxWidth, Math.max(minVisible, Math.floor(height * imageAspectRatio)));
      const finalHeight = Math.min(height, Math.max(minVisible, Math.floor(width / imageAspectRatio)));
      const finalWidth = Math.min(maxBoxWidth, Math.max(minVisible, Math.floor(finalHeight * imageAspectRatio)));
      return { score: finalWidth * finalHeight, width: finalWidth, height: finalHeight };
    };

    const placements = [
      { key: 'right', fit: estimateSide(availableRight) },
      { key: 'left', fit: estimateSide(availableLeft) },
      { key: 'below', fit: estimateVertical(availableBelow) },
      { key: 'above', fit: estimateVertical(availableAbove) },
    ].sort((a, b) => b.fit.score - a.fit.score);

    const chosen = placements.find((p) => p.fit.width >= minVisible && p.fit.height >= minVisible) || placements[0];
    const placement = chosen.key;
    const previewWidth = chosen.fit.width;
    const previewHeight = chosen.fit.height;
    if (!previewWidth || !previewHeight) return;

    tooltip.style.width = `${Math.round(previewWidth)}px`;
    tooltip.style.height = `${Math.round(previewHeight)}px`;

    let left = RQ_HOVER_MARGIN;
    let top = RQ_HOVER_MARGIN;
    if (placement === 'right') {
      left = Math.round(anchorRect.right + RQ_HOVER_GAP);
      top = Math.round(anchorRect.top + (anchorRect.height / 2) - (previewHeight / 2));
    } else if (placement === 'left') {
      left = Math.round(anchorRect.left - RQ_HOVER_GAP - previewWidth);
      top = Math.round(anchorRect.top + (anchorRect.height / 2) - (previewHeight / 2));
    } else if (placement === 'below') {
      top = Math.round(anchorRect.bottom + RQ_HOVER_GAP);
      left = Math.round(anchorRect.left + (anchorRect.width / 2) - (previewWidth / 2));
    } else if (placement === 'above') {
      top = Math.round(anchorRect.top - RQ_HOVER_GAP - previewHeight);
      left = Math.round(anchorRect.left + (anchorRect.width / 2) - (previewWidth / 2));
    }

    left = Math.min(Math.max(RQ_HOVER_MARGIN, left), viewportWidth - previewWidth - RQ_HOVER_MARGIN);
    top = Math.min(Math.max(RQ_HOVER_MARGIN, top), viewportHeight - previewHeight - RQ_HOVER_MARGIN);

    tooltip.style.left = `${Math.round(left)}px`;
    tooltip.style.top = `${Math.round(top)}px`;
    tooltip.classList.add('visible');
  }

  function bindRqHoverPreview(thumb, altText = 'Record preview') {
    if (!thumb || thumb.dataset.rqHoverBound === '1') return;
    thumb.dataset.rqHoverBound = '1';

    const show = () => {
      if (!thumb.src) return;
      showRqHoverPreviewTooltip(thumb, thumb.src, altText, {
        width: thumb.naturalWidth,
        height: thumb.naturalHeight,
      });
    };

    thumb.addEventListener('mouseenter', show);
    thumb.addEventListener('focus', show);
    thumb.addEventListener('mouseleave', () => hideRqHoverPreviewTooltip());
    thumb.addEventListener('blur', () => hideRqHoverPreviewTooltip());
  }

  window.addEventListener('scroll', () => hideRqHoverPreviewTooltip(), { passive: true });
  window.addEventListener('resize', () => hideRqHoverPreviewTooltip());

  function buildAliquotPopupHtml(feature, label = 'Aliquot') {
    const attrs = feature?.attributes || {};
    const links = buildPdfProxyLinks(attrs, 'Open CP&F PDF (API)');
    const linkHtml = links.length ? links.map((l, i) => `${i + 1}. ${l}`).join('<br/>') : 'No CP&amp;F PDF links found';
    return `<b>Aliquot</b><br/>${escapeHtml(label)}<div class="hr"></div><div class="small"><b>CP&amp;F PDFs</b><br/>${linkHtml}</div>`;
  }

  function flattenCpfRecordLinks(records = []) {
    const links = [];
    const seen = new Set();
    for (const record of records) {
      for (const url of (record?.links || [])) {
        const key = canonicalizeUrl(url);
        if (!key || seen.has(key)) continue;
        seen.add(key);
        links.push(url);
      }
    }
    return links;
  }

  async function queryCpfRecordsForAliquot(feature) {
    const corners = getPolygonCornerMarkers(feature, 'aliquot');
    const out = [];
    const seen = new Set();

    for (const corner of corners) {
      const records = await queryCpfRecordsNearCorner(corner.north, corner.east);
      for (const record of records) {
        const links = [];
        for (const url of (record?.links || [])) {
          const key = canonicalizeUrl(url);
          if (!key || seen.has(key)) continue;
          seen.add(key);
          links.push(url);
        }
        if (!links.length) continue;
        out.push({
          instrument: record.instrument,
          monset: record.monset,
          surveyor: record.surveyor,
          distanceMeters: record.distanceMeters,
          links,
        });
      }
      if (out.length >= 8) break;
    }

    return out;
  }

  function buildCpfPdfThumbnailUrl(pdfProxyUrl) {
    // pdfProxyUrl is a relative URL like /api/ros-pdf?url=... from buildRosPdfProxyUrl
    return `/api/project-files/pdf-thumbnail?${new URLSearchParams({ source: pdfProxyUrl })}`;
  }

  async function loadCpfThumbnailWithRetry(imgEl, thumbnailUrl, maxAttempts = 9) {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      if (attempt > 0) {
        await new Promise((r) => setTimeout(r, Math.min(600 * Math.pow(2, attempt - 1), 10000)));
      }
      try {
        const resp = await fetch(thumbnailUrl);
        if (resp.ok && resp.headers.get('content-type')?.startsWith('image/')) {
          const blob = await resp.blob();
          imgEl.src = URL.createObjectURL(blob);
          imgEl.style.display = '';
          bindRqHoverPreview(imgEl, imgEl.alt || 'CP&F preview');
          return true;
        }
        if (resp.status === 202) continue; // still generating — retry
        break; // permanent error
      } catch {
        break;
      }
    }
    return false;
  }

  async function lazyLoadAliquotSummaryCpfLinks(targets = []) {
    for (const target of targets) {
      const node = document.querySelector(`[data-aliquot-cpf-links="${target.token}"]`);
      if (!node) continue;
      try {
        const records = await queryCpfRecordsForAliquot(target.feature);
        if (!flattenCpfRecordLinks(records).length) {
          node.innerHTML = '<span class="small">No CP&amp;F PDF links found.</span>';
          log(`No CP&F PDF links found for summary ${target.label}.`, 'warn');
          continue;
        }
        // Collapsed view: minimal CP&F preview (thumbnail + instrument + monument set + surveyor)
        const first = records[0];
        const firstProxyUrl = first.links?.[0] ? buildRosPdfProxyUrl(first.links[0]) : null;

        const resolvedInstrument = resolveCpfRecordInstrument(first);
        const instrumentText = resolvedInstrument ? String(resolvedInstrument).trim() : '';
        const instrumentHtml = instrumentText ? escapeHtml(instrumentText) : 'CP&amp;F';

        const monsetText = first.monset != null ? String(first.monset).trim() : '';
        const surveyorText = first.surveyor != null ? String(first.surveyor).trim() : '';

        const monsetHtml = monsetText
          ? `<div class="small" style="margin-top:2px;color:var(--muted)">Monument Set: <span style="color:var(--text)">${escapeHtml(monsetText)}</span></div>`
          : '';
        const surveyorHtml = surveyorText
          ? `<div class="small" style="color:var(--muted)">Surveyor: <span style="color:var(--text)">${escapeHtml(surveyorText)}</span></div>`
          : '';

        let moreRowsHtml = '';
        if (records.length > 1) {
          moreRowsHtml = records.slice(1).map((rec, idx) => {
            const inst = resolveCpfRecordInstrument(rec) || `Record ${idx + 2}`;
            const ms = rec.monset != null ? String(rec.monset).trim() : '';
            const sv = rec.surveyor != null ? String(rec.surveyor).trim() : '';
            const msH = ms
              ? `<div class="small" style="margin-top:2px;color:var(--muted)">Monument Set: <span style="color:var(--text)">${escapeHtml(ms)}</span></div>`
              : '';
            const svH = sv
              ? `<div class="small" style="color:var(--muted)">Surveyor: <span style="color:var(--text)">${escapeHtml(sv)}</span></div>`
              : '';
            const proxyUrl = rec.links?.[0] ? buildRosPdfProxyUrl(rec.links[0]) : null;
            const openAttr = proxyUrl ? ` data-cpf-open="${escapeHtml(proxyUrl)}"` : '';
            const thumbHtml = proxyUrl
              ? `<img class="cpf-thumb" style="display:none;flex-shrink:0" alt="CP&amp;F PDF thumbnail" data-cpf-proxy="${escapeHtml(proxyUrl)}"/>`
              : '';
            return `<div class="cpf-record-row" style="display:flex;gap:8px;align-items:flex-start"${openAttr}>${thumbHtml}<div style="flex:1;min-width:0"><b>${escapeHtml(inst)}</b>${msH}${svH}</div></div>`;
          }).join('');
        }

        const expandHtml = records.length > 1
          ? `<div style="margin-top:6px"><button class="secondary cpf-expand-btn" data-cpf-expand>Show all ${records.length} records</button></div>`
          : '';
        const allRecordsHtml = records.length > 1
          ? `<div data-cpf-all style="display:none;margin-top:8px">${moreRowsHtml}</div>`
          : '';

        const openAttr = firstProxyUrl ? ` data-cpf-open="${escapeHtml(firstProxyUrl)}"` : '';

        node.innerHTML = `<div class="cpf-collapsed">
          <img class="cpf-thumb" style="display:none" alt="CP&amp;F PDF thumbnail"/>
          <div class="cpf-collapsed-info">
            <b class="cpf-inst"${openAttr} style="cursor:${firstProxyUrl ? 'pointer' : 'default'}">${instrumentHtml}</b>
            ${monsetHtml}${surveyorHtml}
            ${expandHtml}${allRecordsHtml}
          </div>
        </div>`;

        // Wire expand/collapse button
        const expandBtn = node.querySelector('[data-cpf-expand]');
        const allDiv = node.querySelector('[data-cpf-all]');
        if (expandBtn && allDiv) {
          let expanded = false;
          const total = records.length;
          const syncLabel = () => {
            expandBtn.textContent = expanded ? 'Hide records' : `Show all ${total} records`;
          };
          syncLabel();
          expandBtn.addEventListener('click', (evt) => {
            evt.stopPropagation();
            expanded = !expanded;
            allDiv.style.display = expanded ? '' : 'none';
            syncLabel();
            // Lazy-load thumbnails for secondary records on first expand.
            if (expanded) {
              allDiv.querySelectorAll('img[data-cpf-proxy]').forEach((imgEl) => {
                if (imgEl.dataset.rqLoaded) return;
                imgEl.dataset.rqLoaded = '1';
                const proxyUrl = imgEl.dataset.cpfProxy;
                if (!proxyUrl) return;
                imgEl.addEventListener('click', (e) => { e.stopPropagation(); window.open(proxyUrl, '_blank', 'noopener'); });
                loadCpfThumbnailWithRetry(imgEl, buildCpfPdfThumbnailUrl(proxyUrl));
              });
            }
          });
        }

        // Make instrument + record rows open their PDFs (no extra text links)
        node.querySelectorAll('[data-cpf-open]').forEach((el) => {
          el.addEventListener('click', (evt) => {
            evt.stopPropagation();
            const url = el.getAttribute('data-cpf-open');
            if (url) window.open(url, '_blank', 'noopener');
          });
        });

        // Load thumbnail for the first record's PDF (clicking thumbnail opens the PDF)
        if (firstProxyUrl) {
          const thumbEl = node.querySelector('.cpf-thumb');
          if (thumbEl) {
            thumbEl.addEventListener('click', (evt) => {
              evt.stopPropagation();
              window.open(firstProxyUrl, '_blank', 'noopener');
            });
            const okThumb = await loadCpfThumbnailWithRetry(thumbEl, buildCpfPdfThumbnailUrl(firstProxyUrl));
            if (!okThumb) {
              // If thumbnail failed, keep it hidden; instrument text remains clickable.
            }
          }
        }

        log(`Loaded CP&F PDF links for summary ${target.label}.`);
      } catch (e) {
        node.innerHTML = `<span class="small" style="color:#ffb3b3">CP&amp;F lookup failed: ${escapeHtml(e.message || e)}</span>`;
        log(`CP&F summary lookup failed for ${target.label}: ${e.message || e}`, 'warn');
      }
    }
  }

  // -----------------------------
  // Export helpers
  // -----------------------------
  function buildExportGeoJSON() {
    const features = [];

    function pushPolygonFeature(feature, role) {
      if (!feature?.geometry) return;
      const geometry = arcPolygonToGeoJSON(feature.geometry);
      if (!geometry) return;
      features.push({
        type: "Feature",
        properties: {
          role,
          ...(feature.attributes || {})
        },
        geometry
      });
    }

    pushPolygonFeature(state.parcelFeature, "parcel");
    pushPolygonFeature(state.subdivisionFeature, "subdivision");
    pushPolygonFeature(state.sectionFeature, "section");
    pushPolygonFeature(state.townshipFeature, "township");

    for (const feature of state.aliquotFeatures || []) pushPolygonFeature(feature, "aliquot");
    for (const feature of state.rosFeatures || []) pushPolygonFeature(feature, "ros");

    if (state.lastLonLat) {
      features.push({
        type: "Feature",
        properties: { role: "address_point" },
        geometry: { type: "Point", coordinates: [state.lastLonLat.lon, state.lastLonLat.lat] }
      });
    }

    return {
      type: "FeatureCollection",
      metadata: {
        generatedAt: new Date().toISOString(),
        count: features.length
      },
      features
    };
  }

  function downloadJson(obj, filename) {
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  function downloadText(text, filename, mime="text/plain") {
    const blob = new Blob([text], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  async function fetchParcelGeometry2243FromPoint(lon, lat) {
    return fetchParcelNearPoint(lon, lat, EXPORT_OUT_SR, 150);
  }

  async function fetchAliquotsAtPoint(lon, lat, outSR = 4326) {
    const payload = await loadAliquotsAtPoint(lon, lat, outSR);
    return payload?.aliquots || [];
  }

  async function fetchSectionGeometry2243FromPoint(lon, lat) {
    const section4326 = await findContainingPolygon(LAYERS.sections, lon, lat, 2500, 4326);
    const objectId = Number(section4326?.attributes?.OBJECTID);
    if (!Number.isFinite(objectId)) return null;

    const resp = await arcQuery(LAYERS.sections, {
      where: `OBJECTID=${objectId}`,
      outFields: '*',
      returnGeometry: true,
      outSR: EXPORT_OUT_SR,
      resultRecordCount: 1,
    });

    return resp?.features?.[0] || null;
  }

  async function fetchSubdivisionGeometry2243FromPoint(lon, lat) {
    const subdivision4326 = await findContainingPolygon(LAYERS.subdivisions, lon, lat, 2500, 4326);
    if (!subdivision4326) return null;

    const objectId = Number(subdivision4326?.attributes?.OBJECTID);
    if (!Number.isFinite(objectId)) {
      return findContainingPolygon(LAYERS.subdivisions, lon, lat, 2500, EXPORT_OUT_SR);
    }

    const resp = await arcQuery(LAYERS.subdivisions, {
      where: `OBJECTID=${objectId}`,
      outFields: '*',
      returnGeometry: true,
      outSR: EXPORT_OUT_SR,
      resultRecordCount: 1,
    });

    return resp?.features?.[0] || null;
  }

  // -----------------------------
  // PDF Basis of Bearing (upload)
  // -----------------------------
  function extractBasisLines(text) {
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const hits = [];
    const re = /(BASIS\s+OF\s+BEARING|BASIS\s+OF\s+BEARINGS|BEARINGS?\s+ARE\s+BASED\s+ON|BEARINGS?\s+SHOWN\s+HEREON\s+ARE\s+BASED\s+ON)/i;

    for (const ln of lines) if (re.test(ln)) hits.push(ln);

    const context = [];
    for (let i=0; i<lines.length; i++) {
      if (re.test(lines[i])) {
        const start = Math.max(0, i-2);
        const end = Math.min(lines.length, i+5);
        context.push(lines.slice(start, end).join(" "));
      }
    }

    const uniq = (arr) => {
      const s = new Set();
      const out = [];
      for (const x of arr) { const k=x.toUpperCase(); if (!s.has(k)) { s.add(k); out.push(x); } }
      return out;
    };
    return { hits: uniq(hits), context: uniq(context) };
  }

  async function scanUploadedPdf(file) {
    if (!file) throw new Error("No PDF selected.");
    if (!window.pdfjsLib) throw new Error("pdfjsLib missing.");
    const buf = await file.arrayBuffer();
    const doc = await pdfjsLib.getDocument({ data: buf }).promise;
    let fullText = "";
    for (let p=1; p<=doc.numPages; p++) {
      const page = await doc.getPage(p);
      const tc = await page.getTextContent();
      const strings = tc.items.map(it => it.str);
      fullText += strings.join("\n") + "\n";
    }
    return extractBasisLines(fullText);
  }

  // -----------------------------
  // Main flow
  // -----------------------------
  async function doLookup(options = {}) {
    const lookupButton = $("btnLookup");
    lookupButton.disabled = true;
    setBusyModalOpen(true, 'Loading RecordQuarry data…', 'Querying address, parcel, subdivision, section, township, ROS, and aliquot records.');
    clearLog();
    $("btnExportParcelCSV").disabled = true;
    $("btnExportPointForge").disabled = true;
    state.exportGeoJSON = null;
    state.parcelFeature2243 = null;
    state.subdivisionFeature2243 = null;
    state.subdivisionFeature = null;
    state.nearbySubdivisions = [];
    state.aliquotFeatures = [];
    state.sectionFeature2243 = null;
    state.aliquotFeatures2243 = [];
    state.selectedParcel = true;
    state.selectedAliquot = null;
    state.selectedAliquotKeys.clear();
    state.selectedRosKeys.clear();
    state.selectedSubdivisionKeys.clear();
    setSummaryCards([]);
    clearMapLayers();
    resetUtilitiesRadiusUiAndState();

    const rawAddr = $("addr").value.trim();
    if (!rawAddr) { log("Enter an address.", "warn"); return; }

    try {
      log("Lookup started.");
      invalidateMapSoon("lookup start");

      const cachedAddressSnapshot = (!options.lookupPayload && !options.disableAddressCache)
        ? await loadAddressLookupSnapshot(rawAddr)
        : null;
      const cachedLookup = options.lookupPayload || cachedAddressSnapshot?.lookup || null;
      const lookup = canUseCachedLookupPayload(cachedLookup)
        ? cachedLookup
        : await lookupByAddress(rawAddr);
      state.lastLookupPayload = lookup;
      state.lastLookupAddress = rawAddr;
      if (options.lookupPayload) {
        log("Loaded saved project results from local storage.");
      } else if (cachedAddressSnapshot?.lookup) {
        log(`Loaded saved address results from ${cachedAddressSnapshot.savedAt || 'local storage'}.`);
      }
      const addrF = lookup.addressFeature || null;
      const candidates = addrF ? [addrF] : [];
      if (!addrF) {
        log("Address not found in Ada County Address layer (16). Continuing with geocoder coordinates.", "warn");
      }
      state.addressFeature = addrF;

      const lon = lookup.location?.lon ?? addrF?.geometry?.x;
      const lat = lookup.location?.lat ?? addrF?.geometry?.y;
      const addrLL = [lat, lon];
      const addressDisplay = addrF ? formatAddressAttrs(addrF.attributes || {}) : (lookup.geocode?.display || rawAddr);
      log(`Address match: ${addrLL[0].toFixed(7)}, ${addrLL[1].toFixed(7)}`);
      if (addrF) {
        drawAddressPoint(addrF);
      } else {
        const geocodeMarker = L.circleMarker(addrLL, { radius: 7, weight: 2, color: "#ffffff", fillColor: "#2a3dff", fillOpacity: 0.9 });
        geocodeMarker.bindPopup(`<b>Geocoded Address</b><br/>${escapeHtml(addressDisplay)}`);
        layers.address.addLayer(geocodeMarker);
      }

      map.setView(addrLL, 18);
      invalidateMapSoon("after setView");
      state.lastLonLat = { lon, lat };

      const parcel = lookup.parcel;
      if (!parcel) {
        log("Parcel not found near that address point (0/10/30/150m).", "bad");
        setSummaryCards([
          card("Address", addressDisplay,
            [["Lat/Lon", `${lat.toFixed(7)}, ${lon.toFixed(7)}`],["Candidates", String(candidates.length)]],
            [])
        ]);
        invalidateMapSoon("parcel not found");
        return;
      }
      state.parcelFeature = parcel;

      drawParcel();

      const ext = arcExtentFromPolygon(parcel.geometry);
      if (ext) {
        const bounds = L.latLngBounds([ext.ymin, ext.xmin], [ext.ymax, ext.xmax]);
        map.fitBounds(bounds.pad(0.15));
        invalidateMapSoon("after fitBounds");
      }

      const c = centroidOfPolygon(parcel.geometry) || { x: lon, y: lat };
      log(`Parcel centroid: ${c.y.toFixed(7)}, ${c.x.toFixed(7)}`);

      const subdiv = lookup.subdivision || null;
      const section = lookup.section || null;
      const township = lookup.township || null;

      state.subdivisionFeature = subdiv;
      state.sectionFeature = section;
      state.townshipFeature = township;
      state.nearbySubdivisions = [];

      try {
        const nearbySubdivisionFeatures = await findNearbySubdivisions(parcel, 4326);
        const nearbyWithPlatData = await attachSubdivisionPlatData(nearbySubdivisionFeatures, parcel);
        state.nearbySubdivisions = dedupeNearbySubdivisionEntries(nearbyWithPlatData, parcel);
        state.nearbySubdivisions = limitNearbySubdivisionEntries(state.nearbySubdivisions, parcel, SUBDIVISION_NEARBY_MAX_RESULTS);
        log(`Subdivisions within ${SUBDIVISION_NEARBY_RADIUS_FT} ft: ${state.nearbySubdivisions.length}`);
      } catch (e) {
        state.nearbySubdivisions = subdiv ? [{ feature: subdiv, name: getSubdivisionNameFromAttrs(subdiv.attributes || {}), plat: null }] : [];
        log(`Nearby subdivision lookup failed: ${e.message || e}`, 'warn');
      }

      try {
        state.aliquotFeatures = await fetchAliquotsAtPoint(lon, lat, 4326);
        state.aliquotFeatures2243 = await fetchAliquotsAtPoint(lon, lat, EXPORT_OUT_SR);
        applySelectionSnapshot(options.selectionSnapshot || cachedAddressSnapshot?.selection || null);
        drawAliquots(state.aliquotFeatures, section);
        log(`Aliquots loaded: ${state.aliquotFeatures.length}`);
      } catch (e) {
        state.aliquotFeatures = [];
        state.aliquotFeatures2243 = [];
        state.selectedAliquotKeys.clear();
        log(`Aliquot lookup failed: ${e.message || e}`, "warn");
      }

      const nearbySubdivisionEntries = state.nearbySubdivisions.length
        ? state.nearbySubdivisions
        : (subdiv ? [{ feature: subdiv, name: getSubdivisionNameFromAttrs(subdiv.attributes || {}), plat: null }] : []);
      drawSubdivisionPolygons(nearbySubdivisionEntries);
      if (section) drawPolygonFeature(section, layers.section, { style: () => ({ color:"#ffcc66", weight:2, fillOpacity:0.03, dashArray:"6 6" }) }, "Section");
      if (township) drawPolygonFeature(township, layers.township, { interactive: false, style: () => ({ color:"#ff5a7a", weight:2, fillOpacity:0.02, dashArray:"3 8" }) }, "Township");

      drawCornerMarkers(buildCornerMarkerEntries());

      const utilityLookupPromise = loadUtilitiesByAddress(rawAddr, {
        outSR: EXPORT_OUT_SR,
        sources: ['power'],
        timeoutMs: UTILITY_LOOKUP_TIMEOUT_MS,
      })
        .then((utilityLocations) => ({ utilityLocations, error: null }))
        .catch((error) => ({ utilityLocations: [], error }));

      const rosFromLookup = normalizeRosFeatures(lookup.ros || []);
      const ros = filterRosFeaturesForSection(rosFromLookup, section);
      state.utilityLocations = [];
      drawUtilityLocations(state.utilityLocations);
      state.rosFeatures = ros;
      state.selectedRosKeys = new Set();
      const selectionSnapshot = options.selectionSnapshot || cachedAddressSnapshot?.selection || null;
      if (
        Array.isArray(selectionSnapshot?.selectedRosKeys)
        || Array.isArray(selectionSnapshot?.deselectedRosKeys)
        || Array.isArray(selectionSnapshot?.selectedSubdivisionKeys)
        || Array.isArray(selectionSnapshot?.deselectedSubdivisionKeys)
      ) {
        applySelectionSnapshot(selectionSnapshot);
      }
      log(`ROS in containing section: ${ros.length} (from ${rosFromLookup.length} nearby ROS)`);

      for (const f of ros) {
        const g = f.geometry;
        if (!g) continue;
        if (g.x != null && g.y != null) {
          const m = L.circleMarker([g.y, g.x], { radius: 5, weight: 1.5, color: "#ffffff", fillColor:"#ff5a7a", fillOpacity: .7 });
          m.bindPopup(buildRosPopupHtml(f.attributes || {}));
          layers.ros.addLayer(m);
        } else if (g.paths) {
          const gj = { type:"Feature", properties:{}, geometry:{ type:"LineString", coordinates: g.paths[0].map(([x,y])=>[x,y]) } };
          const l = L.geoJSON(gj, { style:{ color:"#ff5a7a", weight:2 }});
          l.bindPopup(buildRosPopupHtml(f.attributes || {}));
          layers.ros.addLayer(l);
        } else if (g.rings) {
          const gj = arcPolygonToGeoJSON(g);
          const p = L.geoJSON(gj, { style:{ color:"#ff5a7a", weight:2, fillOpacity:0.02 }});
          p.bindPopup(buildRosPopupHtml(f.attributes || {}));
          layers.ros.addLayer(p);
        }
      }

      const cards = [];
      cards.push(card(
        "Address",
        addressDisplay,
        [
          ["Location", `${lat.toFixed(7)}, ${lon.toFixed(7)}`],
          ["Candidates", `${candidates.length}`],
        ],
        [],
        {
          onRender: (cardEl) => {
            // Show parcel geometry thumbnail on the Address card (aligned right).
            cardEl.classList.add("address-card");
            const thumb = document.createElement("div");
            thumb.className = "addr-parcel-thumb";
            const svg = createParcelGeometryThumbSvg(parcel.geometry, 92, 8);
            if (svg) thumb.appendChild(svg);
            cardEl.appendChild(thumb);
          }
        }
      ));

      if (state.projectContext.projectId) {
        const projectCard = card(
          "Project",
          state.projectContext.projectName || state.projectContext.projectId,
          [
            ["Client", state.projectContext.client || "(none)"],
            ["Address", addressDisplay],
          ],
          []
        );
        projectCard.style.display = 'none';
        cards.push(projectCard);

      }

      const pAttrs = parcel.attributes || {};
      const parcelCard = card(
        "Parcel",
        "Parcel feature",
        [
          ["Centroid", `${c.y.toFixed(7)}, ${c.x.toFixed(7)}`],
          ["Attrs", `${Object.keys(pAttrs).length} fields`],
          ["Export", `Unique parcel/subdivision/aliquots CSV in P,N,E,Z,D (EPSG:${EXPORT_OUT_SR}, ID West ftUS)`],
        ],
        [],
        {
          onSelect: () => centerMapOnFeature(parcel, layers.parcel, 'Parcel'),
          onRender: (cardEl) => {
            const starBtn = document.createElement('button');
            const syncStar = (isBusy = false) => {
              const selected = state.selectedParcel;
              starBtn.textContent = selected ? '★' : '☆';
              starBtn.title = selected ? 'Exclude parcel from export' : 'Include parcel in export';
              starBtn.setAttribute('aria-pressed', selected ? 'true' : 'false');
              starBtn.disabled = Boolean(isBusy);
            };
            starBtn.type = 'button';
            starBtn.className = 'rq-star-btn';
            syncStar(false);
            starBtn.addEventListener('click', (evt) => {
              evt.stopPropagation();
              syncStar(true);
              const next = !state.selectedParcel;
              setParcelSelected(next);
              syncStar(false);
              drawParcel();
              drawCornerMarkers(buildCornerMarkerEntries());
              log(`${next ? 'Included' : 'Excluded'} parcel in export.`);
            });
            cardEl.appendChild(starBtn);
          },
        }
      );
      parcelCard.style.display = 'none';
      cards.push(parcelCard);

      // Keep a stable subdivision list for plat cards and selection toggles.
      const subdivisionCards = state.nearbySubdivisions.length
        ? state.nearbySubdivisions
        : (subdiv ? [{ feature: subdiv, name: getSubdivisionNameFromAttrs(subdiv.attributes || {}), plat: null }] : []);
      if (township) { const c = card("Township", "Containing feature", summarizeAttrs(township.attributes), []); c.style.display = "none"; cards.push(c); }
      if (section) { const c = card("Section", "Containing feature", summarizeAttrs(section.attributes), []); c.style.display = "none"; cards.push(c); }
      const utilitiesCard = card(
        "Utilities",
        "Idaho Power residential utility locations",
        [["Count", "Loading…"]],
        [["Status", `Loading in background (max ${Math.round(UTILITY_LOOKUP_TIMEOUT_MS / 1000)}s)`]],
        {
          onRender: (cardEl) => {
            const rows = cardEl.querySelectorAll('.kvs .kv');
            if (rows[0]) {
              const value = rows[0].querySelector('.v');
              if (value) value.id = 'utilCountValue';
            }
            if (rows[1]) {
              const value = rows[1].querySelector('.v');
              if (value) value.id = 'utilStatusValue';
            }

            const body = cardEl.querySelector('.cbody');
            if (!body) return;
            const sliderWrap = document.createElement('div');
            sliderWrap.innerHTML = `
              <div class="hr" style="margin:8px 0"></div>
              <div class="small" id="utilRadiusHelp">Export radius: <b><span id="utilRadiusVal">${UTIL_RADIUS_DEFAULT_FT}</span> ft</b> from parcel corners — <b><span id="utilRadiusCount">0</span></b> of 0 selected.</div>
              <input id="utilRadius" type="range" min="0" max="${UTIL_RADIUS_MAX_FT}" step="1" value="${UTIL_RADIUS_DEFAULT_FT}" disabled style="margin-top:8px;width:100%"/>
              <div class="small" id="utilRadiusHint" style="margin-top:4px;color:var(--muted)">Highlighted on map · included in PointForge export</div>
            `;
            body.appendChild(sliderWrap);
          },
        }
      );
      cards.push(utilitiesCard);



            const aliquotCardSliceStart = cards.length;
      const aliquotSummaryCpfTargets = [];
      if (state.aliquotFeatures.length) {
        const COLLAPSE_DIST_M = 500; // metres

        function aliquotDistMeters(feature) {
          if (!state.lastLonLat) return 0;
          const centroid = centroidOfPolygon(feature.geometry);
          if (!centroid) return 0;
          // outSR 4326: centroid.x = lon, centroid.y = lat
          return haversineMeters(state.lastLonLat.lat, state.lastLonLat.lon, centroid.y, centroid.x);
        }

        // Group aliquots by Township + Range + Section (parsed from BLM PLSSID/FRSTDIVID).
        // The Index (SECDIVNO/SECDIVLAB) identifies each aliquot within the group.
        const groups = new Map();
        for (const [idx, f] of state.aliquotFeatures.entries()) {
          const loc = parsePlssFromAliquot(f);
          const sectionLabel = loc.section ? `Sec ${loc.section}` : '';
          const groupKey = [loc.township, loc.range, sectionLabel].filter(Boolean).join(' ') || 'Aliquots';
          if (!groups.has(groupKey)) groups.set(groupKey, { label: groupKey, items: [], minDist: Infinity });
          const distMeters = aliquotDistMeters(f);
          const grp = groups.get(groupKey);
          grp.items.push({ f, idx, loc, distMeters });
          if (distMeters < grp.minDist) grp.minDist = distMeters;
        }

        // Sort groups by nearest member, then items within each group by distance.
        const sortedGroups = [...groups.values()].sort((a, b) => a.minDist - b.minDist);
        for (const grp of sortedGroups) grp.items.sort((a, b) => a.distMeters - b.distMeters);

        const makeAliquotHeader = (label) => {
          const headerEl = document.createElement('div');
          headerEl.className = 'aliquot-group-header';
          headerEl.style.cssText = 'font-size:11px;font-weight:700;color:var(--muted);text-transform:uppercase;letter-spacing:.5px;padding:6px 2px 2px;margin-top:4px;';
          headerEl.textContent = label;
          return headerEl;
        };

        const nearEls = [];
        const farEls = [];

        for (const group of sortedGroups) {
          const groupNearEls = [];
          const groupFarEls = [];

          for (const { f, idx, loc, distMeters } of group.items) {
            const a = f.attributes || {};
            const indexLabel = loc.index || a.ALIQUOT || a.ALIQUOT_LABEL || `Aliquot #${idx + 1}`;
            const token = `aliquot-${idx + 1}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
            const selectionKey = buildAliquotSelectionKey(f, idx);
            const isFar = distMeters > COLLAPSE_DIST_M;

            aliquotSummaryCpfTargets.push({ token, feature: f, label: indexLabel });

            const cardEl = card(
              indexLabel,
              group.label,
              [],
              [],
              {
                onSelect: () => centerMapOnFeature(f, layers.aliquots, indexLabel),
                onRender: (el) => {
                  const starBtn = document.createElement('button');
                  const syncStar = () => {
                    const selected = isAliquotSelected(f, idx);
                    starBtn.textContent = selected ? '★' : '☆';
                    starBtn.title = selected ? 'Exclude from export' : 'Include in export';
                    starBtn.setAttribute('aria-pressed', selected ? 'true' : 'false');
                  };
                  starBtn.type = 'button';
                  starBtn.className = 'rq-star-btn';
                  starBtn.dataset.aliquotStarKey = selectionKey;
                  syncStar();
                  starBtn.addEventListener('click', (evt) => {
                    evt.stopPropagation();
                    const next = !isAliquotSelected(f, idx);
                    setAliquotSelected(f, idx, next);
                    syncStar();
                    drawAliquots(state.aliquotFeatures, section);
                    drawCornerMarkers(buildCornerMarkerEntries());
                    log(`${next ? 'Included' : 'Excluded'} aliquot in export: ${indexLabel}`);
                  });
                  el.appendChild(starBtn);
                },
              }
            );


            // CP&F preview (thumbnail + instrument + monument set + surveyor)
            const cpfHost = cardEl.querySelector('.cbody');
            if (cpfHost) {
              const cpfWrap = document.createElement('div');
              cpfWrap.setAttribute('data-aliquot-cpf-links', token);
              cpfWrap.innerHTML = '<div style="font-size:11px;font-weight:700;color:var(--muted);text-transform:uppercase;letter-spacing:.5px;padding:4px 0 2px;">Corner CP&amp;F records</div><span class="small">Loading CP&amp;F records…</span>';
              cpfHost.appendChild(cpfWrap);
            }

            cardEl.classList.add('aliquot-card');
            cardEl.dataset.aliquotCardKey = selectionKey;
            if (isFar) cardEl.classList.add('is-far');

            // Append distance badge (and chevron for far cards) to the card header.
            const chead = cardEl.querySelector('.chead');
            if (chead) {
              const badge = document.createElement('span');
              badge.className = 'dist-badge' + (isFar ? ' is-far' : '');
              badge.textContent = fmtDist(distMeters);
              chead.appendChild(badge);

              if (isFar) {
                const chevron = document.createElement('span');
                chevron.className = 'chead-chevron';
                chevron.textContent = '▾';
                chead.appendChild(chevron);

                // Clicking the header of a far (collapsed) card expands/collapses it.
                chead.addEventListener('click', (evt) => {
                  evt.stopPropagation();
                  cardEl.classList.toggle('is-expanded');
                  centerMapOnFeature(f, layers.aliquots, indexLabel);
                });
              }
            }

            (isFar ? groupFarEls : groupNearEls).push(cardEl);
          }

          if (groupNearEls.length) {
            nearEls.push(makeAliquotHeader(group.label));
            nearEls.push(...groupNearEls);
          }
          if (groupFarEls.length) {
            farEls.push(makeAliquotHeader(group.label));
            farEls.push(...groupFarEls);
          }
        }

        cards.push(...nearEls);

        // Group all far (>500m) aliquots under a single drawer at the bottom.
        if (farEls.length) {
          const farCount = farEls.filter((el) => el?.classList?.contains('aliquot-card')).length;
          const toggleCard = createDistanceGroupToggleCard('Aliquots', farCount, COLLAPSE_DIST_M);
          cards.push(toggleCard);

          for (const el of farEls) el.style.display = 'none';

          let expanded = false;
          const btn = toggleCard.querySelector('[data-rq-see-more-btn]');
          const sub = toggleCard.querySelector('[data-rq-see-more-sub]');
          const sync = () => {
            if (btn) {
              btn.textContent = expanded ? `Hide (${farCount})` : `See More (${farCount})`;
              btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
            }
            if (sub) sub.textContent = `${farCount} Aliquots beyond ${fmtDist(COLLAPSE_DIST_M)}`;
          };
          sync();

          if (btn) {
            btn.addEventListener('click', (evt) => {
              evt.stopPropagation();
              expanded = !expanded;
              for (const el of farEls) el.style.display = expanded ? '' : 'none';
              sync();
            });
          }

          cards.push(...farEls);
        }
      }

      // Render subdivision plat cards after aliquot CP&F summaries and before ROS cards.
      if (subdivisionCards.length) {
        cards.push(createResultCategoryHeader('Subdivisions', 'Subdivision plats'));
      }
      subdivisionCards.forEach((entry, idx) => {
        const feature = entry?.feature || null;
        if (!feature) return;
        const subdivisionName = entry?.name || getSubdivisionNameFromAttrs(feature.attributes || {}) || `Subdivision ${idx + 1}`;
        const plat = entry?.plat || null;
        const links = [];
        if (plat?.platUrl) {
          links.push(`<a href="${escapeHtml(plat.platUrl)}" target="_blank" rel="noopener">Open subdivision plat</a>`);
        }
        const distanceMeters = Number(entry?.distanceMeters);
        const subtitle = Number.isFinite(distanceMeters)
          ? `${fmtDist(distanceMeters)} from parcel centroid`
          : `Within ${SUBDIVISION_NEARBY_RADIUS_FT} ft of parcel centroid`;
        const c = card(
          subdivisionName,
          subtitle,
          summarizeAttrs(feature.attributes),
          links,
          {
            onSelect: () => centerMapOnFeature(feature, layers.subdivision, 'Subdivision'),
            onRender: (cardEl) => {
              const chead = cardEl.querySelector('.chead');
              if (chead) {
                const starBtn = document.createElement('button');
                const syncSubdivisionStar = () => {
                  const selected = isSubdivisionSelected(entry, idx);
                  starBtn.textContent = selected ? '★' : '☆';
                  starBtn.title = selected ? 'Exclude subdivision plat from EvidenceDesk export' : 'Include subdivision plat in EvidenceDesk export';
                  starBtn.setAttribute('aria-pressed', selected ? 'true' : 'false');
                };
                starBtn.type = 'button';
                starBtn.className = 'rq-star-btn';
                starBtn.addEventListener('click', (evt) => {
                  evt.stopPropagation();
                  const next = !isSubdivisionSelected(entry, idx);
                  setSubdivisionSelected(entry, idx, next);
                  syncSubdivisionStar();
                  drawSubdivisionPolygons(subdivisionCards);
                  log(`${next ? 'Included' : 'Excluded'} subdivision ${subdivisionName} in EvidenceDesk export.`);
                });
                syncSubdivisionStar();
                chead.appendChild(starBtn);
              }

              if (plat?.thumbnailUrl) {
                const body = cardEl.querySelector('.cbody');
                if (body) {
                  const wrap = document.createElement('div');
                  wrap.style.marginTop = '8px';
                  wrap.innerHTML = buildSubdivisionThumbnailMarkup(subdivisionName, plat.thumbnailUrl);
                  body.appendChild(wrap);
                }
              }
            },
          }
        );
        c.classList.add('subdivision-card');

        // Subdivision card layout: move thumbnail outside of chead/cbody so it can float left of the header/content.
        const subdivisionThumb = c.querySelector('img.subdivision-plat-thumb');
        if (subdivisionThumb) {
          const wrap = document.createElement('div');
          wrap.className = 'subdivision-thumb-float';
          wrap.appendChild(subdivisionThumb);
          c.insertBefore(wrap, c.firstChild);
        }

        cards.push(c);
      });

      if (ros.length) {
        cards.push(createResultCategoryHeader('Records of Survey', 'Record of Survey sections'));
        const ROS_COLLAPSE_DIST_M = 500; // metres

        function rosFeatureCentroid(feature) {
          const g = feature?.geometry;
          if (!g) return null;
          if (Number.isFinite(Number(g.x)) && Number.isFinite(Number(g.y))) return { x: Number(g.x), y: Number(g.y) };
          if (g.paths?.length) { const p = g.paths[0]?.[0]; return p ? { x: p[0], y: p[1] } : null; }
          return centroidOfPolygon(g);
        }

        const rosSorted = ros
          .map((f, index) => {
            const c = rosFeatureCentroid(f);
            const dist = (c && state.lastLonLat)
              ? haversineMeters(state.lastLonLat.lat, state.lastLonLat.lon, c.y, c.x)
              : 0;
            return { f, dist, index };
          })
          .sort((a, b) => a.dist - b.dist);

        const rosNearEls = [];
        const rosFarEls = [];

        for (const [sortIdx, { f, dist, index }] of rosSorted.entries()) {
          const a = f.attributes || {};
          const isFar = dist > ROS_COLLAPSE_DIST_M;
          const rosLabel = bestRosLabel(a) || `Record of Survey #${sortIdx + 1}`;
          const titleDefault = `Record of Survey #${sortIdx + 1}`;
          const meta = buildAdaCountyRosImageMeta(a);
          const tifName = meta?.fullSizeUrl ? extractRosTifNameFromUrl(meta.fullSizeUrl) : null;

          const cardEl = card(
            titleDefault,
            rosLabel,
            summarizeAttrs(a),
            buildPdfProxyLinks(a),
            {
              onSelect: () => centerMapOnFeature(f, layers.ros, rosLabel),
              extraHtml: buildRosImageHtml(a)
            }
          );

          if (tifName) {
            const titleNode = cardEl.querySelector('.chead > div > div');
            if (titleNode) {
              titleNode.dataset.rosTitleTif = tifName;
              titleNode.dataset.rosTitleDefault = titleDefault;
            }
          }
          applyRosTitlesInNode(cardEl);

          cardEl.classList.add('ros-card');
          if (isFar) cardEl.classList.add('is-far');
          // ROS card layout: move thumbnail outside of chead/cbody so it can float left of the header/content.
          const rosThumb = cardEl.querySelector('img.ros-scan-thumb[data-ros-thumbnail]');
          if (rosThumb) {
            const wrap = document.createElement('div');
            wrap.className = 'ros-thumb-float';
            wrap.appendChild(rosThumb);
            cardEl.insertBefore(wrap, cardEl.firstChild);
          }

          const chead = cardEl.querySelector('.chead');
          if (chead) {
            const starBtn = document.createElement('button');
            const syncRosStar = () => {
              const selected = isRosSelected(f, index);
              starBtn.textContent = selected ? '★' : '☆';
              starBtn.title = selected ? 'Exclude ROS from export' : 'Include ROS in export';
              starBtn.setAttribute('aria-pressed', selected ? 'true' : 'false');
            };
            starBtn.type = 'button';
            starBtn.className = 'rq-star-btn';
            starBtn.addEventListener('click', (evt) => {
              evt.stopPropagation();
              const next = !isRosSelected(f, index);
              setRosSelected(f, index, next);
              syncRosStar();
              log(`${next ? 'Included' : 'Excluded'} ROS ${rosLabel} in export.`);
            });
            syncRosStar();
            chead.appendChild(starBtn);

            const badge = document.createElement('span');
            badge.className = 'dist-badge' + (isFar ? ' is-far' : '');
            badge.textContent = fmtDist(dist);
            chead.appendChild(badge);
          }
          (isFar ? rosFarEls : rosNearEls).push(cardEl);
        }

        // Render near ROS first, then a single drawer containing all far ROS at the bottom.
        cards.push(...rosNearEls);

        if (rosFarEls.length) {
          const farCount = rosFarEls.length;
          const toggleCard = createDistanceGroupToggleCard('Records of Survey', farCount, ROS_COLLAPSE_DIST_M);
          cards.push(toggleCard);

          for (const el of rosFarEls) el.style.display = 'none';

          let expanded = false;
          const btn = toggleCard.querySelector('[data-rq-see-more-btn]');
          const sub = toggleCard.querySelector('[data-rq-see-more-sub]');
          const sync = () => {
            if (btn) {
              btn.textContent = expanded ? `Hide (${farCount})` : `See More (${farCount})`;
              btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
            }
            if (sub) sub.textContent = `${farCount} Records of Survey beyond ${fmtDist(ROS_COLLAPSE_DIST_M)}`;
          };
          sync();

          if (btn) {
            btn.addEventListener('click', (evt) => {
              evt.stopPropagation();
              expanded = !expanded;
              for (const el of rosFarEls) el.style.display = expanded ? '' : 'none';
              sync();
            });
          }

          cards.push(...rosFarEls);
        }
      } else {
        cards.push(card("Record of Survey", "None within 1600m of parcel centroid", [["Note","Increase search distance in code if needed."]], []));
      }

      await setSummaryCards(cards);
      if (aliquotSummaryCpfTargets.length) {
        lazyLoadAliquotSummaryCpfLinks(aliquotSummaryCpfTargets);
      }
      lazyLoadRosScanThumbnails();

      utilityLookupPromise.then(({ utilityLocations, error }) => {
        if (error) {
          log(`Utility lookup failed: ${error.message || error}`, 'warn');
        }
        state.utilityLocations = utilityLocations;
        drawUtilityLocations(state.utilityLocations);
        afterUtilitiesLoadedOrUpdated();
        log(`Utility locations found: ${state.utilityLocations.length}`);

        const utilCountEl = document.getElementById('utilCountValue');
        if (utilCountEl) utilCountEl.textContent = String(state.utilityLocations.length);
        const utilStatusEl = document.getElementById('utilStatusValue');
        if (utilStatusEl) {
          utilStatusEl.textContent = error
            ? 'Lookup timed out or failed; continuing without utility points.'
            : 'Loaded';
        }
      });

      state.exportGeoJSON = buildExportGeoJSON();

      try {
        log(`Fetching parcel/subdivision/aliquot export geometry in EPSG:${EXPORT_OUT_SR}...`);
        state.parcelFeature2243 = await fetchParcelGeometry2243FromPoint(lon, lat);
        state.subdivisionFeature2243 = await fetchSubdivisionGeometry2243FromPoint(lon, lat);
        state.sectionFeature2243 = await fetchSectionGeometry2243FromPoint(lon, lat);

        if (state.parcelFeature2243?.geometry?.rings?.length) {
          $("btnExportParcelCSV").disabled = false;
          $("btnExportPointForge").disabled = false;
          log("Export geometry ready (IDW ft): parcel, subdivision, and aliquot vertices.");
        } else {
          log("Parcel export geometry not available (no rings).", "warn");
        }
      } catch (e) {
        log(`Parcel/subdivision/aliquot export geometry fetch failed: ${e.message || e}`, "warn");
      }

      saveLookupSnapshotsForCurrentState(rawAddr);
      log('Saved lookup cache for this address.');

      invalidateMapSoon("lookup complete");
      log("Done.", "info");
    } catch (e) {
      log(`Error: ${e.message || e}`, "bad");
      console.error(e);
      invalidateMapSoon("after error");
    } finally {
      setBusyModalOpen(false);
      lookupButton.disabled = false;
    }
  }

  // -----------------------------
  // UI events
  // -----------------------------
  $("btnLookup").addEventListener("click", doLookup);

  $("btnClear").addEventListener("click", () => {
    $("addr").value = "";
    state.lastLookupPayload = null;
    state.lastLookupAddress = '';
    clearLog();
    clearMapLayers();
    resetUtilitiesRadiusUiAndState();
    setSummaryCards([]);
    $("btnExportParcelCSV").disabled = true;
    $("btnExportPointForge").disabled = true;
    state.exportGeoJSON = null;
    state.parcelFeature = null;
    state.parcelFeature2243 = null;
    state.subdivisionFeature2243 = null;
    state.subdivisionFeature = null;
    state.nearbySubdivisions = [];
    state.aliquotFeatures = [];
    state.sectionFeature2243 = null;
    state.aliquotFeatures2243 = [];
    state.selectedParcel = true;
    state.selectedAliquot = null;
    state.selectedAliquotKeys.clear();
    state.selectedRosKeys.clear();
    state.selectedSubdivisionKeys.clear();
    state.lastLonLat = null;
    state.utilityLocations = [];
    $("pdfFindings").style.display = "none";
    $("pdfFindings").textContent = "";
    log("Cleared.");
    invalidateMapSoon("clear");
  });

  $("btnExportParcelCSV").addEventListener("click", async () => {
    try {
      if (!state.parcelFeature2243) {
        throw new Error("Parcel export geometry not loaded yet. Run Lookup again.");
      }
      const selectedAliquotFeatures2243 = filterAliquotFeaturesForExport(state.aliquotFeatures2243, state.selectedAliquotKeys);
      const baseExport = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: filterParcelFeatureForExport(state.parcelFeature2243, state.selectedParcel),
        subdivisionFeature2243: state.subdivisionFeature2243,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
      });
      if (!baseExport.count) throw new Error('No boundary vertices available to export.');

      const plssPoints = new Map([...baseExport.points.entries()].filter(([, point]) => (
        !point.sources.has('parcel') && !point.sources.has('subdivision')
      )));
      log(`Looking up CP&F instrument notes for ${plssPoints.size} aliquot/section point(s)...`);
      setBusyModalOpen(true, 'Exporting CSV… gathering CPNF instrument numbers');
      const notesByCoordinate = await buildCpfNotesByCoordinate(plssPoints);

      const finalExport = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: filterParcelFeatureForExport(state.parcelFeature2243, state.selectedParcel),
        subdivisionFeature2243: state.subdivisionFeature2243,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
        notesByCoordinate,
      });

      downloadText(finalExport.csv, "parcel_subdivision_aliquots_unique_points_idw_ft_pnezd.csv", "text/csv");
      log(`Exported unique boundary CSV (PNEZD + notes, IDW ft): points=${finalExport.count}.`);
    } catch (e) {
      log(`Parcel CSV export failed: ${e.message || e}`, "bad");
      console.error(e);
    } finally {
      setBusyModalOpen(false);
    }
  });

  $("btnExportPointForge").addEventListener("click", async () => {
    try {
      if (!state.parcelFeature2243) {
        throw new Error("PointForge export geometry not loaded yet. Run Lookup again.");
      }

      const selectedAliquotFeatures2243 = filterAliquotFeaturesForExport(state.aliquotFeatures2243, state.selectedAliquotKeys);
      const baseExport = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: filterParcelFeatureForExport(state.parcelFeature2243, state.selectedParcel),
        subdivisionFeature2243: null,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
      });
      if (!baseExport.count) throw new Error('No parcel or aliquot corners available to export to PointForge.');

      const plssPoints = new Map([...baseExport.points.entries()].filter(([, point]) => (
        !point.sources.has('parcel') && !point.sources.has('subdivision')
      )));
      log(`Looking up CP&F instrument notes for ${plssPoints.size} PointForge aliquot/section point(s)...`);
      setBusyModalOpen(true, 'Exporting to PointForge… gathering CPNF instrument numbers');
      const notesByCoordinate = await buildCpfNotesByCoordinate(plssPoints);

      const uniquePart = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: filterParcelFeatureForExport(state.parcelFeature2243, state.selectedParcel),
        subdivisionFeature2243: null,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
        notesByCoordinate,
        includePlssWithoutNotes: false,
      });
      if (!uniquePart.count) throw new Error('No parcel points or CP&F-backed aliquot corners available to export to PointForge.');

      const utilityMarkers = buildPowerUtilityMarkersForPointForge(state.utilityLocations, uniquePart.nextPoint);
      const utilityRows = buildPointMarkerCsvRowsPNEZD(utilityMarkers, uniquePart.nextPoint, '');
      const pointForgeCsv = `${uniquePart.csv}${utilityRows.csv}`;

      localStorage.setItem(POINTFORGE_ROS_IMPORT_STORAGE_KEY, JSON.stringify({
        source: 'ros-html',
        exportedAt: new Date().toISOString(),
        csv: pointForgeCsv,
      }));
      const projectFileUpdate = await persistPointForgeExportProjectFile({
        projectContext: state.projectContext,
        notesByCoordinate,
        csv: pointForgeCsv,
        pointCount: uniquePart.count + utilityRows.count,
        overwriteEvidenceRecords: Boolean($("overwriteEvidenceRecords")?.checked),
      });
      if (projectFileUpdate) {
        log(`Saved PointForge export to project file (${projectFileUpdate.cpfCount} CP&F references, ${projectFileUpdate.rosCount || 0} ROS references, ${projectFileUpdate.subdivisionCount || 0} subdivision plat references).`);
      }
      openLinkedApp(buildPointForgeLaunchPath());
      log(`Sent ${uniquePart.count + utilityRows.count} points to PointForge (${utilityRows.count} utility point(s)).`);
    } catch (e) {
      log(`PointForge export failed: ${e.message || e}`, "bad");
      console.error(e);
    } finally {
      setBusyModalOpen(false);
    }
  });

  function openLinkedApp(path) {
    try {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({
          type: 'survey-cad:navigate-app',
          path,
        }, window.location.origin);
        return;
      }
    } catch (_error) {
      // If parent access is blocked, fallback to same-tab navigation.
    }
    window.location.assign(path);
  }

  function buildPointForgeLaunchPath() {
    const params = new URLSearchParams({ source: 'ros' });
    const projectId = String(state?.projectContext?.projectId || '').trim();
    const projectName = String(state?.projectContext?.projectName || '').trim();
    if (projectId) params.set('projectId', projectId);
    if (projectName) params.set('projectName', projectName);
    return `/POINT_TRANSFORMER.HTML?${params.toString()}`;
  }

  $("btnScanPdf").addEventListener("click", async () => {
    const file = $("pdfFile").files?.[0];
    $("pdfFindings").style.display = "none";
    $("pdfFindings").textContent = "";
    try {
      log(`Scanning PDF upload: ${file ? file.name : "(none)"}`);
      const res = await scanUploadedPdf(file);
      const out = [];
      out.push("BASIS OF BEARING — matches:\n");
      if (res.hits.length) out.push(...res.hits.map(x => "• " + x));
      else out.push("(none found as single-line matches)");
      out.push("\n\nBASIS OF BEARING — with context:\n");
      if (res.context.length) out.push(...res.context.map(x => "• " + x));
      else out.push("(none found)");
      $("pdfFindings").textContent = out.join("\n");
      $("pdfFindings").style.display = "block";
      log("PDF scan complete.");
    } catch (e) {
      log(`PDF scan failed: ${e.message || e}`, "bad");
      console.error(e);
    }
  });

  // initial log
  clearLog();
  resetUtilitiesRadiusUiAndState();
  if (state.projectContext.address) {
    $("addr").value = state.projectContext.address;
  }
  if (state.projectContext.projectId) {
    log(`Project loaded: ${state.projectContext.projectName || state.projectContext.projectId} (${state.projectContext.client || "no client"}).`);

    const hasProjectAddress = Boolean(normalizeAddressStorageKey(state.projectContext.address));
    const projectAddressSnapshot = hasProjectAddress ? loadAddressLookupSnapshot(state.projectContext.address) : null;

    if (hasProjectAddress) {
      if (projectAddressSnapshot?.lookup) {
        log(`Restoring cached results for project address from ${projectAddressSnapshot.savedAt || "unknown time"}.`);
      }
      doLookup({ lookupPayload: projectAddressSnapshot?.lookup || null, selectionSnapshot: projectAddressSnapshot?.selection || null }).catch((err) => {
        log(`Saved result restore failed, running live lookup: ${err.message || err}`, "warn");
        doLookup().catch((liveErr) => {
          log(`Lookup failed: ${liveErr.message || liveErr}`, "bad");
          console.error(liveErr);
        });
      });
    } else if (state.projectContext.autostart) {
      doLookup().catch((err) => {
        log(`Lookup failed: ${err.message || err}`, "bad");
        console.error(err);
      });
    }
  } else {
    const hasLaunchAddress = Boolean(normalizeAddressStorageKey(state.projectContext.address));
    const launchAddressSnapshot = hasLaunchAddress ? loadAddressLookupSnapshot(state.projectContext.address) : null;
    const snapshot = loadMostRecentAddressLookupSnapshot();

    if (hasLaunchAddress) {
      if (launchAddressSnapshot?.lookup) {
        log(`Restoring cached results for launch address from ${launchAddressSnapshot.savedAt || 'unknown time'}.`);
      }
      if (state.projectContext.autostart) {
        doLookup({ lookupPayload: launchAddressSnapshot?.lookup || null, selectionSnapshot: launchAddressSnapshot?.selection || null }).catch((err) => {
          log(`Lookup failed: ${err.message || err}`, "bad");
          console.error(err);
        });
      }
    } else if (snapshot?.lookup) {
      if (!$("addr").value) {
        $("addr").value = snapshot.address || '';
      }
      log(`Restoring last lookup for ${snapshot.address || 'saved address'} from ${snapshot.savedAt || 'unknown time'}.`);
      doLookup({ lookupPayload: snapshot.lookup, selectionSnapshot: snapshot.selection }).catch((err) => {
        log(`Saved result restore failed: ${err.message || err}`, "warn");
      });
    }
  }
  log("Ready. Enter an address and click Lookup.");
  invalidateMapSoon("initial");
})();
</script>
</body>
</html>
