<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>RecordQuarry — Ada County Survey Context Lookup (Standalone)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- pdf.js (UMD build defining window.pdfjsLib) -->
  <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>

  <style>
    :root{
      --bg:#0b1020;
      --panel:#101834;
      --panel2:#0e1630;
      --text:#e7ecff;
      --muted:#b6c0ff;
      --line:rgba(255,255,255,.12);
      --good:#24d18f;
      --warn:#ffcc66;
      --bad:#ff5a7a;
      --btn:#2a3dff;
      --btn2:#1a255f;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;min-height:100dvh;margin:0;background:var(--bg);color:var(--text);font-family:var(--sans)}
    a{color:#9ab0ff;text-decoration:none}
    a:hover{text-decoration:underline}

    .app{
      height:100%;
      min-height:100dvh;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    header{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0));
    }
    header .title{font-weight:700;letter-spacing:.2px;}
    header .subtitle{color:var(--muted);font-size:12px;}

    .main{
      flex:1;
      min-height:0;
      display:grid;
      grid-template-columns: 430px 1fr;
      gap:10px;
      padding:10px;
    }
    @media (max-width: 980px){
      .main{grid-template-columns:1fr; grid-template-rows: 460px 1fr;}
    }

    .panel{
      background:rgba(255,255,255,.03);
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .panel .phead{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background:rgba(255,255,255,.03);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex:0 0 auto;
    }
    .panel .phead .h{font-weight:700;font-size:13px;}

    /* IMPORTANT: make panel bodies expand so Leaflet has real height */
    .panel .pbody{
      padding:12px;
      overflow:auto;
      min-height:0;
      flex:1 1 auto;   /* <-- KEY FIX */
    }

    .row{display:flex;gap:10px;align-items:center}
    .row.wrap{flex-wrap:wrap}
    label{font-size:12px;color:var(--muted)}
    input[type="text"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.2);
      color:var(--text);
      outline:none;
    }
    input[type="file"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px dashed var(--line);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      outline:none;
    }
    button{
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg, rgba(42,61,255,.9), rgba(26,37,95,.9));
      color:white;
      font-weight:700;
      cursor:pointer;
      white-space:nowrap;
    }
    button.secondary{
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--text);
      font-weight:600;
    }
    button:disabled{opacity:.5;cursor:not-allowed}

    .small{font-size:12px;color:var(--muted)}
    .mono{font-family:var(--mono);font-size:12px}
    .hr{height:1px;background:var(--line);margin:10px 0}

    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:5px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.2);
      font-size:12px;
      color:var(--muted);
      margin:2px 6px 2px 0;
    }
    .pill .dot{width:8px;height:8px;border-radius:99px;background:var(--muted);opacity:.9}
    .pill.good .dot{background:var(--good)}
    .pill.warn .dot{background:var(--warn)}
    .pill.bad  .dot{background:var(--bad)}

    .hint{
      padding:10px;
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:12px;
    }

    .log{
      font-family:var(--mono);
      font-size:12px;
      line-height:1.35;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
      white-space:pre-wrap;
      overflow-wrap:anywhere;
      word-break:break-word;
      max-height:260px;
      overflow:auto;
    }

    .list{display:flex;flex-direction:column;gap:10px;}
    .card{
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(0,0,0,.14);
      overflow:hidden;
    }
    .card.clickable{
      cursor:pointer;
      transition:border-color .16s ease, box-shadow .16s ease, transform .16s ease;
    }
    .card.clickable:hover,
    .card.clickable:focus-visible{
      border-color:rgba(106,169,255,.7);
      box-shadow:0 0 0 2px rgba(106,169,255,.25);
      transform:translateY(-1px);
      outline:none;
    }
    .card .chead{
      padding:10px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:flex-start;
    }
    .card .cbody{padding:10px;}
    .kv{
      display:grid;
      grid-template-columns: 130px 1fr;
      gap:6px 10px;
      font-size:12px;
      color:var(--muted);
    }
    .kv div:nth-child(2n){
      color:var(--text);
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Right side: ensure map gets height */
    .rightBody{
      padding:0 !important;
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden; /* prevent nested scrollbars */
    }
    .mapWrap{
      flex:1 1 auto;
      min-height:320px; /* <-- map always has real height */
      position:relative;
    }
    #map{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      border-radius:12px;
    }
    @media (max-width: 980px){
      .mapWrap{min-height:420px;}
    }

    @media (max-width: 760px){
      header{
        flex-direction:column;
        align-items:flex-start;
      }
      header .row,
      .panel .phead .row{
        width:100%;
        flex-wrap:wrap;
      }
      .panel .phead{
        flex-direction:column;
        align-items:flex-start;
      }
      .panel .phead .row button{
        flex:1 1 140px;
      }
      .main{
        grid-template-rows:minmax(460px, auto) minmax(420px, 1fr);
      }
      .mapWrap{
        min-height:360px;
      }
    }

    .busyModal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(1, 5, 20, 0.74);
      backdrop-filter: blur(1px);
      z-index:9999;
      padding:16px;
    }
    .busyModal.is-open{display:flex;}
    .busyModalCard{
      width:min(460px, 100%);
      border-radius:14px;
      border:1px solid var(--line);
      background:var(--panel2);
      box-shadow:0 18px 46px rgba(0,0,0,.42);
      padding:18px 16px;
      text-align:center;
    }
    .busySpinner{
      width:34px;
      height:34px;
      margin:0 auto 10px;
      border-radius:50%;
      border:3px solid rgba(255,255,255,.2);
      border-top-color:var(--good);
      animation:spinBusy .85s linear infinite;
    }
    @keyframes spinBusy {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
</head>

<body>
<div class="app">
  <header>
    <div>
      <div class="title">RecordQuarry — Ada County Survey Context Lookup (Standalone)</div>
      <div class="subtitle">Address → Parcel → Subdivision / Section / Township + nearby ROS (JSONP, no CORS failures)</div>
    </div>
    <div class="row">
      <span class="pill good"><span class="dot"></span>ArcGIS JSONP</span>
      <span class="pill warn"><span class="dot"></span>PDF scan uses local uploads</span>
    </div>
  </header>

  <div class="main">
    <!-- LEFT -->
    <div class="panel">
      <div class="phead">
        <div class="h">Lookup</div>
        <div class="row">
          <button id="btnLookup">Lookup</button>
          <button id="btnClear" class="secondary">Clear</button>
        </div>
      </div>
      <div class="pbody">
        <label for="addr">Address (Ada County, ID)</label>
        <input id="addr" type="text" placeholder="e.g. 5707 W Castle Dr, Boise ID" value="5707 W Castle Dr, Boise ID"/>

        <div class="row wrap" style="margin-top:10px">
          <div class="pill" title="ExternalMap MapServer">
            <span class="dot"></span>Service: External/ExternalMap
          </div>
          <div class="pill" title="Parcel query uses point+distance">
            <span class="dot"></span>Parcel: layer 24
          </div>
          <div class="pill" title="Address layer is 16">
            <span class="dot"></span>Address: layer 16
          </div>
        </div>

        <div class="hr"></div>

        <div class="phead" style="padding:0;border:0;background:transparent;justify-content:flex-start">
          <div class="h">PDF Basis of Bearing (local upload)</div>
        </div>
        <input id="pdfFile" type="file" accept="application/pdf"/>
        <button id="btnScanPdf" class="secondary" style="width:100%;margin-top:10px">Scan Uploaded PDF</button>
        <div id="pdfFindings" class="log" style="margin-top:10px;display:none"></div>

        <div class="hr"></div>

        <div class="phead" style="padding:0;border:0;background:transparent;justify-content:flex-start">
          <div class="h">Summary</div>
        </div>
        <div id="summary" class="list" style="margin-top:10px"></div>

        <div class="hr"></div>

        <div class="phead" style="padding:0;border:0;background:transparent;justify-content:flex-start">
          <div class="h">Diagnostics</div>
        </div>
        <div id="log" class="log" style="margin-top:10px"></div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="panel">
      <div class="phead">
        <div class="h">Map + Results</div>
        <div class="row">
          <button id="btnExportGeo" class="secondary" disabled>Export GeoJSON</button>
          <button id="btnExportParcelCSV" class="secondary" disabled title="Exports unique parcel, subdivision, and aliquot vertices as P,N,E,Z,D in EPSG:2243 (ID West ftUS)">Export CSV</button>
          <button id="btnExportPointForge" class="secondary" disabled title="Sends unique parcel, subdivision, and aliquot vertices to PointForge">Export to PointForge</button>
        </div>
      </div>

      <div class="pbody rightBody">
        <div class="mapWrap">
          <div id="map"></div>
        </div>
      </div>
    </div>

  </div>
</div>

<div id="busyModal" class="busyModal" role="status" aria-live="polite" aria-hidden="true">
  <div class="busyModalCard">
    <div class="busySpinner" aria-hidden="true"></div>
    <div id="busyModalMessage">Processing export…</div>
    <div class="small" style="margin-top:8px">Gathering CPNF instrument numbers for exported points.</div>
  </div>
</div>

<script type="module">
import { lookupByAddress, findParcelNearPoint as fetchParcelNearPoint, loadAliquotsAtPoint, loadSubdivisionAtPoint, buildRosPdfProxyUrl } from "./src/browser-survey-client.js";
import { buildAliquotSelectionKey, buildRosBoundaryCsvRowsPNEZD, filterAliquotFeaturesForExport } from "./src/ros-export.js";

(() => {
  // -----------------------------
  // Configuration (Ada County)
  // -----------------------------
  const BASE = "https://adacountyassessor.org/arcgis/rest/services/External/ExternalMap/MapServer";
  const LAYERS = {
    address: 16,
    ros: 17,
    subdivisions: 18,
    townships: 19,
    sections: 20,
    parcels: 24,
  };

  // EPSG:2243 (NAD83 / Idaho West ftUS) for export.
  // We do NOT client-project; we request outSR=2243 from the server (no CORS via JSONP).
  const EXPORT_OUT_SR = 2243;

  // Ada County CP&F record lookup (used when clicking corner markers).
  const ADA_PORTAL_BASE = "https://gisprod.adacounty.id.gov/arcgis";
  const ADA_CPF_WEBMAP_ITEM_ID = "019521c7932442f0b4b581f641cbf236";
  const ADA_CPF_PDF_BASE = "https://gisprod.adacounty.id.gov/apps/acdscpf/CpfPdfs/";
  const POINTFORGE_ROS_IMPORT_STORAGE_KEY = "pointforgeRosImport";
  const PROJECT_LOOKUP_STORAGE_PREFIX = "surveyfoundryProjectLookup";
  const PROJECT_FILE_STORAGE_PREFIX = "surveyfoundryProjectFile";

  // pdf.js worker
  if (!window.pdfjsLib) {
    alert("pdf.js failed to load (pdfjsLib missing). Check network access.");
  } else {
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
  }

  // -----------------------------
  // UI helpers
  // -----------------------------
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  function ts() {
    const d = new Date();
    return d.toISOString().replace("T"," ").replace("Z","");
  }
  function log(line, kind="info") {
    const prefix = kind === "bad" ? "✖" : kind === "warn" ? "⚠" : "•";
    logEl.textContent += `[${ts()}] ${prefix} ${line}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function clearLog() { logEl.textContent = ""; }

  function setBusyModalOpen(isOpen, message = 'Processing export…') {
    const modal = $("busyModal");
    const msg = $("busyModalMessage");
    msg.textContent = message;
    modal.classList.toggle('is-open', !!isOpen);
    modal.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
  }

  function getProjectContext() {
    const params = new URLSearchParams(window.location.search || "");
    const projectId = params.get("projectId") || "";
    const address = params.get("address") || "";
    const projectName = params.get("projectName") || "";
    const client = params.get("client") || "";
    const autostart = params.get("autostart") === "1";
    return { projectId, address, projectName, client, autostart };
  }

  function projectLookupStorageKey(projectId) {
    return `${PROJECT_LOOKUP_STORAGE_PREFIX}:${projectId}`;
  }

  function projectFileStorageKey(projectId) {
    return `${PROJECT_FILE_STORAGE_PREFIX}:${projectId}`;
  }

  function loadProjectLookupSnapshot(projectId) {
    if (!projectId) return null;
    try {
      const raw = localStorage.getItem(projectLookupStorageKey(projectId));
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object" || !parsed.lookup) return null;
      return parsed;
    } catch {
      return null;
    }
  }

  function saveProjectLookupSnapshot(projectId, snapshot) {
    if (!projectId || !snapshot) return;
    localStorage.setItem(projectLookupStorageKey(projectId), JSON.stringify(snapshot));
  }

  function slugify(value, fallback = 'resource') {
    const slug = String(value || '')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
    return slug || fallback;
  }

  function createProjectFileFolder(key, label, description) {
    return { key, label, description, index: [] };
  }

  function defaultProjectFile(context = {}) {
    const projectId = context.projectId || `project-${Date.now()}`;
    const projectName = context.projectName || 'Untitled Project';
    return {
      schemaVersion: '1.0.0',
      generatedAt: new Date().toISOString(),
      project: {
        id: projectId,
        name: projectName,
        client: context.client || '',
        address: context.address || '',
      },
      archive: {
        type: 'zip',
        rootFolderName: `${slugify(projectName, 'surveyfoundry-project')}-${slugify(projectId, 'project')}`,
      },
      folders: [
        createProjectFileFolder('ros', 'RoS', 'Record of Survey source files and exports.'),
        createProjectFileFolder('cpfs', 'CP&Fs', 'Corner Perpetuation & Filing references resolved by instrument number.'),
        createProjectFileFolder('point-files', 'Point Files', 'PointForge-managed points exported as CSV.'),
        createProjectFileFolder('drawings', 'Drawings', 'LineSmith drawing packages generated from linked point files.'),
        createProjectFileFolder('deeds', 'Deeds', 'Deed references and exported documents.'),
        createProjectFileFolder('plats', 'Plats', 'Subdivision plats and plat-related exhibits.'),
        createProjectFileFolder('invoices', 'Invoices', 'Billing artifacts and project invoices.'),
        createProjectFileFolder('other', 'Other', 'Future expansion area for additional project evidence types.'),
      ],
    };
  }

  function loadProjectFileSnapshot(projectContext = {}) {
    const projectId = projectContext.projectId || '';
    if (!projectId) return null;
    try {
      const raw = localStorage.getItem(projectFileStorageKey(projectId));
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object' || !Array.isArray(parsed.folders)) return null;
      return parsed;
    } catch {
      return null;
    }
  }

  function saveProjectFileSnapshot(projectContext = {}, projectFile) {
    const projectId = projectContext.projectId || '';
    if (!projectId || !projectFile) return;
    localStorage.setItem(projectFileStorageKey(projectId), JSON.stringify(projectFile));
  }

  function ensureProjectFileFolder(projectFile, folderKey) {
    if (!projectFile || !Array.isArray(projectFile.folders)) return null;
    const existing = projectFile.folders.find((folder) => folder.key === folderKey);
    if (existing) {
      if (!Array.isArray(existing.index)) existing.index = [];
      return existing;
    }
    const fallback = createProjectFileFolder(folderKey, folderKey, '');
    projectFile.folders.push(fallback);
    return fallback;
  }

  function parseCpfInstrumentsFromNotesMap(notesByCoordinate = new Map()) {
    const instruments = new Set();
    for (const note of notesByCoordinate.values()) {
      const raw = String(note || '').trim();
      if (!raw) continue;
      const normalized = raw.replace(/^CPNFS:\s*/i, '');
      for (const item of normalized.split('...')) {
        const instrument = item.trim();
        if (instrument) instruments.add(instrument);
      }
    }
    return [...instruments].sort();
  }

  function addProjectFileResource(projectFile, resource) {
    const folder = ensureProjectFileFolder(projectFile, resource.folder);
    if (!folder) return;
    const exists = folder.index.some((item) => (
      item?.reference?.type === resource.reference.type
      && String(item?.reference?.value ?? '') === String(resource.reference.value ?? '')
    ));
    if (!exists) folder.index.push(resource);
  }

  function persistPointForgeExportProjectFile({ projectContext = {}, notesByCoordinate, csv, pointCount }) {
    if (!projectContext.projectId) return null;

    const projectFile = loadProjectFileSnapshot(projectContext) || defaultProjectFile(projectContext);
    const exportTimestamp = new Date().toISOString();
    const cpfInstruments = parseCpfInstrumentsFromNotesMap(notesByCoordinate);

    for (const instrument of cpfInstruments) {
      addProjectFileResource(projectFile, {
        id: `cpf-${slugify(instrument, 'instrument')}`,
        folder: 'cpfs',
        title: `CP&F ${instrument}`,
        exportFormat: 'pdf',
        reference: {
          type: 'instrument-number',
          value: instrument,
          resolverHint: 'lookup-cpf-pdf',
          metadata: { instrument },
        },
      });
    }

    addProjectFileResource(projectFile, {
      id: `pointforge-export-${Date.now()}`,
      folder: 'point-files',
      title: `PointForge export ${exportTimestamp}`,
      exportFormat: 'csv',
      reference: {
        type: 'local-storage',
        value: POINTFORGE_ROS_IMPORT_STORAGE_KEY,
        resolverHint: 'local-pointforge-export',
        metadata: {
          source: 'RecordQuarry',
          exportedAt: exportTimestamp,
          pointCount: Number(pointCount) || 0,
          csvLength: String(csv || '').length,
        },
      },
    });

    projectFile.generatedAt = exportTimestamp;
    saveProjectFileSnapshot(projectContext, projectFile);
    return { projectFile, cpfCount: cpfInstruments.length };
  }

  // -----------------------------
  // JSONP for ArcGIS (no CORS)
  // -----------------------------
  function toQuery(params) {
    const parts = [];
    for (const [k,v] of Object.entries(params)) {
      if (v === undefined || v === null) continue;
      const value = typeof v === 'object' ? JSON.stringify(v) : String(v);
      parts.push(encodeURIComponent(k) + "=" + encodeURIComponent(value));
    }
    return parts.join("&");
  }

  function arcJsonp(url, params, timeoutMs=20000) {
    return new Promise((resolve, reject) => {
      const cb = "__arc_cb_" + Math.random().toString(36).slice(2);
      const script = document.createElement("script");
      const timer = setTimeout(() => {
        cleanup();
        reject(new Error("JSONP timeout"));
      }, timeoutMs);

      function cleanup() {
        clearTimeout(timer);
        try { delete window[cb]; } catch {}
        if (script.parentNode) script.parentNode.removeChild(script);
      }

      window[cb] = (data) => {
        cleanup();
        resolve(data);
      };

      const fullParams = Object.assign({}, params, { f: "json", callback: cb });
      script.src = url + (url.includes("?") ? "&" : "?") + toQuery(fullParams);
      script.onerror = () => {
        cleanup();
        reject(new Error("JSONP script load failed"));
      };
      document.head.appendChild(script);
    });
  }

  async function arcQuery(layerId, params) {
    const url = `${BASE}/${layerId}/query`;
    const data = await arcJsonp(url, params);
    if (data && data.error) {
      const msg = data.error.message || "ArcGIS error";
      throw new Error(`${msg}${data.error.details ? " :: " + data.error.details.join(" | ") : ""}`);
    }
    return data;
  }

  // -----------------------------
  // CP&F corner record lookup helpers
  // -----------------------------
  let cpfLayerInfo = null;
  let cpfLayerInfoPromise = null;

  function canonicalizeUrl(url) {
    try {
      const u = new URL(url);
      u.hash = '';
      return `${u.origin}${u.pathname}`.toLowerCase() + (u.search ? u.search.toLowerCase() : '');
    } catch {
      return String(url || '').trim().toLowerCase();
    }
  }

  function pickField(attrs, layerMeta, patterns) {
    const keys = Object.keys(attrs || {});
    const fields = layerMeta?.fields || [];
    for (const re of patterns) {
      const key = keys.find((k) => re.test(k));
      if (key) return key;
      const field = fields.find((f) => re.test(f.name || '') || re.test(f.alias || ''));
      if (field && attrs[field.name] !== undefined) return field.name;
    }
    return null;
  }

  function buildCpfPdfLinks(instrument, maybeUrl, maybeFileName) {
    const out = [];
    const seen = new Set();

    function add(url) {
      if (!url) return;
      const text = String(url).trim();
      if (!text) return;
      const key = canonicalizeUrl(text);
      if (seen.has(key)) return;
      seen.add(key);
      out.push(text);
    }

    if (maybeUrl) {
      const text = String(maybeUrl).trim();
      if (/^https?:\/\//i.test(text)) add(text);
      else if (/\.pdf$/i.test(text)) add(ADA_CPF_PDF_BASE + text.replace(/^\/+/, ''));
    }

    if (maybeFileName) {
      const text = String(maybeFileName).trim();
      if (/^https?:\/\//i.test(text)) add(text);
      else if (/\.pdf$/i.test(text)) add(ADA_CPF_PDF_BASE + text.replace(/^\/+/, ''));
      else add(ADA_CPF_PDF_BASE + encodeURIComponent(text) + '.pdf');
    }

    if (instrument != null && instrument !== '') {
      add(ADA_CPF_PDF_BASE + encodeURIComponent(String(instrument).trim()) + '.pdf');
    }

    return out;
  }

  async function discoverAdaCpfLayerViaJsonp() {
    const itemDataUrl = `${ADA_PORTAL_BASE}/sharing/rest/content/items/${ADA_CPF_WEBMAP_ITEM_ID}/data`;
    const webmap = await arcJsonp(itemDataUrl, { f: 'pjson' }, 25000);

    const candidates = [];
    function walk(entries) {
      if (!Array.isArray(entries)) return;
      for (const entry of entries) {
        if (entry?.url) candidates.push(entry.url);
        if (entry?.layers) walk(entry.layers);
      }
    }
    walk(webmap?.operationalLayers);
    if (!candidates.length) throw new Error('CP&F web map has no operational layer URLs.');

    async function readMeta(url) {
      return arcJsonp(String(url).replace(/\?+.*$/, ''), { f: 'pjson' }, 25000);
    }
    function hasInstrumentField(fields = []) {
      return fields.some((f) => /instr|instrument/i.test(f.name || '') || /instr|instrument/i.test(f.alias || ''));
    }

    for (const baseUrlRaw of candidates) {
      const baseUrl = String(baseUrlRaw).replace(/\/+$/, '');
      const meta = await readMeta(baseUrl).catch(() => null);
      if (!meta) continue;

      if (Array.isArray(meta.layers) && meta.layers.length) {
        for (const layer of meta.layers) {
          const layerUrl = `${baseUrl}/${layer.id}`;
          const layerMeta = await readMeta(layerUrl).catch(() => null);
          if (!layerMeta) continue;
          if (/esriGeometryPoint/i.test(layerMeta.geometryType || '') && hasInstrumentField(layerMeta.fields || [])) {
            return { layerUrl, layerMeta };
          }
        }
      }

      if (/esriGeometryPoint/i.test(meta.geometryType || '') && hasInstrumentField(meta.fields || [])) {
        return { layerUrl: baseUrl, layerMeta: meta };
      }
    }

    throw new Error('Could not identify CP&F point layer with instrument fields.');
  }

  async function ensureCpfLayerInfo() {
    if (cpfLayerInfo) return cpfLayerInfo;
    if (!cpfLayerInfoPromise) {
      cpfLayerInfoPromise = discoverAdaCpfLayerViaJsonp()
        .then((info) => {
          cpfLayerInfo = info;
          return info;
        })
        .finally(() => { cpfLayerInfoPromise = null; });
    }
    return cpfLayerInfoPromise;
  }

  async function queryCpfRecordsNearCorner(north, east, maxMeters = 250, inSR = 4326) {
    const { layerUrl, layerMeta } = await ensureCpfLayerInfo();
    const radii = [5, 10, 25, 50, 100, 150, maxMeters];

    for (const radius of radii) {
      const payload = await arcJsonp(`${layerUrl.replace(/\/+$/, '')}/query`, {
        f: 'pjson',
        where: '1=1',
        geometry: { x: east, y: north, spatialReference: { wkid: inSR } },
        geometryType: 'esriGeometryPoint',
        inSR,
        spatialRel: 'esriSpatialRelIntersects',
        distance: radius,
        units: 'esriSRUnit_Meter',
        outFields: '*',
        returnGeometry: true,
        outSR: 4326,
      }, 25000).catch(() => null);

      const features = payload?.features || [];
      if (!features.length) continue;

      const instrumentKey = pickField(features[0]?.attributes || {}, layerMeta, [/^instrument$/i, /instr/i, /instrument_?no/i, /inst_?no/i]);
      const pdfUrlKey = pickField(features[0]?.attributes || {}, layerMeta, [/pdf/i, /doc/i, /document/i, /hyperlink/i, /url/i, /link/i]);
      const pdfNameKey = pickField(features[0]?.attributes || {}, layerMeta, [/file/i, /filename/i, /pdfname/i]);

      const records = features.map((feature) => {
        const x = Number(feature?.geometry?.x);
        const y = Number(feature?.geometry?.y);
        const distanceMeters = inSR === 4326 && Number.isFinite(x) && Number.isFinite(y)
          ? haversineMeters(north, east, y, x)
          : null;
        const attrs = feature.attributes || {};
        const instrument = instrumentKey ? attrs[instrumentKey] : null;
        const pdfUrl = pdfUrlKey ? attrs[pdfUrlKey] : null;
        const pdfName = pdfNameKey ? attrs[pdfNameKey] : null;
        return {
          distanceMeters,
          instrument,
          links: buildCpfPdfLinks(instrument, pdfUrl, pdfName),
        };
      }).filter((record) => record.links.length && (record.distanceMeters == null || record.distanceMeters <= (radius + 0.5)));

      if (records.length) return records;
    }

    return [];
  }

  function cpfLinksHtml(records = []) {
    if (!records.length) return '<span class="small">No CP&amp;F PDF links found near this corner.</span>';
    return records.slice(0, 8).map((record, idx) => {
      const instrument = record.instrument != null && String(record.instrument).trim()
        ? escapeHtml(String(record.instrument))
        : `Record ${idx + 1}`;
      const links = record.links.map((url, i) => (
        `<a target="_blank" rel="noopener" href="${escapeHtml(buildRosPdfProxyUrl(url))}">CP&amp;F PDF${record.links.length > 1 ? ` ${i + 1}` : ''}</a>`
      )).join('<br/>');
      return `<div style="margin:6px 0"><b>${instrument}</b><br/>${links}</div>`;
    }).join('');
  }

  function uniqueCpInstrumentNote(records = []) {
    const values = [];
    const seen = new Set();
    for (const record of records) {
      const inst = record?.instrument == null ? '' : String(record.instrument).trim();
      if (!inst || seen.has(inst)) continue;
      seen.add(inst);
      values.push(inst);
    }
    if (!values.length) return '';
    return `CPNFS: ${values.join('...')}`;
  }

  async function buildCpfNotesByCoordinate(plssPointsMap) {
    const notes = new Map();
    for (const [key, point] of (plssPointsMap || new Map()).entries()) {
      try {
        const records = await queryCpfRecordsNearCorner(point.north, point.east, 250, EXPORT_OUT_SR);
        const note = uniqueCpInstrumentNote(records);
        if (note) notes.set(key, note);
      } catch (e) {
        log(`CP&F export note lookup failed for ${point.north.toFixed(3)}, ${point.east.toFixed(3)}: ${e.message || e}`, 'warn');
      }
    }
    return notes;
  }

  // -----------------------------
  // Geometry helpers
  // -----------------------------
  function arcPointToLatLng(g) {
    if (!g) return null;
    return [g.y, g.x];
  }

  function arcPolygonToGeoJSON(geom) {
    return {
      type: "Feature",
      properties: {},
      geometry: {
        type: "Polygon",
        coordinates: (geom?.rings || []).map(ring => ring.map(([x,y]) => [x,y]))
      }
    };
  }

  function arcExtentFromPolygon(geom) {
    const rings = geom?.rings || [];
    let xmin=Infinity,ymin=Infinity,xmax=-Infinity,ymax=-Infinity;
    for (const ring of rings) {
      for (const [x,y] of ring) {
        if (x < xmin) xmin = x;
        if (y < ymin) ymin = y;
        if (x > xmax) xmax = x;
        if (y > ymax) ymax = y;
      }
    }
    if (!isFinite(xmin)) return null;
    return { xmin, ymin, xmax, ymax };
  }

  function arcExtentFromGeometry(geom) {
    if (!geom) return null;
    if (geom.x != null && geom.y != null) {
      return { xmin: geom.x, ymin: geom.y, xmax: geom.x, ymax: geom.y };
    }
    if (Array.isArray(geom.paths)) {
      let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
      for (const path of geom.paths) {
        for (const [x, y] of (path || [])) {
          if (x < xmin) xmin = x;
          if (y < ymin) ymin = y;
          if (x > xmax) xmax = x;
          if (y > ymax) ymax = y;
        }
      }
      if (isFinite(xmin)) return { xmin, ymin, xmax, ymax };
    }
    return arcExtentFromPolygon(geom);
  }

  function centerMapOnFeature(feature, layerGroup, label = 'feature') {
    const ext = arcExtentFromGeometry(feature?.geometry);
    if (!ext) return;
    const samePoint = Math.abs(ext.xmax - ext.xmin) < 1e-12 && Math.abs(ext.ymax - ext.ymin) < 1e-12;
    if (samePoint) {
      map.setView([ext.ymin, ext.xmin], Math.max(map.getZoom(), 19));
    } else {
      map.fitBounds(L.latLngBounds([ext.ymin, ext.xmin], [ext.ymax, ext.xmax]).pad(0.2));
    }
    if (layerGroup?.getLayers) {
      for (const item of layerGroup.getLayers()) {
        if (typeof item.getBounds === 'function') {
          const b = item.getBounds();
          if (b?.isValid?.() && b.contains([ext.ymin, ext.xmin])) {
            item.openPopup?.();
            break;
          }
        } else if (typeof item.getLatLng === 'function') {
          const ll = item.getLatLng();
          if (ll && Math.abs(ll.lat - ext.ymin) < 1e-10 && Math.abs(ll.lng - ext.xmin) < 1e-10) {
            item.openPopup?.();
            break;
          }
        }
      }
    }
    invalidateMapSoon(`summary select: ${label}`);
  }

  function centroidOfPolygon(geom) {
    const ring = geom?.rings?.[0] || [];
    if (!ring.length) return null;
    let sx=0, sy=0, n=0;
    for (const [x,y] of ring) { sx += x; sy += y; n++; }
    return { x: sx/n, y: sy/n };
  }

  function haversineMeters(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2-lat1);
    const dLon = toRad(lon2-lon1);
    const a =
      Math.sin(dLat/2)**2 +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.min(1, Math.sqrt(a)));
  }

  function pointInRing(pointXY, ring) {
    let inside = false;
    const [x, y] = pointXY;
    for (let i=0, j=ring.length-1; i<ring.length; j=i++) {
      const xi = ring[i][0], yi = ring[i][1];
      const xj = ring[j][0], yj = ring[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-30) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function pointInPolygon(pointXY, geom) {
    const rings = geom?.rings || [];
    if (!rings.length) return false;
    if (!pointInRing(pointXY, rings[0])) return false;
    for (let i=1; i<rings.length; i++) {
      if (pointInRing(pointXY, rings[i])) return false;
    }
    return true;
  }

  function normalizedAliquotLabel(feature, sectionFeature) {
    const attrs = feature?.attributes || {};
    if (attrs.ALIQUOT) return String(attrs.ALIQUOT).toUpperCase();

    const ring = feature?.geometry?.rings?.[0] || [];
    const secRing = sectionFeature?.geometry?.rings?.[0] || [];
    if (!ring.length || !secRing.length) return 'ALIQUOT';

    const center = centroidOfPolygon(feature.geometry);
    if (!center) return 'ALIQUOT';

    let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
    for (const [x, y] of secRing) {
      xmin = Math.min(xmin, x);
      ymin = Math.min(ymin, y);
      xmax = Math.max(xmax, x);
      ymax = Math.max(ymax, y);
    }
    if (!isFinite(xmin) || !isFinite(ymin) || !isFinite(xmax) || !isFinite(ymax)) return 'ALIQUOT';

    const nx = (center.x - xmin) / Math.max(1e-9, xmax - xmin);
    const ny = (center.y - ymin) / Math.max(1e-9, ymax - ymin);

    const h = nx >= 0.5 ? 'E' : 'W';
    const v = ny >= 0.5 ? 'N' : 'S';
    return `${v}${h}`;
  }

  function buildAllSelectedAliquotKeys(aliquotFeatures) {
    return new Set((aliquotFeatures || []).map((feature, index) => buildAliquotSelectionKey(feature, index)));
  }

  function isAliquotSelected(feature, index) {
    return state.selectedAliquotKeys.has(buildAliquotSelectionKey(feature, index));
  }

  function setAliquotSelected(feature, index, selected) {
    const key = buildAliquotSelectionKey(feature, index);
    if (selected) state.selectedAliquotKeys.add(key);
    else state.selectedAliquotKeys.delete(key);
    document.querySelectorAll(`[data-aliquot-select-key="${key}"]`).forEach((node) => {
      node.checked = selected;
    });
  }

  function drawAliquots(aliquotFeatures, sectionFeature) {
    layers.aliquots.clearLayers();
    for (const [index, feature] of (aliquotFeatures || []).entries()) {
      const gj = arcPolygonToGeoJSON(feature.geometry);
      const label = normalizedAliquotLabel(feature, sectionFeature);
      const popupHtml = buildAliquotPopupHtml(feature, label);
      const selected = isAliquotSelected(feature, index);
      const layer = L.geoJSON(gj, {
        style: {
          color: selected ? '#6aa9ff' : '#4b5f8a',
          weight: selected ? 1.8 : 1.3,
          fillOpacity: selected ? 0.14 : 0.03,
          dashArray: selected ? null : '4 4',
        },
      });
      layer.eachLayer((l) => {
        l.bindPopup(popupHtml);
        l.on('click', () => {
          state.selectedAliquot = feature;
          const nextSelected = !isAliquotSelected(feature, index);
          setAliquotSelected(feature, index, nextSelected);
          drawAliquots(state.aliquotFeatures, sectionFeature);
          log(`${nextSelected ? 'Included' : 'Excluded'} aliquot in export: ${label}`);
        });
      });
      layers.aliquots.addLayer(layer);
    }
  }



  function getPolygonCornerMarkers(feature, role, options = {}) {
    const rings = feature?.geometry?.rings || [];
    const points = [];
    for (let ringIndex = 0; ringIndex < rings.length; ringIndex++) {
      const ring = rings[ringIndex] || [];
      const trimmed = ring.length > 1 && ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]
        ? ring.slice(0, -1)
        : ring;
      for (let vertexIndex = 0; vertexIndex < trimmed.length; vertexIndex++) {
        const vertex = trimmed[vertexIndex];
        const x = Number(vertex[0]);
        const y = Number(vertex[1]);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        points.push({
          east: x,
          north: y,
          label: `${role.toUpperCase()}_CORNER R${ringIndex + 1} V${vertexIndex + 1}`,
          color: options.color || '#ffffff',
        });
      }
    }
    return points;
  }

  function drawCornerMarkers(featuresByRole = []) {
    layers.cornerMarkers.clearLayers();
    for (const entry of featuresByRole) {
      const role = entry.role;
      const featureList = entry.features || [];
      for (const feature of featureList) {
        const corners = getPolygonCornerMarkers(feature, role, entry);
        for (const corner of corners) {
          const marker = L.circleMarker([corner.north, corner.east], {
            radius: 3,
            weight: 1,
            color: '#101834',
            fillColor: corner.color,
            fillOpacity: 0.95,
          });
          marker.bindPopup(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px">Loading CP&amp;F records…</div>`);
          marker.on('click', async () => {
            marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px">Loading CP&amp;F records…</div>`);
            try {
              const cpfRecords = await queryCpfRecordsNearCorner(corner.north, corner.east);
              marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="hr"></div>${cpfLinksHtml(cpfRecords)}`);
              if (cpfRecords.length) log(`Loaded CP&F PDF links for ${role} corner ${corner.label}.`);
              else log(`No CP&F PDF links found for ${role} corner ${corner.label}.`, 'warn');
            } catch (e) {
              marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px;color:#ffb3b3">CP&amp;F lookup failed: ${escapeHtml(e.message || e)}</div>`);
              log(`CP&F corner lookup failed: ${e.message || e}`, 'warn');
            }
          });
          layers.cornerMarkers.addLayer(marker);
        }
      }
    }
  }

  // -----------------------------
  // Address parsing
  // -----------------------------
  const DIRS = new Set(["N","S","E","W","NE","NW","SE","SW"]);
  const SUFFIXES = new Set(["ST","AVE","AV","DR","RD","LN","CT","PL","WAY","BLVD","CIR","PKWY","TRL","TER","HWY"]);
  function normalizeSpaces(s){ return (s||"").trim().replace(/\s+/g," "); }

  function parseAddress(raw) {
    raw = normalizeSpaces(raw);
    const parts = raw.split(",").map(s => s.trim()).filter(Boolean);
    const streetPart = parts[0] || "";
    const cityPart = parts[1] || "";

    const toks = streetPart.toUpperCase().split(/\s+/).filter(Boolean);
    const out = { AddNum: null, StPreDir: null, StName: null, StSuffix: null, City: null };

    if (toks.length && /^\d+$/.test(toks[0])) {
      out.AddNum = parseInt(toks[0], 10);
      toks.shift();
    }
    if (toks.length && DIRS.has(toks[0])) {
      out.StPreDir = toks.shift();
    }
    let suffix = null;
    if (toks.length && SUFFIXES.has(toks[toks.length-1])) {
      suffix = toks.pop();
    }
    out.StSuffix = suffix;
    out.StName = toks.length ? toks.join(" ") : null;

    if (cityPart) out.City = cityPart.toUpperCase().split(/\s+/)[0];
    return out;
  }

  // -----------------------------
  // Map setup
  // -----------------------------
  const map = L.map("map", { zoomControl: true });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 20,
    attribution: "&copy; OpenStreetMap contributors"
  }).addTo(map);
  map.setView([43.615, -116.202], 12);

  const layers = {
    address: L.layerGroup().addTo(map),
    parcel: L.layerGroup().addTo(map),
    subdivision: L.layerGroup().addTo(map),
    section: L.layerGroup().addTo(map),
    township: L.layerGroup().addTo(map),
    ros: L.layerGroup().addTo(map),
    aliquots: L.layerGroup().addTo(map),
    cornerMarkers: L.layerGroup().addTo(map),
  };

  function clearMapLayers() {
    Object.values(layers).forEach(g => g.clearLayers());
  }

  // ---- Leaflet display fix helpers ----
  function invalidateMapSoon(reason="") {
    requestAnimationFrame(() => map.invalidateSize());
    setTimeout(() => map.invalidateSize(), 50);
    setTimeout(() => map.invalidateSize(), 250);
    if (reason) log(`map.invalidateSize() (${reason})`);
  }
  window.addEventListener("load", () => invalidateMapSoon("window load"));
  window.addEventListener("resize", () => invalidateMapSoon("window resize"));
  try {
    const ro = new ResizeObserver(() => map.invalidateSize());
    ro.observe($("map"));
    ro.observe(document.querySelector(".mapWrap"));
  } catch {}

  // -----------------------------
  // Results state
  // -----------------------------
  const state = {
    addressFeature: null,
    parcelFeature: null,        // displayed (outSR 4326)
    parcelFeature2243: null,    // export geometry (outSR 2243)
    subdivisionFeature2243: null,
    subdivisionFeature: null,
    sectionFeature: null,
    sectionFeature2243: null,
    aliquotFeatures2243: [],
    townshipFeature: null,
    rosFeatures: [],
    aliquotFeatures: [],
    selectedAliquot: null,
    selectedAliquotKeys: new Set(),
    exportGeoJSON: null,
    lastLonLat: null,
    projectContext: getProjectContext()
  };

  function setSummaryCards(cards) {
    const root = $("summary");
    root.innerHTML = "";
    if (!cards.length) {
      root.innerHTML = `<div class="small">No results yet.</div>`;
      return;
    }
    for (const c of cards) root.appendChild(c);
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replace(/&/g,"&amp;").replace(/</g,"&lt;")
      .replace(/>/g,"&gt;").replace(/"/g,"&quot;")
      .replace(/'/g,"&#039;");
  }

  function card(title, subtitle, kvPairs, links=[], options={}) {
    const el = document.createElement("div");
    el.className = "card";
    if (typeof options.onSelect === 'function') {
      el.classList.add('clickable');
      el.tabIndex = 0;
      el.addEventListener('click', options.onSelect);
      el.addEventListener('keydown', (evt) => {
        if (evt.key === 'Enter' || evt.key === ' ') {
          evt.preventDefault();
          options.onSelect();
        }
      });
    }
    const head = document.createElement("div");
    head.className = "chead";
    head.innerHTML = `
      <div>
        <div style="font-weight:800">${escapeHtml(title)}</div>
        <div class="small">${escapeHtml(subtitle || "")}</div>
      </div>
    `;
    const body = document.createElement("div");
    body.className = "cbody";

    const kv = document.createElement("div");
    kv.className = "kv";
    for (const [k,v] of kvPairs) {
      const kdiv = document.createElement("div");
      kdiv.textContent = k;
      const vdiv = document.createElement("div");
      vdiv.innerHTML = v;
      kv.appendChild(kdiv);
      kv.appendChild(vdiv);
    }
    body.appendChild(kv);

    if (links.length) {
      const hr = document.createElement("div");
      hr.className = "hr";
      body.appendChild(hr);
      const ldiv = document.createElement("div");
      ldiv.className = "small";
      ldiv.innerHTML = links.map(h => `• ${h}`).join("<br/>");
      body.appendChild(ldiv);
    }

    el.appendChild(head);
    el.appendChild(body);
    if (typeof options.onRender === 'function') {
      options.onRender(el);
    }
    return el;
  }

  // -----------------------------
  // Address lookup
  // -----------------------------
  function buildAddressWhere(p) {
    const clauses = ["1=1"];
    if (p.AddNum != null) clauses.push(`AddNum = ${p.AddNum}`);
    if (p.StName) clauses.push(`UPPER(StName) LIKE '%${p.StName.replace(/'/g,"''")}%'`);
    if (p.StPreDir) clauses.push(`UPPER(StPreDir) = '${p.StPreDir.replace(/'/g,"''")}'`);
    if (p.StSuffix) clauses.push(`UPPER(StSuffix) = '${p.StSuffix.replace(/'/g,"''")}'`);
    if (p.City) clauses.push(`UPPER(CommName) LIKE '%${p.City.replace(/'/g,"''")}%'`);
    return clauses.join(" AND ");
  }

  function scoreAddressCandidate(p, attrs) {
    let s = 0;
    if (p.AddNum != null && attrs.AddNum == p.AddNum) s += 10;
    if (p.StPreDir && String(attrs.StPreDir||"").toUpperCase() === p.StPreDir) s += 4;
    if (p.StSuffix && String(attrs.StSuffix||"").toUpperCase() === p.StSuffix) s += 4;
    if (p.City && String(attrs.CommName||"").toUpperCase().includes(p.City)) s += 2;
    if (p.StName && String(attrs.StName||"").toUpperCase().includes(p.StName.split(" ")[0])) s += 2;
    return s;
  }

  async function findBestAddressFeature(rawAddr) {
    const parsed = parseAddress(rawAddr);
    log(`Parsed address: AddNum=${parsed.AddNum ?? "-"} PreDir=${parsed.StPreDir ?? "-"} StName=${parsed.StName ?? "-"} Suffix=${parsed.StSuffix ?? "-"} City=${parsed.City ?? "-"}`);

    const where = buildAddressWhere(parsed);
    log(`Address query WHERE: ${where}`);

    const resp = await arcQuery(LAYERS.address, {
      where,
      outFields: "*",
      returnGeometry: true,
      outSR: 4326
    });
    const feats = resp?.features || [];
    log(`Address query returned ${feats.length} feature(s).`);
    if (!feats.length) return { best: null, candidates: [] };

    const scored = feats
      .map(f => ({ f, score: scoreAddressCandidate(parsed, f.attributes || {}) }))
      .sort((a,b) => b.score - a.score);

    return { best: scored[0].f, candidates: scored.map(x => x.f) };
  }

  // -----------------------------
  // Parcel query (point+distance)
  // -----------------------------
  async function findParcelNearPoint(lon, lat, outSR=4326) {
    const distances = [0, 10, 30, 150];
    let best = null;

    for (const d of distances) {
      const params = {
        where: "1=1",
        outFields: "*",
        returnGeometry: true,
        outSR,
        geometry: `${lon},${lat}`,
        geometryType: "esriGeometryPoint",
        inSR: 4326,
        spatialRel: "esriSpatialRelIntersects",
      };
      if (d > 0) {
        params.distance = d;
        params.units = "esriSRUnit_Meter";
      }

      log(`Parcel search: point+distance ${d}m (outSR=${outSR})`);
      const resp = await arcQuery(LAYERS.parcels, params);
      const feats = resp?.features || [];
      log(`Parcel candidates @ ${d}m: ${feats.length}`);

      if (feats.length) {
        if (outSR === 4326) {
          const pointXY = [lon, lat];
          const containing = feats.find(f => pointInPolygon(pointXY, f.geometry));
          if (containing) { best = containing; break; }

          let nearest = null;
          let bestDist = Infinity;
          for (const f of feats) {
            const c = centroidOfPolygon(f.geometry);
            if (!c) continue;
            const meters = haversineMeters(lat, lon, c.y, c.x);
            if (meters < bestDist) { bestDist = meters; nearest = f; }
          }
          best = nearest || feats[0];
          break;
        } else {
          best = feats[0];
          break;
        }
      }
    }
    return best;
  }

  async function findContainingPolygon(layerId, lon, lat, searchMeters, outSR = 4326) {
    const resp = await arcQuery(layerId, {
      where: "1=1",
      outFields: "*",
      returnGeometry: true,
      outSR,
      geometry: `${lon},${lat}`,
      geometryType: "esriGeometryPoint",
      inSR: 4326,
      spatialRel: "esriSpatialRelIntersects",
      distance: searchMeters,
      units: "esriSRUnit_Meter"
    });
    const feats = resp?.features || [];
    if (!feats.length) return null;

    if (outSR !== 4326) return feats[0];

    const pointXY = [lon, lat];
    const containing = feats.find(f => pointInPolygon(pointXY, f.geometry));
    if (containing) return containing;

    let nearest = null;
    let bestDist = Infinity;
    for (const f of feats) {
      const c = centroidOfPolygon(f.geometry);
      if (!c) continue;
      const meters = haversineMeters(lat, lon, c.y, c.x);
      if (meters < bestDist) { bestDist = meters; nearest = f; }
    }
    return nearest || feats[0];
  }

  async function findRosNearPoint(lon, lat, searchMeters=1600) {
    const resp = await arcQuery(LAYERS.ros, {
      where: "1=1",
      outFields: "*",
      returnGeometry: true,
      outSR: 4326,
      geometry: `${lon},${lat}`,
      geometryType: "esriGeometryPoint",
      inSR: 4326,
      spatialRel: "esriSpatialRelIntersects",
      distance: searchMeters,
      units: "esriSRUnit_Meter"
    });
    return resp?.features || [];
  }

  // -----------------------------
  // Draw
  // -----------------------------
  function formatAddressAttrs(a) {
    const parts = [];
    if (a.AddNum) parts.push(a.AddNum);
    if (a.StPreDir) parts.push(a.StPreDir);
    if (a.StName) parts.push(a.StName);
    if (a.StSuffix) parts.push(a.StSuffix);
    const line1 = parts.join(" ");
    const line2 = [a.CommName, a.State, a.Zip4].filter(Boolean).join(" ");
    return [line1, line2].filter(Boolean).join(", ");
  }

  function drawAddressPoint(f) {
    const ll = arcPointToLatLng(f.geometry);
    if (!ll) return null;
    const m = L.circleMarker(ll, { radius: 7, weight: 2, color: "#ffffff", fillColor: "#2a3dff", fillOpacity: 0.9 });
    m.bindPopup(`<b>Address</b><br/>${escapeHtml(formatAddressAttrs(f.attributes || {}))}`);
    layers.address.addLayer(m);
    return m;
  }

  function drawPolygonFeature(f, group, geojsonOptions, label) {
    const gj = arcPolygonToGeoJSON(f.geometry);
    const layer = L.geoJSON(gj, geojsonOptions);
    layer.bindPopup(`<b>${escapeHtml(label)}</b>`);
    group.addLayer(layer);
    return layer;
  }

  function bestRosLabel(a) {
    const fields = ["RS","ROS","Survey","SurveyNo","SURVEYNO","Book","BOOK","Page","PAGE","Document","DOC","Description","DESC","Name","NAME"];
    const parts = [];
    for (const f of fields) if (a[f]) parts.push(`${f}:${a[f]}`);
    if (parts.length) return parts.slice(0,3).join("  ");
    for (const [k,v] of Object.entries(a||{})) {
      if (typeof v === "string" && v.trim()) return v.trim();
    }
    return "ROS feature";
  }

  function normalizeRosFeatures(rosItems = []) {
    return rosItems
      .map((item) => (item?.feature?.geometry ? item.feature : item))
      .filter((f) => f?.geometry);
  }

  function rosIntersectsSection(rosFeature, sectionFeature) {
    if (!sectionFeature?.geometry) return true;
    const g = rosFeature?.geometry;
    if (!g) return false;
    if (g.x != null && g.y != null) {
      return pointInPolygon([g.x, g.y], sectionFeature.geometry);
    }
    if (g.rings?.length) {
      const c = centroidOfPolygon(g);
      return c ? pointInPolygon([c.x, c.y], sectionFeature.geometry) : false;
    }
    if (g.paths?.[0]?.length) {
      return g.paths[0].some(([x, y]) => pointInPolygon([x, y], sectionFeature.geometry));
    }
    return false;
  }

  function filterRosFeaturesForSection(rosFeatures, sectionFeature) {
    return (rosFeatures || []).filter((feature) => rosIntersectsSection(feature, sectionFeature));
  }

  function summarizeAttrs(attrs) {
    if (!attrs) return [["(no attrs)",""]];
    const picks = [];
    const prefer = ["PARCEL","PIN","RP","AIN","SUB","TOWNSHIP","RANGE","SECTION","BOOK","PAGE","RS","ROS","DOC","URL","PDF","LINK","NAME","DESC"];
    const keys = Object.keys(attrs);
    const used = new Set();

    function add(k) {
      if (used.has(k)) return;
      const v = attrs[k];
      if (v === null || v === undefined || v === "") return;
      used.add(k);
      picks.push([k, escapeHtml(v)]);
    }

    for (const token of prefer) {
      for (const k of keys) {
        if (k.toUpperCase().includes(token)) add(k);
        if (picks.length >= 10) break;
      }
      if (picks.length >= 10) break;
    }
    if (!picks.length) for (const k of keys.slice(0,8)) add(k);
    return picks;
  }

  function findPdfLinks(attrs) {
    const links = [];
    for (const [k,v] of Object.entries(attrs || {})) {
      if (!v) continue;
      const sv = String(v);
      if (/^https?:\/\//i.test(sv) && /\.pdf(\?|$)/i.test(sv)) links.push({ key: k, url: sv });
      if (!/^https?:\/\//i.test(sv) && /\.pdf(\?|$)/i.test(sv)) {
        links.push({ key: k, url: new URL(sv, BASE).toString() });
      }
    }
    const seen = new Set();
    return links.filter(l => (seen.has(l.url) ? false : (seen.add(l.url), true)));
  }

  function buildPdfProxyLinks(attrs, linkText = "Open PDF (API)") {
    const pdfs = findPdfLinks(attrs || {});
    return pdfs.map((p) => (
      `<a target="_blank" rel="noopener" href="${escapeHtml(buildRosPdfProxyUrl(p.url))}">${escapeHtml(linkText)}</a> <span class="small">(${escapeHtml(p.key)})</span>`
    ));
  }

  function buildRosPopupHtml(attrs = {}) {
    const desc = bestRosLabel(attrs);
    const links = buildPdfProxyLinks(attrs, "Open PDF (API)");
    const linkHtml = links.length ? links.map((l, i) => `${i + 1}. ${l}`).join("<br/>") : "No PDF links found";
    return `<b>Record of Survey</b><br/>${escapeHtml(desc)}<div class="hr"></div><div class="small"><b>PDFs</b><br/>${linkHtml}</div>`;
  }

  function buildAliquotPopupHtml(feature, label = 'Aliquot') {
    const attrs = feature?.attributes || {};
    const links = buildPdfProxyLinks(attrs, 'Open CP&F PDF (API)');
    const linkHtml = links.length ? links.map((l, i) => `${i + 1}. ${l}`).join('<br/>') : 'No CP&amp;F PDF links found';
    return `<b>Aliquot</b><br/>${escapeHtml(label)}<div class="hr"></div><div class="small"><b>CP&amp;F PDFs</b><br/>${linkHtml}</div>`;
  }

  function flattenCpfRecordLinks(records = []) {
    const links = [];
    const seen = new Set();
    for (const record of records) {
      for (const url of (record?.links || [])) {
        const key = canonicalizeUrl(url);
        if (!key || seen.has(key)) continue;
        seen.add(key);
        links.push(url);
      }
    }
    return links;
  }

  async function queryCpfRecordsForAliquot(feature) {
    const corners = getPolygonCornerMarkers(feature, 'aliquot');
    const out = [];
    const seen = new Set();

    for (const corner of corners) {
      const records = await queryCpfRecordsNearCorner(corner.north, corner.east);
      for (const record of records) {
        const links = [];
        for (const url of (record?.links || [])) {
          const key = canonicalizeUrl(url);
          if (!key || seen.has(key)) continue;
          seen.add(key);
          links.push(url);
        }
        if (!links.length) continue;
        out.push({
          instrument: record.instrument,
          distanceMeters: record.distanceMeters,
          links,
        });
      }
      if (out.length >= 8) break;
    }

    return out;
  }

  async function lazyLoadAliquotSummaryCpfLinks(targets = []) {
    for (const target of targets) {
      const node = document.querySelector(`[data-aliquot-cpf-links="${target.token}"]`);
      if (!node) continue;
      try {
        const records = await queryCpfRecordsForAliquot(target.feature);
        const html = cpfLinksHtml(records);
        node.innerHTML = html;
        if (flattenCpfRecordLinks(records).length) {
          log(`Loaded CP&F PDF links for summary ${target.label}.`);
        } else {
          node.innerHTML = '<span class="small">No CP&amp;F PDF links found.</span>';
          log(`No CP&F PDF links found for summary ${target.label}.`, 'warn');
        }
      } catch (e) {
        node.innerHTML = `<span class="small" style="color:#ffb3b3">CP&amp;F lookup failed: ${escapeHtml(e.message || e)}</span>`;
        log(`CP&F summary lookup failed for ${target.label}: ${e.message || e}`, 'warn');
      }
    }
  }

  // -----------------------------
  // Export helpers
  // -----------------------------
  function buildExportGeoJSON() {
    const features = [];

    function pushPolygonFeature(feature, role) {
      if (!feature?.geometry) return;
      const geometry = arcPolygonToGeoJSON(feature.geometry);
      if (!geometry) return;
      features.push({
        type: "Feature",
        properties: {
          role,
          ...(feature.attributes || {})
        },
        geometry
      });
    }

    pushPolygonFeature(state.parcelFeature, "parcel");
    pushPolygonFeature(state.subdivisionFeature, "subdivision");
    pushPolygonFeature(state.sectionFeature, "section");
    pushPolygonFeature(state.townshipFeature, "township");

    for (const feature of state.aliquotFeatures || []) pushPolygonFeature(feature, "aliquot");
    for (const feature of state.rosFeatures || []) pushPolygonFeature(feature, "ros");

    if (state.lastLonLat) {
      features.push({
        type: "Feature",
        properties: { role: "address_point" },
        geometry: { type: "Point", coordinates: [state.lastLonLat.lon, state.lastLonLat.lat] }
      });
    }

    return {
      type: "FeatureCollection",
      metadata: {
        generatedAt: new Date().toISOString(),
        count: features.length
      },
      features
    };
  }

  function downloadJson(obj, filename) {
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  function downloadText(text, filename, mime="text/plain") {
    const blob = new Blob([text], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  async function fetchParcelGeometry2243FromPoint(lon, lat) {
    return fetchParcelNearPoint(lon, lat, EXPORT_OUT_SR, 150);
  }

  async function fetchAliquotsAtPoint(lon, lat, outSR = 4326) {
    const payload = await loadAliquotsAtPoint(lon, lat, outSR);
    return payload?.aliquots || [];
  }

  async function fetchSectionGeometry2243FromPoint(lon, lat) {
    const section4326 = await findContainingPolygon(LAYERS.sections, lon, lat, 2500, 4326);
    const objectId = Number(section4326?.attributes?.OBJECTID);
    if (!Number.isFinite(objectId)) return null;

    const resp = await arcQuery(LAYERS.sections, {
      where: `OBJECTID=${objectId}`,
      outFields: '*',
      returnGeometry: true,
      outSR: EXPORT_OUT_SR,
      resultRecordCount: 1,
    });

    return resp?.features?.[0] || null;
  }

  // -----------------------------
  // PDF Basis of Bearing (upload)
  // -----------------------------
  function extractBasisLines(text) {
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const hits = [];
    const re = /(BASIS\s+OF\s+BEARING|BASIS\s+OF\s+BEARINGS|BEARINGS?\s+ARE\s+BASED\s+ON|BEARINGS?\s+SHOWN\s+HEREON\s+ARE\s+BASED\s+ON)/i;

    for (const ln of lines) if (re.test(ln)) hits.push(ln);

    const context = [];
    for (let i=0; i<lines.length; i++) {
      if (re.test(lines[i])) {
        const start = Math.max(0, i-2);
        const end = Math.min(lines.length, i+5);
        context.push(lines.slice(start, end).join(" "));
      }
    }

    const uniq = (arr) => {
      const s = new Set();
      const out = [];
      for (const x of arr) { const k=x.toUpperCase(); if (!s.has(k)) { s.add(k); out.push(x); } }
      return out;
    };
    return { hits: uniq(hits), context: uniq(context) };
  }

  async function scanUploadedPdf(file) {
    if (!file) throw new Error("No PDF selected.");
    if (!window.pdfjsLib) throw new Error("pdfjsLib missing.");
    const buf = await file.arrayBuffer();
    const doc = await pdfjsLib.getDocument({ data: buf }).promise;
    let fullText = "";
    for (let p=1; p<=doc.numPages; p++) {
      const page = await doc.getPage(p);
      const tc = await page.getTextContent();
      const strings = tc.items.map(it => it.str);
      fullText += strings.join("\n") + "\n";
    }
    return extractBasisLines(fullText);
  }

  // -----------------------------
  // Main flow
  // -----------------------------
  async function doLookup(options = {}) {
    clearLog();
    $("btnExportGeo").disabled = true;
    $("btnExportParcelCSV").disabled = true;
    $("btnExportPointForge").disabled = true;
    state.exportGeoJSON = null;
    state.parcelFeature2243 = null;
    state.subdivisionFeature2243 = null;
    state.aliquotFeatures = [];
    state.sectionFeature2243 = null;
    state.aliquotFeatures2243 = [];
    state.selectedAliquot = null;
    state.selectedAliquotKeys.clear();
    setSummaryCards([]);
    clearMapLayers();

    const rawAddr = $("addr").value.trim();
    if (!rawAddr) { log("Enter an address.", "warn"); return; }

    try {
      log("Lookup started.");
      invalidateMapSoon("lookup start");

      const lookup = options.lookupPayload || await lookupByAddress(rawAddr);
      if (options.lookupPayload) {
        log("Loaded saved project results from local storage.");
      }
      const addrF = lookup.addressFeature || null;
      const candidates = addrF ? [addrF] : [];
      if (!addrF) {
        log("Address not found in Ada County Address layer (16). Continuing with geocoder coordinates.", "warn");
      }
      state.addressFeature = addrF;

      const lon = lookup.location?.lon ?? addrF?.geometry?.x;
      const lat = lookup.location?.lat ?? addrF?.geometry?.y;
      const addrLL = [lat, lon];
      const addressDisplay = addrF ? formatAddressAttrs(addrF.attributes || {}) : (lookup.geocode?.display || rawAddr);
      log(`Address match: ${addrLL[0].toFixed(7)}, ${addrLL[1].toFixed(7)}`);
      if (addrF) {
        drawAddressPoint(addrF);
      } else {
        const geocodeMarker = L.circleMarker(addrLL, { radius: 7, weight: 2, color: "#ffffff", fillColor: "#2a3dff", fillOpacity: 0.9 });
        geocodeMarker.bindPopup(`<b>Geocoded Address</b><br/>${escapeHtml(addressDisplay)}`);
        layers.address.addLayer(geocodeMarker);
      }

      map.setView(addrLL, 18);
      invalidateMapSoon("after setView");
      state.lastLonLat = { lon, lat };

      const parcel = lookup.parcel;
      if (!parcel) {
        log("Parcel not found near that address point (0/10/30/150m).", "bad");
        setSummaryCards([
          card("Address", addressDisplay,
            [["Lat/Lon", `${lat.toFixed(7)}, ${lon.toFixed(7)}`],["Candidates", String(candidates.length)]],
            [])
        ]);
        invalidateMapSoon("parcel not found");
        return;
      }
      state.parcelFeature = parcel;

      drawPolygonFeature(parcel, layers.parcel, {
        style: () => ({ color: "#24d18f", weight: 3, fillOpacity: 0.08 })
      }, "Parcel");

      const ext = arcExtentFromPolygon(parcel.geometry);
      if (ext) {
        const bounds = L.latLngBounds([ext.ymin, ext.xmin], [ext.ymax, ext.xmax]);
        map.fitBounds(bounds.pad(0.15));
        invalidateMapSoon("after fitBounds");
      }

      const c = centroidOfPolygon(parcel.geometry) || { x: lon, y: lat };
      log(`Parcel centroid: ${c.y.toFixed(7)}, ${c.x.toFixed(7)}`);

      const subdiv = lookup.subdivision || null;
      const section = lookup.section || null;
      const township = lookup.township || null;

      state.subdivisionFeature = subdiv;
      state.sectionFeature = section;
      state.townshipFeature = township;

      try {
        state.aliquotFeatures = await fetchAliquotsAtPoint(lon, lat, 4326);
        state.aliquotFeatures2243 = await fetchAliquotsAtPoint(lon, lat, EXPORT_OUT_SR);
        state.selectedAliquotKeys = buildAllSelectedAliquotKeys(state.aliquotFeatures);
        drawAliquots(state.aliquotFeatures, section);
        log(`Aliquots loaded: ${state.aliquotFeatures.length}`);
      } catch (e) {
        state.aliquotFeatures = [];
        state.aliquotFeatures2243 = [];
        state.selectedAliquotKeys.clear();
        log(`Aliquot lookup failed: ${e.message || e}`, "warn");
      }

      if (subdiv) drawPolygonFeature(subdiv, layers.subdivision, { style: () => ({ color:"#9ab0ff", weight:2, fillOpacity:0.04 }) }, "Subdivision");
      if (section) drawPolygonFeature(section, layers.section, { style: () => ({ color:"#ffcc66", weight:2, fillOpacity:0.03, dashArray:"6 6" }) }, "Section");
      if (township) drawPolygonFeature(township, layers.township, { style: () => ({ color:"#ff5a7a", weight:2, fillOpacity:0.02, dashArray:"3 8" }) }, "Township");

      drawCornerMarkers([
        { role: "parcel", features: parcel ? [parcel] : [], color: "#24d18f" },
        { role: "subdivision", features: subdiv ? [subdiv] : [], color: "#9ab0ff" },
        { role: "aliquot", features: state.aliquotFeatures || [], color: "#6aa9ff" },
      ]);

      const rosFromLookup = normalizeRosFeatures(lookup.ros || []);
      const ros = filterRosFeaturesForSection(rosFromLookup, section);
      state.rosFeatures = ros;
      log(`ROS in containing section: ${ros.length} (from ${rosFromLookup.length} nearby ROS)`);

      for (const f of ros) {
        const g = f.geometry;
        if (!g) continue;
        if (g.x != null && g.y != null) {
          const m = L.circleMarker([g.y, g.x], { radius: 5, weight: 1.5, color: "#ffffff", fillColor:"#ff5a7a", fillOpacity: .7 });
          m.bindPopup(buildRosPopupHtml(f.attributes || {}));
          layers.ros.addLayer(m);
        } else if (g.paths) {
          const gj = { type:"Feature", properties:{}, geometry:{ type:"LineString", coordinates: g.paths[0].map(([x,y])=>[x,y]) } };
          const l = L.geoJSON(gj, { style:{ color:"#ff5a7a", weight:2 }});
          l.bindPopup(buildRosPopupHtml(f.attributes || {}));
          layers.ros.addLayer(l);
        } else if (g.rings) {
          const gj = arcPolygonToGeoJSON(g);
          const p = L.geoJSON(gj, { style:{ color:"#ff5a7a", weight:2, fillOpacity:0.02 }});
          p.bindPopup(buildRosPopupHtml(f.attributes || {}));
          layers.ros.addLayer(p);
        }
      }

      const cards = [];
      cards.push(card(
        "Address",
        addressDisplay,
        [
          ["Location", `${lat.toFixed(7)}, ${lon.toFixed(7)}`],
          ["Candidates", `${candidates.length}`],
        ],
        []
      ));

      if (state.projectContext.projectId) {
        cards.push(card(
          "Project",
          state.projectContext.projectName || state.projectContext.projectId,
          [
            ["Client", state.projectContext.client || "(none)"],
            ["Address", addressDisplay],
          ],
          []
        ));
      }

      const pAttrs = parcel.attributes || {};
      cards.push(card(
        "Parcel",
        "Parcel feature",
        [
          ["Centroid", `${c.y.toFixed(7)}, ${c.x.toFixed(7)}`],
          ["Attrs", `${Object.keys(pAttrs).length} fields`],
          ["Export", `Unique parcel/subdivision/aliquots CSV in P,N,E,Z,D (EPSG:${EXPORT_OUT_SR}, ID West ftUS)`],
        ],
        []
      ));

      cards.push(card(
        "Aliquots",
        "CPNF-style aliquot lookup",
        [["Count", String(state.aliquotFeatures.length)]],
        []
      ));

      const aliquotSummaryCpfTargets = [];
      if (state.aliquotFeatures.length) {
        const aliquotCards = state.aliquotFeatures.map((f, idx) => {
          const a = f.attributes || {};
          const title = a.ALIQUOT || a.ALIQUOT_LABEL || `Aliquot #${idx + 1}`;
          const token = `aliquot-${idx + 1}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
          const selectionKey = buildAliquotSelectionKey(f, idx);
          aliquotSummaryCpfTargets.push({ token, feature: f, label: `Aliquot #${idx + 1}` });
          return card(
            `Aliquot #${idx + 1}`,
            title,
            summarizeAttrs(a),
            [
              `<label style="display:flex;align-items:center;gap:8px"><input type="checkbox" data-aliquot-select-key="${selectionKey}" ${isAliquotSelected(f, idx) ? 'checked' : ''}/> Include in export</label>`,
              ...buildPdfProxyLinks(a, "Open CP&F PDF (API)"),
              `<div class="small"><b>Corner CP&amp;F records</b><br/><span data-aliquot-cpf-links="${token}">Loading CP&amp;F records…</span></div>`
            ],
            {
              onSelect: () => centerMapOnFeature(f, layers.aliquots, `Aliquot #${idx + 1}`),
              onRender: (cardEl) => {
                const checkbox = cardEl.querySelector(`[data-aliquot-select-key="${selectionKey}"]`);
                if (!checkbox) return;
                checkbox.addEventListener('click', (evt) => evt.stopPropagation());
                checkbox.addEventListener('change', () => {
                  setAliquotSelected(f, idx, checkbox.checked);
                  drawAliquots(state.aliquotFeatures, section);
                  log(`${checkbox.checked ? 'Included' : 'Excluded'} aliquot in export: ${title}`);
                });
              },
            }
          );
        });
        cards.push(...aliquotCards);
      }

      if (subdiv) cards.push(card("Subdivision", "Containing feature", summarizeAttrs(subdiv.attributes), []));
      if (section) cards.push(card("Section", "Containing feature", summarizeAttrs(section.attributes), []));
      if (township) cards.push(card("Township", "Containing feature", summarizeAttrs(township.attributes), []));

      if (ros.length) {
        const rosCards = ros.slice(0, 10).map((f, idx) => {
          const a = f.attributes || {};
          return card(
            `Record of Survey #${idx+1}`,
            bestRosLabel(a),
            summarizeAttrs(a),
            buildPdfProxyLinks(a),
            { onSelect: () => centerMapOnFeature(f, layers.ros, `ROS #${idx + 1}`) }
          );
        });
        cards.push(...rosCards);
      } else {
        cards.push(card("Record of Survey", "None within 1600m of parcel centroid", [["Note","Increase search distance in code if needed."]], []));
      }

      setSummaryCards(cards);
      if (aliquotSummaryCpfTargets.length) {
        lazyLoadAliquotSummaryCpfLinks(aliquotSummaryCpfTargets);
      }

      state.exportGeoJSON = buildExportGeoJSON();
      $("btnExportGeo").disabled = false;

      try {
        log(`Fetching parcel/subdivision/aliquot export geometry in EPSG:${EXPORT_OUT_SR}...`);
        state.parcelFeature2243 = await fetchParcelGeometry2243FromPoint(lon, lat);
        state.subdivisionFeature2243 = await loadSubdivisionAtPoint(lon, lat, EXPORT_OUT_SR);
        state.sectionFeature2243 = await fetchSectionGeometry2243FromPoint(lon, lat);

        if (state.parcelFeature2243?.geometry?.rings?.length) {
          $("btnExportParcelCSV").disabled = false;
          $("btnExportPointForge").disabled = false;
          log("Export geometry ready (IDW ft): parcel, subdivision, and aliquot vertices.");
        } else {
          log("Parcel export geometry not available (no rings).", "warn");
        }
      } catch (e) {
        log(`Parcel/subdivision/aliquot export geometry fetch failed: ${e.message || e}`, "warn");
      }

      if (state.projectContext.projectId) {
        saveProjectLookupSnapshot(state.projectContext.projectId, {
          savedAt: new Date().toISOString(),
          address: rawAddr,
          lookup,
        });
        log(`Saved lookup results to project ${state.projectContext.projectName || state.projectContext.projectId}.`);
      }

      invalidateMapSoon("lookup complete");
      log("Done.", "info");
    } catch (e) {
      log(`Error: ${e.message || e}`, "bad");
      console.error(e);
      invalidateMapSoon("after error");
    }
  }

  // -----------------------------
  // UI events
  // -----------------------------
  $("btnLookup").addEventListener("click", doLookup);

  $("btnClear").addEventListener("click", () => {
    $("addr").value = "";
    clearLog();
    clearMapLayers();
    setSummaryCards([]);
    $("btnExportGeo").disabled = true;
    $("btnExportParcelCSV").disabled = true;
    $("btnExportPointForge").disabled = true;
    state.exportGeoJSON = null;
    state.parcelFeature = null;
    state.parcelFeature2243 = null;
    state.subdivisionFeature2243 = null;
    state.aliquotFeatures = [];
    state.sectionFeature2243 = null;
    state.aliquotFeatures2243 = [];
    state.selectedAliquot = null;
    state.selectedAliquotKeys.clear();
    state.lastLonLat = null;
    $("pdfFindings").style.display = "none";
    $("pdfFindings").textContent = "";
    log("Cleared.");
    invalidateMapSoon("clear");
  });

  $("btnExportGeo").addEventListener("click", () => {
    if (!state.exportGeoJSON) return;
    downloadJson(state.exportGeoJSON, "ada_lookup.geojson");
  });

  $("btnExportParcelCSV").addEventListener("click", async () => {
    try {
      if (!state.parcelFeature2243) {
        throw new Error("Parcel export geometry not loaded yet. Run Lookup again.");
      }
      const selectedAliquotFeatures2243 = filterAliquotFeaturesForExport(state.aliquotFeatures2243, state.selectedAliquotKeys);
      const baseExport = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: state.parcelFeature2243,
        subdivisionFeature2243: state.subdivisionFeature2243,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
      });
      if (!baseExport.count) throw new Error('No boundary vertices available to export.');

      const plssPoints = new Map([...baseExport.points.entries()].filter(([, point]) => (
        !point.sources.has('parcel') && !point.sources.has('subdivision')
      )));
      log(`Looking up CP&F instrument notes for ${plssPoints.size} aliquot/section point(s)...`);
      setBusyModalOpen(true, 'Exporting CSV… gathering CPNF instrument numbers');
      const notesByCoordinate = await buildCpfNotesByCoordinate(plssPoints);

      const finalExport = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: state.parcelFeature2243,
        subdivisionFeature2243: state.subdivisionFeature2243,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
        notesByCoordinate,
      });

      downloadText(finalExport.csv, "parcel_subdivision_aliquots_unique_points_idw_ft_pnezd.csv", "text/csv");
      log(`Exported unique boundary CSV (PNEZD + notes, IDW ft): points=${finalExport.count}.`);
    } catch (e) {
      log(`Parcel CSV export failed: ${e.message || e}`, "bad");
      console.error(e);
    } finally {
      setBusyModalOpen(false);
    }
  });

  $("btnExportPointForge").addEventListener("click", async () => {
    try {
      if (!state.parcelFeature2243) {
        throw new Error("PointForge export geometry not loaded yet. Run Lookup again.");
      }

      const selectedAliquotFeatures2243 = filterAliquotFeaturesForExport(state.aliquotFeatures2243, state.selectedAliquotKeys);
      const baseExport = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: state.parcelFeature2243,
        subdivisionFeature2243: state.subdivisionFeature2243,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
      });
      if (!baseExport.count) throw new Error('No boundary vertices available to export to PointForge.');

      const plssPoints = new Map([...baseExport.points.entries()].filter(([, point]) => (
        !point.sources.has('parcel') && !point.sources.has('subdivision')
      )));
      log(`Looking up CP&F instrument notes for ${plssPoints.size} PointForge aliquot/section point(s)...`);
      setBusyModalOpen(true, 'Exporting to PointForge… gathering CPNF instrument numbers');
      const notesByCoordinate = await buildCpfNotesByCoordinate(plssPoints);

      const uniquePart = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: state.parcelFeature2243,
        subdivisionFeature2243: state.subdivisionFeature2243,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
        notesByCoordinate,
        includePlssWithoutNotes: false,
      });
      if (!uniquePart.count) throw new Error('No parcel/subdivision points or CP&F-backed PLSS points available to export to PointForge.');

      localStorage.setItem(POINTFORGE_ROS_IMPORT_STORAGE_KEY, JSON.stringify({
        source: 'ros-html',
        exportedAt: new Date().toISOString(),
        csv: uniquePart.csv,
      }));
      const projectFileUpdate = persistPointForgeExportProjectFile({
        projectContext: state.projectContext,
        notesByCoordinate,
        csv: uniquePart.csv,
        pointCount: uniquePart.count,
      });
      if (projectFileUpdate) {
        log(`Saved PointForge export to project file (${projectFileUpdate.cpfCount} CP&F references).`);
      }
      openLinkedApp('/POINT_TRANSFORMER.HTML?source=ros');
      log(`Sent ${uniquePart.count} unique boundary points to PointForge.`);
    } catch (e) {
      log(`PointForge export failed: ${e.message || e}`, "bad");
      console.error(e);
    } finally {
      setBusyModalOpen(false);
    }
  });

  function openLinkedApp(path) {
    try {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({
          type: 'survey-cad:navigate-app',
          path,
        }, window.location.origin);
        return;
      }
    } catch (_error) {
      // If parent access is blocked, fallback to same-tab navigation.
    }
    window.location.assign(path);
  }

  $("btnScanPdf").addEventListener("click", async () => {
    const file = $("pdfFile").files?.[0];
    $("pdfFindings").style.display = "none";
    $("pdfFindings").textContent = "";
    try {
      log(`Scanning PDF upload: ${file ? file.name : "(none)"}`);
      const res = await scanUploadedPdf(file);
      const out = [];
      out.push("BASIS OF BEARING — matches:\n");
      if (res.hits.length) out.push(...res.hits.map(x => "• " + x));
      else out.push("(none found as single-line matches)");
      out.push("\n\nBASIS OF BEARING — with context:\n");
      if (res.context.length) out.push(...res.context.map(x => "• " + x));
      else out.push("(none found)");
      $("pdfFindings").textContent = out.join("\n");
      $("pdfFindings").style.display = "block";
      log("PDF scan complete.");
    } catch (e) {
      log(`PDF scan failed: ${e.message || e}`, "bad");
      console.error(e);
    }
  });

  // initial log
  clearLog();
  if (state.projectContext.projectId) {
    if (state.projectContext.address) {
      $("addr").value = state.projectContext.address;
    }
    log(`Project loaded: ${state.projectContext.projectName || state.projectContext.projectId} (${state.projectContext.client || "no client"}).`);
    const snapshot = loadProjectLookupSnapshot(state.projectContext.projectId);
    if (snapshot && state.projectContext.autostart) {
      log(`Restoring saved project results from ${snapshot.savedAt || "unknown time"}.`);
      doLookup({ lookupPayload: snapshot.lookup }).catch((err) => {
        log(`Saved result restore failed, running live lookup: ${err.message || err}`, "warn");
        doLookup().catch((liveErr) => {
          log(`Lookup failed: ${liveErr.message || liveErr}`, "bad");
          console.error(liveErr);
        });
      });
    } else if (state.projectContext.autostart) {
      doLookup().catch((err) => {
        log(`Lookup failed: ${err.message || err}`, "bad");
        console.error(err);
      });
    }
  }
  log("Ready. Enter an address and click Lookup.");
  invalidateMapSoon("initial");
})();
</script>
</body>
</html>
