<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>RecordQuarry — Ada County Survey Context Lookup (Standalone)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- pdf.js (UMD build defining window.pdfjsLib) -->
  <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>

  <style>
    :root{
      --bg:#0b1020;
      --panel:#101834;
      --panel2:#0e1630;
      --text:#e7ecff;
      --muted:#b6c0ff;
      --line:rgba(255,255,255,.12);
      --good:#24d18f;
      --warn:#ffcc66;
      --bad:#ff5a7a;
      --btn:#2a3dff;
      --btn2:#1a255f;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;min-height:100dvh;margin:0;background:var(--bg);color:var(--text);font-family:var(--sans)}
    a{color:#9ab0ff;text-decoration:none}
    a:hover{text-decoration:underline}

    .app{
      height:100%;
      min-height:100dvh;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    header{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0));
    }
    header .title{font-weight:700;letter-spacing:.2px;}
    header .subtitle{color:var(--muted);font-size:12px;}

    .main{
      flex:1;
      min-height:0;
      display:grid;
      grid-template-columns: 430px 1fr;
      gap:10px;
      padding:10px;
    }
    @media (max-width: 980px){
      .main{grid-template-columns:1fr; grid-template-rows: 460px 1fr;}
    }

    .panel{
      background:rgba(255,255,255,.03);
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .panel .phead{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background:rgba(255,255,255,.03);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex:0 0 auto;
    }
    .panel .phead .h{font-weight:700;font-size:13px;}

    /* IMPORTANT: make panel bodies expand so Leaflet has real height */
    .panel .pbody{
      padding:12px;
      overflow:auto;
      min-height:0;
      flex:1 1 auto;   /* <-- KEY FIX */
    }

    .row{display:flex;gap:10px;align-items:center}
    .row.wrap{flex-wrap:wrap}
    label{font-size:12px;color:var(--muted)}
    input[type="text"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,2);
      color:var(--text);
      outline:none;
    }
    input[type="file"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px dashed var(--line);
      background:rgba(0,0,0,18);
      color:var(--muted);
      outline:none;
    }
    button{
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,12);
      background:linear-gradient(180deg, rgba(42,61,255,9), rgba(26,37,95,9));
      color:white;
      font-weight:700;
      cursor:pointer;
      white-space:nowrap;
    }
    button.secondary{
      background:rgba(255,255,255,06);
      border:1px solid var(--line);
      color:var(--text);
      font-weight:600;
    }
    button.workflowPrimary{
      background:linear-gradient(180deg, rgba(42,61,255,1), rgba(26,37,95,96));
      border:1px solid rgba(116,140,255,85);
      box-shadow:0 0 0 1px rgba(255,255,255,16) inset, 0 10px 26px rgba(42,61,255,28);
    }
    button:disabled{opacity:.5;cursor:not-allowed}

    .workflowAction{
      margin-left:auto;
    }

    .small{font-size:12px;color:var(--muted)}
    .mono{font-family:var(--mono);font-size:12px}
    .hr{height:1px;background:var(--line);margin:10px 0}

    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:5px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.2);
      font-size:12px;
      color:var(--muted);
      margin:2px 6px 2px 0;
    }
    .pill .dot{width:8px;height:8px;border-radius:99px;background:var(--muted);opacity:.9}
    .pill.good .dot{background:var(--good)}
    .pill.warn .dot{background:var(--warn)}
    .pill.bad  .dot{background:var(--bad)}

    .hint{
      padding:10px;
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:12px;
    }

    .log{
      font-family:var(--mono);
      font-size:12px;
      line-height:1.35;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
      white-space:pre-wrap;
      overflow-wrap:anywhere;
      word-break:break-word;
      max-height:260px;
      overflow:auto;
    }

    .list{display:flex;flex-direction:column;gap:10px;}
    .card{
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(0,0,0,14);
      overflow:hidden;
      position:relative;
    }
    .rq-star-btn{
      position:absolute;
      top:0.3rem;
      right:0.45rem;
      background:none;
      border:none;
      cursor:pointer;
      font-size:1.05rem;
      line-height:1;
      padding:2px;
      color:#64748b;
      opacity:0.65;
      transition:color 150ms ease,opacity 150ms ease;
    }
    .rq-star-btn:hover:not(:disabled){
      opacity:1;
      color:#e2e8f0;
    }
    .rq-star-btn[aria-pressed="true"]{
      color:#eab308;
      opacity:1;
    }
    .rq-star-btn:disabled{
      cursor:not-allowed;
      opacity:0.35;
    }
    .card.clickable{
      cursor:pointer;
      transition:border-color .16s ease, box-shadow .16s ease, transform .16s ease;
    }
    .card.clickable:hover,
    .card.clickable:focus-visible{
      border-color:rgba(106,169,255,7);
      box-shadow:0 0 0 2px rgba(106,169,255,25);
      transform:translateY(-1px);
      outline:none;
    }
    .card .chead{
      padding:10px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:flex-start;
    }
    .card .cbody{padding:10px;}
    .kv{
      display:grid;
      grid-template-columns: 130px 1fr;
      gap:6px 10px;
      font-size:12px;
      color:var(--muted);
    }
    .kv div:nth-child(2n){
      color:var(--text);
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Right side: ensure map gets height */
    .rightBody{
      padding:0 !important;
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden; /* prevent nested scrollbars */
    }
    .mapWrap{
      flex:1 1 auto;
      min-height:320px; /* <-- map always has real height */
      position:relative;
    }
    #map{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      border-radius:12px;
    }
    @media (max-width: 980px){
      .mapWrap{min-height:420px;}
    }

    @media (max-width: 760px){
      header{
        flex-direction:column;
        align-items:flex-start;
      }
      header .row,
      .panel .phead .row{
        width:100%;
        flex-wrap:wrap;
      }
      .panel .phead{
        flex-direction:column;
        align-items:flex-start;
      }
      .panel .phead .row button{
        flex:1 1 140px;
      }
      .main{
        grid-template-rows:minmax(460px, auto) minmax(420px, 1fr);
      }
      .mapWrap{
        min-height:360px;
      }
    }

    .cpf-collapsed{display:flex;gap:8px;align-items:flex-start}
    .cpf-thumb{width:60px;height:76px;object-fit:cover;border-radius:4px;border:1px solid var(--line);flex-shrink:0;background:rgba(0,0,0,.3);cursor:pointer}
    .cpf-collapsed-info{flex:1;min-width:0}
    .cpf-expand-btn{font-size:11px;padding:3px 8px;margin-top:5px}

    /* Aliquot distance badge & collapsible cards */
    .dist-badge{font-size:10px;color:var(--muted);background:rgba(255,255,255,07);border-radius:4px;padding:1px 6px;flex-shrink:0;white-space:nowrap}
    .dist-badge.is-far{color:var(--warn)}
    .chead-chevron{font-size:10px;opacity:.55;transition:transform .18s ease;flex-shrink:0;margin-left:2px}
    .card.aliquot-card > .chead{cursor:pointer;user-select:none}
    .card.aliquot-card.is-far > .cbody{display:none}
    .card.aliquot-card.is-far.is-expanded > .cbody{display:block}
    .card.aliquot-card.is-far:not(.is-expanded) .chead-chevron{transform:rotate(-90deg)}
    .card.ros-card > .chead{cursor:pointer;user-select:none}
    .card.ros-card.is-far > .cbody{display:none}
    .card.ros-card.is-far.is-expanded > .cbody{display:block}
    .card.ros-card.is-far:not(.is-expanded) .chead-chevron{transform:rotate(-90deg)}

    
    /* Distance group "See More" controls (for far Aliquots / ROS) */
    .rq-see-more-card{
      border-style:dashed;
      background:rgba(255,255,255,.02);
    }
    .rq-see-more-card .chead{
      cursor:default;
    }
    .rq-see-more-card .cbody{
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .rq-see-more-btn{
      width:100%;
      max-width:360px;
    }

    .busyModal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(1, 5, 20, 0.74);
      backdrop-filter: blur(1px);
      z-index:9999;
      padding:16px;
    }
    .busyModal.is-open{display:flex;}
    .busyModalCard{
      width:min(460px, 100%);
      border-radius:14px;
      border:1px solid var(--line);
      background:var(--panel2);
      box-shadow:0 18px 46px rgba(0,0,0,42);
      padding:18px 16px;
      text-align:center;
    }
    .busySpinner{
      width:34px;
      height:34px;
      margin:0 auto 10px;
      border-radius:50%;
      border:3px solid rgba(255,255,255,2);
      border-top-color:var(--good);
      animation:spinBusy .85s linear infinite;
    }
    @keyframes spinBusy {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>
  <script type="module" src="/src/browser-localstorage-sync.js"></script>
</head>

<body>
<div class="app">
  <header>
    <div>
      <div class="title">RecordQuarry — Ada County Survey Context Lookup (Standalone)</div>
      <div class="subtitle">Address → Parcel → Subdivision / Section / Township + nearby ROS (JSONP, no CORS failures)</div>
    </div>
    <div class="row">
      <button id="btnExportPointForge" class="workflowPrimary workflowAction" disabled title="Sends aliquot corner coordinates to PointForge">Export to PointForge</button>
    </div>
  </header>

  <div class="main">
    <!-- LEFT -->
    <div class="panel">
      <div class="phead">
        <div class="h">Lookup</div>
        <div class="row">
          <button id="btnLookup">Lookup</button>
          <button id="btnClear" class="secondary">Clear</button>
          <button id="btnExportParcelCSV" class="secondary" disabled title="Exports unique parcel, subdivision, and aliquot vertices as P,N,E,Z,D in EPSG:2243 (ID West ftUS)">Export CSV</button>
        </div>
      </div>
      <div class="pbody">
        <label for="addr">Address (Ada County, ID)</label>
        <input id="addr" type="text" placeholder="e.g. 5707 W Castle Dr, Boise ID" value=""/>

        <div class="hr"></div>

        <div class="phead" style="padding:0;border:0;background:transparent;justify-content:flex-start">
          <div class="h">PDF Basis of Bearing (local upload)</div>
        </div>
        <input id="pdfFile" type="file" accept="application/pdf"/>
        <button id="btnScanPdf" class="secondary" style="width:100%;margin-top:10px">Scan Uploaded PDF</button>
        <div id="pdfFindings" class="log" style="margin-top:10px;display:none"></div>

        <div class="hr"></div>

        <div class="phead" style="padding:0;border:0;background:transparent;justify-content:flex-start">
          <div class="h">Summary</div>
        </div>
        <div id="summary" class="list" style="margin-top:10px"></div>

        <div class="hr"></div>

        <div class="phead" style="padding:0;border:0;background:transparent;justify-content:flex-start">
          <div class="h">Diagnostics</div>
        </div>
        <div id="log" class="log" style="margin-top:10px"></div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="panel">
      <div class="pbody rightBody">
        <div class="mapWrap">
          <div id="map"></div>
        </div>
      </div>
    </div>

  </div>
</div>

<div id="busyModal" class="busyModal" role="status" aria-live="polite" aria-hidden="true">
  <div class="busyModalCard">
    <div class="busySpinner" aria-hidden="true"></div>
    <div id="busyModalMessage">Processing export…</div>
    <div id="busyModalDetail" class="small" style="margin-top:8px">Gathering CPNF instrument numbers for exported points.</div>
  </div>
</div>

<script type="module">
import { lookupByAddress, findParcelNearPoint as fetchParcelNearPoint, loadAliquotsAtPoint, loadSubdivisionAtPoint, loadUtilitiesByAddress, buildRosPdfProxyUrl } from "./src/browser-survey-client.js";
import { buildAliquotSelectionKey, buildPointMarkerCsvRowsPNEZD, buildPowerUtilityMarkersForPointForge, buildRosBoundaryCsvRowsPNEZD, filterAliquotFeaturesForExport, filterParcelFeatureForExport } from "./src/ros-export.js";

(async () => {
  // -----------------------------
  // Configuration (Ada County)
  // -----------------------------
  const BASE = "https://adacountyassessor.org/arcgis/rest/services/External/ExternalMap/MapServer";
  const LAYERS = {
    address: 16,
    ros: 17,
    subdivisions: 18,
    townships: 19,
    sections: 20,
    parcels: 24,
  };

  // EPSG:2243 (NAD83 / Idaho West ftUS) for export.
  // We do NOT client-project; we request outSR=2243 from the server (no CORS via JSONP).
  const EXPORT_OUT_SR = 2243;

  // Ada County CP&F record lookup (used when clicking corner markers).
  const ADA_PORTAL_BASE = "https://gisprod.adacounty.id.gov/arcgis";
  const ADA_CPF_WEBMAP_ITEM_ID = "019521c7932442f0b4b581f641cbf236";
  const ADA_CPF_PDF_BASE = "https://gisprod.adacounty.id.gov/apps/acdscpf/CpfPdfs/";
  const POINTFORGE_ROS_IMPORT_STORAGE_KEY = "pointforgeRosImport";
  const PROJECT_LOOKUP_STORAGE_PREFIX = "surveyfoundryProjectLookup";
  const ADDRESS_LOOKUP_STORAGE_PREFIX = "surveyfoundryAddressLookup";
  const PROJECT_FILE_STORAGE_PREFIX = "surveyfoundryProjectFile";
  const LAST_LOOKUP_ADDRESS_STORAGE_KEY = "surveyfoundryLastLookupAddress";

  // pdf.js worker
  if (!window.pdfjsLib) {
    alert("pdf.js failed to load (pdfjsLib missing). Check network access.");
  } else {
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
  }

  // -----------------------------
  // UI helpers
  // -----------------------------
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  function ts() {
    const d = new Date();
    return d.toISOString().replace("T"," ").replace("Z","");
  }
  function log(line, kind="info") {
    const prefix = kind === "bad" ? "✖" : kind === "warn" ? "⚠" : "•";
    logEl.textContent += `[${ts()}] ${prefix} ${line}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function clearLog() { logEl.textContent = ""; }

  // -----------------------------
  // Far-distance group collapsing ("See More")
  // -----------------------------
  function rqHideEl(el) {
    if (!el || !el.style) return;
    if (el.dataset && el.dataset.rqPrevDisplay === undefined) {
      el.dataset.rqPrevDisplay = el.style.display || '';
    }
    el.style.display = 'none';
  }

  function rqShowEl(el) {
    if (!el || !el.style) return;
    const prev = el.dataset ? el.dataset.rqPrevDisplay : '';
    el.style.display = prev != null ? prev : '';
  }

  function rqMakeSeeMoreCard(title, subtitle, buttonLabel) {
    const el = document.createElement('div');
    el.className = 'card rq-see-more-card';

    const head = document.createElement('div');
    head.className = 'chead';
    const headWrap = document.createElement('div');
    const headTitle = document.createElement('div');
    headTitle.style.fontWeight = '800';
    headTitle.textContent = title;
    const headSub = document.createElement('div');
    headSub.className = 'small';
    headSub.textContent = subtitle;
    headWrap.appendChild(headTitle);
    headWrap.appendChild(headSub);
    head.appendChild(headWrap);

    const body = document.createElement('div');
    body.className = 'cbody';

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'secondary rq-see-more-btn';
    btn.textContent = buttonLabel;

    body.appendChild(btn);
    el.appendChild(head);
    el.appendChild(body);

    return { el, btn };
  }

  // Collapses "far" cards inside cards[startIdx..endIdx) into a single See More control.
  // Supports optional group headers (e.g., aliquot-group-header) that should be hidden when they
  // would otherwise display with zero visible cards beneath them.
  function rqApplyDistanceGroupSeeMore(cards, startIdx, endIdx, options = {}) {
    const cardClass = options.cardClass || '';
    const farClass = options.farClass || 'is-far';
    const headerClass = options.headerClass || '';
    const title = options.title || 'See More';
    const thresholdMeters = Number(options.thresholdMeters) || 500;

    const slice = cards.slice(startIdx, endIdx);
    if (!slice.length) return;

    const isCard = (el) => Boolean(el && el.classList && cardClass && el.classList.contains(cardClass));
    const isFarCard = (el) => isCard(el) && el.classList.contains(farClass);
    const isHeader = (el) => Boolean(headerClass && el && el.classList && el.classList.contains(headerClass));

    const hideIdx = new Set();

    // Always hide far cards.
    for (let i = 0; i < slice.length; i++) {
      if (isFarCard(slice[i])) hideIdx.add(i);
    }
    if (!hideIdx.size) return;

    // Hide headers that would otherwise appear with no visible cards under them.
    if (headerClass) {
      for (let i = 0; i < slice.length; i++) {
        if (!isHeader(slice[i])) continue;

        let hasVisibleCard = false;
        for (let j = i + 1; j < slice.length; j++) {
          if (isHeader(slice[j])) break;
          if (isCard(slice[j]) && !isFarCard(slice[j])) { hasVisibleCard = true; break; }
        }

        if (!hasVisibleCard) {
          hideIdx.add(i);
          for (let j = i + 1; j < slice.length; j++) {
            if (isHeader(slice[j])) break;
            if (isCard(slice[j])) hideIdx.add(j);
          }
        }
      }
    }

    const firstHiddenRel = Math.min(...hideIdx.values());
    const hiddenCardsCount = [...hideIdx.values()].filter((i) => isCard(slice[i])).length;

    const hiddenEls = [...hideIdx.values()].map((i) => slice[i]).filter(Boolean);

    // Initial state: hide group.
    for (const el of hiddenEls) rqHideEl(el);

    let expanded = false;
    const collapsedLabel = `See More (${hiddenCardsCount} beyond ${Math.round(thresholdMeters)}m)`;
    const expandedLabel = `Hide (${hiddenCardsCount} beyond ${Math.round(thresholdMeters)}m)`;

    const control = rqMakeSeeMoreCard(
      title,
      `${hiddenCardsCount} result(s) hidden by distance`,
      collapsedLabel
    );

    control.btn.addEventListener('click', (evt) => {
      evt.stopPropagation();
      expanded = !expanded;
      control.btn.textContent = expanded ? expandedLabel : collapsedLabel;
      if (expanded) {
        for (const el of hiddenEls) rqShowEl(el);
      } else {
        for (const el of hiddenEls) rqHideEl(el);
      }
    });

    // Insert the control card just before the first hidden element, preserving order.
    cards.splice(startIdx + firstHiddenRel, 0, control.el);
  }

  function setBusyModalOpen(isOpen, message = 'Loading…', detail = '') {
    const modal = $("busyModal");
    const msgEl = $("busyModalMessage");
    const detailEl = $("busyModalDetail");
    if (!modal || !msgEl || !detailEl) return;
    if (isOpen) {
      msgEl.textContent = message || 'Loading…';
      detailEl.textContent = detail || '';
      modal.classList.add('is-open');
      modal.setAttribute('aria-hidden', 'false');
    } else {
      modal.classList.remove('is-open');
      modal.setAttribute('aria-hidden', 'true');
    }
  }

  // -----------------------------
  // Local snapshot storage
  // -----------------------------
  function normalizeAddressStorageKey(address) {
    const raw = String(address || '').trim();
    if (!raw) return '';
    return raw.toLowerCase().replace(/\s+/g, ' ');
  }

  function projectLookupStorageKey(projectId) {
    return `${PROJECT_LOOKUP_STORAGE_PREFIX}:${String(projectId || '').trim()}`;
  }

  function addressLookupStorageKey(address) {
    return `${ADDRESS_LOOKUP_STORAGE_PREFIX}:${normalizeAddressStorageKey(address)}`;
  }

  function projectFileStorageKey(projectId) {
    return `${PROJECT_FILE_STORAGE_PREFIX}:${String(projectId || '').trim()}`;
  }

  function getProjectContext() {
    try {
      const params = new URLSearchParams(window.location.search || '');
      return {
        projectId: params.get('projectId') || '',
        projectName: params.get('projectName') || '',
        address: params.get('address') || '',
        client: params.get('client') || '',
        autostart: params.get('autostart') === '1' || params.get('autostart') === 'true',
      };
    } catch {
      return { projectId: '', projectName: '', address: '', client: '', autostart: false };
    }
  }

  function loadLaunchProject(projectId) {
    try {
      const raw = localStorage.getItem(`surveyfoundryLaunchProject:${String(projectId || '').trim()}`);
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  }

  function loadProjectLookupSnapshot(projectId) {
    const key = projectLookupStorageKey(projectId);
    if (!key || !key.includes(':')) return null;
    try {
      const raw = localStorage.getItem(key);
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  }

  function saveProjectLookupSnapshot(projectId, payload, selectionSnapshot = null, address = '') {
    const key = projectLookupStorageKey(projectId);
    if (!key || !key.includes(':') || !payload) return;
    const snap = {
      savedAt: new Date().toISOString(),
      address: String(address || ''),
      lookup: payload,
      selection: selectionSnapshot || null,
    };
    try {
      localStorage.setItem(key, JSON.stringify(snap));
    } catch {}
  }

  function loadAddressLookupSnapshot(address) {
    const key = addressLookupStorageKey(address);
    if (!key || !key.includes(':')) return null;
    try {
      const raw = localStorage.getItem(key);
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  }

  function saveAddressLookupSnapshot(address, payload, selectionSnapshot = null) {
    const key = addressLookupStorageKey(address);
    if (!key || !key.includes(':') || !payload) return;
    const snap = {
      savedAt: new Date().toISOString(),
      address: String(address || ''),
      lookup: payload,
      selection: selectionSnapshot || null,
    };
    try {
      localStorage.setItem(key, JSON.stringify(snap));
      localStorage.setItem(LAST_LOOKUP_ADDRESS_STORAGE_KEY, normalizeAddressStorageKey(address));
    } catch {}
  }

  function loadMostRecentAddressLookupSnapshot() {
    try {
      const lastKey = localStorage.getItem(LAST_LOOKUP_ADDRESS_STORAGE_KEY) || '';
      if (!lastKey) return null;
      const foundKey = `${ADDRESS_LOOKUP_STORAGE_PREFIX}:${lastKey}`;
      const raw = localStorage.getItem(foundKey);
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  }

  function buildSelectionSnapshot() {
    return {
      selectedParcel: Boolean(state.selectedParcel),
      selectedAliquotKeys: Array.from(state.selectedAliquotKeys || []),
    };
  }

  function applySelectionSnapshot(selectionSnapshot) {
    const snap = selectionSnapshot && typeof selectionSnapshot === 'object' ? selectionSnapshot : null;
    if (!snap) return;
    if (snap.selectedParcel != null) {
      state.selectedParcel = Boolean(snap.selectedParcel);
    }
    if (Array.isArray(snap.selectedAliquotKeys)) {
      state.selectedAliquotKeys = new Set(snap.selectedAliquotKeys.map((k) => String(k)));
    }
  }

  function saveLookupSnapshotsForCurrentState(address) {
    const selectionSnapshot = buildSelectionSnapshot();
    saveAddressLookupSnapshot(address, state.lastLookupPayload, selectionSnapshot);

    if (state.projectContext.projectId) {
      const projectId = state.projectContext.projectId;
      saveProjectLookupSnapshot(projectId, state.lastLookupPayload, selectionSnapshot, address);
    }
  }

  function defaultProjectFile(projectContext = {}) {
    const projectId = String(projectContext.projectId || '').trim();
    const projectName = String(projectContext.projectName || '').trim();
    const client = String(projectContext.client || '').trim();
    return {
      type: 'surveyfoundry-project-file',
      version: 1,
      projectId,
      projectName,
      client,
      generatedAt: new Date().toISOString(),
      folders: [
        createProjectFileFolder('cpfs', 'CP&F Records', 'CP&F PDFs collected from RecordQuarry and other apps.'),
        createProjectFileFolder('point-files', 'Point Files', 'Point exports (e.g., PointForge import CSV).'),
      ],
    };
  }

  function createProjectFileFolder(key, name, description) {
    return {
      key,
      name,
      description: String(description || ''),
      index: [],
    };
  }

  function loadProjectFileSnapshot(projectContext = {}) {
    const projectId = projectContext.projectId || '';
    if (!projectId) return null;
    try {
      const raw = localStorage.getItem(projectFileStorageKey(projectId));
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  }

  function saveProjectFileSnapshot(projectContext = {}, projectFile) {
    const projectId = projectContext.projectId || '';
    if (!projectId || !projectFile) return;
    localStorage.setItem(projectFileStorageKey(projectId), JSON.stringify(projectFile));
  }

  function ensureProjectFileFolder(projectFile, folderKey) {
    if (!projectFile || !Array.isArray(projectFile.folders)) return null;
    const existing = projectFile.folders.find((folder) => folder.key === folderKey);
    if (existing) {
      if (!Array.isArray(existing.index)) existing.index = [];
      return existing;
    }
    const fallback = createProjectFileFolder(folderKey, folderKey, '');
    projectFile.folders.push(fallback);
    return fallback;
  }

  function parseCpfInstrumentsFromNotesMap(notesByCoordinate = new Map()) {
    const instruments = new Set();
    for (const note of notesByCoordinate.values()) {
      const raw = String(note || '').trim();
      if (!raw) continue;
      const normalized = raw.replace(/^CPNFS?:\s*/i, '');
      const parts = normalized.split(/(?:\.{3}|…|,|;|\n)+/g);
      for (const item of parts) {
        const instrument = normalizeCpInstrumentNumber(item);
        if (instrument) instruments.add(instrument);
      }
    }
    return [...instruments].sort();
  }

  function normalizeCpInstrumentNumber(value) {
    return String(value || '')
      .trim()
      .replace(/\s+/g, ' ')
      .toUpperCase();
  }

  function addProjectFileResource(projectFile, resource) {
    const folder = ensureProjectFileFolder(projectFile, resource.folder);
    if (!folder) return;
    const referenceType = String(resource?.reference?.type ?? '').trim();
    const referenceValue = referenceType === 'instrument-number'
      ? normalizeCpInstrumentNumber(resource?.reference?.value)
      : String(resource?.reference?.value ?? '');
    if (!referenceType || !referenceValue) return;

    const exists = folder.index.some((item) => (
      String(item?.reference?.type ?? '').trim() === referenceType
      && (
        referenceType === 'instrument-number'
          ? normalizeCpInstrumentNumber(item?.reference?.value) === referenceValue
          : String(item?.reference?.value ?? '') === referenceValue
      )
    ));
    if (!exists) {
      folder.index.push({
        ...resource,
        reference: {
          ...(resource.reference || {}),
          type: referenceType,
          value: referenceValue,
        },
      });
    }
  }

  function resolveProjectContextForProjectFile(projectContext = {}) {
    if (projectContext?.projectId) return projectContext;
    const runtimeContext = getProjectContext();
    if (runtimeContext?.projectId) {
      return {
        ...projectContext,
        ...runtimeContext,
      };
    }
    return projectContext;
  }

  async function persistPointForgeExportProjectFile({ projectContext = {}, notesByCoordinate, csv, pointCount }) {
    const resolvedProjectContext = resolveProjectContextForProjectFile(projectContext);
    if (!resolvedProjectContext.projectId) return null;

    const projectFile = loadProjectFileSnapshot(resolvedProjectContext) || defaultProjectFile(resolvedProjectContext);
    const exportTimestamp = new Date().toISOString();
    const cpfInstruments = parseCpfInstrumentsFromNotesMap(notesByCoordinate);

    for (const instrument of cpfInstruments) {
      addProjectFileResource(projectFile, {
        id: `cpf-${slugify(instrument, 'instrument')}`,
        folder: 'cpfs',
        title: `CP&F ${instrument}`,
        exportFormat: 'pdf',
        reference: {
          type: 'instrument-number',
          value: instrument,
          resolverHint: 'lookup-cpf-pdf',
          metadata: { instrument },
        },
      });
    }

    addProjectFileResource(projectFile, {
      id: `pointforge-export-${Date.now()}`,
      folder: 'point-files',
      title: `PointForge export ${exportTimestamp}`,
      exportFormat: 'csv',
      reference: {
        type: 'local-storage',
        value: POINTFORGE_ROS_IMPORT_STORAGE_KEY,
        resolverHint: 'local-pointforge-export',
        metadata: {
          source: 'RecordQuarry',
          exportedAt: exportTimestamp,
          pointCount: Number(pointCount) || 0,
          csvLength: String(csv || '').length,
        },
      },
    });

    projectFile.generatedAt = exportTimestamp;
    saveProjectFileSnapshot(resolvedProjectContext, projectFile);

    // Persist CP&F records server-side so EvidenceDesk can display them.
    if (cpfInstruments.length && resolvedProjectContext.projectId) {
      try {
        const cpfsPayload = cpfInstruments.map((instrument) => ({
          instrument,
          title: `CP&F ${instrument}`,
          source: 'RecordQuarry',
        }));
        await fetch(`/api/projects/${encodeURIComponent(resolvedProjectContext.projectId)}/cpfs`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ cpfs: cpfsPayload }),
        });
      } catch {
        // Non-fatal: server sync is best-effort; local snapshot was already saved.
      }
    }

    return { projectFile, cpfCount: cpfInstruments.length };
  }

  // -----------------------------
  // JSONP for ArcGIS (no CORS)
  // -----------------------------
  function toQuery(params) {
    const parts = [];
    for (const [k,v] of Object.entries(params)) {
      if (v === undefined || v === null) continue;
      const value = typeof v === 'object' ? JSON.stringify(v) : String(v);
      parts.push(encodeURIComponent(k) + "=" + encodeURIComponent(value));
    }
    return parts.join("&");
  }

  function arcJsonp(url, params, timeoutMs=20000) {
    return new Promise((resolve, reject) => {
      const cb = "__arc_cb_" + Math.random().toString(36).slice(2);
      const script = document.createElement("script");
      const timer = setTimeout(() => {
        cleanup();
        reject(new Error("JSONP timeout"));
      }, timeoutMs);

      function cleanup() {
        clearTimeout(timer);
        try { delete window[cb]; } catch {}
        if (script.parentNode) script.parentNode.removeChild(script);
      }

      window[cb] = (data) => {
        cleanup();
        resolve(data);
      };

      const fullParams = Object.assign({}, params, { f: "json", callback: cb });
      script.src = url + (url.includes("?") ? "&" : "?") + toQuery(fullParams);
      script.onerror = () => {
        cleanup();
        reject(new Error("JSONP script load failed"));
      };
      document.head.appendChild(script);
    });
  }

  async function arcQuery(layerId, params) {
    const url = `${BASE}/${layerId}/query`;
    const data = await arcJsonp(url, params);
    if (data && data.error) {
      const msg = data.error.message || "ArcGIS error";
      throw new Error(`${msg}${data.error.details ? " :: " + data.error.details.join(" | ") : ""}`);
    }
    return data;
  }

  // -----------------------------
  // CP&F corner record lookup helpers
  // -----------------------------
  let cpfLayerInfo = null;
  let cpfLayerInfoPromise = null;

  function pickField(attrs, layerMeta, regexList) {
    const keys = Object.keys(attrs || {});
    const fields = layerMeta?.fields || [];
    for (const re of regexList) {
      const k = keys.find((key) => re.test(key));
      if (k) return k;
      const f = fields.find((field) => re.test(field?.name || '') || re.test(field?.alias || ''));
      if (f?.name) return f.name;
    }
    return null;
  }

  function buildCpfPdfLinks(instrument, pdfUrl, pdfName) {
    const links = [];
    const rawUrl = String(pdfUrl || '').trim();
    if (rawUrl) {
      links.push(rawUrl);
    }
    const name = String(pdfName || '').trim();
    const inst = String(instrument || '').trim();
    if (name && /\.pdf$/i.test(name)) {
      links.push(`${ADA_CPF_PDF_BASE}${encodeURIComponent(name)}`);
    } else if (inst) {
      links.push(`${ADA_CPF_PDF_BASE}${encodeURIComponent(inst)}.pdf`);
    }
    return [...new Set(links)];
  }

  async function discoverAdaCpfLayerViaJsonp() {
    const itemDataUrl = `${ADA_PORTAL_BASE}/sharing/rest/content/items/${ADA_CPF_WEBMAP_ITEM_ID}/data`;
    const webmap = await arcJsonp(itemDataUrl, { f: 'pjson' }, 25000);

    const candidates = [];
    function walk(entries) {
      if (!Array.isArray(entries)) return;
      for (const entry of entries) {
        if (entry?.url) candidates.push(entry.url);
        if (entry?.layers) walk(entry.layers);
      }
    }
    walk(webmap?.operationalLayers);
    if (!candidates.length) throw new Error('CP&F web map has no operational layer URLs.');

    async function readMeta(url) {
      return arcJsonp(String(url).replace(/\?+.*$/, ''), { f: 'pjson' }, 25000);
    }
    function hasInstrumentField(fields = []) {
      return fields.some((f) => /instr|instrument/i.test(f.name || '') || /instr|instrument/i.test(f.alias || ''));
    }

    for (const baseUrlRaw of candidates) {
      const baseUrl = String(baseUrlRaw).replace(/\/+$/, '');
      const meta = await readMeta(baseUrl).catch(() => null);
      if (!meta) continue;

      if (Array.isArray(meta.layers) && meta.layers.length) {
        for (const layer of meta.layers) {
          const layerUrl = `${baseUrl}/${layer.id}`;
          const layerMeta = await readMeta(layerUrl).catch(() => null);
          if (!layerMeta) continue;
          if (/esriGeometryPoint/i.test(layerMeta.geometryType || '') && hasInstrumentField(layerMeta.fields || [])) {
            return { layerUrl, layerMeta };
          }
        }
      }

      if (/esriGeometryPoint/i.test(meta.geometryType || '') && hasInstrumentField(meta.fields || [])) {
        return { layerUrl: baseUrl, layerMeta: meta };
      }
    }

    throw new Error('Could not identify CP&F point layer with instrument fields.');
  }

  async function ensureCpfLayerInfo() {
    if (cpfLayerInfo) return cpfLayerInfo;
    if (!cpfLayerInfoPromise) {
      cpfLayerInfoPromise = discoverAdaCpfLayerViaJsonp()
        .then((info) => {
          cpfLayerInfo = info;
          return info;
        })
        .finally(() => { cpfLayerInfoPromise = null; });
    }
    return cpfLayerInfoPromise;
  }

  function haversineMeters(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2-lat1);
    const dLon = toRad(lon2-lon1);
    const a =
      Math.sin(dLat/2)**2 +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.min(1, Math.sqrt(a)));
  }

  function pointInRing(pointXY, ring) {
    let inside = false;
    const [x, y] = pointXY;
    for (let i=0, j=ring.length-1; i<ring.length; j=i++) {
      const xi = ring[i][0], yi = ring[i][1];
      const xj = ring[j][0], yj = ring[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-30) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function pointInPolygon(pointXY, geom) {
    const rings = geom?.rings || [];
    if (!rings.length) return false;
    if (!pointInRing(pointXY, rings[0])) return false;
    for (let i=1; i<rings.length; i++) {
      if (pointInRing(pointXY, rings[i])) return false;
    }
    return true;
  }

  function centroidOfPolygon(geom) {
    const rings = geom?.rings || [];
    if (!rings.length || !rings[0].length) return null;
    const pts = rings[0];
    let area = 0, cx = 0, cy = 0;
    for (let i=0, j=pts.length-1; i<pts.length; j=i++) {
      const [x0, y0] = pts[j];
      const [x1, y1] = pts[i];
      const a = x0*y1 - x1*y0;
      area += a;
      cx += (x0 + x1) * a;
      cy += (y0 + y1) * a;
    }
    if (Math.abs(area) < 1e-12) {
      // fallback: average
      let sx = 0, sy = 0;
      for (const [x,y] of pts) { sx += x; sy += y; }
      return { x: sx/pts.length, y: sy/pts.length };
    }
    area *= 0.5;
    cx /= (6*area);
    cy /= (6*area);
    return { x: cx, y: cy };
  }

  async function queryCpfRecordsNearCorner(north, east, maxMeters = 250, inSR = 4326) {
    const { layerUrl, layerMeta } = await ensureCpfLayerInfo();
    const radii = [5, 10, 25, 50, 100, 150, maxMeters];

    for (const radius of radii) {
      const payload = await arcJsonp(`${layerUrl.replace(/\/+$/, '')}/query`, {
        f: 'pjson',
        where: '1=1',
        geometry: { x: east, y: north, spatialReference: { wkid: inSR } },
        geometryType: 'esriGeometryPoint',
        inSR,
        spatialRel: 'esriSpatialRelIntersects',
        distance: radius,
        units: 'esriSRUnit_Meter',
        outFields: '*',
        returnGeometry: true,
        outSR: 4326,
      }, 25000).catch(() => null);

      const features = payload?.features || [];
      if (!features.length) continue;

      const instrumentKey = pickField(features[0]?.attributes || {}, layerMeta, [/^instrument$/i, /instr/i, /instrument_?no/i, /inst_?no/i]);
      const pdfUrlKey = pickField(features[0]?.attributes || {}, layerMeta, [/pdf/i, /doc/i, /document/i, /hyperlink/i, /url/i, /link/i]);
      const pdfNameKey = pickField(features[0]?.attributes || {}, layerMeta, [/file/i, /filename/i, /pdfname/i]);
      const monsetKey = pickField(features[0]?.attributes || {}, layerMeta, [/^monset$/i, /monument.*set/i]);
      const surveyorKey = pickField(features[0]?.attributes || {}, layerMeta, [/^surveyor$/i]);
      const townshipKey = pickField(features[0]?.attributes || {}, layerMeta, [/^township$/i]);
      const rangeKey = pickField(features[0]?.attributes || {}, layerMeta, [/^range$/i]);
      const sectionKey = pickField(features[0]?.attributes || {}, layerMeta, [/^section$/i]);
      const indexNumberKey = pickField(features[0]?.attributes || {}, layerMeta, [/^index_?number$/i, /^index$/i]);

      const records = features.map((feature) => {
        const x = Number(feature?.geometry?.x);
        const y = Number(feature?.geometry?.y);
        const distanceMeters = inSR === 4326 && Number.isFinite(x) && Number.isFinite(y)
          ? haversineMeters(north, east, y, x)
          : null;
        const attrs = feature.attributes || {};
        const instrument = instrumentKey ? attrs[instrumentKey] : null;
        const pdfUrl = pdfUrlKey ? attrs[pdfUrlKey] : null;
        const pdfName = pdfNameKey ?
          attrs[pdfNameKey] : null;
        const monset = monsetKey ? attrs[monsetKey] : null;
        const surveyor = surveyorKey ? attrs[surveyorKey] : null;
        const township = townshipKey ? attrs[townshipKey] : null;
        const range = rangeKey ? attrs[rangeKey] : null;
        const section = sectionKey ?
          attrs[sectionKey] : null;
        const indexNumber = indexNumberKey ? attrs[indexNumberKey] : null;
        return {
          distanceMeters,
          instrument,
          pdfUrl,
          pdfName,
          monset,
          surveyor,
          township,
          range,
          section,
          indexNumber,
          links: buildCpfPdfLinks(instrument, pdfUrl, pdfName),
        };
      }).filter((record) => record.links.length && (record.distanceMeters == null || record.distanceMeters <= (radius + 0.5)));

      if (records.length) return records;
    }

    return [];
  }

  function extractInstrumentFromCpfIdentifier(rawValue) {
    const raw = String(rawValue || '').trim();
    if (!raw) return '';
    const withoutQuery = raw.split(/[?#]/, 1)[0];
    const decoded = (() => {
      try {
        return decodeURIComponent(withoutQuery);
      } catch {
        return withoutQuery;
      }
    })();
    const baseName = decoded.split('/').pop() || decoded;
    const withoutExtension = baseName.replace(/\.pdf$/i, '');
    return normalizeCpInstrumentNumber(withoutExtension);
  }

  function resolveCpfRecordInstrument(record = {}) {
    const direct = normalizeCpInstrumentNumber(record?.instrument);
    if (direct) return direct;

    const fromName = extractInstrumentFromCpfIdentifier(record?.pdfName);
    if (fromName) return fromName;

    const fromUrl = extractInstrumentFromCpfIdentifier(record?.pdfUrl);
    if (fromUrl) return fromUrl;

    for (const link of (record?.links || [])) {
      const fromLink = extractInstrumentFromCpfIdentifier(link);
      if (fromLink) return fromLink;
    }
    return '';
  }

  function cpfLinksHtml(records = []) {
    if (!records.length) return '<span class="small">No CP&amp;F PDF links found near this corner.</span>';
    return records.slice(0, 8).map((record, idx) => {
      const resolvedInstrument = resolveCpfRecordInstrument(record);
      const instrument = resolvedInstrument
        ? escapeHtml(resolvedInstrument)
        : `Record ${idx + 1}`;
      const links = record.links.map((url, i) => (
        `<a target="_blank" rel="noopener" href="${escapeHtml(buildRosPdfProxyUrl(url))}">CP&amp;F PDF${record.links.length > 1 ? ` ${i + 1}` : ''}</a>`
      )).join('<br/>');
      const monsetHtml = record.monset != null && String(record.monset).trim()
        ? `<div style="margin-top:2px;color:var(--muted)">Monument Set: <span style="color:var(--text)">${escapeHtml(String(record.monset).trim())}</span></div>`
        : '';
      const surveyorHtml = record.surveyor != null && String(record.surveyor).trim()
        ? `<div style="color:var(--muted)">Surveyor: <span style="color:var(--text)">${escapeHtml(String(record.surveyor).trim())}</span></div>`
        : '';
      return `<div style="margin:6px 0"><b>${instrument}</b>${monsetHtml}${surveyorHtml}<div style="margin-top:2px">${links}</div></div>`;
    }).join('');
  }

  function slugify(value, fallback = 'item') {
    const raw = String(value || '').trim().toLowerCase();
    if (!raw) return fallback;
    return raw
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '') || fallback;
  }

  // -----------------------------
  // Results state
  // -----------------------------
  const initialProjectContext = getProjectContext();
  if (!normalizeAddressStorageKey(initialProjectContext.address) && initialProjectContext.projectId) {
    const launchAddress = String(loadLaunchProject(initialProjectContext.projectId)?.address || '').trim();
    if (launchAddress) {
      initialProjectContext.address = launchAddress;
    }
  }

  const state = {
    addressFeature: null,
    parcelFeature: null,        // displayed (outSR 4326)
    parcelFeature2243: null,    // export geometry (outSR 2243)
    subdivisionFeature2243: null,
    subdivisionFeature: null,
    sectionFeature: null,
    sectionFeature2243: null,
    aliquotFeatures2243: [],
    townshipFeature: null,
    rosFeatures: [],
    aliquotFeatures: [],
    selectedParcel: true,
    selectedAliquot: null,
    selectedAliquotKeys: new Set(),
    lastLookupPayload: null,
    lastLookupAddress: '',
    exportGeoJSON: null,
    lastLonLat: null,
    utilityLocations: [],
    projectContext: initialProjectContext
  };

  function setSummaryCards(cards) {
    const root = $("summary");
    root.innerHTML = "";
    if (!cards.length) {
      root.innerHTML = `<div class="small">No results yet.</div>`;
      return;
    }
    for (const c of cards) root.appendChild(c);
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replace(/&/g,"&amp;").replace(/</g,"&lt;")
      .replace(/>/g,"&gt;").replace(/"/g,"&quot;")
      .replace(/'/g,"&#039;");
  }

  function card(title, subtitle, kvPairs, links=[], options={}) {
    const el = document.createElement("div");
    el.className = "card";
    if (typeof options.onSelect === 'function') {
      el.classList.add('clickable');
      el.tabIndex = 0;
      el.addEventListener('click', options.onSelect);
      el.addEventListener('keydown', (evt) => {
        if (evt.key === 'Enter' || evt.key === ' ') {
          evt.preventDefault();
          options.onSelect();
        }
      });
    }
    const head = document.createElement("div");
    head.className = "chead";
    head.innerHTML = `
      <div>
        <div style="font-weight:800">${escapeHtml(title)}</div>
        <div class="small">${escapeHtml(subtitle || "")}</div>
      </div>
    `;
    const body = document.createElement("div");
    body.className = "cbody";

    const kv = document.createElement("div");
    kv.className = "kv";
    for (const [k,v] of kvPairs) {
      const kdiv = document.createElement("div");
      kdiv.textContent = k;
      const vdiv = document.createElement("div");
      vdiv.innerHTML = v;
      kv.appendChild(kdiv);
      kv.appendChild(vdiv);
    }
    body.appendChild(kv);

    if (links.length) {
      const hr = document.createElement("div");
      hr.className = "hr";
      body.appendChild(hr);
      const ldiv = document.createElement("div");
      ldiv.className = "small";
      ldiv.innerHTML = links.map(h => `• ${h}`).join("<br/>");
      body.appendChild(ldiv);
    }

    el.appendChild(head);
    el.appendChild(body);
    if (typeof options.onRender === 'function') {
      options.onRender(el);
    }
    return el;
  }

  // -----------------------------
  // Map setup
  // -----------------------------
  const map = L.map("map", { zoomControl: true });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 20,
    attribution: "&copy; OpenStreetMap contributors"
  }).addTo(map);
  map.setView([43.615, -116.202], 12);

  map.createPane('contextPolygons');
  map.getPane('contextPolygons').style.zIndex = '320';
  map.createPane('aliquotPolygons');
  map.getPane('aliquotPolygons').style.zIndex = '380';
  map.createPane('selectablePolygons');
  map.getPane('selectablePolygons').style.zIndex = '430';

  const layers = {
    address: L.layerGroup().addTo(map),
    parcel: L.layerGroup().addTo(map),
    subdivision: L.layerGroup().addTo(map),
    section: L.layerGroup().addTo(map),
    township: L.layerGroup().addTo(map),
    ros: L.layerGroup().addTo(map),
    utilities: L.layerGroup().addTo(map),
    aliquots: L.layerGroup().addTo(map),
    cornerMarkers: L.layerGroup().addTo(map),
  };

  function clearMapLayers() {
    Object.values(layers).forEach(g => g.clearLayers());
  }

  // ---- Leaflet display fix helpers ----
  function invalidateMapSoon(reason="") {
    requestAnimationFrame(() => map.invalidateSize());
    setTimeout(() => map.invalidateSize(), 50);
    setTimeout(() => map.invalidateSize(), 250);
    if (reason) log(`map.invalidateSize() (${reason})`);
  }
  window.addEventListener("load", () => invalidateMapSoon("window load"));
  window.addEventListener("resize", () => invalidateMapSoon("window resize"));
  try {
    const ro = new ResizeObserver(() => map.invalidateSize());
    ro.observe($("map"));
    ro.observe(document.querySelector(".mapWrap"));
  } catch {}

  // -----------------------------
  // Address parsing
  // -----------------------------
  const DIRS = new Set(["N","S","E","W","NE","NW","SE","SW"]);
  const SUFFIXES = new Set(["ST","AVE","AV","DR","RD","LN","CT","PL","WAY","BLVD","CIR","PKWY","TRL","TER","HWY"]);
  function normalizeSpaces(s){ return (s||"").trim().replace(/\s+/g," "); }

  function parseAddress(raw) {
    raw = normalizeSpaces(raw);
    const parts = raw.split(",").map(s => s.trim()).filter(Boolean);
    const streetPart = parts[0] || "";
    const cityPart = parts[1] || "";

    const toks = streetPart.toUpperCase().split(/\s+/).filter(Boolean);
    const out = { AddNum: null, StPreDir: null, StName: null, StSuffix: null, City: null };

    if (toks.length && /^\d+$/.test(toks[0])) {
      out.AddNum = parseInt(toks[0], 10);
      toks.shift();
    }
    if (toks.length && DIRS.has(toks[0])) {
      out.StPreDir = toks.shift();
    }
    let suffix = null;
    if (toks.length && SUFFIXES.has(toks[toks.length-1])) {
      suffix = toks.pop();
    }
    out.StSuffix = suffix;
    out.StName = toks.length ? toks.join(" ") : null;

    if (cityPart) out.City = cityPart.toUpperCase().split(/\s+/)[0];
    return out;
  }

  // -----------------------------
  // ArcGIS helpers
  // -----------------------------
  function arcPointToLatLng(geom) {
    if (!geom) return null;
    if (geom.x == null || geom.y == null) return null;
    return [geom.y, geom.x];
  }

  function arcPolygonToGeoJSON(geom) {
    const rings = geom?.rings;
    if (!rings || !rings.length) return null;
    return {
      type: "Feature",
      properties: {},
      geometry: { type:"Polygon", coordinates: rings.map(r => r.map(([x,y]) => [x,y])) }
    };
  }

  function arcExtentFromPolygon(geom) {
    const rings = geom?.rings || [];
    if (!rings.length || !rings[0].length) return null;
    let xmin=Infinity,ymin=Infinity,xmax=-Infinity,ymax=-Infinity;
    for (const ring of rings) {
      for (const [x,y] of ring) {
        xmin = Math.min(xmin,x);
        ymin = Math.min(ymin,y);
        xmax = Math.max(xmax,x);
        ymax = Math.max(ymax,y);
      }
    }
    if (!isFinite(xmin) || !isFinite(ymin) || !isFinite(xmax) || !isFinite(ymax)) return null;
    return { xmin,ymin,xmax,ymax };
  }

  async function findContainingPolygon(layerId, lon, lat, searchMeters=2500, outSR=4326) {
    const resp = await arcQuery(layerId, {
      where: "1=1",
      outFields: "*",
      returnGeometry: true,
      outSR,
      geometry: `${lon},${lat}`,
      geometryType: "esriGeometryPoint",
      inSR: 4326,
      spatialRel: "esriSpatialRelIntersects",
      distance: searchMeters,
      units: "esriSRUnit_Meter"
    });
    const feats = resp?.features || [];
    if (!feats.length) return null;

    // Prefer true containment if possible.
    const pointXY = [lon, lat];
    const containing = feats.find(f => pointInPolygon(pointXY, f.geometry));
    if (containing) return containing;

    let nearest = null;
    let bestDist = Infinity;
    for (const f of feats) {
      const c = centroidOfPolygon(f.geometry);
      if (!c) continue;
      const meters = haversineMeters(lat, lon, c.y, c.x);
      if (meters < bestDist) { bestDist = meters; nearest = f; }
    }
    return nearest || feats[0];
  }

  async function findParcelNearPoint(lon, lat, outSR=4326, searchMeters=150) {
    const resp = await arcQuery(LAYERS.parcels, {
      where: "1=1",
      outFields: "*",
      returnGeometry: true,
      outSR,
      geometry: `${lon},${lat}`,
      geometryType: "esriGeometryPoint",
      inSR: 4326,
      spatialRel: "esriSpatialRelIntersects",
      distance: searchMeters,
      units: "esriSRUnit_Meter",
      resultRecordCount: 1
    });
    return resp?.features?.[0] || null;
  }

  async function findSubdivisionNearPoint(lon, lat, outSR=4326, searchMeters=2500) {
    return findContainingPolygon(LAYERS.subdivisions, lon, lat, searchMeters, outSR);
  }

  async function findSectionNearPoint(lon, lat, outSR=4326, searchMeters=2500) {
    return findContainingPolygon(LAYERS.sections, lon, lat, searchMeters, outSR);
  }

  async function findTownshipNearPoint(lon, lat, outSR=4326, searchMeters=2500) {
    return findContainingPolygon(LAYERS.townships, lon, lat, searchMeters, outSR);
  }

  async function findRosNearPoint(lon, lat, searchMeters=1600) {
    const resp = await arcQuery(LAYERS.ros, {
      where: "1=1",
      outFields: "*",
      returnGeometry: true,
      outSR: 4326,
      geometry: `${lon},${lat}`,
      geometryType: "esriGeometryPoint",
      inSR: 4326,
      spatialRel: "esriSpatialRelIntersects",
      distance: searchMeters,
      units: "esriSRUnit_Meter"
    });
    return resp?.features || [];
  }

  // -----------------------------
  // Draw
  // -----------------------------
  function formatAddressAttrs(a) {
    const parts = [];
    if (a.AddNum) parts.push(a.AddNum);
    if (a.StPreDir) parts.push(a.StPreDir);
    if (a.StName) parts.push(a.StName);
    if (a.StSuffix) parts.push(a.StSuffix);
    const line1 = parts.join(" ");
    const line2 = [a.CommName, a.State, a.Zip4].filter(Boolean).join(" ");
    return [line1, line2].filter(Boolean).join(", ");
  }

  function drawAddressPoint(f) {
    const ll = arcPointToLatLng(f.geometry);
    if (!ll) return null;
    const m = L.circleMarker(ll, { radius: 7, weight: 2, color: "#ffffff", fillColor: "#2a3dff", fillOpacity: 0.9 });
    m.bindPopup(`<b>Address</b><br/>${escapeHtml(formatAddressAttrs(f.attributes || {}))}`);
    layers.address.addLayer(m);
    return m;
  }

  function drawUtilityLocations(utilities = []) {
    layers.utilities.clearLayers();
    for (const utility of (utilities || [])) {
      const lon = Number(utility?.location?.lon);
      const lat = Number(utility?.location?.lat);
      if (!Number.isFinite(lon) || !Number.isFinite(lat)) continue;
      const label = utility?.code || utility?.name || utility?.provider || 'Utility';
      const marker = L.circleMarker([lat, lon], { radius: 6, weight: 2, color: '#ffffff', fillColor: '#ffcc66', fillOpacity: 0.9 });
      marker.bindPopup(`<b>Utility</b><br/>${escapeHtml(label)}<br/><span class="small">${escapeHtml(utility?.provider || 'Idaho Power')}</span>`);
      layers.utilities.addLayer(marker);
    }
  }

  function drawPolygonFeature(f, group, geojsonOptions, label) {
    const gj = arcPolygonToGeoJSON(f.geometry);
    const options = geojsonOptions || {};
    if (!options.pane) options.pane = 'contextPolygons';
    const layer = L.geoJSON(gj, options);
    layer.bindPopup(`<b>${escapeHtml(label)}</b>`);
    group.addLayer(layer);
    return layer;
  }

  function setParcelSelected(isSelected) {
    state.selectedParcel = Boolean(isSelected);
  }

  function isAliquotSelected(feature, index) {
    const key = buildAliquotSelectionKey(feature, index);
    return state.selectedAliquotKeys.has(key);
  }

  function setAliquotSelected(feature, index, isSelected) {
    const key = buildAliquotSelectionKey(feature, index);
    if (isSelected) state.selectedAliquotKeys.add(key);
    else state.selectedAliquotKeys.delete(key);
  }

  function drawParcel() {
    layers.parcel.clearLayers();
    const parcel = state.parcelFeature;
    if (!parcel?.geometry) return;
    const gj = arcPolygonToGeoJSON(parcel.geometry);
    const layer = L.geoJSON(gj, {
      pane: 'contextPolygons',
      style: () => ({
        color: state.selectedParcel ? "#24d18f" : "#4b5f8a",
        weight: state.selectedParcel ? 2 : 1.5,
        fillOpacity: state.selectedParcel ? 0.12 : 0.03,
        dashArray: state.selectedParcel ? null : '4 4',
      }),
    });
    const a = parcel.attributes || {};
    layer.bindPopup(`<b>Parcel</b><br/>${escapeHtml(a.PARCELNO || a.PARCEL || a.PIN || '')}`);
    layer.eachLayer((l) => {
      l.on('click', () => {
        const next = !state.selectedParcel;
        setParcelSelected(next);
        drawParcel();
        drawCornerMarkers(buildCornerMarkerEntries());
        log(`${next ? 'Included' : 'Excluded'} parcel in export via parcel click.`);
      });
    });
    layers.parcel.addLayer(layer);
  }

  function normalizedAliquotLabel(feature, sectionFeature) {
    const attrs = feature?.attributes || {};
    if (attrs.ALIQUOT) return String(attrs.ALIQUOT).toUpperCase();

    const ring = feature?.geometry?.rings?.[0] || [];
    const secRing = sectionFeature?.geometry?.rings?.[0] || [];
    if (!ring.length || !secRing.length) return 'ALIQUOT';

    const center = centroidOfPolygon(feature.geometry);
    if (!center) return 'ALIQUOT';

    let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
    for (const [x, y] of secRing) {
      xmin = Math.min(xmin, x);
      ymin = Math.min(ymin, y);
      xmax = Math.max(xmax, x);
      ymax = Math.max(ymax, y);
    }
    if (!isFinite(xmin) || !isFinite(ymin) || !isFinite(xmax) || !isFinite(ymax)) return 'ALIQUOT';

    const nx = (center.x - xmin) / Math.max(1e-9, xmax - xmin);
    const ny = (center.y - ymin) / Math.max(1e-9, ymax - ymin);

    const h = nx >= 0.5 ? 'E' : 'W';
    const v = ny >= 0.5 ? 'N' : 'S';
    return `${v}${h}`;
  }

  function buildAllSelectedAliquotKeys(aliquotFeatures) {
    return new Set((aliquotFeatures || []).map((feature, index) => buildAliquotSelectionKey(feature, index)));
  }

  // Parse Township, Range, Section, and Index from BLM aliquot attributes.
  // PLSSID format: {ST(2)}{PM(2)}{TWP(3)}{zone(1)}{TWPDIR(1)}{RNG(3)}{zone(1)}{RNGDIR(1)}{extra}
  // e.g. "ID080030N0020E0" → T3N R2E
  // FRSTDIVID appends "SN{sec*10}" e.g. "SN150" → Section 15
  // SECDIVNO / SECDIVLAB is the Index e.g. "SWNE"
  function parsePlssFromAliquot(feature) {
    const attrs = feature?.attributes || {};
    const plssid = String(attrs.PLSSID || '');
    const frstdivid = String(attrs.FRSTDIVID || '');
    const index = String(attrs.SECDIVNO || attrs.SECDIVLAB || '').trim();

    let township = '', range = '';
    const plssMatch = plssid.match(/^[A-Z]{2}\d{2}(\d{3})\d([NS])(\d{3})\d([EW])/);
    if (plssMatch) {
      const twpNum = parseInt(plssMatch[1], 10);
      if (twpNum) township = `T${twpNum}${plssMatch[2]}`;
      const rngNum = parseInt(plssMatch[3], 10);
      if (rngNum) range = `R${rngNum}${plssMatch[4]}`;
    }

    let section = '';
    const suffix = plssid ? frstdivid.slice(plssid.length) : '';
    const secMatch = suffix.match(/^SN(\d+)/);
    if (secMatch) {
      const secNum = Math.round(parseInt(secMatch[1], 10) / 10);
      if (secNum >= 1 && secNum <= 36) section = String(secNum);
    }

    return {
      township,
      range,
      section,
      index,
    };
  }

  function drawAliquots(aliquotFeatures = [], sectionFeature) {
    layers.aliquots.clearLayers();
    for (const [index, feature] of (aliquotFeatures || []).entries()) {
      if (!feature?.geometry) continue;
      const selectionKey = buildAliquotSelectionKey(feature, index);
      const selected = state.selectedAliquotKeys.has(selectionKey);
      const gj = arcPolygonToGeoJSON(feature.geometry);
      const label = normalizedAliquotLabel(feature, sectionFeature);
      const popupHtml = `<b>Aliquot</b><br/>${escapeHtml(label)}<br/><span class="small">${escapeHtml(selectionKey)}</span>`;
      const layer = L.geoJSON(gj, {
        pane: 'aliquotPolygons',
        style: () => ({
          color: selected ? '#6aa9ff' : '#4b5f8a',
          weight: selected ? 1.8 : 1.3,
          fillOpacity: selected ? 0.14 : 0.03,
          dashArray: selected ? null : '4 4',
        }),
      });
      layer.eachLayer((l) => {
        l.bindPopup(popupHtml);
        l.on('click', () => {
          state.selectedAliquot = feature;
          const nextSelected = !isAliquotSelected(feature, index);
          setAliquotSelected(feature, index, nextSelected);
          drawAliquots(state.aliquotFeatures, sectionFeature);
          drawCornerMarkers(buildCornerMarkerEntries());
          log(`${nextSelected ? 'Included' : 'Excluded'} aliquot in export: ${label}`);
        });
      });
      layers.aliquots.addLayer(layer);
    }
  }

  function getPolygonCornerMarkers(feature, role, options = {}) {
    const rings = feature?.geometry?.rings || [];
    const points = [];
    for (let ringIndex = 0; ringIndex < rings.length; ringIndex++) {
      const ring = rings[ringIndex] || [];
      const trimmed = ring.length > 1 && ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]
        ? ring.slice(0, -1)
        : ring;
      for (let vertexIndex = 0; vertexIndex < trimmed.length; vertexIndex++) {
        const vertex = trimmed[vertexIndex];
        const x = Number(vertex[0]);
        const y = Number(vertex[1]);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        points.push({
          east: x,
          north: y,
          label: `${role.toUpperCase()}_CORNER R${ringIndex + 1} V${vertexIndex + 1}`,
          color: options.color || '#ffffff',
        });
      }
    }
    return points;
  }

  function buildCornerMarkerEntries() {
    return [
      { role: 'aliquot', features: state.aliquotFeatures || [], color: '#6aa9ff' },
      { role: 'subdivision', features: state.subdivisionFeature ? [state.subdivisionFeature] : [], color: '#9ab0ff' },
      { role: 'parcel', features: state.parcelFeature ? [state.parcelFeature] : [], color: '#24d18f' },
    ];
  }

  function drawCornerMarkers(featuresByRole = []) {
    layers.cornerMarkers.clearLayers();
    for (const entry of featuresByRole) {
      const role = entry.role;
      const featureList = entry.features || [];
      for (const [featureIndex, feature] of featureList.entries()) {
        const corners = getPolygonCornerMarkers(feature, role, entry);
        const aliquotSelected = role === 'aliquot' ? isAliquotSelected(feature, featureIndex) : null;
        const roleSelected = role === 'aliquot' ? aliquotSelected : role === 'parcel' ? state.selectedParcel : true;
        for (const corner of corners) {
          const marker = L.circleMarker([corner.north, corner.east], {
            radius: roleSelected ? 5 : 3,
            weight: roleSelected ? 2 : 1,
            color: roleSelected ? '#ffcc66' : '#101834',
            fillColor: corner.color,
            fillOpacity: roleSelected ? 0.9 : 0.6,
          });
          marker.bindPopup(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px">Click for CP&amp;F records…</div>`);
          marker.on('click', async () => {
            if (role === 'aliquot') {
              state.selectedAliquot = feature;
              const nextSelected = !isAliquotSelected(feature, featureIndex);
              setAliquotSelected(feature, featureIndex, nextSelected);
              drawAliquots(state.aliquotFeatures, state.sectionFeature);
              log(`${nextSelected ? 'Included' : 'Excluded'} aliquot in export via corner: ${normalizedAliquotLabel(feature, state.sectionFeature)}`);
            } else if (role === 'parcel') {
              const nextSelected = !state.selectedParcel;
              setParcelSelected(nextSelected);
              drawParcel();
              log(`${nextSelected ? 'Included' : 'Excluded'} parcel in export via corner selection.`);
            }
            drawCornerMarkers(featuresByRole);
            marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px">Loading CP&amp;F records…</div>`);
            try {
              const cpfRecords = await queryCpfRecordsNearCorner(corner.north, corner.east);
              marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="hr"></div>${cpfLinksHtml(cpfRecords)}`);
              if (cpfRecords.length) log(`Loaded CP&F PDF links for ${role} corner ${corner.label}.`);
              else log(`No CP&F PDF links found for ${role} corner ${corner.label}.`, 'warn');
            } catch (e) {
              marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px;color:#ffb3b3">CP&amp;F lookup failed: ${escapeHtml(e.message || e)}</div>`);
              log(`CP&F corner lookup failed: ${e.message || e}`, 'warn');
            }
          });
          layers.cornerMarkers.addLayer(marker);
        }
      }
    }
  }

  function bestRosLabel(a) {
    const fields = ["RS","ROS","Survey","SurveyNo","SURVEYNO","Book","BOOK","Page","PAGE","Document","DOC","Description","DESC","Name","NAME"];
    const parts = [];
    for (const f of fields) if (a[f]) parts.push(`${f}:${a[f]}`);
    if (parts.length) return parts.slice(0,3).join("  ");
    for (const [k,v] of Object.entries(a||{})) {
      if (typeof v === "string" && v.trim()) return v.trim();
    }
    return "ROS feature";
  }

  function normalizeRosFeatures(rosItems = []) {
    return rosItems
      .map((item) => (item?.feature?.geometry ? item.feature : item))
      .filter((f) => f?.geometry);
  }

  function rosIntersectsSection(rosFeature, sectionFeature) {
    if (!sectionFeature?.geometry) return true;
    const g = rosFeature?.geometry;
    if (!g) return false;
    if (g.x != null && g.y != null) {
      return pointInPolygon([g.x, g.y], sectionFeature.geometry);
    }
    if (g.rings?.length) {
      const c = centroidOfPolygon(g);
      return c ? pointInPolygon([c.x, c.y], sectionFeature.geometry) : false;
    }
    if (g.paths?.[0]?.length) {
      return g.paths[0].some(([x, y]) => pointInPolygon([x, y], sectionFeature.geometry));
    }
    return false;
  }

  function filterRosFeaturesForSection(rosFeatures, sectionFeature) {
    return (rosFeatures || []).filter((feature) => rosIntersectsSection(feature, sectionFeature));
  }

  function buildRosPopupHtml(feature) {
    const attrs = feature?.attributes || {};
    const label = bestRosLabel(attrs);
    const links = buildPdfProxyLinks(attrs);
    const linkHtml = links.length ? `<div class="hr"></div><div class="small">${links.map(l => `• ${l}`).join('<br/>')}</div>` : '';
    return `<b>Record of Survey</b><br/>${escapeHtml(label)}${linkHtml}`;
  }

  function buildPdfProxyLinks(attrs, linkText = 'Open PDF (API)') {
    const urls = [];
    for (const [k, v] of Object.entries(attrs || {})) {
      if (!v) continue;
      const key = String(k || '').toLowerCase();
      if (!/(pdf|doc|document|url|hyperlink|link|path)/i.test(key)) continue;
      const raw = String(v).trim();
      if (!raw) continue;
      if (/^https?:\/\//i.test(raw) || /\.pdf(\?|#|$)/i.test(raw)) {
        urls.push(raw);
      }
    }
    const uniq = [...new Set(urls)];
    return uniq.slice(0, 4).map((u) => `<a target="_blank" rel="noopener" href="${escapeHtml(buildRosPdfProxyUrl(u))}">${escapeHtml(linkText)}</a>`);
  }

  function summarizeAttrs(a) {
    const pairs = [];
    const skip = new Set(["SHAPE","SHAPE_AREA","SHAPE_LENGTH","OBJECTID","OBJECTID_1","GLOBALID"]);
    for (const [k,v] of Object.entries(a || {})) {
      if (skip.has(String(k).toUpperCase())) continue;
      if (v === null || v === undefined) continue;
      const s = typeof v === "string" ? v.trim() : String(v);
      if (!s) continue;
      pairs.push([k, escapeHtml(s)]);
      if (pairs.length >= 10) break;
    }
    if (!pairs.length) pairs.push(["Attrs", `${Object.keys(a||{}).length} fields`]);
    return pairs;
  }

  function centerMapOnFeature(feature, layerGroup, label="Feature") {
    try {
      if (!feature?.geometry) return;
      const g = feature.geometry;
      if (g.x != null && g.y != null) {
        map.setView([g.y, g.x], Math.max(16, map.getZoom()));
        invalidateMapSoon("center point");
        return;
      }
      const ext = arcExtentFromPolygon(g);
      if (ext) {
        const bounds = L.latLngBounds([ext.ymin, ext.xmin], [ext.ymax, ext.xmax]);
        map.fitBounds(bounds.pad(0.18));
        invalidateMapSoon("center polygon");
        return;
      }
      if (g.paths?.length && g.paths[0]?.length) {
        const pts = g.paths[0];
        let xmin=Infinity,ymin=Infinity,xmax=-Infinity,ymax=-Infinity;
        for (const [x,y] of pts) {
          xmin=Math.min(xmin,x); ymin=Math.min(ymin,y); xmax=Math.max(xmax,x); ymax=Math.max(ymax,y);
        }
        if (isFinite(xmin) && isFinite(ymin) && isFinite(xmax) && isFinite(ymax)) {
          const bounds = L.latLngBounds([ymin, xmin], [ymax, xmax]);
          map.fitBounds(bounds.pad(0.18));
          invalidateMapSoon("center line");
        }
      }
    } catch (e) {
      log(`Center map failed: ${e.message || e}`, "warn");
    }
  }

  // -----------------------------
  // Export helpers
  // -----------------------------
  function buildExportGeoJSON() {
    const features = [];

    function pushPolygonFeature(feature, role) {
      if (!feature?.geometry) return;
      const geometry = arcPolygonToGeoJSON(feature.geometry);
      if (!geometry) return;
      features.push({
        type: "Feature",
        properties: {
          role,
          ...(feature.attributes || {})
        },
        geometry: geometry.geometry
      });
    }

    pushPolygonFeature(state.parcelFeature, "parcel");
    pushPolygonFeature(state.subdivisionFeature, "subdivision");
    pushPolygonFeature(state.sectionFeature, "section");
    pushPolygonFeature(state.townshipFeature, "township");

    for (const feature of state.aliquotFeatures || []) pushPolygonFeature(feature, "aliquot");
    for (const feature of state.rosFeatures || []) pushPolygonFeature(feature, "ros");

    if (state.lastLonLat) {
      features.push({
        type: "Feature",
        properties: { role: "address_point" },
        geometry: { type: "Point", coordinates: [state.lastLonLat.lon, state.lastLonLat.lat] }
      });
    }

    return {
      type: "FeatureCollection",
      metadata: {
        generatedAt: new Date().toISOString(),
        count: features.length
      },
      features
    };
  }

  function downloadJson(obj, filename) {
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  function downloadText(text, filename, mime="text/plain") {
    const blob = new Blob([text], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  async function fetchParcelGeometry2243FromPoint(lon, lat) {
    return fetchParcelNearPoint(lon, lat, EXPORT_OUT_SR, 150);
  }

  async function fetchAliquotsAtPoint(lon, lat, outSR = 4326) {
    const payload = await loadAliquotsAtPoint(lon, lat, outSR);
    return payload?.aliquots || [];
  }

  async function fetchSectionGeometry2243FromPoint(lon, lat) {
    const section4326 = await findContainingPolygon(LAYERS.sections, lon, lat, 2500, 4326);
    const objectId = Number(section4326?.attributes?.OBJECTID);
    if (!Number.isFinite(objectId)) return null;

    const resp = await arcQuery(LAYERS.sections, {
      where: `OBJECTID=${objectId}`,
      outFields: '*',
      returnGeometry: true,
      outSR: EXPORT_OUT_SR,
      resultRecordCount: 1,
    });

    return resp?.features?.[0] || null;
  }

  async function fetchSubdivisionGeometry2243FromPoint(lon, lat) {
    const subdivision4326 = await findContainingPolygon(LAYERS.subdivisions, lon, lat, 2500, 4326);
    if (!subdivision4326) return null;

    const objectId = Number(subdivision4326?.attributes?.OBJECTID);
    if (!Number.isFinite(objectId)) {
      return findContainingPolygon(LAYERS.subdivisions, lon, lat, 2500, EXPORT_OUT_SR);
    }

    const resp = await arcQuery(LAYERS.subdivisions, {
      where: `OBJECTID=${objectId}`,
      outFields: '*',
      returnGeometry: true,
      outSR: EXPORT_OUT_SR,
      resultRecordCount: 1,
    });

    return resp?.features?.[0] || null;
  }

  // -----------------------------
  // PDF Basis of Bearing (upload)
  // -----------------------------
  function extractBasisLines(text) {
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const hits = [];
    const re = /(BASIS\s+OF\s+BEARING|BASIS\s+OF\s+BEARINGS|BEARINGS?\s+ARE\s+BASED\s+ON|BEARINGS?\s+SHOWN\s+HEREON\s+ARE\s+BASED\s+ON)/i;

    for (const ln of lines) if (re.test(ln)) hits.push(ln);

    const context = [];
    for (let i=0; i<lines.length; i++) {
      if (re.test(lines[i])) {
        const start = Math.max(0, i-2);
        const end = Math.min(lines.length, i+5);
        context.push(lines.slice(start, end).join(" "));
      }
    }

    const uniq = (arr) => {
      const s = new Set();
      const out = [];
      for (const x of arr) { const k=x.toUpperCase(); if (!s.has(k)) { s.add(k); out.push(x); } }
      return out;
    };
    return { hits: uniq(hits), context: uniq(context) };
  }

  async function scanUploadedPdf(file) {
    if (!file) throw new Error("No PDF selected.");
    if (!window.pdfjsLib) throw new Error("pdfjsLib missing.");
    const buf = await file.arrayBuffer();
    const doc = await pdfjsLib.getDocument({ data: buf }).promise;
    let fullText = "";
    for (let p=1; p<=doc.numPages; p++) {
      const page = await doc.getPage(p);
      const tc = await page.getTextContent();
      const strings = tc.items.map(it => it.str);
      fullText += strings.join("\n") + "\n";
    }
    return extractBasisLines(fullText);
  }

  // -----------------------------
  // Main flow
  // -----------------------------
  async function doLookup(options = {}) {
    const lookupButton = $("btnLookup");
    lookupButton.disabled = true;
    setBusyModalOpen(true, 'Loading RecordQuarry data…', 'Querying address, parcel, subdivision, section, township, ROS, and aliquot records.');
    clearLog();
    $("btnExportParcelCSV").disabled = true;
    $("btnExportPointForge").disabled = true;
    state.exportGeoJSON = null;
    state.parcelFeature2243 = null;
    state.subdivisionFeature2243 = null;
    state.aliquotFeatures = [];
    state.sectionFeature2243 = null;
    state.aliquotFeatures2243 = [];
    state.selectedParcel = true;
    state.selectedAliquot = null;
    state.selectedAliquotKeys.clear();
    setSummaryCards([]);
    clearMapLayers();

    const rawAddr = $("addr").value.trim();
    if (!rawAddr) { log("Enter an address.", "warn"); return; }

    try {
      log("Lookup started.");
      invalidateMapSoon("lookup start");

      const cachedAddressSnapshot = (!options.lookupPayload && !options.disableAddressCache)
        ? await loadAddressLookupSnapshot(rawAddr)
        : null;
      const lookup = options.lookupPayload || cachedAddressSnapshot?.lookup || await lookupByAddress(rawAddr);
      state.lastLookupPayload = lookup;
      state.lastLookupAddress = rawAddr;
      if (options.lookupPayload) {
        log("Loaded saved project results from local storage.");
      } else if (cachedAddressSnapshot?.lookup) {
        log(`Loaded saved address results from ${cachedAddressSnapshot.savedAt || 'local storage'}.`);
      }
      const addrF = lookup.addressFeature || null;
      const candidates = addrF ? [addrF] : [];
      if (!addrF) {
        log("Address not found in Ada County Address layer (16). Continuing with geocoder coordinates.", "warn");
      }
      state.addressFeature = addrF;

      const lon = lookup.location?.lon ?? addrF?.geometry?.x;
      const lat = lookup.location?.lat ?? addrF?.geometry?.y;
      const addrLL = [lat, lon];
      const addressDisplay = addrF ? formatAddressAttrs(addrF.attributes || {}) : (lookup.geocode?.display || rawAddr);
      log(`Address match: ${addrLL[0].toFixed(7)}, ${addrLL[1].toFixed(7)}`);
      if (addrF) {
        drawAddressPoint(addrF);
      } else {
        const geocodeMarker = L.circleMarker(addrLL, { radius: 7, weight: 2, color: "#ffffff", fillColor: "#2a3dff", fillOpacity: 0.9 });
        geocodeMarker.bindPopup(`<b>Geocoded Address</b><br/>${escapeHtml(addressDisplay)}`);
        layers.address.addLayer(geocodeMarker);
      }

      map.setView(addrLL, 18);
      invalidateMapSoon("after setView");
      state.lastLonLat = { lon, lat };

      const parcel = lookup.parcel;
      if (!parcel) {
        log("Parcel not found near that address point (0/10/30/150m).", "bad");
        setSummaryCards([
          card("Address", addressDisplay,
            [["Lat/Lon", `${lat.toFixed(7)}, ${lon.toFixed(7)}`],["Candidates", String(candidates.length)]],
            [])
        ]);
        invalidateMapSoon("parcel not found");
        return;
      }
      state.parcelFeature = parcel;

      drawParcel();

      const ext = arcExtentFromPolygon(parcel.geometry);
      if (ext) {
        const bounds = L.latLngBounds([ext.ymin, ext.xmin], [ext.ymax, ext.xmax]);
        map.fitBounds(bounds.pad(0.15));
        invalidateMapSoon("after fitBounds");
      }

      const c = centroidOfPolygon(parcel.geometry) || { x: lon, y: lat };
      log(`Parcel centroid: ${c.y.toFixed(7)}, ${c.x.toFixed(7)}`);

      const subdiv = lookup.subdivision || null;
      const section = lookup.section || null;
      const township = lookup.township || null;

      state.subdivisionFeature = subdiv;
      state.sectionFeature = section;
      state.townshipFeature = township;

      try {
        state.aliquotFeatures = await fetchAliquotsAtPoint(lon, lat, 4326);
        state.aliquotFeatures2243 = await fetchAliquotsAtPoint(lon, lat, EXPORT_OUT_SR);
        applySelectionSnapshot(options.selectionSnapshot || cachedAddressSnapshot?.selection || null);
        drawAliquots(state.aliquotFeatures, section);
        log(`Aliquots loaded: ${state.aliquotFeatures.length}`);
      } catch (e) {
        state.aliquotFeatures = [];
        state.aliquotFeatures2243 = [];
        state.selectedAliquotKeys.clear();
        log(`Aliquot lookup failed: ${e.message || e}`, "warn");
      }

      if (subdiv) drawPolygonFeature(subdiv, layers.subdivision, { style: () => ({ color:"#9ab0ff", weight:2, fillOpacity:0.04 }) }, "Subdivision");
      if (section) drawPolygonFeature(section, layers.section, { style: () => ({ color:"#ffcc66", weight:2, fillOpacity:0.03, dashArray:"6 6" }) }, "Section");
      if (township) drawPolygonFeature(township, layers.township, { interactive: false, style: () => ({ color:"#ff5a7a", weight:2, fillOpacity:0.02, dashArray:"3 8" }) }, "Township");

      drawCornerMarkers(buildCornerMarkerEntries());

      const rosFromLookup = normalizeRosFeatures(lookup.ros || []);
      const ros = filterRosFeaturesForSection(rosFromLookup, section);
      let utilityLocations = [];
      try {
        utilityLocations = await loadUtilitiesByAddress(rawAddr, { outSR: EXPORT_OUT_SR, sources: ['power'] });
      } catch (utilityError) {
        log(`Utility lookup failed: ${utilityError.message || utilityError}`, 'warn');
      }
      state.utilityLocations = utilityLocations;
      drawUtilityLocations(state.utilityLocations);
      log(`Utility locations found: ${state.utilityLocations.length}`);
      state.rosFeatures = ros;
      log(`ROS in containing section: ${ros.length} (from ${rosFromLookup.length} nearby ROS)`);

      for (const f of ros) {
        const g = f.geometry;
        if (!g) continue;
        if (g.x != null && g.y != null) {
          const m = L.circleMarker([g.y, g.x], { radius: 5, weight: 1.5, color: "#ffffff", fillColor:"#ff5a7a", fillOpacity: .7 });
          m.bindPopup(buildRosPopupHtml(f));
          layers.ros.addLayer(m);
        } else if (g.paths?.length || g.rings?.length) {
          const gj = (g.rings?.length) ? arcPolygonToGeoJSON(g) : { type:"Feature", properties:{}, geometry:{ type:"LineString", coordinates: (g.paths[0]||[]).map(([x,y]) => [x,y]) } };
          const layer = L.geoJSON(gj, { pane: 'contextPolygons', style: () => ({ color:"#ff5a7a", weight:2, fillOpacity:0.02 }) });
          layer.bindPopup(buildRosPopupHtml(f));
          layers.ros.addLayer(layer);
        }
      }

      // -----------------------------
      // Summary cards
      // -----------------------------
      const cards = [];

      const pAttrs = parcel.attributes || {};
      cards.push(card(
        "Parcel",
        "Parcel feature",
        [
          ["Centroid", `${c.y.toFixed(7)}, ${c.x.toFixed(7)}`],
          ["Attrs", `${Object.keys(pAttrs).length} fields`],
          ["Export", `Unique parcel/subdivision/aliquots CSV in P,N,E,Z,D (EPSG:${EXPORT_OUT_SR}, ID West ftUS)`],
        ],
        [],
        {
          onSelect: () => centerMapOnFeature(parcel, layers.parcel, 'Parcel'),
          onRender: (cardEl) => {
            const starBtn = document.createElement('button');
            const syncStar = (isBusy = false) => {
              const selected = state.selectedParcel;
              starBtn.textContent = selected ? '★' : '☆';
              starBtn.title = selected ? 'Exclude parcel from export' : 'Include parcel in export';
              starBtn.setAttribute('aria-pressed', selected ? 'true' : 'false');
              starBtn.disabled = Boolean(isBusy);
            };
            starBtn.type = 'button';
            starBtn.className = 'rq-star-btn';
            syncStar(false);
            starBtn.addEventListener('click', (evt) => {
              evt.stopPropagation();
              syncStar(true);
              const next = !state.selectedParcel;
              setParcelSelected(next);
              syncStar(false);
              drawParcel();
              drawCornerMarkers(buildCornerMarkerEntries());
              log(`${next ? 'Included' : 'Excluded'} parcel in export.`);
            });
            cardEl.appendChild(starBtn);
          },
        }
      ));

      function fmtDist(m) {
        return m < 1609.34 ? `${Math.round(m)} m` : `${(m / 1609.34).toFixed(2)} mi`;
      }

      const aliquotSummaryCpfTargets = [];
      const aliquotCardSliceStart = cards.length;
      if (state.aliquotFeatures.length) {
        const COLLAPSE_DIST_M = 500; // metres

        function aliquotDistMeters(feature) {
          if (!state.lastLonLat) return 0;
          const centroid = centroidOfPolygon(feature.geometry);
          if (!centroid) return 0;
          // outSR 4326: centroid.x = lon, centroid.y = lat
          return haversineMeters(state.lastLonLat.lat, state.lastLonLat.lon, centroid.y, centroid.x);
        }

        // Group aliquots by Township + Range + Section (parsed from BLM PLSSID/FRSTDIVID).
        // The Index (SECDIVNO/SECDIVLAB) identifies each aliquot within the group.
        const groups = new Map();
        for (const [idx, f] of state.aliquotFeatures.entries()) {
          const loc = parsePlssFromAliquot(f);
          const sectionLabel = loc.section ? `Sec ${loc.section}` : '';
          const groupKey = [loc.township, loc.range, sectionLabel].filter(Boolean).join(' ') || 'Aliquots';
          if (!groups.has(groupKey)) groups.set(groupKey, { label: groupKey, items: [], minDist: Infinity });
          const distMeters = aliquotDistMeters(f);
          const grp = groups.get(groupKey);
          grp.items.push({ f, idx, loc, distMeters });
          if (distMeters < grp.minDist) grp.minDist = distMeters;
        }

        // Sort groups by nearest member, then items within each group by distance.
        const sortedGroups = [...groups.values()].sort((a, b) => a.minDist - b.minDist);
        for (const grp of sortedGroups) grp.items.sort((a, b) => a.distMeters - b.distMeters);

        for (const group of sortedGroups) {
          // Group header — shown for every group so the Township/Range/Section is always visible.
          const headerEl = document.createElement('div');
          headerEl.className = 'aliquot-group-header';
          headerEl.style.cssText = 'font-size:11px;font-weight:700;color:var(--muted);text-transform:uppercase;letter-spacing:.5px;padding:6px 2px 2px;margin-top:4px;';
          headerEl.textContent = group.label;
          cards.push(headerEl);

          for (const { f, idx, loc, distMeters } of group.items) {
            const a = f.attributes || {};
            const indexLabel = loc.index || a.ALIQUOT || a.ALIQUOT_LABEL || `Aliquot #${idx + 1}`;
            const token = `aliquot-${idx + 1}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
            const selectionKey = buildAliquotSelectionKey(f, idx);
            const isFar = distMeters > COLLAPSE_DIST_M && !isAliquotSelected(f, idx);
            aliquotSummaryCpfTargets.push({ token, feature: f, label: indexLabel });
            const cardEl = card(
              indexLabel,
              group.label,
              summarizeAttrs(a),
              [
                ...buildPdfProxyLinks(a, "Open CP&F PDF (API)"),
                `<div class="small"><b>Corner CP&amp;F records</b><br/><span data-aliquot-cpf-links="${token}">Loading CP&amp;F records…</span></div>`
              ],
              {
                onSelect: () => centerMapOnFeature(f, layers.aliquots, indexLabel),
                onRender: (el) => {
                  const starBtn = document.createElement('button');
                  const syncStar = () => {
                    const selected = isAliquotSelected(f, idx);
                    starBtn.textContent = selected ? '★' : '☆';
                    starBtn.title = selected ? 'Exclude from export' : 'Include in export';
                    starBtn.setAttribute('aria-pressed', selected ? 'true' : 'false');
                  };
                  starBtn.type = 'button';
                  starBtn.className = 'rq-star-btn';
                  syncStar();
                  starBtn.addEventListener('click', (evt) => {
                    evt.stopPropagation();
                    const next = !isAliquotSelected(f, idx);
                    setAliquotSelected(f, idx, next);
                    syncStar();
                    drawAliquots(state.aliquotFeatures, section);
                    drawCornerMarkers(buildCornerMarkerEntries());
                    log(`${next ? 'Included' : 'Excluded'} aliquot in export: ${indexLabel}`);
                  });
                  el.appendChild(starBtn);
                },
              }
            );
            cardEl.classList.add('aliquot-card');
            cardEl.dataset.aliquotCardKey = selectionKey;
            if (isFar) cardEl.classList.add('is-far');

            // Append distance badge (and chevron for far cards) to the card header.
            const chead = cardEl.querySelector('.chead');
            if (chead) {
              const badge = document.createElement('span');
              badge.className = 'dist-badge' + (isFar ? ' is-far' : '');
              badge.textContent = fmtDist(distMeters);
              chead.appendChild(badge);
              if (isFar) {
                const chevron = document.createElement('span');
                chevron.className = 'chead-chevron';
                chevron.textContent = '▾';
                chead.appendChild(chevron);
                // Clicking the header of a far (collapsed) card expands/collapses it.
                chead.addEventListener('click', (evt) => {
                  evt.stopPropagation();
                  cardEl.classList.toggle('is-expanded');
                  centerMapOnFeature(f, layers.aliquots, indexLabel);
                });
              }
            }

            cards.push(cardEl);
          }
        }
      }

      const aliquotCardSliceEnd = cards.length;
      rqApplyDistanceGroupSeeMore(cards, aliquotCardSliceStart, aliquotCardSliceEnd, {
        cardClass: 'aliquot-card',
        farClass: 'is-far',
        headerClass: 'aliquot-group-header',
        title: 'Aliquots',
        thresholdMeters: 500,
      });


      if (state.utilityLocations.length) {
        cards.push(card("Utilities", "Idaho Power residential utility locations", [["Count", String(state.utilityLocations.length)]], []));
      }

      if (subdiv) cards.push(card("Subdivision", "Containing feature", summarizeAttrs(subdiv.attributes), []));
      if (section) cards.push(card("Section", "Containing feature", summarizeAttrs(section.attributes), []));
      if (township) cards.push(card("Township", "Containing feature", summarizeAttrs(township.attributes), []));

      const rosCardSliceStart = cards.length;
      if (ros.length) {
        const ROS_COLLAPSE_DIST_M = 500; // metres

        function rosFeatureCentroid(feature) {
          const g = feature?.geometry;
          if (!g) return null;
          if (Number.isFinite(Number(g.x)) && Number.isFinite(Number(g.y))) return { x: Number(g.x), y: Number(g.y) };
          if (g.paths?.length) { const p = g.paths[0]?.[0]; return p ? { x: p[0], y: p[1] } : null; }
          return centroidOfPolygon(g);
        }

        const rosSorted = ros.slice(0, 10)
          .map((f) => {
            const c = rosFeatureCentroid(f);
            const dist = (c && state.lastLonLat)
              ? haversineMeters(state.lastLonLat.lat, state.lastLonLat.lon, c.y, c.x)
              : 0;
            return { f, dist };
          })
          .sort((a, b) => a.dist - b.dist);

        for (const [sortIdx, { f, dist }] of rosSorted.entries()) {
          const a = f.attributes || {};
          const isFar = dist > ROS_COLLAPSE_DIST_M;
          const rosLabel = bestRosLabel(a) || `Record of Survey #${sortIdx + 1}`;
          const cardEl = card(
            `Record of Survey #${sortIdx + 1}`,
            rosLabel,
            summarizeAttrs(a),
            buildPdfProxyLinks(a),
            { onSelect: () => centerMapOnFeature(f, layers.ros, rosLabel) }
          );
          cardEl.classList.add('ros-card');
          if (isFar) cardEl.classList.add('is-far');
          const chead = cardEl.querySelector('.chead');
          if (chead) {
            const badge = document.createElement('span');
            badge.className = 'dist-badge' + (isFar ? ' is-far' : '');
            badge.textContent = fmtDist(dist);
            chead.appendChild(badge);
            if (isFar) {
              const chevron = document.createElement('span');
              chevron.className = 'chead-chevron';
              chevron.textContent = '▾';
              chead.appendChild(chevron);
              chead.addEventListener('click', (evt) => {
                evt.stopPropagation();
                cardEl.classList.toggle('is-expanded');
                centerMapOnFeature(f, layers.ros, rosLabel);
              });
            }
          }
          cards.push(cardEl);
        }
      } else {
        cards.push(card("Record of Survey", "None within 1600m of parcel centroid", [["Note","Increase search distance in code if needed."]], []));
      }

      
      const rosCardSliceEnd = cards.length;
      if (ros.length) {
        rqApplyDistanceGroupSeeMore(cards, rosCardSliceStart, rosCardSliceEnd, {
          cardClass: 'ros-card',
          farClass: 'is-far',
          title: 'Records of Survey',
          thresholdMeters: 500,
        });
      }

      setSummaryCards(cards);
      if (aliquotSummaryCpfTargets.length) {
        lazyLoadAliquotSummaryCpfLinks(aliquotSummaryCpfTargets);
      }

      state.exportGeoJSON = buildExportGeoJSON();

      try {
        log(`Fetching parcel/subdivision/aliquot export geometry in EPSG:${EXPORT_OUT_SR}...`);
        state.parcelFeature2243 = await fetchParcelGeometry2243FromPoint(lon, lat);
        state.subdivisionFeature2243 = await fetchSubdivisionGeometry2243FromPoint(lon, lat);
        state.sectionFeature2243 = await fetchSectionGeometry2243FromPoint(lon, lat);

        if (state.parcelFeature2243?.geometry?.rings?.length) {
          $("btnExportParcelCSV").disabled = false;
          $("btnExportPointForge").disabled = false;
          log("Export geometry ready (IDW ft): parcel, subdivision, and aliquot vertices.");
        } else {
          log("Parcel export geometry not available (no rings).", "warn");
        }
      } catch (e) {
        log(`Parcel/subdivision/aliquot export geometry fetch failed: ${e.message || e}`, "warn");
      }

      saveLookupSnapshotsForCurrentState(rawAddr);
      if (state.projectContext.projectId) {
        log(`Saved lookup results to project ${state.projectContext.projectName || state.projectContext.projectId}.`);
      }

      invalidateMapSoon("lookup complete");
      log("Done.", "info");
    } catch (e) {
      log(`Error: ${e.message || e}`, "bad");
      console.error(e);
      invalidateMapSoon("after error");
    } finally {
      setBusyModalOpen(false);
      lookupButton.disabled = false;
    }
  }

  // -----------------------------
  // Lazy-load CP&F links for each aliquot card summary
  // -----------------------------
  async function lazyLoadAliquotSummaryCpfLinks(targets = []) {
    for (const target of targets) {
      const node = document.querySelector(`[data-aliquot-cpf-links="${target.token}"]`);
      if (!node) continue;
      node.textContent = "Loading CP&F records…";
      try {
        const centroid = centroidOfPolygon(target.feature.geometry);
        if (!centroid) throw new Error("No centroid for aliquot.");
        const records = await queryCpfRecordsNearCorner(centroid.y, centroid.x, 250, 4326);
        if (!records.length) {
          node.innerHTML = `<span class="small">No CP&amp;F records found within 250m.</span>`;
          continue;
        }

        const first = records[0];
        const rest = records.slice(1);

        const firstLinks = first.links.map((u, i) => `<a target="_blank" rel="noopener" href="${escapeHtml(buildRosPdfProxyUrl(u))}">CP&amp;F PDF${first.links.length > 1 ? ` ${i + 1}` : ''}</a>`).join('<br/>');
        const restHtml = rest.map((rec, idx) => {
          const inst = resolveCpfRecordInstrument(rec) || `Record ${idx + 2}`;
          const links = rec.links.map((u, i) => `<a target="_blank" rel="noopener" href="${escapeHtml(buildRosPdfProxyUrl(u))}">CP&amp;F PDF${rec.links.length > 1 ? ` ${i + 1}` : ''}</a>`).join('<br/>');
          return `<div style="margin:8px 0"><b>${escapeHtml(inst)}</b><div style="margin-top:2px">${links}</div></div>`;
        }).join('');

        node.innerHTML = `
          <div class="cpf-collapsed">
            <img class="cpf-thumb" alt="CP&F thumbnail"/>
            <div class="cpf-collapsed-info">
              <div><b>${escapeHtml(resolveCpfRecordInstrument(first) || 'CP&F')}</b></div>
              <div style="margin-top:2px">${firstLinks}</div>
              ${rest.length ? `<button class="secondary cpf-expand-btn" data-cpf-expand>Show all (${records.length})</button>` : ''}
              <div data-cpf-all style="display:none;margin-top:8px">${restHtml}</div>
            </div>
          </div>
        `;

        // Wire expand button
        const expandBtn = node.querySelector('[data-cpf-expand]');
        const allDiv = node.querySelector('[data-cpf-all]');
        if (expandBtn && allDiv) {
          expandBtn.addEventListener('click', (evt) => {
            evt.stopPropagation();
            allDiv.style.display = '';
            expandBtn.parentElement.remove();
          });
        }

        // Load thumbnail for the first record's PDF
        const firstProxyUrl = first.links[0] ? buildRosPdfProxyUrl(first.links[0]) : null;
        if (firstProxyUrl) {
          const thumbEl = node.querySelector('.cpf-thumb');
          if (thumbEl) {
            // Clicking thumbnail opens the PDF
            const pdfHref = escapeHtml(firstProxyUrl);
            thumbEl.addEventListener('click', () => window.open(pdfHref, '_blank', 'noopener'));
            loadCpfThumbnailWithRetry(thumbEl, buildCpfPdfThumbnailUrl(firstProxyUrl));
          }
        }

        log(`Loaded CP&F PDF links for summary ${target.label}.`);
      } catch (e) {
        node.innerHTML = `<span class="small" style="color:#ffb3b3">CP&amp;F lookup failed: ${escapeHtml(e.message || e)}</span>`;
        log(`CP&F summary lookup failed for ${target.label}: ${e.message || e}`, 'warn');
      }
    }
  }

  function buildCpfPdfThumbnailUrl(proxyUrl) {
    // Simple heuristic: if proxy is returning a PDF, we can let the server generate thumbnail.
    // If no server thumbnailing exists, this will just fail silently and we fall back to blank.
    const u = new URL(proxyUrl, window.location.origin);
    u.searchParams.set('thumb', '1');
    return u.toString();
  }

  async function loadCpfThumbnailWithRetry(imgEl, url, attempts = 3) {
    let lastErr = null;
    for (let i = 0; i < attempts; i++) {
      try {
        await new Promise((resolve, reject) => {
          imgEl.onload = () => resolve();
          imgEl.onerror = () => reject(new Error('img load failed'));
          imgEl.src = url + (url.includes('?') ? '&' : '?') + `t=${Date.now()}-${i}`;
        });
        return;
      } catch (e) {
        lastErr = e;
        await new Promise(r => setTimeout(r, 250 * (i + 1)));
      }
    }
    // leave blank (non-fatal)
    if (lastErr) {}
  }

  // -----------------------------
  // UI events
  // -----------------------------
  $("btnLookup").addEventListener("click", doLookup);

  $("btnClear").addEventListener("click", () => {
    $("addr").value = "";
    state.lastLookupPayload = null;
    state.lastLookupAddress = '';
    clearLog();
    clearMapLayers();
    $("btnExportParcelCSV").disabled = true;
    $("btnExportPointForge").disabled = true;
    state.exportGeoJSON = null;
    state.parcelFeature2243 = null;
    state.subdivisionFeature2243 = null;
    state.aliquotFeatures = [];
    state.sectionFeature2243 = null;
    state.aliquotFeatures2243 = [];
    state.selectedParcel = true;
    state.selectedAliquot = null;
    state.selectedAliquotKeys.clear();
    setSummaryCards([]);
    log("Cleared.");
    invalidateMapSoon("clear");
  });

  $("btnExportParcelCSV").addEventListener("click", async () => {
    try {
      if (!state.parcelFeature2243) {
        throw new Error("Export geometry not loaded yet. Run Lookup again.");
      }

      const selectedAliquotFeatures2243 = filterAliquotFeaturesForExport(state.aliquotFeatures2243, state.selectedAliquotKeys);
      const baseExport = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: filterParcelFeatureForExport(state.parcelFeature2243, state.selectedParcel),
        subdivisionFeature2243: state.subdivisionFeature2243,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
      });
      if (!baseExport.count) throw new Error("No parcel/subdivision/aliquot points available for export.");

      const plssPoints = new Map([...baseExport.points.entries()].filter(([, point]) => (
        !point.sources.has('parcel') && !point.sources.has('subdivision')
      )));
      log(`Looking up CP&F instrument notes for ${plssPoints.size} aliquot/section point(s)...`);
      setBusyModalOpen(true, 'Exporting CSV… gathering CPNF instrument numbers');
      const notesByCoordinate = await buildCpfNotesByCoordinate(plssPoints);

      const finalExport = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: filterParcelFeatureForExport(state.parcelFeature2243, state.selectedParcel),
        subdivisionFeature2243: state.subdivisionFeature2243,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
        notesByCoordinate,
      });

      downloadText(finalExport.csv, "parcel_subdivision_aliquots_unique_points_idw_ft_pnezd.csv", "text/csv");
      log(`Exported unique boundary CSV (PNEZD + notes, IDW ft): points=${finalExport.count}.`);
    } catch (e) {
      log(`Parcel CSV export failed: ${e.message || e}`, "bad");
      console.error(e);
    } finally {
      setBusyModalOpen(false);
    }
  });

  $("btnExportPointForge").addEventListener("click", async () => {
    try {
      if (!state.parcelFeature2243) {
        throw new Error("PointForge export geometry not loaded yet. Run Lookup again.");
      }

      const selectedAliquotFeatures2243 = filterAliquotFeaturesForExport(state.aliquotFeatures2243, state.selectedAliquotKeys);
      const baseExport = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: filterParcelFeatureForExport(state.parcelFeature2243, state.selectedParcel),
        subdivisionFeature2243: null,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
      });
      if (!baseExport.count) throw new Error('No parcel or aliquot corners available to export to PointForge.');

      const plssPoints = new Map([...baseExport.points.entries()].filter(([, point]) => (
        !point.sources.has('parcel') && !point.sources.has('subdivision')
      )));
      log(`Looking up CP&F instrument notes for ${plssPoints.size} PointForge aliquot/section point(s)...`);
      setBusyModalOpen(true, 'Exporting to PointForge… gathering CPNF instrument numbers');
      const notesByCoordinate = await buildCpfNotesByCoordinate(plssPoints);

      const uniquePart = buildRosBoundaryCsvRowsPNEZD({
        parcelFeature2243: filterParcelFeatureForExport(state.parcelFeature2243, state.selectedParcel),
        subdivisionFeature2243: null,
        sectionFeature2243: state.sectionFeature2243,
        aliquotFeatures2243: selectedAliquotFeatures2243,
        startPoint: 1,
        notesByCoordinate,
        includePlssWithoutNotes: false,
      });
      if (!uniquePart.count) throw new Error('No parcel points or CP&F-backed aliquot corners available to export to PointForge.');

      const utilityMarkers = buildPowerUtilityMarkersForPointForge(state.utilityLocations, uniquePart.nextPoint);
      const utilityRows = buildPointMarkerCsvRowsPNEZD(utilityMarkers, uniquePart.nextPoint, '');
      const pointForgeCsv = `${uniquePart.csv}${utilityRows.csv}`;

      localStorage.setItem(POINTFORGE_ROS_IMPORT_STORAGE_KEY, JSON.stringify({
        source: 'ros-html',
        exportedAt: new Date().toISOString(),
        csv: pointForgeCsv,
      }));
      const projectFileUpdate = await persistPointForgeExportProjectFile({
        projectContext: state.projectContext,
        notesByCoordinate,
        csv: pointForgeCsv,
        pointCount: uniquePart.count + utilityRows.count,
      });
      if (projectFileUpdate) {
        log(`Saved PointForge export to project file (${projectFileUpdate.cpfCount} CP&F references).`);
      }
      openLinkedApp(buildPointForgeLaunchPath());
      log(`Sent ${uniquePart.count + utilityRows.count} points to PointForge (${utilityRows.count} utility point(s)).`);
    } catch (e) {
      log(`PointForge export failed: ${e.message || e}`, "bad");
      console.error(e);
    } finally {
      setBusyModalOpen(false);
    }
  });

  function openLinkedApp(path) {
    try {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({
          type: 'survey-cad:navigate-app',
          path,
        }, window.location.origin);
        return;
      }
    } catch (_error) {
      // If parent access is blocked, fallback to same-tab navigation.
    }
    window.location.assign(path);
  }

  function buildPointForgeLaunchPath() {
    const params = new URLSearchParams({ source: 'ros' });
    const projectId = String(state?.projectContext?.projectId || '').trim();
    const projectName = String(state?.projectContext?.projectName || '').trim();
    if (projectId) params.set('projectId', projectId);
    if (projectName) params.set('projectName', projectName);
    return `/POINT_TRANSFORMER.HTML?${params.toString()}`;
  }

  async function buildCpfNotesByCoordinate(pointsMap = new Map()) {
    const notes = new Map();
    for (const [key, point] of pointsMap.entries()) {
      if (!point || !Number.isFinite(point.north) || !Number.isFinite(point.east)) continue;
      try {
        const records = await queryCpfRecordsNearCorner(point.north, point.east, 250, 4326);
        const instruments = records.map(resolveCpfRecordInstrument).filter(Boolean);
        if (instruments.length) {
          notes.set(key, `CPNF: ${[...new Set(instruments)].slice(0, 6).join(', ')}`);
        }
      } catch {
        // ignore missing notes
      }
    }
    return notes;
  }

  $("btnScanPdf").addEventListener("click", async () => {
    const file = $("pdfFile").files?.[0];
    $("pdfFindings").style.display = "none";
    $("pdfFindings").textContent = "";
    try {
      log(`Scanning PDF upload: ${file ? file.name : "(none)"}`);
      const res = await scanUploadedPdf(file);
      const out = [];
      out.push("BASIS OF BEARING — matches:\n");
      if (res.hits.length) out.push(...res.hits.map(x => "• " + x));
      else out.push("(none found as single-line matches)");
      out.push("\n\nBASIS OF BEARING — with context:\n");
      if (res.context.length) out.push(...res.context.map(x => "• " + x));
      else out.push("(none found)");
      $("pdfFindings").textContent = out.join("\n");
      $("pdfFindings").style.display = "block";
      log("PDF scan complete.");
    } catch (e) {
      log(`PDF scan failed: ${e.message || e}`, "bad");
      console.error(e);
    }
  });

  // initial log
  clearLog();
  if (state.projectContext.address) {
    $("addr").value = state.projectContext.address;
  }
  if (state.projectContext.projectId) {
    log(`Project loaded: ${state.projectContext.projectName || state.projectContext.projectId} (${state.projectContext.client || "no client"}).`);

    const hasProjectAddress = Boolean(normalizeAddressStorageKey(state.projectContext.address));
    const projectSnapshot = await loadProjectLookupSnapshot(state.projectContext.projectId);
    const projectAddressSnapshot = hasProjectAddress ? await loadAddressLookupSnapshot(state.projectContext.address) : null;

    let launchLookupPayload = null;
    let launchSelectionSnapshot = null;

    if (hasProjectAddress) {
      if (projectAddressSnapshot?.lookup) {
        launchLookupPayload = projectAddressSnapshot.lookup;
        launchSelectionSnapshot = projectAddressSnapshot.selection;
        log(`Restoring cached results for project address from ${projectAddressSnapshot.savedAt || "unknown time"}.`);
      } else if (projectSnapshot?.lookup) {
        launchLookupPayload = projectSnapshot.lookup;
        launchSelectionSnapshot = projectSnapshot.selection;
        log(`Restoring saved project results from ${projectSnapshot.savedAt || "unknown time"}.`);
      }
      doLookup({ lookupPayload: launchLookupPayload, selectionSnapshot: launchSelectionSnapshot }).catch((err) => {
        log(`Saved result restore failed, running live lookup: ${err.message || err}`, "warn");
        doLookup().catch((liveErr) => {
          log(`Lookup failed: ${liveErr.message || liveErr}`, "bad");
          console.error(liveErr);
        });
      });
    } else if (projectSnapshot?.lookup && state.projectContext.autostart) {
      log(`Restoring saved project results from ${projectSnapshot.savedAt || "unknown time"}.`);
      doLookup({ lookupPayload: projectSnapshot.lookup, selectionSnapshot: projectSnapshot.selection }).catch((err) => {
        log(`Saved result restore failed, running live lookup: ${err.message || err}`, "warn");
        doLookup().catch((liveErr) => {
          log(`Lookup failed: ${liveErr.message || liveErr}`, "bad");
          console.error(liveErr);
        });
      });
    } else if (state.projectContext.autostart) {
      doLookup().catch((err) => {
        log(`Lookup failed: ${err.message || err}`, "bad");
        console.error(err);
      });
    }
  } else {
    const hasLaunchAddress = Boolean(normalizeAddressStorageKey(state.projectContext.address));
    const launchAddressSnapshot = hasLaunchAddress
      ? await loadAddressLookupSnapshot(state.projectContext.address)
      : null;
    const snapshot = await loadMostRecentAddressLookupSnapshot();

    if (hasLaunchAddress) {
      if (launchAddressSnapshot?.lookup) {
        log(`Restoring cached results for launch address from ${launchAddressSnapshot.savedAt || 'unknown time'}.`);
      }
      if (state.projectContext.autostart) {
        doLookup({ lookupPayload: launchAddressSnapshot?.lookup || null, selectionSnapshot: launchAddressSnapshot?.selection || null }).catch((err) => {
          log(`Lookup failed: ${err.message || err}`, "bad");
          console.error(err);
        });
      }
    } else if (snapshot?.lookup) {
      if (!$("addr").value) {
        $("addr").value = snapshot.address || '';
      }
      log(`Restoring last lookup for ${snapshot.address || 'saved address'} from ${snapshot.savedAt || 'unknown time'}.`);
      doLookup({ lookupPayload: snapshot.lookup, selectionSnapshot: snapshot.selection }).catch((err) => {
        log(`Saved result restore failed: ${err.message || err}`, "warn");
      });
    }
  }
  log("Ready. Enter an address and click Lookup.");
  invalidateMapSoon("initial");
})();
</script>
</body>
</html>
