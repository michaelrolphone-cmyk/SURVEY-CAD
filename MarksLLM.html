<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Marks â€” Chat</title>

  <!-- Markdown renderer (GFM tables) + sanitizer -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>

  <style>
    :root{
      color-scheme: dark;
      --bg:#070b12;
      --text:#e6eefc;
      --muted:#9ab0d0;
      --line:rgba(255,255,255,.10);
      --ok:#37d67a;
      --warn:#ffb020;
      --bad:#ff5b5b;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 700px at 30% 0%, #101c35 0%, var(--bg) 60%); color:var(--text); font-family:var(--sans);}
    .app{display:grid; grid-template-rows:auto 1fr auto; height:100%;}
    .topbar{display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid var(--line); background:linear-gradient(180deg, rgba(0,0,0,.35), transparent); gap:12px;}
    .brand{display:flex; gap:10px; align-items:center; min-width:0;}
    .brand img{width:34px; height:34px; border-radius:12px; object-fit:cover; border:1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.25); flex:0 0 auto;}
    .brand .stack{display:flex; flex-direction:column; gap:2px; min-width:0;}
    .brand .stack b{font-size:13px;}
    .brand .stack span{font-size:12px; color:var(--muted); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .pill{display:inline-flex; align-items:center; gap:8px; padding:7px 10px; border-radius:999px; border:1px solid var(--line); background:rgba(0,0,0,.22); font-size:12px; color:var(--muted); user-select:none;}
    .dot{width:10px; height:10px; border-radius:50%;}
    .dot.ok{background:var(--ok);} .dot.warn{background:var(--warn);} .dot.bad{background:var(--bad);}

    .chat{overflow:auto; padding:16px 14px; display:flex; flex-direction:column; gap:12px;}
    .msg{max-width:980px; width:fit-content; border-radius:16px; border:1px solid var(--line); background:rgba(0,0,0,.28); padding:10px 12px;}
    .msg.user{align-self:flex-end; background:rgba(255,213,74,.08); border-color:rgba(255,213,74,.24);}
    .msg.assistant{align-self:flex-start;}

    .meta{display:flex; gap:10px; align-items:center; margin-bottom:6px; color:var(--muted); font-size:11px;}
    .meta .role{font-weight:800; letter-spacing:.2px;}

    .plain{
      white-space:pre-wrap;
      word-break:break-word;
      font-family:var(--sans);
      font-size:13px;
      line-height:1.45;
      margin:0;
    }

    .md{
      font-family:var(--sans);
      font-size:13px;
      line-height:1.55;
      color:var(--text);
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .md :where(p, ul, ol, blockquote, pre){ margin: 0.45em 0; }
    .md :where(h1,h2,h3){ margin: 0.6em 0 0.35em; line-height:1.2; }
    .md :where(h1){ font-size:1.25em; }
    .md :where(h2){ font-size:1.15em; }
    .md :where(h3){ font-size:1.07em; }
    .md :where(a){ color: #bcd7ff; text-decoration: underline; text-decoration-thickness: 1px; }
    .md :where(code){
      font-family: var(--mono);
      font-size: 0.95em;
      padding: 0.1em 0.35em;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 8px;
      background: rgba(0,0,0,.28);
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .md :where(pre){
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.32);
      overflow: auto;
      max-width: 100%;
    }
    .md :where(pre code){
      padding: 0;
      border: none;
      background: transparent;
      border-radius: 0;
      font-size: 0.92em;
      white-space: pre;
      word-break: normal;
      overflow-wrap: normal;
    }
    .md :where(blockquote){
      border-left: 3px solid rgba(255,255,255,.18);
      padding-left: 10px;
      color: rgba(230,238,252,.9);
      background: rgba(0,0,0,.18);
      border-radius: 10px;
      padding-top: 6px;
      padding-bottom: 6px;
    }

    /* Tables wrap */
    .md .table-wrap{
      max-width:100%;
      overflow-x:auto;
      -webkit-overflow-scrolling: touch;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
    }
    .md :where(table){
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
      display: table;
      min-width: 0;
    }
    .md :where(th, td){
      border: 1px solid rgba(255,255,255,.12);
      padding: 8px 10px;
      vertical-align: top;
      white-space: normal;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .md :where(th){
      background: rgba(255,255,255,.06);
      color: rgba(230,238,252,.95);
      font-weight: 700;
    }
    .md :where(tr:nth-child(even) td){
      background: rgba(0,0,0,.12);
    }

    /* Inline SVG frame (rendered from code blocks) */
    .svgFrame{
      margin: 0.45em 0;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.24);
      overflow:auto;
      max-width: 100%;
      color: var(--muted);
      font-size: 12px;
    }
    .svgFrame svg{
      display:block;
      width: 100%;
      height: auto;
      max-width: 100%;
    }

    .composer{
      border-top:1px solid var(--line);
      padding:12px 14px;
      background:linear-gradient(180deg, transparent, rgba(0,0,0,.35));
    }

    /* Persona picker (compact) */
    .personaRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .personaRow .left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .personaLabel{
      font-size:12px;
      color:var(--muted);
      user-select:none;
      white-space:nowrap;
    }
    .personaSelect{
      appearance:none;
      -webkit-appearance:none;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      color:var(--text);
      border-radius:12px;
      padding:8px 34px 8px 10px;
      font-size:12px;
      outline:none;
      cursor:pointer;
      min-width: 200px;
      max-width: 60vw;
    }
    .personaWrap{
      position:relative;
      display:inline-flex;
      align-items:center;
      min-width:0;
    }
    .personaWrap:after{
      content:"â–¾";
      position:absolute;
      right:10px;
      top:50%;
      transform:translateY(-50%);
      color:rgba(230,238,252,.65);
      pointer-events:none;
      font-size:12px;
    }
    .personaHint{
      font-size:12px;
      color:rgba(154,176,208,.85);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width: 45vw;
    }

    /* Attachments row */
    .attachRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin: 0 0 10px;
      align-items:center;
      min-height: 0;
    }
    .attachChip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: rgba(230,238,252,.92);
      font-size:12px;
      max-width: 100%;
    }
    .attachChip .name{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width: min(62vw, 520px);
    }
    .attachChip .x{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(230,238,252,.9);
      border-radius: 999px;
      width: 22px;
      height: 22px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      padding:0;
      line-height: 1;
      flex: 0 0 auto;
    }
    .attachChip .x:hover{ background: rgba(255,255,255,.10); }
    .attachChip .ico{
      width: 14px;
      height: 14px;
      display:inline-block;
      opacity: .9;
      flex: 0 0 auto;
    }

    .composer .box{
      display:flex;
      gap:10px;
      align-items:flex-end;
    }
    .attachBtn{
      flex:0 0 auto;
      border:1px solid var(--line);
      border-radius:14px;
      width:42px;
      height:42px;
      background:rgba(255,255,255,.04);
      color:var(--text);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
      user-select:none;
    }
    .attachBtn:hover{ background: rgba(255,255,255,.08); }
    .attachBtn:active{ transform: translateY(1px); }
    .attachBtn[disabled]{opacity:.55; cursor:not-allowed;}

    textarea{
      flex:1 1 auto;
      min-width:0;
      min-height:56px;
      max-height:220px;
      resize:vertical;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      color:var(--text);
      border-radius:14px;
      padding:10px 10px;
      outline:none;
      font-family:var(--sans);
      box-sizing:border-box;
    }
    textarea:focus{border-color: rgba(255,213,74,.55); box-shadow:0 0 0 3px rgba(255,213,74,.12);}
    textarea.dropActive{ border-color: rgba(109,215,255,.7); box-shadow:0 0 0 3px rgba(109,215,255,.14); }

    .btn{
      flex:0 0 auto;
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 14px;
      background:rgba(255,255,255,.04);
      color:var(--text);
      cursor:pointer;
      font-weight:700;
      font-size:12px;
      height:42px;
      box-sizing:border-box;
      white-space:nowrap;
    }
    .btn[disabled]{opacity:.55; cursor:not-allowed;}

    @media (max-width: 520px){
      .personaSelect{min-width: 160px;}
      .personaHint{display:none;}
      .attachChip .name{ max-width: 58vw; }
    }
    @media (max-width: 420px){
      .composer .box{flex-direction:column; align-items:stretch;}
      .btn{width:100%;}
      .attachBtn{ width:100%; }
      .personaRow{flex-direction:column; align-items:stretch;}
      .personaRow .left{justify-content:space-between;}
      .personaSelect{max-width:100%; width:100%;}
      .attachChip .name{ max-width: 78vw; }
    }

    /* Thinking indicator */
    .thinking{
      display:flex;
      align-items:center;
      gap:10px;
      margin-top:6px;
      color: var(--muted);
      font-size:12px;
      user-select:none;
    }
    .dots{
      display:inline-flex;
      gap:5px;
      align-items:center;
      height: 10px;
    }
    .dots i{
      width:7px; height:7px;
      border-radius:50%;
      background: rgba(230,238,252,.55);
      display:block;
      animation: bounce 1.05s infinite ease-in-out;
    }
    .dots i:nth-child(2){animation-delay: .15s;}
    .dots i:nth-child(3){animation-delay: .30s;}
    @keyframes bounce{
      0%, 80%, 100% { transform: translateY(0); opacity:.45; }
      40% { transform: translateY(-5px); opacity:1; }
    }

    .chat::-webkit-scrollbar{width:10px}
    .chat::-webkit-scrollbar-thumb{background:rgba(255,255,255,.10); border-radius:999px}
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="brand">
        <img src="/assets/icons/MarksAI.png" alt="Marks" onerror="this.style.opacity=.4;" />
        <div class="stack">
          <b>Marks</b>
          <span id="subtitle">LM socket proxy chat</span>
        </div>
      </div>
      <span class="pill">
        <span class="dot bad" id="statusDot"></span>
        <span id="statusText">Disconnected</span>
      </span>
    </header>

    <main class="chat" id="chat"></main>

    <footer class="composer" id="composer">
      <div class="personaRow">
        <div class="left">
          <span class="personaLabel">Persona</span>
          <span class="personaWrap">
            <select class="personaSelect" id="personaSelect">
              <option value="field">Field Assistant</option>
              <option value="legal">Legal Expert</option>
            </select>
          </span>
        </div>
        <div class="personaHint" id="personaHint">Loadingâ€¦</div>
      </div>

      <div class="attachRow" id="attachRow" aria-label="Attachments"></div>

      <div class="box">
        <button class="attachBtn" id="btnAttach" type="button" aria-label="Attach file" title="Attach file">+</button>
        <input id="filePicker" type="file" multiple hidden
               accept=".txt,.md,.csv,.tsv,.json,.geojson,.xml,.yml,.yaml,.log,.ini,.cfg,.py,.js,.ts,.html,.css,.sql,.wkt,.wkb,.gml,.dxf,.fld" />
        <textarea id="input" placeholder="Message Marksâ€¦ (Shift+Enter for newline)"></textarea>
        <button class="btn" id="btnSend">Send</button>
      </div>
    </footer>
  </div>

  <script>
    const WS_URL = "wss://record-of-survey-795c317ace89.herokuapp.com/ws/lmproxy";

    // Base instructions injected BEFORE persona
    const BASE_INSTRUCTIONS_URL = "/config/base-instructions.json";

    const PERSONAS = {
      field: { key: "field", label: "Field Assistant", url: "/config/personas/marks-field.json" },
      legal: { key: "legal", label: "Legal Expert", url: "/config/personas/marks-legal.json" }
    };
    const PERSONA_STORAGE_KEY = "marks.persona.key";

    // ---- Deep-link Quick Q&A ----
    const DEEPLINK_HASH = "#deeplink";
    const DEEPLINK_Q_KEY = "marks.deeplink.question";
    const DEEPLINK_AUTOSEND = true;
    let pendingDeepLinkQuestion = null;

    function readDeepLinkQuestionIfAny() {
      if (location.hash !== DEEPLINK_HASH) return null;
      const q = localStorage.getItem(DEEPLINK_Q_KEY);
      if (q && String(q).trim()) {
        localStorage.removeItem(DEEPLINK_Q_KEY);
        return String(q).trim();
      }
      return null;
    }
    // ----------------------------

    // ---- Attachments injection wrapper + helper ----
    const ATTACHMENT_ONLY_HELPER = "Analyze the attached file(s).";
    const MAX_ATTACH_FILES = 6;
    const MAX_ATTACH_BYTES_EACH = 2_000_000;   // 2 MB per file
    const MAX_ATTACH_CHARS_EACH = 220_000;     // clip huge text

    const ATTACH_WRAP_START = "<<<ATTACHMENTS>>>";
    const ATTACH_WRAP_END   = "<<<END_ATTACHMENTS>>>";

    let attachments = []; // [{id, name, type, size, text, clipped}]
    // ----------------------------

    let ws = null;
    let keepalive = null;

    let helloSent = false;
    let handshakeOk = false;

    let inflight = null; // { id, raw, contentEl, thinkingEl, scheduled }

    // âœ… NEW: Base/persona are now arrays of messages (not one system blob)
    let baseSeedMessages = [];    // [{role, content}, ...]
    let personaSeedMessages = []; // [{role, content}, ...]

    const history = [];           // seeded with base+persona, then conversation
    const HISTORY_MAX = 24;

    const $ = (id) => document.getElementById(id);

    if (window.marked) {
      marked.setOptions({ gfm: true, breaks: true, mangle: false, headerIds: false });
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function wrapTables(html) {
      return html.replace(/<table([\s\S]*?)>([\s\S]*?)<\/table>/g, (m, attrs, inner) => {
        return `<div class="table-wrap"><table${attrs}>${inner}</table></div>`;
      });
    }

    // If streaming code fences are unbalanced, temporarily close them so marked can render <pre><code>
    function closeOpenCodeFences(md) {
      const s = String(md || "");
      const fenceCount = (s.match(/```/g) || []).length;
      if (fenceCount % 2 === 1) return s + "\n```";
      return s;
    }

    function renderMarkdownToHtml(mdText) {
      const md = closeOpenCodeFences(mdText);
      if (!window.marked) return escapeHtml(md).replace(/\n/g, "<br/>");
      let html = marked.parse(md || "");
      html = wrapTables(html);
      if (window.DOMPurify) {
        // sanitize as HTML only â€” SVG is rendered from code blocks via our SVG sanitizer.
        return DOMPurify.sanitize(html, {
          USE_PROFILES: { html: true },
          ADD_TAGS: ["table","thead","tbody","tr","th","td","div"],
          ADD_ATTR: ["colspan","rowspan","align","class"]
        });
      }
      return html;
    }

    function setStatus(kind, text) {
      $("statusDot").className = "dot " + (kind || "bad");
      $("statusText").textContent = text || "";
      $("subtitle").textContent = (kind === "ok") ? "Connected" : (kind === "warn") ? "Connectingâ€¦" : "LM socket proxy chat";
    }

    function scrollBottom() {
      $("chat").scrollTop = $("chat").scrollHeight;
    }

    function humanBytes(n) {
      const v = Number(n);
      if (!Number.isFinite(v) || v <= 0) return "0 B";
      const u = ["B","KB","MB","GB"];
      let i = 0, x = v;
      while (x >= 1024 && i < u.length - 1) { x /= 1024; i++; }
      return `${(i === 0 ? x : x.toFixed(1))} ${u[i]}`;
    }

    // USER bubble header: "You" only (id in tooltip)
    function addUserMsg(id, text, attachList = []) {
      const wrap = document.createElement("div");
      wrap.className = "msg user";

      const metaRow = document.createElement("div");
      metaRow.className = "meta";
      metaRow.title = `id=${id}`;
      metaRow.innerHTML = `<span class="role">You</span>`;

      const body = document.createElement("pre");
      body.className = "plain";
      body.textContent = text || "";

      wrap.appendChild(metaRow);
      wrap.appendChild(body);

      if (attachList && attachList.length) {
        const row = document.createElement("div");
        row.className = "attachRow";
        attachList.forEach((a) => {
          const chip = document.createElement("span");
          chip.className = "attachChip";
          chip.title = `${a.name} â€¢ ${humanBytes(a.size)}${a.clipped ? " â€¢ clipped" : ""}`;
          chip.innerHTML = `<span class="ico">ðŸ“Ž</span><span class="name">${escapeHtml(a.name)}</span>`;
          row.appendChild(chip);
        });
        wrap.appendChild(row);
      }

      $("chat").appendChild(wrap);
      scrollBottom();
    }

    // ASSISTANT bubble header: "Marks" only (id in tooltip)
    function addAssistantPlaceholder(id) {
      const wrap = document.createElement("div");
      wrap.className = "msg assistant";

      const metaRow = document.createElement("div");
      metaRow.className = "meta";
      metaRow.title = `id=${id}`;
      metaRow.innerHTML = `<span class="role">Marks</span>`;

      const thinkingEl = document.createElement("div");
      thinkingEl.className = "thinking";
      thinkingEl.innerHTML = `<span>Thinking</span><span class="dots"><i></i><i></i><i></i></span>`;

      const contentEl = document.createElement("div");
      contentEl.className = "md";
      contentEl.style.display = "none";

      wrap.appendChild(metaRow);
      wrap.appendChild(thinkingEl);
      wrap.appendChild(contentEl);

      $("chat").appendChild(wrap);
      scrollBottom();

      return { wrap, thinkingEl, contentEl };
    }

    function showAssistantErrorInline(id, message) {
      if (inflight && inflight.id === id) {
        inflight.thinkingEl.style.display = "none";
        inflight.contentEl.style.display = "";
        inflight.contentEl.innerHTML = renderMarkdownToHtml(`**ERROR:** ${message}`);
        progressiveInlineSvgsFromCodeBlocks(inflight.contentEl);
        inlineSvgsFromCodeBlocks(inflight.contentEl);
        scrollBottom();
        inflight = null;
        setUiBusy(false);
        return;
      }
      const p = addAssistantPlaceholder(id);
      p.thinkingEl.style.display = "none";
      p.contentEl.style.display = "";
      p.contentEl.innerHTML = renderMarkdownToHtml(`**ERROR:** ${message}`);
      progressiveInlineSvgsFromCodeBlocks(p.contentEl);
      inlineSvgsFromCodeBlocks(p.contentEl);
      scrollBottom();
    }

    function setUiBusy(busy, hintText) {
      $("btnSend").disabled = !!busy;
      $("personaSelect").disabled = !!busy;
      $("btnAttach").disabled = !!busy;
      if (typeof hintText === "string") $("personaHint").textContent = hintText;
    }

    function newId() {
      return (crypto && crypto.randomUUID) ? crypto.randomUUID() : ("req-" + Math.random().toString(16).slice(2));
    }

    function wsSend(obj) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return false;
      ws.send(JSON.stringify(obj));
      return true;
    }

    function startKeepalive() {
      stopKeepalive();
      keepalive = setInterval(() => wsSend({ type: "ping", ts: Date.now() }), 25000);
    }
    function stopKeepalive() {
      if (keepalive) clearInterval(keepalive);
      keepalive = null;
    }

    function sendHello(force = false) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      if (helloSent && !force) return;
      wsSend({ type: "hello", client_id: "marks-ui", role: "ui", ts: Date.now() });
      helloSent = true;
      handshakeOk = false;
    }

    // ==========================
    // âœ… NEW: Use *all* messages[]
    // ==========================
    const ALLOWED_ROLES = new Set(["system", "user", "assistant"]); // keep proxy-compatible

    function normalizeRole(role, fallback = "system") {
      const r = String(role || "").toLowerCase();
      return ALLOWED_ROLES.has(r) ? r : fallback;
    }

    function coerceContentToString(content) {
      if (typeof content === "string") return content;
      // Handle "content parts" style: [{type:'text', text:'...'}, ...]
      if (Array.isArray(content)) {
        return content.map(p => {
          if (!p) return "";
          if (typeof p === "string") return p;
          if (typeof p.text === "string") return p.text;
          return "";
        }).join("");
      }
      if (content == null) return "";
      if (typeof content === "number" || typeof content === "boolean") return String(content);
      try { return JSON.stringify(content, null, 2); } catch { return String(content); }
    }

    // Accepts:
    //  - string => [{role:'system', content:string}]
    //  - {messages:[...]} => all items in order
    //  - {role, content} => one message
    //  - {system/system_prompt/...} => one system message
    //  - otherwise => system message with JSON stringified
    function normalizeConfigToMessages(json, fallbackRole = "system") {
      // string
      if (typeof json === "string") {
        const c = json.trim();
        return c ? [{ role: fallbackRole, content: c }] : [];
      }
      // object
      if (json && typeof json === "object") {
        // messages array => USE ALL
        if (Array.isArray(json.messages)) {
          const msgs = json.messages
            .filter(m => m && typeof m === "object")
            .map(m => {
              const role = normalizeRole(m.role, fallbackRole);
              const content = coerceContentToString(m.content).trim();
              return content ? { role, content } : null;
            })
            .filter(Boolean);

          if (msgs.length) return msgs;
        }

        // direct role/content
        if (typeof json.role === "string" && "content" in json) {
          const role = normalizeRole(json.role, fallbackRole);
          const content = coerceContentToString(json.content).trim();
          return content ? [{ role, content }] : [];
        }

        // common prompt keys => single system
        const candidates = [
          json.system,
          json.system_prompt,
          json.systemPrompt,
          json.prompt,
          json.content,
          json.instructions
        ].filter(v => typeof v === "string" && v.trim().length);

        if (candidates.length) return [{ role: fallbackRole, content: candidates[0].trim() }];

        // fallback stringified
        const s = JSON.stringify(json, null, 2);
        return s && s.trim() ? [{ role: fallbackRole, content: s }] : [];
      }

      // other => string
      const s = String(json ?? "").trim();
      return s ? [{ role: fallbackRole, content: s }] : [];
    }

    function seedLen() {
      return (baseSeedMessages?.length || 0) + (personaSeedMessages?.length || 0);
    }

    function reseedHistory() {
      history.length = 0;
      if (baseSeedMessages && baseSeedMessages.length) history.push(...baseSeedMessages);
      if (personaSeedMessages && personaSeedMessages.length) history.push(...personaSeedMessages);
    }

    function trimHistory() {
      const keep = seedLen();
      while (history.length > keep + HISTORY_MAX) history.splice(keep, 1);
    }

    // ---- Loading base + persona ----

    async function loadBaseInstructions() {
      setUiBusy(true, "Loading base instructionsâ€¦");
      const resp = await fetch(BASE_INSTRUCTIONS_URL, { cache: "no-store" });
      if (!resp.ok) throw new Error(`base instructions fetch failed: ${resp.status} ${resp.statusText}`);
      const json = await resp.json();

      const msgs = normalizeConfigToMessages(json, "system");
      if (!msgs.length) throw new Error("base instructions empty (no usable messages)");

      baseSeedMessages = msgs;
    }

    async function loadPersona(key) {
      const p = PERSONAS[key] || PERSONAS.field;
      setUiBusy(true, `Loading: ${p.label}â€¦`);
      try {
        if (!baseSeedMessages.length) await loadBaseInstructions();

        const resp = await fetch(p.url, { cache: "no-store" });
        if (!resp.ok) throw new Error(`persona fetch failed: ${resp.status} ${resp.statusText}`);
        const json = await resp.json();

        const msgs = normalizeConfigToMessages(json, "system");
        if (!msgs.length) throw new Error("persona empty (no usable messages)");

        personaSeedMessages = msgs;

        // Reset conversation history but keep base+persona seed messages (ALL of them)
        reseedHistory();
        inflight = null;

        localStorage.setItem(PERSONA_STORAGE_KEY, p.key);
        setUiBusy(false, `Active: ${p.label}`);

        const id = "persona-" + Math.random().toString(16).slice(2, 8);
        const a = addAssistantPlaceholder(id);
        a.thinkingEl.style.display = "none";
        a.contentEl.style.display = "";
        a.contentEl.innerHTML = renderMarkdownToHtml(`Persona loaded: **${p.label}**\n\nSeed messages: base **${baseSeedMessages.length}**, persona **${personaSeedMessages.length}**.`);
        progressiveInlineSvgsFromCodeBlocks(a.contentEl);
        inlineSvgsFromCodeBlocks(a.contentEl);

        maybeTryDeepLinkSend();
      } catch (e) {
        setUiBusy(false, `Persona load failed`);
        showAssistantErrorInline("persona", `persona load failed â€” ${e?.message || String(e)}`);
      }
    }

    function connect() {
      helloSent = false;
      handshakeOk = false;
      inflight = null;

      setStatus("warn", "Connectingâ€¦");
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        setStatus("ok", "Connected");
        startKeepalive();
        sendHello(false);
      };

      ws.onclose = () => {
        stopKeepalive();
        setStatus("bad", "Disconnected");
        ws = null;
        inflight = null;
        setUiBusy(false);
      };

      ws.onerror = () => setStatus("bad", "Socket error");

      ws.onmessage = (ev) => {
        let msg;
        try { msg = JSON.parse(ev.data); } catch { return; }

        const type = String(msg?.type || "");
        if (type === "ping") { wsSend({ type: "pong", ts: Date.now() }); return; }
        if (type === "pong") return;

        if (type === "server_hello") { if (!helloSent) sendHello(false); return; }
        if (type === "hello_ack") {
          handshakeOk = true;
          maybeTryDeepLinkSend();
          return;
        }

        const id = String(msg?.id || "");

        if (type === "started") return;

        if (type === "delta") {
          const delta = (msg.delta || "");
          if (!inflight || inflight.id !== id) {
            const p = addAssistantPlaceholder(id);
            inflight = { id, raw: "", contentEl: p.contentEl, thinkingEl: p.thinkingEl, scheduled: false };
          }
          inflight.raw += delta;

          if (!inflight.scheduled) {
            inflight.scheduled = true;
            requestAnimationFrame(() => {
              if (!inflight) return;
              inflight.thinkingEl.style.display = "none";
              inflight.contentEl.style.display = "";
              inflight.contentEl.innerHTML = renderMarkdownToHtml(inflight.raw);

              progressiveInlineSvgsFromCodeBlocks(inflight.contentEl);

              scrollBottom();
              inflight.scheduled = false;
            });
          }
          return;
        }

        if (type === "done") {
          const finalText = msg.message || "";
          if (!inflight || inflight.id !== id) {
            const p = addAssistantPlaceholder(id);
            p.thinkingEl.style.display = "none";
            p.contentEl.style.display = "";
            p.contentEl.innerHTML = renderMarkdownToHtml(finalText);
            progressiveInlineSvgsFromCodeBlocks(p.contentEl);
            inlineSvgsFromCodeBlocks(p.contentEl);
          } else {
            inflight.raw = finalText || inflight.raw;
            inflight.thinkingEl.style.display = "none";
            inflight.contentEl.style.display = "";
            inflight.contentEl.innerHTML = renderMarkdownToHtml(inflight.raw);

            progressiveInlineSvgsFromCodeBlocks(inflight.contentEl);
            inlineSvgsFromCodeBlocks(inflight.contentEl);
          }

          history.push({ role: "assistant", content: finalText || (inflight ? inflight.raw : "") });
          trimHistory();

          inflight = null;
          setUiBusy(false);
          scrollBottom();
          return;
        }

        if (type === "error") {
          const err = msg?.error?.message || msg?.message || "unknown error";
          showAssistantErrorInline(id || "error", err);

          if (String(err).toLowerCase().includes("must send hello")) {
            helloSent = false;
            sendHello(true);
          }

          inflight = null;
          setUiBusy(false);
          return;
        }
      };
    }

    // -------- Attachments UI --------

    function renderAttachRow() {
      const row = $("attachRow");
      row.replaceChildren();

      if (!attachments.length) return;

      attachments.forEach((a) => {
        const chip = document.createElement("span");
        chip.className = "attachChip";
        chip.title = `${a.name} â€¢ ${humanBytes(a.size)}${a.clipped ? " â€¢ clipped" : ""}`;
        chip.innerHTML = `
          <span class="ico">ðŸ“Ž</span>
          <span class="name">${escapeHtml(a.name)}</span>
          <button class="x" type="button" aria-label="Remove attachment">Ã—</button>
        `;
        chip.querySelector(".x").addEventListener("click", () => {
          attachments = attachments.filter(x => x.id !== a.id);
          renderAttachRow();
        });
        row.appendChild(chip);
      });
    }

    function isLikelyTextFile(file) {
      const type = (file?.type || "").toLowerCase();
      if (type.startsWith("text/")) return true;
      if (type === "application/json" || type === "application/xml" || type === "image/svg+xml") return true;
      if (type === "application/vnd.geo+json") return true;
      const name = (file?.name || "").toLowerCase();
      return /\.(txt|md|csv|tsv|json|geojson|xml|yml|yaml|log|ini|cfg|py|js|ts|html|css|sql|wkt|gml|dxf|fld)$/i.test(name);
    }

    function guessFenceLang(name, type) {
      const n = (name || "").toLowerCase();
      const t = (type || "").toLowerCase();
      if (t.includes("json") || n.endsWith(".json") || n.endsWith(".geojson")) return "json";
      if (t.includes("xml") || n.endsWith(".xml") || n.endsWith(".gml") || n.endsWith(".svg")) return "xml";
      if (n.endsWith(".csv")) return "csv";
      if (n.endsWith(".tsv")) return "tsv";
      if (n.endsWith(".yml") || n.endsWith(".yaml")) return "yaml";
      if (n.endsWith(".sql")) return "sql";
      if (n.endsWith(".html")) return "html";
      if (n.endsWith(".css")) return "css";
      if (n.endsWith(".js")) return "javascript";
      if (n.endsWith(".ts")) return "typescript";
      if (n.endsWith(".py")) return "python";
      return "";
    }

    function buildAttachmentsInjectionBlock(list) {
      if (!list || !list.length) return "";

      let out = `\n\n${ATTACH_WRAP_START}\n`;
      for (const a of list) {
        const lang = guessFenceLang(a.name, a.type);
        const head = `FILE: ${a.name}\nTYPE: ${a.type || "unknown"}\nSIZE: ${a.size}\n${a.clipped ? "NOTE: content was clipped\n" : ""}`;
        out += `\n${head}CONTENT:\n\`\`\`${lang}\n${a.text || ""}\n\`\`\`\n`;
      }
      out += `\n${ATTACH_WRAP_END}\n`;
      return out;
    }

    async function addFiles(files) {
      const list = Array.from(files || []);
      if (!list.length) return;

      const room = Math.max(0, MAX_ATTACH_FILES - attachments.length);
      const incoming = list.slice(0, room);

      for (const f of incoming) {
        if (!isLikelyTextFile(f)) {
          showAssistantErrorInline("attach", `Only text-based files are supported right now. Skipped: ${f.name}`);
          continue;
        }
        if (f.size > MAX_ATTACH_BYTES_EACH) {
          showAssistantErrorInline("attach", `File too large (max ${humanBytes(MAX_ATTACH_BYTES_EACH)}). Skipped: ${f.name}`);
          continue;
        }

        let text = "";
        try { text = await f.text(); }
        catch {
          showAssistantErrorInline("attach", `Could not read file. Skipped: ${f.name}`);
          continue;
        }

        let clipped = false;
        if (text.length > MAX_ATTACH_CHARS_EACH) {
          text = text.slice(0, MAX_ATTACH_CHARS_EACH) + `\n\n[...clipped at ${MAX_ATTACH_CHARS_EACH} chars...]`;
          clipped = true;
        }

        attachments.push({
          id: newId(),
          name: f.name || "attachment",
          type: f.type || "",
          size: f.size || 0,
          text,
          clipped
        });
      }

      renderAttachRow();

      if (list.length > incoming.length) {
        showAssistantErrorInline("attach", `Attachment limit: ${MAX_ATTACH_FILES} files. Extra files were ignored.`);
      }
    }

    // -------- SVG rendering from code blocks (progressive + final) --------

    function looksLikeSvg(s) {
      const t = String(s || "").trim();
      return t.startsWith("<svg") || (t.startsWith("<?xml") && t.includes("<svg"));
    }

    function sanitizeSvgToFragment(svgText) {
      const raw = String(svgText || "").trim();
      if (!raw) return null;

      const parser = new DOMParser();
      const doc = parser.parseFromString(raw, "image/svg+xml");
      const svg = doc.documentElement;

      if (!svg || svg.nodeName.toLowerCase() !== "svg") return null;
      if (svg.querySelector("parsererror")) return null;

      svg.querySelectorAll("script, foreignObject, iframe, object, embed").forEach(n => n.remove());

      svg.querySelectorAll("*").forEach((el) => {
        Array.from(el.attributes || []).forEach((attr) => {
          const name = String(attr.name || "").toLowerCase();
          const value = String(attr.value || "");
          if (name.startsWith("on")) el.removeAttribute(attr.name);
          if (name === "href" || name === "xlink:href") {
            const v = value.trim();
            if (v && !v.startsWith("#")) el.removeAttribute(attr.name);
          }
        });
      });

      const frag = document.createDocumentFragment();
      frag.appendChild(document.importNode(svg, true));
      return frag;
    }

    const svgPreToFrame = new WeakMap();

    function bestEffortSvgMarkup(svgText) {
      let s = String(svgText || "").trim();
      if (!s.startsWith("<svg") && !(s.startsWith("<?xml") && s.includes("<svg"))) return null;

      const svgStart = s.indexOf("<svg");
      if (svgStart > 0) s = s.slice(svgStart);

      const lastLt = s.lastIndexOf("<");
      const lastGt = s.lastIndexOf(">");
      if (lastLt > lastGt) s = s.slice(0, lastLt);

      if (!s.includes("</svg>")) s += "\n</svg>";
      return s;
    }

    function renderSvgIntoFrame(frameEl, svgMarkup) {
      const frag = sanitizeSvgToFragment(svgMarkup);
      if (!frag) return false;
      const probe = frag.querySelector ? frag.querySelector("svg") : null;
      if (!probe) return false;

      frameEl.textContent = "";
      frameEl.innerHTML = "";
      frameEl.appendChild(frag);
      return true;
    }

    function progressiveInlineSvgsFromCodeBlocks(containerEl) {
      if (!containerEl) return;

      const codeEls = containerEl.querySelectorAll("pre > code");
      codeEls.forEach((code) => {
        const raw = (code.textContent || "").trim();
        if (!raw) return;
        if (!looksLikeSvg(raw)) return;

        const pre = code.closest("pre");
        if (!pre) return;

        let frame = svgPreToFrame.get(pre);
        if (!frame) {
          frame = document.createElement("div");
          frame.className = "svgFrame";
          frame.textContent = "Rendering SVGâ€¦";
          pre.style.display = "none";
          pre.parentNode.insertBefore(frame, pre.nextSibling);
          svgPreToFrame.set(pre, frame);
        } else {
          pre.style.display = "none";
        }

        const lenKey = String(raw.length);
        if (frame.dataset.lastLen === lenKey) return;
        frame.dataset.lastLen = lenKey;

        const markup = bestEffortSvgMarkup(raw);
        if (!markup) return;

        const ok = renderSvgIntoFrame(frame, markup);
        if (!ok) frame.textContent = "Rendering SVGâ€¦";
      });
    }

    function inlineSvgsFromCodeBlocks(containerEl) {
      if (!containerEl) return;

      const codeEls = containerEl.querySelectorAll("pre > code");
      codeEls.forEach((code) => {
        const svgText = (code.textContent || "").trim();
        if (!looksLikeSvg(svgText)) return;

        const pre = code.closest("pre");
        if (!pre) return;

        const existingFrame = svgPreToFrame.get(pre);
        if (existingFrame) {
          const frag = sanitizeSvgToFragment(svgText);
          if (frag) {
            existingFrame.textContent = "";
            existingFrame.innerHTML = "";
            existingFrame.appendChild(frag);
          }
          pre.remove();
          return;
        }

        const frag = sanitizeSvgToFragment(svgText);
        if (!frag) return;

        const frame = document.createElement("div");
        frame.className = "svgFrame";
        frame.appendChild(frag);

        pre.replaceWith(frame);
      });
    }

    // -------- Send logic --------

    function sendChatText(text, attachList = []) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      if (!handshakeOk) {
        showAssistantErrorInline("ui", "not ready (hello handshake pending).");
        sendHello(false);
        return;
      }
      if (!baseSeedMessages.length) {
        showAssistantErrorInline("ui", "base instructions not loaded yet.");
        return;
      }
      if (!personaSeedMessages.length) {
        showAssistantErrorInline("ui", "persona not loaded yet.");
        return;
      }
      if (inflight) {
        showAssistantErrorInline("ui", "wait for Marks to finish (or add queueing).");
        return;
      }

      let userText = String(text || "").trim();
      if (!userText && attachList && attachList.length) userText = ATTACHMENT_ONLY_HELPER;
      if (!userText && (!attachList || !attachList.length)) return;

      const injection = buildAttachmentsInjectionBlock(attachList);
      const messageToModel = userText + (injection || "");

      const id = newId();

      addUserMsg(id, userText, attachList);

      history.push({ role: "user", content: messageToModel });
      trimHistory();

      const p = addAssistantPlaceholder(id);
      inflight = { id, raw: "", contentEl: p.contentEl, thinkingEl: p.thinkingEl, scheduled: false };

      setUiBusy(true, $("personaHint").textContent || "");

      const payload = {
        type: "chat",
        id,
        body: {
          messages: history.slice(),
          temperature: 0.2,
          max_tokens: 4096,
          stream: true
        }
      };

      requestAnimationFrame(() => {
        const ok = wsSend(payload);
        if (!ok) {
          showAssistantErrorInline(id, "socket not open");
          inflight = null;
          setUiBusy(false);
        }
      });
    }

    function sendChat() {
      const userText = $("input").value.trim();
      const attachList = attachments.slice();

      if (!userText && !attachList.length) return;

      $("input").value = "";
      $("input").focus();

      attachments = [];
      renderAttachRow();

      sendChatText(userText, attachList);
    }

    function maybeTryDeepLinkSend() {
      if (!pendingDeepLinkQuestion) return;

      const seedReady = !!(baseSeedMessages.length && personaSeedMessages.length);
      const wsReady = !!(ws && ws.readyState === WebSocket.OPEN);
      if (!seedReady || !wsReady || !handshakeOk) return;

      const q = pendingDeepLinkQuestion;
      pendingDeepLinkQuestion = null;

      $("input").value = q;
      $("input").focus();

      if (DEEPLINK_AUTOSEND) sendChat();
    }

    // -------- Wire UI events --------

    $("btnSend").onclick = sendChat;
    $("input").addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendChat(); }
    });

    $("personaSelect").addEventListener("change", async (e) => {
      await loadPersona(e.target.value);
    });

    $("btnAttach").addEventListener("click", () => $("filePicker").click());
    $("filePicker").addEventListener("change", async (e) => {
      await addFiles(e.target.files);
      e.target.value = ""; // allow reselect same file
    });

    const dropTargets = [$("composer"), $("input")];
    dropTargets.forEach((el) => {
      el.addEventListener("dragover", (e) => {
        e.preventDefault();
        $("input").classList.add("dropActive");
      });
      el.addEventListener("dragleave", () => {
        $("input").classList.remove("dropActive");
      });
      el.addEventListener("drop", async (e) => {
        e.preventDefault();
        $("input").classList.remove("dropActive");
        const files = e.dataTransfer?.files;
        if (files && files.length) await addFiles(files);
      });
    });

    // -------- Boot --------

    (async function boot(){
      pendingDeepLinkQuestion = readDeepLinkQuestionIfAny();

      const saved = localStorage.getItem(PERSONA_STORAGE_KEY);
      const key = (saved && PERSONAS[saved]) ? saved : "field";
      $("personaSelect").value = key;

      try {
        await loadBaseInstructions();
      } catch (e) {
        showAssistantErrorInline("base", `base instructions load failed â€” ${e?.message || String(e)}`);
      }

      await loadPersona(key);

      // Ensure history is seeded even if loadPersona didn't run due to errors
      if (!history.length && (baseSeedMessages.length || personaSeedMessages.length)) reseedHistory();

      connect();
      maybeTryDeepLinkSend();
    })();
  </script>
</body>
</html>
