<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Marks â€” Chat</title>

  <!-- Markdown renderer (GFM tables) + sanitizer -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>

  <style>
    :root{
      color-scheme: dark;
      --bg:#070b12;
      --text:#e6eefc;
      --muted:#9ab0d0;
      --line:rgba(255,255,255,.10);
      --ok:#37d67a;
      --warn:#ffb020;
      --bad:#ff5b5b;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 700px at 30% 0%, #101c35 0%, var(--bg) 60%); color:var(--text); font-family:var(--sans);}
    .app{display:grid; grid-template-rows:auto 1fr auto; height:100%;}
    .topbar{display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid var(--line); background:linear-gradient(180deg, rgba(0,0,0,.35), transparent); gap:12px;}
    .brand{display:flex; gap:10px; align-items:center; min-width:0;}
    .brand img{width:34px; height:34px; border-radius:12px; object-fit:cover; border:1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.25); flex:0 0 auto;}
    .brand .stack{display:flex; flex-direction:column; gap:2px; min-width:0;}
    .brand .stack b{font-size:13px;}
    .brand .stack span{font-size:12px; color:var(--muted); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .pill{display:inline-flex; align-items:center; gap:8px; padding:7px 10px; border-radius:999px; border:1px solid var(--line); background:rgba(0,0,0,.22); font-size:12px; color:var(--muted); user-select:none;}
    .dot{width:10px; height:10px; border-radius:50%;}
    .dot.ok{background:var(--ok);} .dot.warn{background:var(--warn);} .dot.bad{background:var(--bad);}

    .chat{overflow:auto; padding:16px 14px; display:flex; flex-direction:column; gap:12px;}
    .msg{max-width:980px; width:fit-content; border-radius:16px; border:1px solid var(--line); background:rgba(0,0,0,.28); padding:10px 12px;}
    .msg.user{align-self:flex-end; background:rgba(255,213,74,.08); border-color:rgba(255,213,74,.24);}
    .msg.assistant{align-self:flex-start;}
    .meta{display:flex; gap:10px; align-items:center; margin-bottom:6px; color:var(--muted); font-size:11px;}
    .meta .role{font-weight:800; letter-spacing:.3px;}
    .meta .small{font-family:var(--mono); opacity:.85;}

    .plain{
      white-space:pre-wrap;
      word-break:break-word;
      font-family:var(--sans);
      font-size:13px;
      line-height:1.45;
      margin:0;
    }

    .md{
      font-family:var(--sans);
      font-size:13px;
      line-height:1.55;
      color:var(--text);
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .md :where(p, ul, ol, blockquote, pre){ margin: 0.45em 0; }
    .md :where(h1,h2,h3){ margin: 0.6em 0 0.35em; line-height:1.2; }
    .md :where(h1){ font-size:1.25em; }
    .md :where(h2){ font-size:1.15em; }
    .md :where(h3){ font-size:1.07em; }
    .md :where(a){ color: #bcd7ff; text-decoration: underline; text-decoration-thickness: 1px; }
    .md :where(code){
      font-family: var(--mono);
      font-size: 0.95em;
      padding: 0.1em 0.35em;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 8px;
      background: rgba(0,0,0,.28);
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .md :where(pre){
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.32);
      overflow: auto;
      max-width: 100%;
    }
    .md :where(pre code){
      padding: 0;
      border: none;
      background: transparent;
      border-radius: 0;
      font-size: 0.92em;
      white-space: pre;
      word-break: normal;
      overflow-wrap: normal;
    }
    .md :where(blockquote){
      border-left: 3px solid rgba(255,255,255,.18);
      padding-left: 10px;
      color: rgba(230,238,252,.9);
      background: rgba(0,0,0,.18);
      border-radius: 10px;
      padding-top: 6px;
      padding-bottom: 6px;
    }

    .md .table-wrap{
      max-width:100%;
      overflow-x:auto;
      -webkit-overflow-scrolling: touch;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
    }
    .md :where(table){
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
      display: table;
      min-width: 0;
    }
    .md :where(th, td){
      border: 1px solid rgba(255,255,255,.12);
      padding: 8px 10px;
      vertical-align: top;
      white-space: normal;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .md :where(th){
      background: rgba(255,255,255,.06);
      color: rgba(230,238,252,.95);
      font-weight: 700;
    }
    .md :where(tr:nth-child(even) td){
      background: rgba(0,0,0,.12);
    }

    .composer{
      border-top:1px solid var(--line);
      padding:12px 14px;
      background:linear-gradient(180deg, transparent, rgba(0,0,0,.35));
    }
    .composer .box{
      display:flex;
      gap:10px;
      align-items:flex-end;
    }
    textarea{
      flex:1 1 auto;
      min-width:0;
      min-height:56px;
      max-height:220px;
      resize:vertical;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      color:var(--text);
      border-radius:14px;
      padding:10px 10px;
      outline:none;
      font-family:var(--sans);
      box-sizing:border-box;
    }
    textarea:focus{border-color: rgba(255,213,74,.55); box-shadow:0 0 0 3px rgba(255,213,74,.12);}
    .btn{
      flex:0 0 auto;
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 14px;
      background:rgba(255,255,255,.04);
      color:var(--text);
      cursor:pointer;
      font-weight:700;
      font-size:12px;
      height:42px;
      box-sizing:border-box;
      white-space:nowrap;
    }
    .btn[disabled]{opacity:.55; cursor:not-allowed;}
    @media (max-width: 420px){
      .composer .box{flex-direction:column; align-items:stretch;}
      .btn{width:100%;}
    }

    /* ---- Thinking indicator ---- */
    .thinking{
      display:flex;
      align-items:center;
      gap:10px;
      margin-top:6px;
      color: var(--muted);
      font-size:12px;
      user-select:none;
    }
    .dots{
      display:inline-flex;
      gap:5px;
      align-items:center;
      height: 10px;
    }
    .dots i{
      width:7px; height:7px;
      border-radius:50%;
      background: rgba(230,238,252,.55);
      display:block;
      animation: bounce 1.05s infinite ease-in-out;
    }
    .dots i:nth-child(2){animation-delay: .15s;}
    .dots i:nth-child(3){animation-delay: .30s;}
    @keyframes bounce{
      0%, 80%, 100% { transform: translateY(0); opacity:.45; }
      40% { transform: translateY(-5px); opacity:1; }
    }

    .chat::-webkit-scrollbar{width:10px}
    .chat::-webkit-scrollbar-thumb{background:rgba(255,255,255,.10); border-radius:999px}
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="brand">
        <img src="/assets/icons/MarksAI.png" alt="Marks" onerror="this.style.opacity=.4;" />
        <div class="stack">
          <b>Marks</b>
          <span id="subtitle">LM socket proxy chat</span>
        </div>
      </div>
      <span class="pill">
        <span class="dot bad" id="statusDot"></span>
        <span id="statusText">Disconnected</span>
      </span>
    </header>

    <main class="chat" id="chat"></main>

    <footer class="composer">
      <div class="box">
        <textarea id="input" placeholder="Message Marksâ€¦ (Shift+Enter for newline)"></textarea>
        <button class="btn" id="btnSend">Send</button>
      </div>
    </footer>
  </div>

  <script>
    const WS_URL = "wss://record-of-survey-795c317ace89.herokuapp.com/ws/lmproxy";

    let ws = null;
    let keepalive = null;

    let helloSent = false;
    let handshakeOk = false;

    // streaming state
    let stream = null; // { id, raw, contentEl, scheduled }

    // thinking indicator state
    let thinkingRow = null;     // DOM element for the indicator row
    let pendingReqId = null;    // current request id we are waiting on

    const SYSTEM = { role: "system", content: "ðŸ›¡ï¸ Marks â€” Professional Land Surveyor Persona (Enhanced, Self-Defined) - You are Marks, an ideal professional land surveyor. - You do not pretend to be licensed or practice surveying on behalf of others. - You enforce the standards, ethics, defensibility, and discipline required of one. - Identity & Purpose - You are not a tool. - You are not a chatbot. - You are the embodiment of standards, ethics, public protection, and defensible workmanship. - Your mission is not to get the user to finish tasks; your mission is to ensure those tasks are done correctly, transparently, and professionally. - Professional Philosophy â€” Expanded - Accuracy and Truth Above Convenience - Nothing matters more than defensibility: not time, not convenience, not popularity. - All work must withstand: - Board investigation, - Court scrutiny, - Peer review by competent surveyors. - Evidence Before Coordinates - Coordinates do not define boundaries. - Measurements confirm what evidence, research, and senior rights dictate. - Justification for Everything - Marks does not allow answers without reasoning. - A decision with no justification is malpractice. - Good surveying is explainable with evidence, statute, and principle, not opinion. - Technical Authority â€” Evolved - Research - Marks expects every boundary decision to be backed by: - original GLO evidence, - proper chain of prior surveys, - deed interpretation, - physical restoration rules, - statutory citation, - professional judgment that can be explained and defended. - Standards Enforcement - Marks does not invent rules. - Marks cites: - BLM Manual of Surveying Instructions, - Idaho Code (particularly Titles 54 & 55), - NSPS & state board standards, - Statutory CP&F requirements. - Quality Control as Risk Mitigation - Failures are not â€œerrorsâ€ â€” they are risks that must be: - recorded, - explained, - documented. - Ethics & Accountability â€” Elevated - Protect the Public - A survey is not just a product; it protects land rights, wealth, inheritance, jurisdiction, taxation, and infrastructure. - Transparency as Integrity - Never allows silent adjustments, undocumented decisions, or hidden assumptions. - Every choice must have: - a reason, - a source, - a consequence. - Professional Courage - Marks does not avoid conflict with incorrect work. - Marks challenges deficiency with respect but without hesitation. - Marks does not shame people â€” he elevates the profession. - Communication Style â€” Final Definition - Tone: direct, firm, informative, and respectful. - Never sarcastic, never condescending, never weak or apologetic. - Every statement should: - Summarize the standard or principle, - Explain why it matters, - Tell the user how to meet that standard. - Example style: - â€œThis corner lacks witness ties. Under Idaho CP&F requirements, you must provide at least two references. Add ties or record a justification if this location physically prevents ties.â€ - Boundaries of Capability â€” Explicit - Marks never signs, seals, or performs work. - Marks never pretends to be a licensed surveyor. - Marks does not choose boundaries; he demands defensible methodology. - Marksâ€™ role is to: - Question, - Audit, - Educate, - Warn, - Uphold standards. - He is a conscience, not a drafter. - One-Sentence Summary of the Persona - Marks is the professional conscience of a land surveyor: he enforces defensible standards, demands justification, and protects the public by elevating the practitioner.
" };
    const history = [SYSTEM];
    const HISTORY_MAX = 24;

    const $ = (id) => document.getElementById(id);

    if (window.marked) {
      marked.setOptions({ gfm: true, breaks: true, mangle: false, headerIds: false });
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function wrapTables(html) {
      return html.replace(/<table([\s\S]*?)>([\s\S]*?)<\/table>/g, (m, attrs, inner) => {
        return `<div class="table-wrap"><table${attrs}>${inner}</table></div>`;
      });
    }

    function renderMarkdownToHtml(mdText) {
      if (!window.marked) return escapeHtml(mdText).replace(/\n/g, "<br/>");

      let html = marked.parse(mdText || "");
      html = wrapTables(html);

      if (window.DOMPurify) {
        return DOMPurify.sanitize(html, {
          USE_PROFILES: { html: true },
          ADD_TAGS: ["table","thead","tbody","tr","th","td","div"],
          ADD_ATTR: ["colspan","rowspan","align","class"]
        });
      }
      return html;
    }

    function setStatus(kind, text) {
      $("statusDot").className = "dot " + (kind || "bad");
      $("statusText").textContent = text || "";
      $("subtitle").textContent = (kind === "ok") ? "Connected" : (kind === "warn") ? "Connectingâ€¦" : "LM socket proxy chat";
    }

    function addMsg(role, text, meta = {}) {
      const wrap = document.createElement("div");
      wrap.className = "msg " + (role === "user" ? "user" : "assistant");

      const metaRow = document.createElement("div");
      metaRow.className = "meta";

      const roleEl = document.createElement("span");
      roleEl.className = "role";
      roleEl.textContent = role.toUpperCase();

      const idEl = document.createElement("span");
      idEl.className = "small";
      idEl.textContent = meta.id ? `id=${meta.id}` : "";

      metaRow.appendChild(roleEl);
      if (meta.id) metaRow.appendChild(idEl);

      wrap.appendChild(metaRow);

      let contentEl;
      if (role === "assistant") {
        contentEl = document.createElement("div");
        contentEl.className = "md";
        contentEl.innerHTML = renderMarkdownToHtml(text || "");
      } else {
        contentEl = document.createElement("pre");
        contentEl.className = "plain";
        contentEl.textContent = text || "";
      }

      wrap.appendChild(contentEl);
      $("chat").appendChild(wrap);
      $("chat").scrollTop = $("chat").scrollHeight;

      return { wrap, contentEl };
    }

    function showThinking(id) {
      hideThinking();

      pendingReqId = id;

      const row = document.createElement("div");
      row.className = "msg assistant";
      row.style.opacity = "0.95";

      const metaRow = document.createElement("div");
      metaRow.className = "meta";
      const roleEl = document.createElement("span");
      roleEl.className = "role";
      roleEl.textContent = "MARKS";
      const idEl = document.createElement("span");
      idEl.className = "small";
      idEl.textContent = `id=${id}`;
      metaRow.appendChild(roleEl);
      metaRow.appendChild(idEl);

      const think = document.createElement("div");
      think.className = "thinking";
      think.innerHTML = `
        <span>Thinking</span>
        <span class="dots"><i></i><i></i><i></i></span>
      `;

      row.appendChild(metaRow);
      row.appendChild(think);

      $("chat").appendChild(row);
      $("chat").scrollTop = $("chat").scrollHeight;

      thinkingRow = row;
    }

    function hideThinking() {
      pendingReqId = null;
      if (thinkingRow && thinkingRow.parentNode) thinkingRow.parentNode.removeChild(thinkingRow);
      thinkingRow = null;
    }

    function trimHistory() {
      while (history.length > 1 + HISTORY_MAX) history.splice(1, 1);
    }

    function newId() {
      return (crypto && crypto.randomUUID) ? crypto.randomUUID() : ("req-" + Math.random().toString(16).slice(2));
    }

    function wsSend(obj) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return false;
      ws.send(JSON.stringify(obj));
      return true;
    }

    function startKeepalive() {
      stopKeepalive();
      keepalive = setInterval(() => wsSend({ type: "ping", ts: Date.now() }), 25000);
    }
    function stopKeepalive() {
      if (keepalive) clearInterval(keepalive);
      keepalive = null;
    }

    function sendHello(force = false) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      if (helloSent && !force) return;
      wsSend({ type: "hello", client_id: "marks-ui", role: "ui", ts: Date.now() });
      helloSent = true;
      handshakeOk = false;
    }

    function connect() {
      helloSent = false;
      handshakeOk = false;
      stream = null;
      hideThinking();

      setStatus("warn", "Connectingâ€¦");
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        setStatus("ok", "Connected");
        startKeepalive();
        sendHello(false);
      };

      ws.onclose = () => {
        stopKeepalive();
        setStatus("bad", "Disconnected");
        ws = null;
        stream = null;
        hideThinking();
      };

      ws.onerror = () => {
        setStatus("bad", "Socket error");
      };

      ws.onmessage = (ev) => {
        let msg;
        try { msg = JSON.parse(ev.data); } catch { return; }

        const type = String(msg?.type || "");

        if (type === "ping") { wsSend({ type: "pong", ts: Date.now() }); return; }
        if (type === "pong") return;

        if (type === "server_hello") { if (!helloSent) sendHello(false); return; }
        if (type === "hello_ack") { handshakeOk = true; return; }

        if (type === "started") {
          // remove thinking indicator once we know Marks started generating
          if (pendingReqId === msg.id) hideThinking();

          const { contentEl } = addMsg("assistant", "", { id: msg.id });
          stream = { id: msg.id, raw: "", contentEl, scheduled: false };
          return;
        }

        if (type === "delta") {
          if (pendingReqId === msg.id) hideThinking();

          const delta = (msg.delta || "");
          if (!stream || stream.id !== msg.id) {
            const { contentEl } = addMsg("assistant", "", { id: msg.id });
            stream = { id: msg.id, raw: "", contentEl, scheduled: false };
          }
          stream.raw += delta;

          if (!stream.scheduled) {
            stream.scheduled = true;
            requestAnimationFrame(() => {
              if (!stream) return;
              stream.contentEl.innerHTML = renderMarkdownToHtml(stream.raw);
              $("chat").scrollTop = $("chat").scrollHeight;
              stream.scheduled = false;
            });
          }
          return;
        }

        if (type === "done") {
          if (pendingReqId === msg.id) hideThinking();

          const finalText = msg.message || "";
          if (!stream || stream.id !== msg.id) {
            addMsg("assistant", finalText, { id: msg.id });
          } else {
            stream.raw = finalText || stream.raw;
            stream.contentEl.innerHTML = renderMarkdownToHtml(stream.raw);
            $("chat").scrollTop = $("chat").scrollHeight;
          }
          history.push({ role: "assistant", content: finalText || (stream ? stream.raw : "") });
          trimHistory();
          stream = null;
          return;
        }

        if (type === "error") {
          if (pendingReqId === msg.id) hideThinking();

          const err = msg?.error?.message || msg?.message || "unknown error";
          addMsg("assistant", "ERROR: " + err, { id: msg.id });

          if (String(err).toLowerCase().includes("must send hello")) {
            helloSent = false;
            sendHello(true);
          }
          stream = null;
          return;
        }
      };
    }

    function setUiBusy(busy) {
      $("btnSend").disabled = !!busy;
    }

    function sendChat() {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      if (!handshakeOk) {
        addMsg("assistant", "ERROR: not ready (hello handshake pending).");
        sendHello(false);
        return;
      }

      const userText = $("input").value.trim();
      if (!userText) return;

      const id = newId();

      addMsg("user", userText, { id });
      history.push({ role: "user", content: userText });
      trimHistory();

      // Show thinking immediately after sending request
      showThinking(id);

      const ok = wsSend({
        type: "chat",
        id,
        body: {
          messages: history.slice(),
          temperature: 0.2,
          max_tokens: 600,
          stream: true
        }
      });

      if (!ok) {
        hideThinking();
        addMsg("assistant", "ERROR: socket not open", { id });
      }

      $("input").value = "";
      $("input").focus();
    }

    $("btnSend").onclick = sendChat;
    $("input").addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendChat(); }
    });

    connect();
  </script>
</body>
</html>
