<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Ada County ROS / Parcel / PLSS Lookup (Standalone)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- pdf.js (UMD build defining window.pdfjsLib) -->
  <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>

  <style>
    :root{
      --bg:#0b1020;
      --panel:#101834;
      --panel2:#0e1630;
      --text:#e7ecff;
      --muted:#b6c0ff;
      --line:rgba(255,255,255,.12);
      --good:#24d18f;
      --warn:#ffcc66;
      --bad:#ff5a7a;
      --btn:#2a3dff;
      --btn2:#1a255f;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:var(--sans)}
    a{color:#9ab0ff;text-decoration:none}
    a:hover{text-decoration:underline}

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    header{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0));
    }
    header .title{font-weight:700;letter-spacing:.2px;}
    header .subtitle{color:var(--muted);font-size:12px;}

    .main{
      flex:1;
      min-height:0;
      display:grid;
      grid-template-columns: 430px 1fr;
      gap:10px;
      padding:10px;
    }
    @media (max-width: 980px){
      .main{grid-template-columns:1fr; grid-template-rows: 460px 1fr;}
    }

    .panel{
      background:rgba(255,255,255,.03);
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .panel .phead{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background:rgba(255,255,255,.03);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex:0 0 auto;
    }
    .panel .phead .h{font-weight:700;font-size:13px;}

    /* IMPORTANT: make panel bodies expand so Leaflet has real height */
    .panel .pbody{
      padding:12px;
      overflow:auto;
      min-height:0;
      flex:1 1 auto;   /* <-- KEY FIX */
    }

    .row{display:flex;gap:10px;align-items:center}
    .row.wrap{flex-wrap:wrap}
    label{font-size:12px;color:var(--muted)}
    input[type="text"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.2);
      color:var(--text);
      outline:none;
    }
    input[type="file"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px dashed var(--line);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      outline:none;
    }
    button{
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg, rgba(42,61,255,.9), rgba(26,37,95,.9));
      color:white;
      font-weight:700;
      cursor:pointer;
      white-space:nowrap;
    }
    button.secondary{
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--text);
      font-weight:600;
    }
    button:disabled{opacity:.5;cursor:not-allowed}

    .small{font-size:12px;color:var(--muted)}
    .mono{font-family:var(--mono);font-size:12px}
    .hr{height:1px;background:var(--line);margin:10px 0}

    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:5px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.2);
      font-size:12px;
      color:var(--muted);
      margin:2px 6px 2px 0;
    }
    .pill .dot{width:8px;height:8px;border-radius:99px;background:var(--muted);opacity:.9}
    .pill.good .dot{background:var(--good)}
    .pill.warn .dot{background:var(--warn)}
    .pill.bad  .dot{background:var(--bad)}

    .hint{
      padding:10px;
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:12px;
    }

    .log{
      font-family:var(--mono);
      font-size:12px;
      line-height:1.35;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
      white-space:pre-wrap;
      overflow-wrap:anywhere;
      word-break:break-word;
      max-height:260px;
      overflow:auto;
    }

    .list{display:flex;flex-direction:column;gap:10px;}
    .card{
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(0,0,0,.14);
      overflow:hidden;
    }
    .card .chead{
      padding:10px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:flex-start;
    }
    .card .cbody{padding:10px;}
    .kv{
      display:grid;
      grid-template-columns: 130px 1fr;
      gap:6px 10px;
      font-size:12px;
      color:var(--muted);
    }
    .kv div:nth-child(2n){
      color:var(--text);
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Right side: ensure map gets height */
    .rightBody{
      padding:0 !important;
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden; /* prevent nested scrollbars */
    }
    .mapWrap{
      flex:1 1 auto;
      min-height:320px; /* <-- map always has real height */
      position:relative;
    }
    #map{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      border-radius:12px;
    }
    @media (max-width: 980px){
      .mapWrap{min-height:420px;}
    }

    .summaryPanel{
      margin:10px;
      border-radius:12px;
      flex:0 0 auto;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      overflow:hidden;
    }
    .summaryPanel .phead{background:rgba(255,255,255,.03);}
    .summaryPanel .pbody{max-height:280px;}
  </style>
</head>

<body>
<div class="app">
  <header>
    <div>
      <div class="title">Ada County Survey Context Lookup (Standalone)</div>
      <div class="subtitle">Address → Parcel → Subdivision / Section / Township + nearby ROS (JSONP, no CORS failures)</div>
    </div>
    <div class="row">
      <span class="pill good"><span class="dot"></span>ArcGIS JSONP</span>
      <span class="pill warn"><span class="dot"></span>PDFs require upload (CORS)</span>
    </div>
  </header>

  <div class="main">
    <!-- LEFT -->
    <div class="panel">
      <div class="phead">
        <div class="h">Lookup</div>
        <div class="row">
          <button id="btnLookup">Lookup</button>
          <button id="btnClear" class="secondary">Clear</button>
        </div>
      </div>
      <div class="pbody">
        <label for="addr">Address (Ada County, ID)</label>
        <input id="addr" type="text" placeholder="e.g. 5707 W Castle Dr, Boise ID" value="5707 W Castle Dr, Boise ID"/>

        <div class="row wrap" style="margin-top:10px">
          <div class="pill" title="ExternalMap MapServer">
            <span class="dot"></span>Service: External/ExternalMap
          </div>
          <div class="pill" title="Parcel query uses point+distance">
            <span class="dot"></span>Parcel: layer 24
          </div>
          <div class="pill" title="Address layer is 16">
            <span class="dot"></span>Address: layer 16
          </div>
        </div>

        <div class="hr"></div>

        <div class="hint">
          <b>Map not displaying fix:</b> This file forces the map container to have height and calls
          <span class="mono">map.invalidateSize()</span> on load, after lookup, and on resize.
        </div>

        <div class="hr"></div>

        <div class="phead" style="padding:0;border:0;background:transparent;justify-content:flex-start">
          <div class="h">PDF Basis of Bearing (local upload)</div>
        </div>
        <div class="small" style="margin:6px 0 10px">
          Automatic PDF download is usually blocked by CORS. Download the ROS PDF and upload it here.
        </div>
        <input id="pdfFile" type="file" accept="application/pdf"/>
        <button id="btnScanPdf" class="secondary" style="width:100%;margin-top:10px">Scan Uploaded PDF</button>
        <div id="pdfFindings" class="log" style="margin-top:10px;display:none"></div>

        <div class="hr"></div>

        <div class="phead" style="padding:0;border:0;background:transparent;justify-content:flex-start">
          <div class="h">Diagnostics</div>
        </div>
        <div id="log" class="log" style="margin-top:10px"></div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="panel">
      <div class="phead">
        <div class="h">Map + Results</div>
        <div class="row">
          <button id="btnExportGeo" class="secondary" disabled>Export GeoJSON</button>
          <button id="btnExportParcelCSV" class="secondary" disabled title="Exports unique parcel, subdivision, and section vertices as P,N,E,Z,D in EPSG:2243 (ID West ftUS)">Export Unique Parcel/Subdivision/Section CSV (IDW ft)</button>
        </div>
      </div>

      <div class="pbody rightBody">
        <div class="mapWrap">
          <div id="map"></div>
        </div>

        <div class="summaryPanel">
          <div class="phead"><div class="h">Summary</div></div>
          <div class="pbody" style="padding:12px;overflow:auto">
            <div id="summary" class="list"></div>
          </div>
        </div>
      </div>
    </div>

  </div>
</div>

<script type="module">
import { lookupByAddress, findParcelNearPoint as fetchParcelNearPoint, loadAliquotsAtPoint, loadSubdivisionAtPoint, buildRosPdfProxyUrl } from "./src/browser-survey-client.js";
import { buildUniquePolygonCsvRowsPNEZD } from "./src/ros-export.js";

(() => {
  // -----------------------------
  // Configuration (Ada County)
  // -----------------------------
  const BASE = "https://adacountyassessor.org/arcgis/rest/services/External/ExternalMap/MapServer";
  const LAYERS = {
    address: 16,
    ros: 17,
    subdivisions: 18,
    townships: 19,
    sections: 20,
    parcels: 24,
  };

  // EPSG:2243 (NAD83 / Idaho West ftUS) for export.
  // We do NOT client-project; we request outSR=2243 from the server (no CORS via JSONP).
  const EXPORT_OUT_SR = 2243;

  // Ada County CP&F record lookup (used when clicking corner markers).
  const ADA_PORTAL_BASE = "https://gisprod.adacounty.id.gov/arcgis";
  const ADA_CPF_WEBMAP_ITEM_ID = "019521c7932442f0b4b581f641cbf236";
  const ADA_CPF_PDF_BASE = "https://gisprod.adacounty.id.gov/apps/acdscpf/CpfPdfs/";

  // pdf.js worker
  if (!window.pdfjsLib) {
    alert("pdf.js failed to load (pdfjsLib missing). Check network access.");
  } else {
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
  }

  // -----------------------------
  // UI helpers
  // -----------------------------
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  function ts() {
    const d = new Date();
    return d.toISOString().replace("T"," ").replace("Z","");
  }
  function log(line, kind="info") {
    const prefix = kind === "bad" ? "✖" : kind === "warn" ? "⚠" : "•";
    logEl.textContent += `[${ts()}] ${prefix} ${line}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function clearLog() { logEl.textContent = ""; }

  // -----------------------------
  // JSONP for ArcGIS (no CORS)
  // -----------------------------
  function toQuery(params) {
    const parts = [];
    for (const [k,v] of Object.entries(params)) {
      if (v === undefined || v === null) continue;
      parts.push(encodeURIComponent(k) + "=" + encodeURIComponent(String(v)));
    }
    return parts.join("&");
  }

  function arcJsonp(url, params, timeoutMs=20000) {
    return new Promise((resolve, reject) => {
      const cb = "__arc_cb_" + Math.random().toString(36).slice(2);
      const script = document.createElement("script");
      const timer = setTimeout(() => {
        cleanup();
        reject(new Error("JSONP timeout"));
      }, timeoutMs);

      function cleanup() {
        clearTimeout(timer);
        try { delete window[cb]; } catch {}
        if (script.parentNode) script.parentNode.removeChild(script);
      }

      window[cb] = (data) => {
        cleanup();
        resolve(data);
      };

      const fullParams = Object.assign({}, params, { f: "json", callback: cb });
      script.src = url + (url.includes("?") ? "&" : "?") + toQuery(fullParams);
      script.onerror = () => {
        cleanup();
        reject(new Error("JSONP script load failed"));
      };
      document.head.appendChild(script);
    });
  }

  async function arcQuery(layerId, params) {
    const url = `${BASE}/${layerId}/query`;
    const data = await arcJsonp(url, params);
    if (data && data.error) {
      const msg = data.error.message || "ArcGIS error";
      throw new Error(`${msg}${data.error.details ? " :: " + data.error.details.join(" | ") : ""}`);
    }
    return data;
  }

  // -----------------------------
  // CP&F corner record lookup helpers
  // -----------------------------
  let cpfLayerInfo = null;
  let cpfLayerInfoPromise = null;

  function canonicalizeUrl(url) {
    try {
      const u = new URL(url);
      u.hash = '';
      return `${u.origin}${u.pathname}`.toLowerCase() + (u.search ? u.search.toLowerCase() : '');
    } catch {
      return String(url || '').trim().toLowerCase();
    }
  }

  function pickField(attrs, layerMeta, patterns) {
    const keys = Object.keys(attrs || {});
    const fields = layerMeta?.fields || [];
    for (const re of patterns) {
      const key = keys.find((k) => re.test(k));
      if (key) return key;
      const field = fields.find((f) => re.test(f.name || '') || re.test(f.alias || ''));
      if (field && attrs[field.name] !== undefined) return field.name;
    }
    return null;
  }

  function buildCpfPdfLinks(instrument, maybeUrl, maybeFileName) {
    const out = [];
    const seen = new Set();

    function add(url) {
      if (!url) return;
      const text = String(url).trim();
      if (!text) return;
      const key = canonicalizeUrl(text);
      if (seen.has(key)) return;
      seen.add(key);
      out.push(text);
    }

    if (maybeUrl) {
      const text = String(maybeUrl).trim();
      if (/^https?:\/\//i.test(text)) add(text);
      else if (/\.pdf$/i.test(text)) add(ADA_CPF_PDF_BASE + text.replace(/^\/+/, ''));
    }

    if (maybeFileName) {
      const text = String(maybeFileName).trim();
      if (/^https?:\/\//i.test(text)) add(text);
      else if (/\.pdf$/i.test(text)) add(ADA_CPF_PDF_BASE + text.replace(/^\/+/, ''));
      else add(ADA_CPF_PDF_BASE + encodeURIComponent(text) + '.pdf');
    }

    if (instrument != null && instrument !== '') {
      add(ADA_CPF_PDF_BASE + encodeURIComponent(String(instrument).trim()) + '.pdf');
    }

    return out;
  }

  async function discoverAdaCpfLayerViaJsonp() {
    const itemDataUrl = `${ADA_PORTAL_BASE}/sharing/rest/content/items/${ADA_CPF_WEBMAP_ITEM_ID}/data`;
    const webmap = await arcJsonp(itemDataUrl, { f: 'pjson' }, 25000);

    const candidates = [];
    function walk(entries) {
      if (!Array.isArray(entries)) return;
      for (const entry of entries) {
        if (entry?.url) candidates.push(entry.url);
        if (entry?.layers) walk(entry.layers);
      }
    }
    walk(webmap?.operationalLayers);
    if (!candidates.length) throw new Error('CP&F web map has no operational layer URLs.');

    async function readMeta(url) {
      return arcJsonp(String(url).replace(/\?+.*$/, ''), { f: 'pjson' }, 25000);
    }
    function hasInstrumentField(fields = []) {
      return fields.some((f) => /instr|instrument/i.test(f.name || '') || /instr|instrument/i.test(f.alias || ''));
    }

    for (const baseUrlRaw of candidates) {
      const baseUrl = String(baseUrlRaw).replace(/\/+$/, '');
      const meta = await readMeta(baseUrl).catch(() => null);
      if (!meta) continue;

      if (Array.isArray(meta.layers) && meta.layers.length) {
        for (const layer of meta.layers) {
          const layerUrl = `${baseUrl}/${layer.id}`;
          const layerMeta = await readMeta(layerUrl).catch(() => null);
          if (!layerMeta) continue;
          if (/esriGeometryPoint/i.test(layerMeta.geometryType || '') && hasInstrumentField(layerMeta.fields || [])) {
            return { layerUrl, layerMeta };
          }
        }
      }

      if (/esriGeometryPoint/i.test(meta.geometryType || '') && hasInstrumentField(meta.fields || [])) {
        return { layerUrl: baseUrl, layerMeta: meta };
      }
    }

    throw new Error('Could not identify CP&F point layer with instrument fields.');
  }

  async function ensureCpfLayerInfo() {
    if (cpfLayerInfo) return cpfLayerInfo;
    if (!cpfLayerInfoPromise) {
      cpfLayerInfoPromise = discoverAdaCpfLayerViaJsonp()
        .then((info) => {
          cpfLayerInfo = info;
          return info;
        })
        .finally(() => { cpfLayerInfoPromise = null; });
    }
    return cpfLayerInfoPromise;
  }

  async function queryCpfRecordsNearCorner(lat, lon, maxMeters = 250) {
    const { layerUrl, layerMeta } = await ensureCpfLayerInfo();
    const radii = [5, 10, 25, 50, 100, 150, maxMeters];

    for (const radius of radii) {
      const payload = await arcJsonp(`${layerUrl.replace(/\/+$/, '')}/query`, {
        f: 'pjson',
        where: '1=1',
        geometry: { x: lon, y: lat, spatialReference: { wkid: 4326 } },
        geometryType: 'esriGeometryPoint',
        inSR: 4326,
        spatialRel: 'esriSpatialRelIntersects',
        distance: radius,
        units: 'esriSRUnit_Meter',
        outFields: '*',
        returnGeometry: true,
        outSR: 4326,
      }, 25000).catch(() => null);

      const features = payload?.features || [];
      if (!features.length) continue;

      const instrumentKey = pickField(features[0]?.attributes || {}, layerMeta, [/^instrument$/i, /instr/i, /instrument_?no/i, /inst_?no/i]);
      const pdfUrlKey = pickField(features[0]?.attributes || {}, layerMeta, [/pdf/i, /doc/i, /document/i, /hyperlink/i, /url/i, /link/i]);
      const pdfNameKey = pickField(features[0]?.attributes || {}, layerMeta, [/file/i, /filename/i, /pdfname/i]);

      const records = features.map((feature) => {
        const attrs = feature.attributes || {};
        const instrument = instrumentKey ? attrs[instrumentKey] : null;
        const pdfUrl = pdfUrlKey ? attrs[pdfUrlKey] : null;
        const pdfName = pdfNameKey ? attrs[pdfNameKey] : null;
        return {
          instrument,
          links: buildCpfPdfLinks(instrument, pdfUrl, pdfName),
        };
      }).filter((record) => record.links.length);

      if (records.length) return records;
    }

    return [];
  }

  function cpfLinksHtml(records = []) {
    if (!records.length) return '<span class="small">No CP&amp;F PDF links found near this corner.</span>';
    return records.slice(0, 8).map((record, idx) => {
      const instrument = record.instrument != null && String(record.instrument).trim()
        ? escapeHtml(String(record.instrument))
        : `Record ${idx + 1}`;
      const links = record.links.map((url, i) => (
        `<a target="_blank" rel="noopener" href="${escapeHtml(buildRosPdfProxyUrl(url))}">CP&amp;F PDF${record.links.length > 1 ? ` ${i + 1}` : ''}</a>`
      )).join('<br/>');
      return `<div style="margin:6px 0"><b>${instrument}</b><br/>${links}</div>`;
    }).join('');
  }

  // -----------------------------
  // Geometry helpers
  // -----------------------------
  function arcPointToLatLng(g) {
    if (!g) return null;
    return [g.y, g.x];
  }

  function arcPolygonToGeoJSON(geom) {
    return {
      type: "Feature",
      properties: {},
      geometry: {
        type: "Polygon",
        coordinates: (geom?.rings || []).map(ring => ring.map(([x,y]) => [x,y]))
      }
    };
  }

  function arcExtentFromPolygon(geom) {
    const rings = geom?.rings || [];
    let xmin=Infinity,ymin=Infinity,xmax=-Infinity,ymax=-Infinity;
    for (const ring of rings) {
      for (const [x,y] of ring) {
        if (x < xmin) xmin = x;
        if (y < ymin) ymin = y;
        if (x > xmax) xmax = x;
        if (y > ymax) ymax = y;
      }
    }
    if (!isFinite(xmin)) return null;
    return { xmin, ymin, xmax, ymax };
  }

  function centroidOfPolygon(geom) {
    const ring = geom?.rings?.[0] || [];
    if (!ring.length) return null;
    let sx=0, sy=0, n=0;
    for (const [x,y] of ring) { sx += x; sy += y; n++; }
    return { x: sx/n, y: sy/n };
  }

  function haversineMeters(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2-lat1);
    const dLon = toRad(lon2-lon1);
    const a =
      Math.sin(dLat/2)**2 +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.min(1, Math.sqrt(a)));
  }

  function pointInRing(pointXY, ring) {
    let inside = false;
    const [x, y] = pointXY;
    for (let i=0, j=ring.length-1; i<ring.length; j=i++) {
      const xi = ring[i][0], yi = ring[i][1];
      const xj = ring[j][0], yj = ring[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-30) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function pointInPolygon(pointXY, geom) {
    const rings = geom?.rings || [];
    if (!rings.length) return false;
    if (!pointInRing(pointXY, rings[0])) return false;
    for (let i=1; i<rings.length; i++) {
      if (pointInRing(pointXY, rings[i])) return false;
    }
    return true;
  }

  function normalizedAliquotLabel(feature, sectionFeature) {
    const attrs = feature?.attributes || {};
    if (attrs.ALIQUOT) return String(attrs.ALIQUOT).toUpperCase();

    const ring = feature?.geometry?.rings?.[0] || [];
    const secRing = sectionFeature?.geometry?.rings?.[0] || [];
    if (!ring.length || !secRing.length) return 'ALIQUOT';

    const center = centroidOfPolygon(feature.geometry);
    if (!center) return 'ALIQUOT';

    let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
    for (const [x, y] of secRing) {
      xmin = Math.min(xmin, x);
      ymin = Math.min(ymin, y);
      xmax = Math.max(xmax, x);
      ymax = Math.max(ymax, y);
    }
    if (!isFinite(xmin) || !isFinite(ymin) || !isFinite(xmax) || !isFinite(ymax)) return 'ALIQUOT';

    const nx = (center.x - xmin) / Math.max(1e-9, xmax - xmin);
    const ny = (center.y - ymin) / Math.max(1e-9, ymax - ymin);

    const h = nx >= 0.5 ? 'E' : 'W';
    const v = ny >= 0.5 ? 'N' : 'S';
    return `${v}${h}`;
  }

  function drawAliquots(aliquotFeatures, sectionFeature) {
    layers.aliquots.clearLayers();
    for (const feature of aliquotFeatures) {
      const gj = arcPolygonToGeoJSON(feature.geometry);
      const label = normalizedAliquotLabel(feature, sectionFeature);
      const layer = L.geoJSON(gj, { style: { color: '#6aa9ff', weight: 1.5, fillOpacity: 0.08 } });
      layer.eachLayer((l) => {
        l.bindPopup(`<b>Aliquot</b><br/>${escapeHtml(label)}`);
        l.on('click', () => {
          state.selectedAliquot = feature;
          log(`Selected aliquot: ${label}`);
        });
      });
      layers.aliquots.addLayer(layer);
    }
  }



  function getPolygonCornerMarkers(feature, role, options = {}) {
    const rings = feature?.geometry?.rings || [];
    const points = [];
    for (let ringIndex = 0; ringIndex < rings.length; ringIndex++) {
      const ring = rings[ringIndex] || [];
      const trimmed = ring.length > 1 && ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]
        ? ring.slice(0, -1)
        : ring;
      for (let vertexIndex = 0; vertexIndex < trimmed.length; vertexIndex++) {
        const vertex = trimmed[vertexIndex];
        const x = Number(vertex[0]);
        const y = Number(vertex[1]);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        points.push({
          east: x,
          north: y,
          label: `${role.toUpperCase()}_CORNER R${ringIndex + 1} V${vertexIndex + 1}`,
          color: options.color || '#ffffff',
        });
      }
    }
    return points;
  }

  function drawCornerMarkers(featuresByRole = []) {
    layers.cornerMarkers.clearLayers();
    for (const entry of featuresByRole) {
      const role = entry.role;
      const featureList = entry.features || [];
      for (const feature of featureList) {
        const corners = getPolygonCornerMarkers(feature, role, entry);
        for (const corner of corners) {
          const marker = L.circleMarker([corner.north, corner.east], {
            radius: 3,
            weight: 1,
            color: '#101834',
            fillColor: corner.color,
            fillOpacity: 0.95,
          });
          marker.bindPopup(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px">Loading CP&amp;F records…</div>`);
          marker.on('click', async () => {
            marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px">Loading CP&amp;F records…</div>`);
            try {
              const cpfRecords = await queryCpfRecordsNearCorner(corner.north, corner.east);
              marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="hr"></div>${cpfLinksHtml(cpfRecords)}`);
              if (cpfRecords.length) log(`Loaded CP&F PDF links for ${role} corner ${corner.label}.`);
              else log(`No CP&F PDF links found for ${role} corner ${corner.label}.`, 'warn');
            } catch (e) {
              marker.setPopupContent(`<b>${escapeHtml(role)} corner</b><br/>${escapeHtml(corner.label)}<div class="small" style="margin-top:6px;color:#ffb3b3">CP&amp;F lookup failed: ${escapeHtml(e.message || e)}</div>`);
              log(`CP&F corner lookup failed: ${e.message || e}`, 'warn');
            }
          });
          layers.cornerMarkers.addLayer(marker);
        }
      }
    }
  }

  // -----------------------------
  // Address parsing
  // -----------------------------
  const DIRS = new Set(["N","S","E","W","NE","NW","SE","SW"]);
  const SUFFIXES = new Set(["ST","AVE","AV","DR","RD","LN","CT","PL","WAY","BLVD","CIR","PKWY","TRL","TER","HWY"]);
  function normalizeSpaces(s){ return (s||"").trim().replace(/\s+/g," "); }

  function parseAddress(raw) {
    raw = normalizeSpaces(raw);
    const parts = raw.split(",").map(s => s.trim()).filter(Boolean);
    const streetPart = parts[0] || "";
    const cityPart = parts[1] || "";

    const toks = streetPart.toUpperCase().split(/\s+/).filter(Boolean);
    const out = { AddNum: null, StPreDir: null, StName: null, StSuffix: null, City: null };

    if (toks.length && /^\d+$/.test(toks[0])) {
      out.AddNum = parseInt(toks[0], 10);
      toks.shift();
    }
    if (toks.length && DIRS.has(toks[0])) {
      out.StPreDir = toks.shift();
    }
    let suffix = null;
    if (toks.length && SUFFIXES.has(toks[toks.length-1])) {
      suffix = toks.pop();
    }
    out.StSuffix = suffix;
    out.StName = toks.length ? toks.join(" ") : null;

    if (cityPart) out.City = cityPart.toUpperCase().split(/\s+/)[0];
    return out;
  }

  // -----------------------------
  // Map setup
  // -----------------------------
  const map = L.map("map", { zoomControl: true });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 20,
    attribution: "&copy; OpenStreetMap contributors"
  }).addTo(map);
  map.setView([43.615, -116.202], 12);

  const layers = {
    address: L.layerGroup().addTo(map),
    parcel: L.layerGroup().addTo(map),
    subdivision: L.layerGroup().addTo(map),
    section: L.layerGroup().addTo(map),
    township: L.layerGroup().addTo(map),
    ros: L.layerGroup().addTo(map),
    aliquots: L.layerGroup().addTo(map),
    cornerMarkers: L.layerGroup().addTo(map),
  };

  function clearMapLayers() {
    Object.values(layers).forEach(g => g.clearLayers());
  }

  // ---- Leaflet display fix helpers ----
  function invalidateMapSoon(reason="") {
    requestAnimationFrame(() => map.invalidateSize());
    setTimeout(() => map.invalidateSize(), 50);
    setTimeout(() => map.invalidateSize(), 250);
    if (reason) log(`map.invalidateSize() (${reason})`);
  }
  window.addEventListener("load", () => invalidateMapSoon("window load"));
  window.addEventListener("resize", () => invalidateMapSoon("window resize"));
  try {
    const ro = new ResizeObserver(() => map.invalidateSize());
    ro.observe($("map"));
    ro.observe(document.querySelector(".mapWrap"));
  } catch {}

  // -----------------------------
  // Results state
  // -----------------------------
  const state = {
    addressFeature: null,
    parcelFeature: null,        // displayed (outSR 4326)
    parcelFeature2243: null,    // export geometry (outSR 2243)
    subdivisionFeature2243: null,
    subdivisionFeature: null,
    sectionFeature: null,
    sectionFeature2243: null,
    townshipFeature: null,
    rosFeatures: [],
    aliquotFeatures: [],
    selectedAliquot: null,
    exportGeoJSON: null,
    lastLonLat: null
  };

  function setSummaryCards(cards) {
    const root = $("summary");
    root.innerHTML = "";
    if (!cards.length) {
      root.innerHTML = `<div class="small">No results yet.</div>`;
      return;
    }
    for (const c of cards) root.appendChild(c);
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replace(/&/g,"&amp;").replace(/</g,"&lt;")
      .replace(/>/g,"&gt;").replace(/"/g,"&quot;")
      .replace(/'/g,"&#039;");
  }

  function card(title, subtitle, kvPairs, links=[]) {
    const el = document.createElement("div");
    el.className = "card";
    const head = document.createElement("div");
    head.className = "chead";
    head.innerHTML = `
      <div>
        <div style="font-weight:800">${escapeHtml(title)}</div>
        <div class="small">${escapeHtml(subtitle || "")}</div>
      </div>
    `;
    const body = document.createElement("div");
    body.className = "cbody";

    const kv = document.createElement("div");
    kv.className = "kv";
    for (const [k,v] of kvPairs) {
      const kdiv = document.createElement("div");
      kdiv.textContent = k;
      const vdiv = document.createElement("div");
      vdiv.innerHTML = v;
      kv.appendChild(kdiv);
      kv.appendChild(vdiv);
    }
    body.appendChild(kv);

    if (links.length) {
      const hr = document.createElement("div");
      hr.className = "hr";
      body.appendChild(hr);
      const ldiv = document.createElement("div");
      ldiv.className = "small";
      ldiv.innerHTML = links.map(h => `• ${h}`).join("<br/>");
      body.appendChild(ldiv);
    }

    el.appendChild(head);
    el.appendChild(body);
    return el;
  }

  // -----------------------------
  // Address lookup
  // -----------------------------
  function buildAddressWhere(p) {
    const clauses = ["1=1"];
    if (p.AddNum != null) clauses.push(`AddNum = ${p.AddNum}`);
    if (p.StName) clauses.push(`UPPER(StName) LIKE '%${p.StName.replace(/'/g,"''")}%'`);
    if (p.StPreDir) clauses.push(`UPPER(StPreDir) = '${p.StPreDir.replace(/'/g,"''")}'`);
    if (p.StSuffix) clauses.push(`UPPER(StSuffix) = '${p.StSuffix.replace(/'/g,"''")}'`);
    if (p.City) clauses.push(`UPPER(CommName) LIKE '%${p.City.replace(/'/g,"''")}%'`);
    return clauses.join(" AND ");
  }

  function scoreAddressCandidate(p, attrs) {
    let s = 0;
    if (p.AddNum != null && attrs.AddNum == p.AddNum) s += 10;
    if (p.StPreDir && String(attrs.StPreDir||"").toUpperCase() === p.StPreDir) s += 4;
    if (p.StSuffix && String(attrs.StSuffix||"").toUpperCase() === p.StSuffix) s += 4;
    if (p.City && String(attrs.CommName||"").toUpperCase().includes(p.City)) s += 2;
    if (p.StName && String(attrs.StName||"").toUpperCase().includes(p.StName.split(" ")[0])) s += 2;
    return s;
  }

  async function findBestAddressFeature(rawAddr) {
    const parsed = parseAddress(rawAddr);
    log(`Parsed address: AddNum=${parsed.AddNum ?? "-"} PreDir=${parsed.StPreDir ?? "-"} StName=${parsed.StName ?? "-"} Suffix=${parsed.StSuffix ?? "-"} City=${parsed.City ?? "-"}`);

    const where = buildAddressWhere(parsed);
    log(`Address query WHERE: ${where}`);

    const resp = await arcQuery(LAYERS.address, {
      where,
      outFields: "*",
      returnGeometry: true,
      outSR: 4326
    });
    const feats = resp?.features || [];
    log(`Address query returned ${feats.length} feature(s).`);
    if (!feats.length) return { best: null, candidates: [] };

    const scored = feats
      .map(f => ({ f, score: scoreAddressCandidate(parsed, f.attributes || {}) }))
      .sort((a,b) => b.score - a.score);

    return { best: scored[0].f, candidates: scored.map(x => x.f) };
  }

  // -----------------------------
  // Parcel query (point+distance)
  // -----------------------------
  async function findParcelNearPoint(lon, lat, outSR=4326) {
    const distances = [0, 10, 30, 150];
    let best = null;

    for (const d of distances) {
      const params = {
        where: "1=1",
        outFields: "*",
        returnGeometry: true,
        outSR,
        geometry: `${lon},${lat}`,
        geometryType: "esriGeometryPoint",
        inSR: 4326,
        spatialRel: "esriSpatialRelIntersects",
      };
      if (d > 0) {
        params.distance = d;
        params.units = "esriSRUnit_Meter";
      }

      log(`Parcel search: point+distance ${d}m (outSR=${outSR})`);
      const resp = await arcQuery(LAYERS.parcels, params);
      const feats = resp?.features || [];
      log(`Parcel candidates @ ${d}m: ${feats.length}`);

      if (feats.length) {
        if (outSR === 4326) {
          const pointXY = [lon, lat];
          const containing = feats.find(f => pointInPolygon(pointXY, f.geometry));
          if (containing) { best = containing; break; }

          let nearest = null;
          let bestDist = Infinity;
          for (const f of feats) {
            const c = centroidOfPolygon(f.geometry);
            if (!c) continue;
            const meters = haversineMeters(lat, lon, c.y, c.x);
            if (meters < bestDist) { bestDist = meters; nearest = f; }
          }
          best = nearest || feats[0];
          break;
        } else {
          best = feats[0];
          break;
        }
      }
    }
    return best;
  }

  async function findContainingPolygon(layerId, lon, lat, searchMeters, outSR = 4326) {
    const resp = await arcQuery(layerId, {
      where: "1=1",
      outFields: "*",
      returnGeometry: true,
      outSR,
      geometry: `${lon},${lat}`,
      geometryType: "esriGeometryPoint",
      inSR: 4326,
      spatialRel: "esriSpatialRelIntersects",
      distance: searchMeters,
      units: "esriSRUnit_Meter"
    });
    const feats = resp?.features || [];
    if (!feats.length) return null;

    const pointXY = [lon, lat];
    const containing = feats.find(f => pointInPolygon(pointXY, f.geometry));
    if (containing) return containing;

    let nearest = null;
    let bestDist = Infinity;
    for (const f of feats) {
      const c = centroidOfPolygon(f.geometry);
      if (!c) continue;
      const meters = haversineMeters(lat, lon, c.y, c.x);
      if (meters < bestDist) { bestDist = meters; nearest = f; }
    }
    return nearest || feats[0];
  }

  async function findRosNearPoint(lon, lat, searchMeters=1600) {
    const resp = await arcQuery(LAYERS.ros, {
      where: "1=1",
      outFields: "*",
      returnGeometry: true,
      outSR: 4326,
      geometry: `${lon},${lat}`,
      geometryType: "esriGeometryPoint",
      inSR: 4326,
      spatialRel: "esriSpatialRelIntersects",
      distance: searchMeters,
      units: "esriSRUnit_Meter"
    });
    return resp?.features || [];
  }

  // -----------------------------
  // Draw
  // -----------------------------
  function formatAddressAttrs(a) {
    const parts = [];
    if (a.AddNum) parts.push(a.AddNum);
    if (a.StPreDir) parts.push(a.StPreDir);
    if (a.StName) parts.push(a.StName);
    if (a.StSuffix) parts.push(a.StSuffix);
    const line1 = parts.join(" ");
    const line2 = [a.CommName, a.State, a.Zip4].filter(Boolean).join(" ");
    return [line1, line2].filter(Boolean).join(", ");
  }

  function drawAddressPoint(f) {
    const ll = arcPointToLatLng(f.geometry);
    if (!ll) return null;
    const m = L.circleMarker(ll, { radius: 7, weight: 2, color: "#ffffff", fillColor: "#2a3dff", fillOpacity: 0.9 });
    m.bindPopup(`<b>Address</b><br/>${escapeHtml(formatAddressAttrs(f.attributes || {}))}`);
    layers.address.addLayer(m);
    return m;
  }

  function drawPolygonFeature(f, group, geojsonOptions, label) {
    const gj = arcPolygonToGeoJSON(f.geometry);
    const layer = L.geoJSON(gj, geojsonOptions);
    layer.bindPopup(`<b>${escapeHtml(label)}</b>`);
    group.addLayer(layer);
    return layer;
  }

  function bestRosLabel(a) {
    const fields = ["RS","ROS","Survey","SurveyNo","SURVEYNO","Book","BOOK","Page","PAGE","Document","DOC","Description","DESC","Name","NAME"];
    const parts = [];
    for (const f of fields) if (a[f]) parts.push(`${f}:${a[f]}`);
    if (parts.length) return parts.slice(0,3).join("  ");
    for (const [k,v] of Object.entries(a||{})) {
      if (typeof v === "string" && v.trim()) return v.trim();
    }
    return "ROS feature";
  }

  function normalizeRosFeatures(rosItems = []) {
    return rosItems
      .map((item) => (item?.feature?.geometry ? item.feature : item))
      .filter((f) => f?.geometry);
  }

  function rosIntersectsSection(rosFeature, sectionFeature) {
    if (!sectionFeature?.geometry) return true;
    const g = rosFeature?.geometry;
    if (!g) return false;
    if (g.x != null && g.y != null) {
      return pointInPolygon([g.x, g.y], sectionFeature.geometry);
    }
    if (g.rings?.length) {
      const c = centroidOfPolygon(g);
      return c ? pointInPolygon([c.x, c.y], sectionFeature.geometry) : false;
    }
    if (g.paths?.[0]?.length) {
      return g.paths[0].some(([x, y]) => pointInPolygon([x, y], sectionFeature.geometry));
    }
    return false;
  }

  function filterRosFeaturesForSection(rosFeatures, sectionFeature) {
    return (rosFeatures || []).filter((feature) => rosIntersectsSection(feature, sectionFeature));
  }

  function summarizeAttrs(attrs) {
    if (!attrs) return [["(no attrs)",""]];
    const picks = [];
    const prefer = ["PARCEL","PIN","RP","AIN","SUB","TOWNSHIP","RANGE","SECTION","BOOK","PAGE","RS","ROS","DOC","URL","PDF","LINK","NAME","DESC"];
    const keys = Object.keys(attrs);
    const used = new Set();

    function add(k) {
      if (used.has(k)) return;
      const v = attrs[k];
      if (v === null || v === undefined || v === "") return;
      used.add(k);
      picks.push([k, escapeHtml(v)]);
    }

    for (const token of prefer) {
      for (const k of keys) {
        if (k.toUpperCase().includes(token)) add(k);
        if (picks.length >= 10) break;
      }
      if (picks.length >= 10) break;
    }
    if (!picks.length) for (const k of keys.slice(0,8)) add(k);
    return picks;
  }

  function findPdfLinks(attrs) {
    const links = [];
    for (const [k,v] of Object.entries(attrs || {})) {
      if (!v) continue;
      const sv = String(v);
      if (/^https?:\/\//i.test(sv) && /\.pdf(\?|$)/i.test(sv)) links.push({ key: k, url: sv });
      if (!/^https?:\/\//i.test(sv) && /\.pdf(\?|$)/i.test(sv)) {
        links.push({ key: k, url: new URL(sv, BASE).toString() });
      }
    }
    const seen = new Set();
    return links.filter(l => (seen.has(l.url) ? false : (seen.add(l.url), true)));
  }

  function buildPdfProxyLinks(attrs, linkText = "Open PDF (API)") {
    const pdfs = findPdfLinks(attrs || {});
    return pdfs.map((p) => (
      `<a target="_blank" rel="noopener" href="${escapeHtml(buildRosPdfProxyUrl(p.url))}">${escapeHtml(linkText)}</a> <span class="small">(${escapeHtml(p.key)})</span>`
    ));
  }

  function buildRosPopupHtml(attrs = {}) {
    const desc = bestRosLabel(attrs);
    const links = buildPdfProxyLinks(attrs, "Open PDF (API)");
    const linkHtml = links.length ? links.map((l, i) => `${i + 1}. ${l}`).join("<br/>") : "No PDF links found";
    return `<b>Record of Survey</b><br/>${escapeHtml(desc)}<div class="hr"></div><div class="small"><b>PDFs</b><br/>${linkHtml}</div>`;
  }

  // -----------------------------
  // Export helpers
  // -----------------------------
  function buildExportGeoJSON() {
    const features = [];

    function pushPolygonFeature(feature, role) {
      if (!feature?.geometry) return;
      const geometry = arcPolygonToGeoJSON(feature.geometry);
      if (!geometry) return;
      features.push({
        type: "Feature",
        properties: {
          role,
          ...(feature.attributes || {})
        },
        geometry
      });
    }

    pushPolygonFeature(state.parcelFeature, "parcel");
    pushPolygonFeature(state.subdivisionFeature, "subdivision");
    pushPolygonFeature(state.sectionFeature, "section");
    pushPolygonFeature(state.townshipFeature, "township");

    for (const feature of state.aliquotFeatures || []) pushPolygonFeature(feature, "aliquot");
    for (const feature of state.rosFeatures || []) pushPolygonFeature(feature, "ros");

    if (state.lastLonLat) {
      features.push({
        type: "Feature",
        properties: { role: "address_point" },
        geometry: { type: "Point", coordinates: [state.lastLonLat.lon, state.lastLonLat.lat] }
      });
    }

    return {
      type: "FeatureCollection",
      metadata: {
        generatedAt: new Date().toISOString(),
        count: features.length
      },
      features
    };
  }

  function downloadJson(obj, filename) {
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  function downloadText(text, filename, mime="text/plain") {
    const blob = new Blob([text], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  async function fetchParcelGeometry2243FromPoint(lon, lat) {
    return fetchParcelNearPoint(lon, lat, EXPORT_OUT_SR, 150);
  }

  async function fetchAliquotsAtPoint(lon, lat, outSR = 4326) {
    const payload = await loadAliquotsAtPoint(lon, lat, outSR);
    return payload?.aliquots || [];
  }

  // -----------------------------
  // PDF Basis of Bearing (upload)
  // -----------------------------
  function extractBasisLines(text) {
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const hits = [];
    const re = /(BASIS\s+OF\s+BEARING|BASIS\s+OF\s+BEARINGS|BEARINGS?\s+ARE\s+BASED\s+ON|BEARINGS?\s+SHOWN\s+HEREON\s+ARE\s+BASED\s+ON)/i;

    for (const ln of lines) if (re.test(ln)) hits.push(ln);

    const context = [];
    for (let i=0; i<lines.length; i++) {
      if (re.test(lines[i])) {
        const start = Math.max(0, i-2);
        const end = Math.min(lines.length, i+5);
        context.push(lines.slice(start, end).join(" "));
      }
    }

    const uniq = (arr) => {
      const s = new Set();
      const out = [];
      for (const x of arr) { const k=x.toUpperCase(); if (!s.has(k)) { s.add(k); out.push(x); } }
      return out;
    };
    return { hits: uniq(hits), context: uniq(context) };
  }

  async function scanUploadedPdf(file) {
    if (!file) throw new Error("No PDF selected.");
    if (!window.pdfjsLib) throw new Error("pdfjsLib missing.");
    const buf = await file.arrayBuffer();
    const doc = await pdfjsLib.getDocument({ data: buf }).promise;
    let fullText = "";
    for (let p=1; p<=doc.numPages; p++) {
      const page = await doc.getPage(p);
      const tc = await page.getTextContent();
      const strings = tc.items.map(it => it.str);
      fullText += strings.join("\n") + "\n";
    }
    return extractBasisLines(fullText);
  }

  // -----------------------------
  // Main flow
  // -----------------------------
  async function doLookup() {
    clearLog();
    $("btnExportGeo").disabled = true;
    $("btnExportParcelCSV").disabled = true;
    state.exportGeoJSON = null;
    state.parcelFeature2243 = null;
    state.subdivisionFeature2243 = null;
    state.aliquotFeatures = [];
    state.sectionFeature2243 = null;
    state.selectedAliquot = null;
    setSummaryCards([]);
    clearMapLayers();

    const rawAddr = $("addr").value.trim();
    if (!rawAddr) { log("Enter an address.", "warn"); return; }

    try {
      log("Lookup started.");
      invalidateMapSoon("lookup start");

      const lookup = await lookupByAddress(rawAddr);
      const addrF = lookup.addressFeature || null;
      const candidates = addrF ? [addrF] : [];
      if (!addrF) {
        log("Address not found in Ada County Address layer (16). Continuing with geocoder coordinates.", "warn");
      }
      state.addressFeature = addrF;

      const lon = lookup.location?.lon ?? addrF?.geometry?.x;
      const lat = lookup.location?.lat ?? addrF?.geometry?.y;
      const addrLL = [lat, lon];
      const addressDisplay = addrF ? formatAddressAttrs(addrF.attributes || {}) : (lookup.geocode?.display || rawAddr);
      log(`Address match: ${addrLL[0].toFixed(7)}, ${addrLL[1].toFixed(7)}`);
      if (addrF) {
        drawAddressPoint(addrF);
      } else {
        const geocodeMarker = L.circleMarker(addrLL, { radius: 7, weight: 2, color: "#ffffff", fillColor: "#2a3dff", fillOpacity: 0.9 });
        geocodeMarker.bindPopup(`<b>Geocoded Address</b><br/>${escapeHtml(addressDisplay)}`);
        layers.address.addLayer(geocodeMarker);
      }

      map.setView(addrLL, 18);
      invalidateMapSoon("after setView");
      state.lastLonLat = { lon, lat };

      const parcel = lookup.parcel;
      if (!parcel) {
        log("Parcel not found near that address point (0/10/30/150m).", "bad");
        setSummaryCards([
          card("Address", addressDisplay,
            [["Lat/Lon", `${lat.toFixed(7)}, ${lon.toFixed(7)}`],["Candidates", String(candidates.length)]],
            [])
        ]);
        invalidateMapSoon("parcel not found");
        return;
      }
      state.parcelFeature = parcel;

      drawPolygonFeature(parcel, layers.parcel, {
        style: () => ({ color: "#24d18f", weight: 3, fillOpacity: 0.08 })
      }, "Parcel");

      const ext = arcExtentFromPolygon(parcel.geometry);
      if (ext) {
        const bounds = L.latLngBounds([ext.ymin, ext.xmin], [ext.ymax, ext.xmax]);
        map.fitBounds(bounds.pad(0.15));
        invalidateMapSoon("after fitBounds");
      }

      const c = centroidOfPolygon(parcel.geometry) || { x: lon, y: lat };
      log(`Parcel centroid: ${c.y.toFixed(7)}, ${c.x.toFixed(7)}`);

      const subdiv = lookup.subdivision || null;
      const section = lookup.section || null;
      const township = lookup.township || null;

      state.subdivisionFeature = subdiv;
      state.sectionFeature = section;
      state.townshipFeature = township;

      try {
        state.aliquotFeatures = await fetchAliquotsAtPoint(lon, lat, 4326);
        drawAliquots(state.aliquotFeatures, section);
        log(`Aliquots loaded: ${state.aliquotFeatures.length}`);
      } catch (e) {
        state.aliquotFeatures = [];
        log(`Aliquot lookup failed: ${e.message || e}`, "warn");
      }

      if (subdiv) drawPolygonFeature(subdiv, layers.subdivision, { style: () => ({ color:"#9ab0ff", weight:2, fillOpacity:0.04 }) }, "Subdivision");
      if (section) drawPolygonFeature(section, layers.section, { style: () => ({ color:"#ffcc66", weight:2, fillOpacity:0.03, dashArray:"6 6" }) }, "Section");
      if (township) drawPolygonFeature(township, layers.township, { style: () => ({ color:"#ff5a7a", weight:2, fillOpacity:0.02, dashArray:"3 8" }) }, "Township");

      drawCornerMarkers([
        { role: "parcel", features: parcel ? [parcel] : [], color: "#24d18f" },
        { role: "subdivision", features: subdiv ? [subdiv] : [], color: "#9ab0ff" },
        { role: "aliquot", features: state.aliquotFeatures || [], color: "#6aa9ff" },
      ]);

      const rosFromLookup = normalizeRosFeatures(lookup.ros || []);
      const ros = filterRosFeaturesForSection(rosFromLookup, section);
      state.rosFeatures = ros;
      log(`ROS in containing section: ${ros.length} (from ${rosFromLookup.length} nearby ROS)`);

      for (const f of ros) {
        const g = f.geometry;
        if (!g) continue;
        if (g.x != null && g.y != null) {
          const m = L.circleMarker([g.y, g.x], { radius: 5, weight: 1.5, color: "#ffffff", fillColor:"#ff5a7a", fillOpacity: .7 });
          m.bindPopup(buildRosPopupHtml(f.attributes || {}));
          layers.ros.addLayer(m);
        } else if (g.paths) {
          const gj = { type:"Feature", properties:{}, geometry:{ type:"LineString", coordinates: g.paths[0].map(([x,y])=>[x,y]) } };
          const l = L.geoJSON(gj, { style:{ color:"#ff5a7a", weight:2 }});
          l.bindPopup(buildRosPopupHtml(f.attributes || {}));
          layers.ros.addLayer(l);
        } else if (g.rings) {
          const gj = arcPolygonToGeoJSON(g);
          const p = L.geoJSON(gj, { style:{ color:"#ff5a7a", weight:2, fillOpacity:0.02 }});
          p.bindPopup(buildRosPopupHtml(f.attributes || {}));
          layers.ros.addLayer(p);
        }
      }

      const cards = [];
      cards.push(card(
        "Address",
        addressDisplay,
        [
          ["Location", `${lat.toFixed(7)}, ${lon.toFixed(7)}`],
          ["Candidates", `${candidates.length}`],
        ],
        []
      ));

      const pAttrs = parcel.attributes || {};
      cards.push(card(
        "Parcel",
        "Parcel feature",
        [
          ["Centroid", `${c.y.toFixed(7)}, ${c.x.toFixed(7)}`],
          ["Attrs", `${Object.keys(pAttrs).length} fields`],
          ["Export", `Unique parcel/subdivision/section CSV in P,N,E,Z,D (EPSG:${EXPORT_OUT_SR}, ID West ftUS)`],
        ],
        []
      ));

      cards.push(card(
        "Aliquots",
        "CPNF-style aliquot lookup",
        [["Count", String(state.aliquotFeatures.length)]],
        []
      ));

      if (state.aliquotFeatures.length) {
        const aliquotCards = state.aliquotFeatures.slice(0, 6).map((f, idx) => {
          const a = f.attributes || {};
          const title = a.ALIQUOT || a.ALIQUOT_LABEL || `Aliquot #${idx + 1}`;
          return card(`Aliquot #${idx + 1}`, title, summarizeAttrs(a), buildPdfProxyLinks(a, "Open Aliquot PDF (API)"));
        });
        cards.push(...aliquotCards);
      }

      if (subdiv) cards.push(card("Subdivision", "Containing feature", summarizeAttrs(subdiv.attributes), []));
      if (section) cards.push(card("Section", "Containing feature", summarizeAttrs(section.attributes), []));
      if (township) cards.push(card("Township", "Containing feature", summarizeAttrs(township.attributes), []));

      if (ros.length) {
        const rosCards = ros.slice(0, 10).map((f, idx) => {
          const a = f.attributes || {};
          return card(`Record of Survey #${idx+1}`, bestRosLabel(a), summarizeAttrs(a), buildPdfProxyLinks(a));
        });
        cards.push(...rosCards);
      } else {
        cards.push(card("Record of Survey", "None within 1600m of parcel centroid", [["Note","Increase search distance in code if needed."]], []));
      }

      setSummaryCards(cards);

      state.exportGeoJSON = buildExportGeoJSON();
      $("btnExportGeo").disabled = false;

      try {
        log(`Fetching parcel/subdivision/section export geometry in EPSG:${EXPORT_OUT_SR}...`);
        state.parcelFeature2243 = await fetchParcelGeometry2243FromPoint(lon, lat);
        state.subdivisionFeature2243 = await loadSubdivisionAtPoint(lon, lat, EXPORT_OUT_SR);
        state.sectionFeature2243 = await findContainingPolygon(LAYERS.sections, lon, lat, 2500, EXPORT_OUT_SR);

        if (state.parcelFeature2243?.geometry?.rings?.length) {
          $("btnExportParcelCSV").disabled = false;
          log("Export geometry ready (IDW ft): parcel, subdivision, and section vertices.");
        } else {
          log("Parcel export geometry not available (no rings).", "warn");
        }
      } catch (e) {
        log(`Parcel/subdivision/section export geometry fetch failed: ${e.message || e}`, "warn");
      }

      invalidateMapSoon("lookup complete");
      log("Done.", "info");
    } catch (e) {
      log(`Error: ${e.message || e}`, "bad");
      console.error(e);
      invalidateMapSoon("after error");
    }
  }

  // -----------------------------
  // UI events
  // -----------------------------
  $("btnLookup").addEventListener("click", doLookup);

  $("btnClear").addEventListener("click", () => {
    $("addr").value = "";
    clearLog();
    clearMapLayers();
    setSummaryCards([]);
    $("btnExportGeo").disabled = true;
    $("btnExportParcelCSV").disabled = true;
    state.exportGeoJSON = null;
    state.parcelFeature = null;
    state.parcelFeature2243 = null;
    state.subdivisionFeature2243 = null;
    state.aliquotFeatures = [];
    state.sectionFeature2243 = null;
    state.selectedAliquot = null;
    state.lastLonLat = null;
    $("pdfFindings").style.display = "none";
    $("pdfFindings").textContent = "";
    log("Cleared.");
    invalidateMapSoon("clear");
  });

  $("btnExportGeo").addEventListener("click", () => {
    if (!state.exportGeoJSON) return;
    downloadJson(state.exportGeoJSON, "ada_lookup.geojson");
  });

  $("btnExportParcelCSV").addEventListener("click", () => {
    try {
      if (!state.parcelFeature2243) {
        throw new Error("Parcel export geometry not loaded yet. Run Lookup again.");
      }
      // Export order: P,N,E,Z,D with one row per unique point.
      const exportFeatures = [
        state.parcelFeature2243,
        state.subdivisionFeature2243,
        state.sectionFeature2243,
      ].filter(Boolean);
      const uniquePart = buildUniquePolygonCsvRowsPNEZD(exportFeatures, 1, 'BOUNDARY_CORNER');
      if (!uniquePart.count) throw new Error('No boundary vertices available to export.');
      downloadText(uniquePart.csv, "parcel_subdivision_section_unique_points_idw_ft_pnezd.csv", "text/csv");
      log(`Exported unique boundary CSV (PNEZD, IDW ft): points=${uniquePart.count}.`);
    } catch (e) {
      log(`Parcel CSV export failed: ${e.message || e}`, "bad");
      console.error(e);
    }
  });

  $("btnScanPdf").addEventListener("click", async () => {
    const file = $("pdfFile").files?.[0];
    $("pdfFindings").style.display = "none";
    $("pdfFindings").textContent = "";
    try {
      log(`Scanning PDF upload: ${file ? file.name : "(none)"}`);
      const res = await scanUploadedPdf(file);
      const out = [];
      out.push("BASIS OF BEARING — matches:\n");
      if (res.hits.length) out.push(...res.hits.map(x => "• " + x));
      else out.push("(none found as single-line matches)");
      out.push("\n\nBASIS OF BEARING — with context:\n");
      if (res.context.length) out.push(...res.context.map(x => "• " + x));
      else out.push("(none found)");
      $("pdfFindings").textContent = out.join("\n");
      $("pdfFindings").style.display = "block";
      log("PDF scan complete.");
    } catch (e) {
      log(`PDF scan failed: ${e.message || e}`, "bad");
      console.error(e);
    }
  });

  // initial log
  clearLog();
  log("Ready. Enter an address and click Lookup.");
  invalidateMapSoon("initial");
})();
</script>
</body>
</html>
