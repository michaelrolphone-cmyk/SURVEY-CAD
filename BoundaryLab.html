<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BoundaryLab — Traverse Closure Checker</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font-family: Inter, system-ui, sans-serif; background: #0b1220; color: #e2e8f0; }
    .layout { display: grid; grid-template-columns: 430px minmax(0, 1fr); min-height: 100vh; }
    .panel { border-right: 1px solid #22314f; padding: 18px; }
    h1 { margin: 0 0 6px; font-size: 1.25rem; }
    p { margin: 0 0 14px; color: #9fb0cc; }
    .toolbar { display: flex; gap: 8px; margin: 10px 0 14px; }
    button, input, select { border: 1px solid #2a3f62; border-radius: 8px; background: #12203a; color: #e2e8f0; padding: 8px 10px; }
    button { cursor: pointer; }
    .primary { background: #2563eb; border-color: #3b82f6; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { border-bottom: 1px solid #22314f; padding: 6px; text-align: left; }
    th { color: #9fb0cc; }
    input, select { width: 100%; box-sizing: border-box; }
    .summary { margin-top: 14px; background: #0f1a2e; border: 1px solid #22314f; border-radius: 10px; padding: 12px; }
    .summaryRow { display: flex; justify-content: space-between; margin: 5px 0; gap: 10px; }
    .bad { color: #fca5a5; }
    .good { color: #86efac; }
    .canvasWrap { padding: 16px; min-width: 0; }
    canvas { width: 100%; height: calc(100vh - 32px); border-radius: 10px; background: #07101d; border: 1px solid #22314f; display: block; }

    @media (max-width: 960px) {
      .layout { grid-template-columns: 1fr; }
      .panel { border-right: 0; border-bottom: 1px solid #22314f; }
      .canvasWrap { padding-top: 10px; }
      canvas { height: min(56vh, 420px); }
    }
  </style>
</head>
<body>
  <div class="layout">
    <aside class="panel">
      <h1>BoundaryLab</h1>
      <p>
        Enter bearings and distances in order. Bearings accept DMS (e.g. <code>N 45°01'07" E</code> or <code>N 45-01-07 E</code>).
        The boundary preview and closure error update as you edit. When opened from a project, traverses can be saved to and loaded from the project API.
      </p>
      <div class="toolbar">
        <button id="addCall" class="primary" type="button">Add Call</button>
        <button id="clearCalls" type="button">Clear</button>
        <button id="exportPointForge" type="button">Export to PointForge</button>
      </div>
      <div class="toolbar">
        <select id="traversePicker" aria-label="Saved traverses in this project">
          <option value="">Project traverses (not connected)</option>
        </select>
        <input id="traverseName" type="text" placeholder="Traverse name" aria-label="Traverse name" />
        <button id="saveTraverse" type="button">Save</button>
        <button id="saveTraverseAs" type="button">Save As New</button>
      </div>
      <table>
        <thead>
          <tr><th>#</th><th>Bearing</th><th>Distance</th><th></th></tr>
        </thead>
        <tbody id="callsBody"></tbody>
      </table>
      <div class="summary">
        <div class="summaryRow"><span>Total Distance</span><strong id="totalDistance">0.00</strong></div>
        <div class="summaryRow"><span>Linear Error</span><strong id="linearError">—</strong></div>
        <div class="summaryRow"><span>Closure Bearing</span><strong id="angularError">—</strong></div>
        <div class="summaryRow"><span>Closure Ratio</span><strong id="closureRatio">—</strong></div>
        <div class="summaryRow"><span>Status</span><strong id="closureStatus">Add calls</strong></div>
      </div>
    </aside>
    <main class="canvasWrap">
      <canvas id="previewCanvas" width="1000" height="700" aria-label="Boundary preview canvas"></canvas>
    </main>
  </div>

  <script type="module">
    import {
      calculateTraverseFromOrderedCalls,
      closureRatio,
      buildTraverseCsvPNEZD,
    } from './src/boundarylab.js';

    const state = {
      calls: [
        { id: crypto.randomUUID(), bearing: 'N 45°00\'00" E', distance: '100' },
        { id: crypto.randomUUID(), bearing: 'S 45-00-00 E', distance: '100' },
      ],
      activeTraverseId: '',
      activeTraverseCasefileId: '',
    };

    const body = document.getElementById('callsBody');
    const addCallButton = document.getElementById('addCall');
    const clearCallsButton = document.getElementById('clearCalls');
    const totalDistanceEl = document.getElementById('totalDistance');
    const linearErrorEl = document.getElementById('linearError');
    const angularErrorEl = document.getElementById('angularError');
    const closureRatioEl = document.getElementById('closureRatio');
    const closureStatusEl = document.getElementById('closureStatus');
    const canvas = document.getElementById('previewCanvas');
    const ctx = canvas.getContext('2d');
    const traversePicker = document.getElementById('traversePicker');
    const traverseNameInput = document.getElementById('traverseName');
    const saveTraverseButton = document.getElementById('saveTraverse');
    const saveTraverseAsButton = document.getElementById('saveTraverseAs');

    const pageParams = new URLSearchParams(window.location.search || '');
    const activeProjectId = String(pageParams.get('activeProjectId') || pageParams.get('projectId') || '').trim();


    async function apiRequest(method, url, body) {
      const res = await fetch(url, {
        method,
        headers: body ? { 'Content-Type': 'application/json' } : undefined,
        body: body ? JSON.stringify(body) : undefined,
      });
      if (!res.ok) {
        const details = await res.text();
        throw new Error(details || `Request failed: ${res.status}`);
      }
      return res.json();
    }

    async function listProjectTraverses() {
      if (!activeProjectId) return [];
      const out = await apiRequest('GET', `/api/projects/${encodeURIComponent(activeProjectId)}/workbench/traverses`);
      return Array.isArray(out?.traverses) ? out.traverses : [];
    }

    async function loadProjectTraverse(traverseId) {
      if (!activeProjectId || !traverseId) return null;
      return apiRequest('GET', `/api/projects/${encodeURIComponent(activeProjectId)}/workbench/traverses/${encodeURIComponent(traverseId)}`);
    }

    async function saveProjectTraverse({ asNew = false } = {}) {
      if (!activeProjectId) {
        alert('BoundaryLab is not connected to a project. Open BoundaryLab from Project Browser to save traverses.');
        return;
      }
      const name = String(traverseNameInput.value || '').trim();
      if (!name) {
        alert('Traverse name is required.');
        traverseNameInput.focus();
        return;
      }
      const calls = state.calls.map((call) => ({
        bearing: String(call.bearing || '').trim(),
        distance: Number.parseFloat(call.distance),
      })).filter((call) => call.bearing && Number.isFinite(call.distance));

      const payload = {
        name,
        calls,
      };

      if (!asNew && state.activeTraverseCasefileId) {
        payload.casefileId = state.activeTraverseCasefileId;
        payload.traverseId = state.activeTraverseId;
      }

      const saved = await apiRequest('POST', `/api/projects/${encodeURIComponent(activeProjectId)}/workbench/traverses`, payload);
      state.activeTraverseId = saved?.traverseId || '';
      state.activeTraverseCasefileId = saved?.casefileId || '';
      await refreshTraversePicker();
    }

    async function refreshTraversePicker() {
      const traverses = await listProjectTraverses();
      const previous = state.activeTraverseId || traversePicker.value || '';
      const options = ['<option value="">Project traverses (select to open)</option>'];
      for (const item of traverses) {
        options.push(`<option value="${esc(item.traverseId)}">${esc(item.name)}</option>`);
      }
      traversePicker.innerHTML = options.join('');
      if (previous) traversePicker.value = traverses.some((item) => item.traverseId === previous) ? previous : '';
      if (!activeProjectId) {
        traversePicker.disabled = true;
        saveTraverseButton.disabled = true;
        saveTraverseAsButton.disabled = true;
      }
    }
    function esc(v = '') {
      return String(v).replace(/[&<>"']/g, (c) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
    }

    // --- DMS / bearing normalization -------------------------------------------------
    // Accepts:
    //   N 45°01'07" E
    //   N45°01'07"E
    //   N 45-01-07 E
    //   N 45 01 07 E
    //   N 45.0186 E  (decimal degrees still works)
    // Converts to:
    //   N <decimalDegrees> E
    // If it can't parse cleanly, returns the original string (so upstream can handle/flag).
    function parseDmsAngleToDecimal(angleText) {
      const s = String(angleText ?? '').trim();
      if (!s) return NaN;

      // Grab 1-3 numeric components (deg, min, sec), seconds may be decimal.
      const nums = s.match(/\d+(?:\.\d+)?/g);
      if (!nums || nums.length === 0) return NaN;

      const deg = Number(nums[0]);
      const min = nums.length >= 2 ? Number(nums[1]) : 0;
      const sec = nums.length >= 3 ? Number(nums[2]) : 0;

      if (!Number.isFinite(deg) || !Number.isFinite(min) || !Number.isFinite(sec)) return NaN;
      if (min < 0 || sec < 0) return NaN;
      // (Keep this permissive; you may have 60+ in dirty input. We won't hard-fail.)

      return deg + (min / 60) + (sec / 3600);
    }

    function formatDecimalDegrees(deg) {
      // Keep stable + readable; trim trailing zeros.
      const rounded = Math.round(deg * 1e8) / 1e8;
      let out = String(rounded);
      if (out.includes('.')) out = out.replace(/\.?0+$/g, '');
      return out;
    }

    function normalizeBearingToDecimalQuadrant(rawBearing) {
      const raw = String(rawBearing ?? '').trim();
      if (!raw) return raw;

      // Normalize some unicode variants (degree/prime/double-prime) to keep matching simple.
      const cleaned = raw
        .replace(/[º]/g, '°')
        .replace(/[′’]/g, "'")
        .replace(/[″“”]/g, '"')
        .trim();

      // Quadrant bearing: leading N/S, trailing E/W, angle in the middle.
      // Allow no spaces: N45-01-07E
      const m = cleaned.match(/^\s*([NS])\s*(.*?)\s*([EW])\s*$/i);
      if (!m) return raw; // not quadrant bearing (or malformed)

      const ns = m[1].toUpperCase();
      const ew = m[3].toUpperCase();
      const mid = (m[2] ?? '').trim();
      if (!mid) return raw;

      // The middle can be DMS with symbols or hyphens or spaces.
      const dec = parseDmsAngleToDecimal(mid);
      if (!Number.isFinite(dec)) return raw;

      return `${ns} ${formatDecimalDegrees(dec)} ${ew}`;
    }

    function normalizedCallsForCompute(calls) {
      // Preserve the user's visible text; only normalize for computation.
      return calls.map((c) => ({
        ...c,
        bearing: normalizeBearingToDecimalQuadrant(c.bearing),
      }));
    }
    // --------------------------------------------------------------------------------

    function captureActiveInputState() {
      const active = document.activeElement;
      if (!(active instanceof HTMLInputElement)) return null;
      const { id, key } = active.dataset;
      if (!id || !key) return null;

      return {
        id,
        key,
        selectionStart: active.selectionStart,
        selectionEnd: active.selectionEnd,
      };
    }

    function restoreActiveInputState(activeState) {
      if (!activeState) return;
      const nextInput = Array.from(body.querySelectorAll('input')).find((input) => (
        input.dataset.id === activeState.id && input.dataset.key === activeState.key
      ));

      if (!nextInput) return;
      nextInput.focus({ preventScroll: true });
      if (Number.isInteger(activeState.selectionStart) && Number.isInteger(activeState.selectionEnd)) {
        nextInput.setSelectionRange(activeState.selectionStart, activeState.selectionEnd);
      }
    }

    function renderRows(activeState = null) {
      body.innerHTML = state.calls.map((call, index) => `
        <tr>
          <td>${index + 1}</td>
          <td>
            <input
              data-id="${call.id}"
              data-key="bearing"
              value="${esc(call.bearing)}"
              placeholder="N 45°01'07&quot; E  (or N 45-01-07 E)"
              title="Accepted: N 45°01'07&quot; E | N 45-01-07 E | N 45 01 07 E | N 45.0186 E"
            />
          </td>
          <td><input data-id="${call.id}" data-key="distance" value="${esc(call.distance)}" placeholder="100" /></td>
          <td><button data-remove="${call.id}" type="button">✕</button></td>
        </tr>
      `).join('');

      restoreActiveInputState(activeState);
    }

    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      const pixelRatio = Math.max(window.devicePixelRatio || 1, 1);
      const displayWidth = Math.max(1, Math.round(rect.width * pixelRatio));
      const displayHeight = Math.max(1, Math.round(rect.height * pixelRatio));

      if (canvas.width === displayWidth && canvas.height === displayHeight) return false;

      canvas.width = displayWidth;
      canvas.height = displayHeight;
      return true;
    }

    function draw(points) {
      resizeCanvasToDisplaySize();
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#0f1b30';
      ctx.fillRect(0, 0, w, h);

      if (!points || points.length === 0) return;
      const xs = points.map((p) => p.x);
      const ys = points.map((p) => p.y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);

      const spanX = Math.max(maxX - minX, 1);
      const spanY = Math.max(maxY - minY, 1);
      const pad = 40;
      const scale = Math.min((w - (pad * 2)) / spanX, (h - (pad * 2)) / spanY);
      const tx = (x) => pad + ((x - minX) * scale);
      const ty = (y) => h - (pad + ((y - minY) * scale));

      ctx.strokeStyle = '#60a5fa';
      ctx.lineWidth = 2;
      ctx.beginPath();
      points.forEach((pt, i) => {
        const x = tx(pt.x);
        const y = ty(pt.y);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      ctx.fillStyle = '#fbbf24';
      points.forEach((pt) => {
        ctx.beginPath();
        ctx.arc(tx(pt.x), ty(pt.y), 3, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function render() {
      renderRows(captureActiveInputState());

      const traversal = calculateTraverseFromOrderedCalls({
        orderedCalls: normalizedCallsForCompute(state.calls),
      });

      const ratio = closureRatio(traversal.totalLength, traversal.linearMisclosure);

      totalDistanceEl.textContent = traversal.totalLength.toFixed(2);
      linearErrorEl.textContent = Number.isFinite(traversal.linearMisclosure) ? traversal.linearMisclosure.toFixed(4) : '—';
      angularErrorEl.textContent = traversal.closureBearing;
      closureRatioEl.textContent = ratio === Infinity ? 'Perfect closure' : (Number.isFinite(ratio) ? `1:${Math.round(ratio).toLocaleString()}` : '—');

      const closed = traversal.closureIsLinear;
      closureStatusEl.textContent = closed ? 'Closed' : 'Open';
      closureStatusEl.className = closed ? 'good' : 'bad';

      draw(traversal.points);
    }

    body.addEventListener('input', (event) => {
      const target = event.target;
      if (!(target instanceof HTMLInputElement)) return;
      const id = target.dataset.id;
      const key = target.dataset.key;
      const call = state.calls.find((row) => row.id === id);
      if (!call || !key) return;
      call[key] = target.value;
      render();
    });

    body.addEventListener('click', (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const removeId = target.getAttribute('data-remove');
      if (!removeId) return;
      state.calls = state.calls.filter((row) => row.id !== removeId);
      render();
    });

    addCallButton.addEventListener('click', () => {
      state.calls.push({ id: crypto.randomUUID(), bearing: '', distance: '' });
      render();
    });

    clearCallsButton.addEventListener('click', () => {
      state.calls = [];
      render();
    });

    const BOUNDARYLAB_POINTFORGE_IMPORT_KEY = 'pointforgeBoundaryLabImport';
    const exportButton = document.getElementById('exportPointForge');

    exportButton.addEventListener('click', () => {
      const traversal = calculateTraverseFromOrderedCalls({
        orderedCalls: normalizedCallsForCompute(state.calls),
        startPoint: { x: 10000, y: 10000, pointNumber: 1 },
      });

      if (!traversal.points || traversal.points.length < 2) return;

      const csv = buildTraverseCsvPNEZD(traversal.points);
      if (!csv) return;

      localStorage.setItem(BOUNDARYLAB_POINTFORGE_IMPORT_KEY, JSON.stringify({
        csv,
        exportedAt: new Date().toISOString(),
        source: 'boundary-lab',
      }));

      try {
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({
            type: 'survey-cad:navigate-app',
            path: '/POINT_TRANSFORMER.HTML?source=boundary-lab',
          }, window.location.origin);
          return;
        }
      } catch (_e) { /* fallback below */ }
      window.location.assign('/POINT_TRANSFORMER.HTML?source=boundary-lab');
    });


    traversePicker.addEventListener('change', async () => {
      const traverseId = String(traversePicker.value || '').trim();
      if (!traverseId) {
        state.activeTraverseId = '';
        state.activeTraverseCasefileId = '';
        return;
      }
      try {
        const loaded = await loadProjectTraverse(traverseId);
        const calls = Array.isArray(loaded?.traverse?.calls) ? loaded.traverse.calls : [];
        state.calls = calls.map((call) => ({
          id: crypto.randomUUID(),
          bearing: String(call?.bearing || ''),
          distance: Number.isFinite(Number(call?.distance)) ? String(call.distance) : '',
        }));
        state.activeTraverseId = traverseId;
        state.activeTraverseCasefileId = String(loaded?.casefile?.id || '');
        traverseNameInput.value = String(loaded?.name || loaded?.casefile?.meta?.name || '');
        render();
      } catch (error) {
        console.error(error);
        alert('Unable to load traverse from API.');
      }
    });

    saveTraverseButton.addEventListener('click', async () => {
      try {
        await saveProjectTraverse({ asNew: false });
      } catch (error) {
        console.error(error);
        alert('Unable to save traverse.');
      }
    });

    saveTraverseAsButton.addEventListener('click', async () => {
      try {
        state.activeTraverseId = '';
        state.activeTraverseCasefileId = '';
        await saveProjectTraverse({ asNew: true });
      } catch (error) {
        console.error(error);
        alert('Unable to save traverse as new.');
      }
    });

    window.addEventListener('resize', render);

    render();
    refreshTraversePicker().catch((error) => {
      console.error(error);
    });
  </script>
</body>
</html>
