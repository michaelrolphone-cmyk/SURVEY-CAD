<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CSV Terrain Surface + Contours + Refinement + Map Tiles (P,N,E,Z,D) — Three.js</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1620;
      --panel2:#121c28;
      --text:#e8eef7;
      --muted:#a5b1c2;
      --accent:#ffd54a;
      --danger:#ff5b5b;
      --ok:#37d67a;
      --line:rgba(255,255,255,.12);
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    #app{display:grid; grid-template-columns: 430px 1fr; height:100%;}
    #left{
      border-right:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.03), transparent 35%), var(--panel);
      padding:14px; overflow:auto;
    }
    #right{position:relative;}
    #c{width:100%; height:100%; display:block;}
    h1{font-size:15px; margin:0 0 10px; letter-spacing:.2px;}
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.04), transparent 80%), var(--panel2);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      margin:10px 0;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .row > *{flex: 1 1 auto;}
    label{display:block; font-size:12px; color:var(--muted); margin:10px 0 6px;}
    textarea{
      width:100%; min-height:170px; resize:vertical;
      background:#091018; color:var(--text);
      border:1px solid var(--line); border-radius:12px;
      padding:10px; outline:none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px; line-height:1.35;
    }
    input[type="file"]{width:100%;}
    input[type="number"]{
      width:100%; background:#091018; color:var(--text);
      border:1px solid var(--line); border-radius:12px;
      padding:10px; outline:none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    button{
      background:#0b0f14; color:var(--text);
      border:1px solid rgba(255,255,255,.18);
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
      transition: transform .06s ease, border-color .15s ease, background .15s ease;
      user-select:none;
    }
    button:hover{border-color: rgba(255,213,74,.55); background: rgba(255,213,74,.06);}
    button:active{transform: translateY(1px);}
    button.primary{border-color: rgba(255,213,74,.65); background: rgba(255,213,74,.10);}
    button.danger{border-color: rgba(255,91,91,.65); background: rgba(255,91,91,.08);}
    .tiny{font-size:12px; color:var(--muted);}
    .kv{display:grid; grid-template-columns: 190px 1fr; gap:6px 10px; font-size:12px; color:var(--muted);}
    .kv b{color:var(--text); font-weight:600;}
    .sep{height:1px; background:var(--line); margin:10px 0;}
    .badge{display:inline-flex; align-items:center; gap:6px; font-size:12px; padding:4px 8px;
      border:1px solid var(--line); border-radius:999px; background:rgba(255,255,255,.03);}
    .dot{width:8px; height:8px; border-radius:50%;}
    .dot.ok{background:var(--ok);}
    .dot.bad{background:var(--danger);}
    .hint{
      position:absolute; left:14px; bottom:14px;
      background: rgba(10,14,20,.78);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px 12px;
      max-width: 560px;
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      font-size:12px; color:var(--muted);
    }
    .hint b{color:var(--text); font-weight:600;}
    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    .grid2 > div{min-width:0;}
    input[type="range"]{width:100%;}
    select{
      width:100%;
      background:#091018;
      color:var(--text);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
      outline:none;
    }
    .checkbox{display:flex; gap:10px; align-items:center; color:var(--muted); font-size:12px; margin-top:8px;}
    .checkbox input{transform: scale(1.15);}
    .status{margin-top:8px;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<div id="app">
  <div id="left">
    <h1>CSV → 3D Surface (P,N,E,Z,D)</h1>

    <div class="card">
      <div class="row">
        <button class="primary" id="btnRender">Render Surface</button>
        <button id="btnFit">Fit View</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="btnSample">Load Sample</button>
        <button class="danger" id="btnClear">Clear</button>
      </div>

      <div class="sep"></div>

      <label>Load CSV file</label>
      <input id="file" type="file" accept=".csv,text/csv" />

      <label>…or load a project point file</label>
      <div class="row">
        <select id="projectPointFile" disabled>
          <option value="">No project point files loaded</option>
        </select>
        <button id="btnLoadProjectPointFile" disabled>Load Project File</button>
      </div>
      <div class="tiny" id="projectPointFileHint" style="margin-top:6px;">Launch Surface Weaver with <span class="mono">?activeProjectId=…</span> to load point files from your active project.</div>

      <label>…or paste CSV text (P,N,E,Z,D; header optional)</label>
      <textarea id="csv" spellcheck="false" placeholder="Example:
1,666102.348,2406162.791,2597.647,Corner
2,666140.112,2406160.118,2599.220,Spot
..."></textarea>

      <div class="status" id="status"></div>
    </div>

    <div class="card">
      <div class="grid2">
        <div>
          <label>Navigation mode</label>
          <select id="navMode">
            <option value="orbit">Orbit</option>
            <option value="fps">First-person</option>
          </select>
          <div class="tiny" style="margin-top:6px;">FPS: click canvas to lock · WASD · Space/Ctrl · Esc unlock</div>
        </div>

        <div>
          <label>Vertical exaggeration (×)</label>
          <input id="zScale" type="range" min="0.1" max="200" step="0.1" value="60" />
          <div class="row" style="margin-top:6px;">
            <div class="tiny"><span id="zScaleLabel" class="mono">60.0×</span></div>
            <input id="zScaleNum" type="number" min="0.1" max="200" step="0.1" value="60" />
          </div>
        </div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <div>
          <label>Point size</label>
          <input id="ptSize" type="range" min="0.2" max="6" step="0.1" value="1.0" />
          <div class="tiny"><span id="ptSizeLabel" class="mono">1.0</span></div>
        </div>
        <div>
          <label>Surface opacity</label>
          <input id="surfOpacity" type="range" min="0.05" max="1" step="0.05" value="0.95" />
          <div class="tiny"><span id="surfOpacityLabel" class="mono">0.95</span></div>
        </div>
      </div>

      <div class="sep"></div>

      <div class="grid2">
        <div>
          <label>Sun azimuth (deg)</label>
          <input id="sunAz" type="range" min="0" max="360" step="1" value="315" />
          <div class="tiny"><span id="sunAzLabel" class="mono">315°</span></div>
        </div>
        <div>
          <label>Sun elevation (deg)</label>
          <input id="sunEl" type="range" min="2" max="80" step="1" value="14" />
          <div class="tiny"><span id="sunElLabel" class="mono">14°</span></div>
        </div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <div>
          <label>Shadows</label>
          <select id="shadowMode">
            <option value="on" selected>On</option>
            <option value="off">Off</option>
          </select>
        </div>
        <div>
          <label>Shadow quality</label>
          <select id="shadowQuality">
            <option value="1024">1024</option>
            <option value="2048" selected>2048</option>
            <option value="4096">4096</option>
          </select>
        </div>
      </div>

      <!-- ✅ Map tiles added (keeps all existing features) -->
      <div class="sep"></div>

      <div class="grid2">
        <div>
          <label>Map tiles</label>
          <select id="tileProvider">
            <option value="none" selected>None</option>
            <option value="esri">Esri World Imagery</option>
            <option value="usgs">USGS ImageryOnly (max z≈16)</option>
          </select>
          <div class="tiny" style="margin-top:6px;">Tiles are draped as a separate overlay mesh (does not affect shadows).</div>
        </div>
        <div>
          <label>Tile texture size</label>
          <select id="tileTexSize">
            <option value="512">512</option>
            <option value="1024" selected>1024</option>
            <option value="2048">2048</option>
          </select>
          <div class="tiny" style="margin-top:6px;">Higher = sharper, more VRAM.</div>
        </div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <div>
          <label>Tile opacity</label>
          <input id="tileOpacity" type="range" min="0" max="1" step="0.05" value="0.30" />
          <div class="tiny"><span id="tileOpacityLabel" class="mono">0.30</span></div>
        </div>
        <div>
          <label>Rebuild tiles</label>
          <button id="btnRebuildTiles">Rebuild Map</button>
          <div class="tiny" style="margin-top:6px;">Use after changing provider/size.</div>
        </div>
      </div>

      <div class="checkbox">
        <input id="wireframe" type="checkbox" />
        <label for="wireframe" style="margin:0;">Wireframe</label>
      </div>
      <div class="checkbox">
        <input id="showSurface" type="checkbox" checked />
        <label for="showSurface" style="margin:0;">Show surface</label>
      </div>
      <div class="checkbox">
        <input id="showPoints" type="checkbox" checked />
        <label for="showPoints" style="margin:0;">Show points</label>
      </div>
      <div class="checkbox">
        <input id="showGrid" type="checkbox" checked />
        <label for="showGrid" style="margin:0;">Show grid</label>
      </div>
    </div>

    <div class="card">
      <div class="sep" style="margin-top:0;"></div>

      <label>Mesh refinement (subdivision levels)</label>
      <input id="subdivLevels" type="range" min="0" max="4" step="1" value="2" />
      <div class="tiny">Level <span id="subdivLabel" class="mono">2</span> — adds vertices by splitting triangles. No height averaging / denoise.</div>
      <div class="tiny" style="margin-top:6px;">
        Cost grows fast: triangles ×4 per level. If your input is large, keep ≤2.
      </div>

      <div class="sep"></div>

      <div class="row">
        <button id="btnRebuildContours">Rebuild Contours</button>
      </div>

      <div class="checkbox">
        <input id="contoursOn" type="checkbox" checked />
        <label for="contoursOn" style="margin:0;">Draw contour lines</label>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <div>
          <label>Contour interval (Z units)</label>
          <input id="contourInterval" type="number" min="0.001" step="0.1" value="1.0" />
          <div class="tiny">In your CSV Z units (feet/meters), not exaggerated units.</div>
        </div>
        <div>
          <label>Major every N intervals</label>
          <input id="contourMajorEvery" type="number" min="1" step="1" value="5" />
          <div class="tiny">Major = brighter line (WebGL line width is limited).</div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="kv">
        <div>Parsed points</div><b id="kvCount">0</b>
        <div>Excluded (Z=0)</div><b id="kvExcluded">0</b>
        <div>Deduped (same N/E)</div><b id="kvDeduped">0</b>
        <div>Triangles (base)</div><b id="kvTrisBase">0</b>
        <div>Triangles (refined)</div><b id="kvTrisRef">0</b>
        <div>Contour segments</div><b id="kvSegs">0</b>
        <div>Offset (E,N,Z)</div><b id="kvOffset" class="mono">—</b>
      </div>
    </div>
  </div>

  <div id="right">
    <canvas id="c"></canvas>
    <div class="hint">
      <b>Orbit:</b> LMB rotate · RMB pan · Wheel zoom<br/>
      <b>FPS:</b> click canvas to lock mouse · WASD move · Space up · Ctrl down · Esc unlock
    </div>
  </div>
</div>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
  import { Delaunay } from "https://cdn.jsdelivr.net/npm/d3-delaunay@6/+esm";
  import Papa from "https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm";

  const el = (id)=>document.getElementById(id);

  const csvTA = el("csv");
  const fileIn = el("file");
  const projectPointFileSel = el("projectPointFile");
  const btnLoadProjectPointFile = el("btnLoadProjectPointFile");
  const projectPointFileHint = el("projectPointFileHint");
  const btnRender = el("btnRender");
  const btnFit = el("btnFit");
  const btnSample = el("btnSample");
  const btnClear = el("btnClear");
  const statusEl = el("status");

  const navModeSel = el("navMode");
  const zScale = el("zScale");
  const zScaleNum = el("zScaleNum");
  const zScaleLabel = el("zScaleLabel");
  const ptSize = el("ptSize");
  const ptSizeLabel = el("ptSizeLabel");
  const surfOpacity = el("surfOpacity");
  const surfOpacityLabel = el("surfOpacityLabel");
  const wireframe = el("wireframe");
  const showSurface = el("showSurface");
  const showPoints = el("showPoints");
  const showGrid = el("showGrid");

  const sunAz = el("sunAz");
  const sunEl = el("sunEl");
  const sunAzLabel = el("sunAzLabel");
  const sunElLabel = el("sunElLabel");
  const shadowMode = el("shadowMode");
  const shadowQuality = el("shadowQuality");

  const tileProvider = el("tileProvider");
  const tileTexSize = el("tileTexSize");
  const tileOpacity = el("tileOpacity");
  const tileOpacityLabel = el("tileOpacityLabel");
  const btnRebuildTiles = el("btnRebuildTiles");

  const subdivLevels = el("subdivLevels");
  const subdivLabel = el("subdivLabel");

  const btnRebuildContours = el("btnRebuildContours");
  const contoursOn = el("contoursOn");
  const contourInterval = el("contourInterval");
  const contourMajorEvery = el("contourMajorEvery");

  const kvCount = el("kvCount");
  const kvExcluded = el("kvExcluded");
  const kvDeduped = el("kvDeduped");
  const kvTrisBase = el("kvTrisBase");
  const kvTrisRef = el("kvTrisRef");
  const kvSegs = el("kvSegs");
  const kvOffset = el("kvOffset");

  const pageParams = new URLSearchParams(window.location.search);
  const activeProjectId = String(pageParams.get("activeProjectId") || pageParams.get("projectId") || "").trim();
  let projectPointFileOptions = [];

  // Three.js setup
  const canvas = el("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setClearColor(0x0b0f14, 1);

  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0b0f14, 250, 7000);

  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 80000);
  camera.position.set(200, 160, 200);

  const ambient = new THREE.AmbientLight(0xffffff, 0.16);
  scene.add(ambient);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.30);
  scene.add(hemi);

  const sun = new THREE.DirectionalLight(0xffffff, 1.25);
  sun.castShadow = true;
  scene.add(sun);

  const sunTarget = new THREE.Object3D();
  scene.add(sunTarget);
  sun.target = sunTarget;

  function applyShadowQuality() {
    const q = Number(shadowQuality.value) || 2048;
    sun.shadow.mapSize.set(q, q);
    sun.shadow.bias = -0.0004;
    sun.shadow.normalBias = 0.02;
    sun.shadow.radius = 2;
  }
  applyShadowQuality();

  const grid = new THREE.GridHelper(2600, 104, 0xffffff, 0xffffff);
  grid.material.transparent = true;
  grid.material.opacity = 0.07;
  grid.receiveShadow = true;
  scene.add(grid);

  const orbit = new OrbitControls(camera, renderer.domElement);
  orbit.enableDamping = true;
  orbit.dampingFactor = 0.08;
  orbit.screenSpacePanning = true;
  orbit.zoomToCursor = false;

  function updateOrbitDistanceLimits(box3){
    if (!box3) {
      orbit.minDistance = 0.25;
      orbit.maxDistance = 250000;
      return;
    }

    const size = new THREE.Vector3();
    box3.getSize(size);
    const maxDim = Math.max(size.x, size.y, size.z, 1);
    const diagonal = Math.max(size.length(), 1);
    const boundingRadius = diagonal * 0.5;

    // Keep wheel zoom from collapsing into the model center where navigation can
    // feel "stuck inside" the mesh, while preserving broad zoom-out range.
    orbit.minDistance = Math.max(0.5, boundingRadius * 1.05, maxDim * 0.18);
    orbit.maxDistance = Math.max(diagonal * 600, orbit.minDistance * 30, 12000);
  }
  updateOrbitDistanceLimits(null);

  const fps = new PointerLockControls(camera, renderer.domElement);
  let fpsEnabled = false;

  const keys = new Set();
  const vel = new THREE.Vector3();
  const up = new THREE.Vector3(0, 1, 0);

  window.addEventListener("keydown", (e)=>keys.add(e.code));
  window.addEventListener("keyup", (e)=>keys.delete(e.code));

  renderer.domElement.addEventListener("click", () => {
    if (navModeSel.value === "fps") fps.lock();
  });

  function resize() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener("resize", resize);
  resize();

  // Scene objects
  let surfaceMesh = null;
  let imageryMesh = null;     // ✅ overlay mesh for tiles
  let pointsMesh = null;
  let boundsBox = null;
  let contourMinor = null;
  let contourMajor = null;

  // Needed for contour mapping in real units
  let lastBounds = null;  // Box3 in centered coords
  let lastOffZ = 0;       // real Z offset
  let lastZEx = 1;        // exaggeration

  // Needed for tile fetch bbox (lon/lat + merc)
  let lastTileBbox = null; // {west,south,east,north, mercWidth, mercHeight}
  let lastTileState = { provider:null, size:null, west:null, south:null, east:null, north:null };

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[m]));
  }

  function buildProjectPointFileApiUrl(projectId = "", pointFileId = "") {
    if (!projectId) return "";
    const base = `/api/projects/${encodeURIComponent(projectId)}/point-files`;
    return pointFileId ? `${base}/${encodeURIComponent(pointFileId)}` : base;
  }

  function renderProjectPointFileChoices(list = []) {
    const normalized = Array.isArray(list) ? list.filter(Boolean) : [];
    projectPointFileOptions = normalized;
    projectPointFileSel.innerHTML = "";

    if (!activeProjectId) {
      projectPointFileSel.disabled = true;
      btnLoadProjectPointFile.disabled = true;
      projectPointFileSel.innerHTML = '<option value="">No active project selected</option>';
      projectPointFileHint.textContent = 'Launch Surface Weaver with ?activeProjectId=… to load point files from your active project.';
      return;
    }

    if (!normalized.length) {
      projectPointFileSel.disabled = true;
      btnLoadProjectPointFile.disabled = true;
      projectPointFileSel.innerHTML = '<option value="">No point files found for this project</option>';
      projectPointFileHint.textContent = `No point files were found for project ${activeProjectId}.`;
      return;
    }

    projectPointFileSel.disabled = false;
    btnLoadProjectPointFile.disabled = true;
    projectPointFileHint.textContent = `Loaded ${normalized.length} point file${normalized.length === 1 ? "" : "s"} from project ${activeProjectId}.`;

    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = "Select a project point file";
    projectPointFileSel.appendChild(placeholder);

    for (const option of normalized) {
      const row = document.createElement("option");
      row.value = option.pointFileId;
      row.textContent = option.pointFileName || option.pointFileId || "Point File";
      projectPointFileSel.appendChild(row);
    }
  }

  async function syncProjectPointFilesFromApi() {
    if (!activeProjectId) {
      renderProjectPointFileChoices([]);
      return;
    }

    const response = await fetch(buildProjectPointFileApiUrl(activeProjectId));
    if (!response.ok) throw new Error(`Unable to list project point files (${response.status}).`);
    const payload = await response.json();
    const list = Array.isArray(payload?.pointFiles) ? payload.pointFiles : [];

    const options = list.map((entry = {}) => ({
      pointFileId: String(entry.pointFileId || "").trim(),
      pointFileName: String(entry.pointFileName || entry.pointFileId || "Point File").trim(),
    })).filter((entry) => entry.pointFileId);

    renderProjectPointFileChoices(options);
  }

  async function loadProjectPointFileIntoCsv() {
    const pointFileId = String(projectPointFileSel.value || "").trim();
    if (!activeProjectId) {
      throw new Error("Surface Weaver is missing an active project id.");
    }
    if (!pointFileId) {
      throw new Error("Pick a project point file first.");
    }

    const response = await fetch(buildProjectPointFileApiUrl(activeProjectId, pointFileId));
    if (!response.ok) throw new Error(`Unable to load selected point file (${response.status}).`);
    const payload = await response.json();
    const text = String(payload?.pointFile?.currentState?.text || "");
    if (!text.trim()) throw new Error("Selected point file is empty.");

    csvTA.value = text;
    const selected = projectPointFileOptions.find((entry) => entry.pointFileId === pointFileId);
    setStatus(true, `Loaded project point file: ${selected?.pointFileName || pointFileId}`);
  }

  function setStatus(ok, msg){
    statusEl.innerHTML = `
      <span class="badge">
        <span class="dot ${ok ? "ok" : "bad"}"></span>
        <span>${escapeHtml(msg)}</span>
      </span>`;
  }

  function clearContours(){
    if (contourMinor){ scene.remove(contourMinor); contourMinor.geometry.dispose(); contourMinor.material.dispose(); contourMinor = null; }
    if (contourMajor){ scene.remove(contourMajor); contourMajor.geometry.dispose(); contourMajor.material.dispose(); contourMajor = null; }
    kvSegs.textContent = "0";
  }

  function clearImagery(){
    if (!imageryMesh) return;
    scene.remove(imageryMesh);
    // IMPORTANT: geometry is shared with surfaceMesh; do NOT dispose geometry here.
    if (imageryMesh.material){
      if (imageryMesh.material.map) imageryMesh.material.map.dispose();
      imageryMesh.material.dispose();
    }
    imageryMesh = null;
  }

  function clearSceneData() {
    clearContours();
    clearImagery();

    if (surfaceMesh) { scene.remove(surfaceMesh); surfaceMesh.geometry.dispose(); surfaceMesh.material.dispose(); surfaceMesh = null; }
    if (pointsMesh) { scene.remove(pointsMesh); pointsMesh.geometry.dispose(); pointsMesh.material.dispose(); pointsMesh = null; }
    if (boundsBox) { scene.remove(boundsBox); boundsBox.geometry.dispose(); boundsBox.material.dispose(); boundsBox = null; }

    lastBounds = null;
    lastOffZ = 0;
    lastZEx = 1;
    lastTileBbox = null;
    lastTileState = { provider:null, size:null, west:null, south:null, east:null, north:null };
    updateFogForBox(null);

    kvCount.textContent = "0";
    kvExcluded.textContent = "0";
    kvDeduped.textContent = "0";
    kvTrisBase.textContent = "0";
    kvTrisRef.textContent = "0";
    kvOffset.textContent = "—";
    setStatus(true, "Cleared.");
  }

  function buildBoundsBox(box3){
    const size = new THREE.Vector3();
    const center = new THREE.Vector3();
    box3.getSize(size);
    box3.getCenter(center);

    const geo = new THREE.BoxGeometry(size.x, size.y, size.z);
    const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.10 });
    const m = new THREE.Mesh(geo, mat);
    m.position.copy(center);
    return m;
  }

  function fitViewToBox(box3){
    const size = new THREE.Vector3();
    const center = new THREE.Vector3();
    box3.getSize(size);
    box3.getCenter(center);

    const maxDim = Math.max(size.x, size.y, size.z);
    const dist = maxDim * 1.55 + 80;

    camera.position.set(center.x + dist, center.y + dist * 0.55, center.z + dist);
    camera.lookAt(center);

    orbit.target.copy(center);
    updateOrbitDistanceLimits(box3);
    orbit.update();
    updateCameraClippingForBox(box3);
    updateFogForBox(box3);
  }

  function updateFogForBox(box3){
    if (!box3) {
      scene.fog.near = 250;
      scene.fog.far = 7000;
      return;
    }

    const size = new THREE.Vector3();
    const center = new THREE.Vector3();
    box3.getSize(size);
    box3.getCenter(center);
    const maxDim = Math.max(size.x, size.y, size.z, 1);
    const cameraDistance = camera.position.distanceTo(center);

    // Keep scene readable while zooming very far out/in on large or tiny models.
    const fogFar = Math.max(maxDim * 24, cameraDistance + (maxDim * 8), 7000);
    const fogNear = Math.max(25, Math.min(fogFar * 0.85, Math.max(maxDim * 0.75, cameraDistance * 0.35)));
    scene.fog.near = fogNear;
    scene.fog.far = fogFar;
  }

  function updateCameraClippingForBox(box3){
    if (!box3) {
      updateOrbitDistanceLimits(null);
      camera.near = 0.1;
      camera.far = 80000;
      camera.updateProjectionMatrix();
      return;
    }

    const center = new THREE.Vector3();
    const size = new THREE.Vector3();
    box3.getCenter(center);
    box3.getSize(size);

    const maxDim = Math.max(size.x, size.y, size.z, 1);
    const cameraDistance = camera.position.distanceTo(center);
    updateOrbitDistanceLimits(box3);
    const far = Math.max(80000, cameraDistance + (maxDim * 18));
    const nearCandidate = Math.max(0.05, (cameraDistance - (maxDim * 1.5)) * 0.25);
    const near = Math.min(Math.max(0.05, nearCandidate), far * 0.5);

    if (Math.abs(camera.near - near) > 0.0001 || Math.abs(camera.far - far) > 0.1) {
      camera.near = near;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
  }

  function degToRad(d){ return d * Math.PI / 180; }

  function updateSunForBounds(box3){
    if (!box3) return;

    const center = new THREE.Vector3();
    const size = new THREE.Vector3();
    box3.getCenter(center);
    box3.getSize(size);

    const az = degToRad(Number(sunAz.value));
    const elv = degToRad(Number(sunEl.value));
    const cosEl = Math.cos(elv);

    const sunVec = new THREE.Vector3(
      cosEl * Math.cos(az),
      Math.sin(elv),
      cosEl * Math.sin(az)
    ).normalize();

    const maxDim = Math.max(size.x, size.y, size.z);
    const dist = maxDim * 2.2 + 250;

    sun.position.copy(center).addScaledVector(sunVec, dist);
    sunTarget.position.copy(center);

    const cam = sun.shadow.camera; // OrthographicCamera
    const halfW = Math.max(size.x, size.z) * 0.72 + 60;
    cam.left   = -halfW;
    cam.right  =  halfW;
    cam.top    =  halfW;
    cam.bottom = -halfW;
    cam.near = 0.1;
    cam.far  = dist * 3.0;
    cam.updateProjectionMatrix();

    sun.intensity = 1.15 + (0.35 * (1 - (Number(sunEl.value) / 80)));
  }

  function applyShadowMode(){
    const on = (shadowMode.value === "on");
    renderer.shadowMap.enabled = on;
    sun.castShadow = on;
    if (surfaceMesh){ surfaceMesh.castShadow = on; surfaceMesh.receiveShadow = on; }
    grid.receiveShadow = on;
  }

  // CSV parsing (P,N,E,Z,D)
  function parseCsvText(text) {
    const parsed = Papa.parse(text.trim(), { dynamicTyping: false, skipEmptyLines: true });
    if (parsed.errors?.length) throw new Error(parsed.errors[0].message || "CSV parse error");

    const rows = parsed.data;

    // Optional header skip
    let startIndex = 0;
    if (rows.length && rows[0].length >= 4) {
      const r0 = rows[0].map(v => String(v).trim().toLowerCase());
      const looksLikeHeader =
        r0.includes("p") || r0.includes("point") || r0.includes("point number") ||
        r0.includes("n") || r0.includes("northing") ||
        r0.includes("e") || r0.includes("easting") ||
        r0.includes("z") || r0.includes("elev") || r0.includes("elevation") || r0.includes("alt") || r0.includes("altitude");
      if (looksLikeHeader) startIndex = 1;
    }

    let excludedZeroZ = 0;

    // Dedupe by (E,N), keep highest Z
    const map = new Map();

    function toNum(x){
      const s = String(x ?? "").trim();
      if (!s) return NaN;
      const n = Number(s.replace(/,/g,""));
      return Number.isFinite(n) ? n : NaN;
    }

    let rawUsed = 0;
    for (let i = startIndex; i < rows.length; i++){
      const row = rows[i];
      if (!row || row.length < 4) continue;
      rawUsed++;

      const P = String(row[0] ?? "").trim();
      const N = toNum(row[1]);
      const E = toNum(row[2]);
      const Z = toNum(row[3]);
      const D = row.length >= 5 ? String(row.slice(4).join(",")).trim() : "";

      if (!Number.isFinite(N) || !Number.isFinite(E) || !Number.isFinite(Z)) continue;
      if (Z === 0) { excludedZeroZ++; continue; }

      const key = `${E.toFixed(4)}|${N.toFixed(4)}`;
      const prev = map.get(key);
      if (!prev || Z > prev.Z) map.set(key, { P, N, E, Z, D });
    }

    const points = Array.from(map.values());
    const deduped = Math.max(0, rawUsed - (points.length + excludedZeroZ));
    return { points, excludedZeroZ, deduped };
  }

  // -------------------- Idaho West (NAD83 / Idaho West, US-ft) inverse TM --------------------
  // This matches NAD83 Idaho West StatePlane Transverse Mercator parameters commonly used for IDW:
  // lat0=41°40' (41.6666666667), lon0=-115.75, k0=0.999933333, FE=2624666.667 US-ft, FN=0
  const USFT_TO_M = 1200 / 3937; // exact US survey ft -> m
  const GRS80_A = 6378137.0;
  const GRS80_F = 1 / 298.257222101;
  const GRS80_E2 = 2 * GRS80_F - GRS80_F * GRS80_F;
  const EP2 = GRS80_E2 / (1 - GRS80_E2);

  const IDW_LAT0 = 41.6666666666667 * Math.PI / 180;
  const IDW_LON0 = -115.75 * Math.PI / 180;
  const IDW_K0 = 0.999933333;
  const IDW_FE_FT = 2624666.667; // ftUS
  const IDW_FN_FT = 0.0;

  const e1 = (1 - Math.sqrt(1 - GRS80_E2)) / (1 + Math.sqrt(1 - GRS80_E2));

  function meridionalArc(phi){
    const e2 = GRS80_E2;
    const e4 = e2*e2;
    const e6 = e4*e2;
    return GRS80_A * (
      (1 - e2/4 - 3*e4/64 - 5*e6/256) * phi
      - (3*e2/8 + 3*e4/32 + 45*e6/1024) * Math.sin(2*phi)
      + (15*e4/256 + 45*e6/1024) * Math.sin(4*phi)
      - (35*e6/3072) * Math.sin(6*phi)
    );
  }
  const M0 = meridionalArc(IDW_LAT0);

  function idahoWestToLonLat(E_ft, N_ft){
    const x = (E_ft - IDW_FE_FT) * USFT_TO_M;
    const y = (N_ft - IDW_FN_FT) * USFT_TO_M;

    const M = M0 + y / IDW_K0;
    const e2 = GRS80_E2;
    const e4 = e2*e2;
    const e6 = e4*e2;

    const mu = M / (GRS80_A * (1 - e2/4 - 3*e4/64 - 5*e6/256));

    const J1 = (3*e1/2 - 27*Math.pow(e1,3)/32);
    const J2 = (21*Math.pow(e1,2)/16 - 55*Math.pow(e1,4)/32);
    const J3 = (151*Math.pow(e1,3)/96);
    const J4 = (1097*Math.pow(e1,4)/512);

    const phi1 = mu + J1*Math.sin(2*mu) + J2*Math.sin(4*mu) + J3*Math.sin(6*mu) + J4*Math.sin(8*mu);

    const sin1 = Math.sin(phi1), cos1 = Math.cos(phi1), tan1 = Math.tan(phi1);
    const N1 = GRS80_A / Math.sqrt(1 - e2*sin1*sin1);
    const R1 = (GRS80_A * (1 - e2)) / Math.pow(1 - e2*sin1*sin1, 1.5);
    const T1 = tan1*tan1;
    const C1 = EP2*cos1*cos1;
    const D = x / (N1 * IDW_K0);

    const D2 = D*D, D3=D2*D, D4=D2*D2, D5=D4*D, D6=D3*D3;

    const lat = phi1 - (N1*tan1/R1) * (
      D2/2
      - (5 + 3*T1 + 10*C1 - 4*C1*C1 - 9*EP2) * D4/24
      + (61 + 90*T1 + 298*C1 + 45*T1*T1 - 252*EP2 - 3*C1*C1) * D6/720
    );

    const lon = IDW_LON0 + (1/cos1) * (
      D
      - (1 + 2*T1 + C1) * D3/6
      + (5 - 2*C1 + 28*T1 - 3*C1*C1 + 8*EP2 + 24*T1*T1) * D5/120
    );

    return { lon: lon * 180/Math.PI, lat: lat * 180/Math.PI };
  }

  function lonLatToWebMerc(lon, lat){
    const R = 6378137;
    const x = R * (lon * Math.PI/180);
    const clampedLat = Math.max(Math.min(lat, 85.05112878), -85.05112878);
    const y = R * Math.log(Math.tan(Math.PI/4 + (clampedLat*Math.PI/180)/2));
    return { x, y };
  }

  function lonLatToTileXY(lon, lat, z){
    const n = 2 ** z;
    const x = Math.floor((lon + 180) / 360 * n);
    const latRad = lat * Math.PI/180;
    const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n);
    return { x, y };
  }

  function chooseZoomForBbox(mercSpanM, desiredPx, maxZ){
    const worldM = 2 * Math.PI * 6378137;
    const z = Math.log2((desiredPx * worldM) / (256 * Math.max(1, mercSpanM)));
    return Math.max(0, Math.min(maxZ, Math.round(z)));
  }

  const PROVIDERS = {
    esri: {
      name: "Esri World Imagery",
      maxZ: 19,
      url: (z,x,y) => `https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${z}/${y}/${x}`
    },
    usgs: {
      name: "USGS ImageryOnly",
      maxZ: 16,
      url: (z,x,y) => `https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/${z}/${y}/${x}`
    }
  };

  async function fetchImageBitmap(url){
    const res = await fetch(url, { mode:"cors", credentials:"omit" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const blob = await res.blob();
    return await createImageBitmap(blob);
  }

  async function buildTileTexture(bbox, providerKey, desiredSize){
    const prov = PROVIDERS[providerKey];
    const { west, south, east, north, mercWidth, mercHeight } = bbox;

    const z = chooseZoomForBbox(Math.max(mercWidth, mercHeight), desiredSize, prov.maxZ);

    const t0 = lonLatToTileXY(west, north, z);
    const t1 = lonLatToTileXY(east, south, z);

    const minX = Math.min(t0.x, t1.x), maxX = Math.max(t0.x, t1.x);
    const minY = Math.min(t0.y, t1.y), maxY = Math.max(t0.y, t1.y);

    const tilesW = (maxX - minX + 1);
    const tilesH = (maxY - minY + 1);
    const total = tilesW * tilesH;

    // guardrail
    if (total > 140){
      throw new Error(`Too many tiles at z=${z} (${total}). Increase area padding less / reduce texture size / use USGS.`);
    }

    const canvasTex = document.createElement("canvas");
    canvasTex.width = tilesW * 256;
    canvasTex.height = tilesH * 256;
    const ctx = canvasTex.getContext("2d", { alpha:false });

    const jobs = [];
    for (let ty=minY; ty<=maxY; ty++){
      for (let tx=minX; tx<=maxX; tx++){
        jobs.push({ tx, ty });
      }
    }

    let done = 0;
    const concurrency = 8;

    const workers = Array.from({length: concurrency}, async () => {
      while (jobs.length){
        const job = jobs.pop();
        const url = prov.url(z, job.tx, job.ty);
        try{
          const bmp = await fetchImageBitmap(url);
          const dx = (job.tx - minX) * 256;
          const dy = (job.ty - minY) * 256;
          ctx.drawImage(bmp, dx, dy);
        }catch(e){
          // missing tile ok; leave blank
        }finally{
          done++;
          if ((done % 10) === 0) setStatus(true, `Tiles: ${prov.name} z=${z} … ${done}/${total}`);
        }
      }
    });

    await Promise.all(workers);

    const out = document.createElement("canvas");
    out.width = out.height = desiredSize;
    out.getContext("2d").drawImage(canvasTex, 0, 0, out.width, out.height);

    const tex = new THREE.CanvasTexture(out);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    tex.needsUpdate = true;

    return { texture: tex, zoom: z, tiles: total };
  }

  // ✅ Indexed triangle subdivision (adds vertices; now also subdivides UVs so tiles stay correct after refinement)
  function subdivideIndexedGeometry(geom, levels){
    levels = Math.max(0, Math.floor(levels));
    if (levels === 0) return geom;

    if (!geom.getIndex()) return geom;

    for (let L = 0; L < levels; L++){
      const posAttr = geom.getAttribute("position");
      const uvAttr = geom.getAttribute("uv");
      const oldPos = posAttr.array;
      const oldCount = posAttr.count;
      const oldIdx = geom.getIndex().array;

      const positions = new Array(oldCount);
      for (let i=0;i<oldCount;i++){
        positions[i] = [ oldPos[i*3], oldPos[i*3+1], oldPos[i*3+2] ];
      }

      const hasUV = !!uvAttr;
      const uvs = hasUV ? new Array(oldCount) : null;
      if (hasUV){
        const oldUv = uvAttr.array;
        for (let i=0;i<oldCount;i++){
          uvs[i] = [ oldUv[i*2], oldUv[i*2+1] ];
        }
      }

      const midpointCache = new Map(); // "a|b" -> newIndex

      const getMid = (a,b) => {
        const i0 = a < b ? a : b;
        const i1 = a < b ? b : a;
        const key = i0 + "|" + i1;
        const hit = midpointCache.get(key);
        if (hit !== undefined) return hit;

        const pa = positions[a];
        const pb = positions[b];
        const m = [
          (pa[0] + pb[0]) * 0.5,
          (pa[1] + pb[1]) * 0.5,
          (pa[2] + pb[2]) * 0.5
        ];
        const idx = positions.length;
        positions.push(m);

        if (hasUV){
          const ua = uvs[a], ub = uvs[b];
          uvs.push([ (ua[0] + ub[0]) * 0.5, (ua[1] + ub[1]) * 0.5 ]);
        }

        midpointCache.set(key, idx);
        return idx;
      };

      const newIdx = [];
      newIdx.length = (oldIdx.length / 3) * 12;
      let w = 0;

      for (let i=0; i<oldIdx.length; i+=3){
        const a = oldIdx[i], b = oldIdx[i+1], c = oldIdx[i+2];

        const ab = getMid(a,b);
        const bc = getMid(b,c);
        const ca = getMid(c,a);

        newIdx[w++] = a;  newIdx[w++] = ab; newIdx[w++] = ca;
        newIdx[w++] = ab; newIdx[w++] = b;  newIdx[w++] = bc;
        newIdx[w++] = ca; newIdx[w++] = bc; newIdx[w++] = c;
        newIdx[w++] = ab; newIdx[w++] = bc; newIdx[w++] = ca;
      }
      newIdx.length = w;

      const flat = new Float32Array(positions.length * 3);
      for (let i=0;i<positions.length;i++){
        const p = positions[i];
        flat[i*3] = p[0];
        flat[i*3+1] = p[1];
        flat[i*3+2] = p[2];
      }

      const idxArr = (positions.length > 65535) ? new Uint32Array(newIdx) : new Uint16Array(newIdx);

      const next = new THREE.BufferGeometry();
      next.setAttribute("position", new THREE.BufferAttribute(flat, 3));
      next.setIndex(new THREE.BufferAttribute(idxArr, 1));

      if (hasUV){
        const flatUv = new Float32Array(uvs.length * 2);
        for (let i=0;i<uvs.length;i++){
          flatUv[i*2] = uvs[i][0];
          flatUv[i*2+1] = uvs[i][1];
        }
        next.setAttribute("uv", new THREE.BufferAttribute(flatUv, 2));
      }

      next.computeVertexNormals();

      geom.dispose();
      geom = next;
    }

    return geom;
  }

  // Surface build (Delaunay on E,N) + UVs for map tiles
  function buildSurface(points, opts){
    if (points.length < 3) throw new Error("Need at least 3 non-zero Z points to build a surface.");

    // Offsets to keep coordinates stable
    let sumE=0, sumN=0, sumZ=0;
    let minE=Infinity, maxE=-Infinity, minN=Infinity, maxN=-Infinity;
    for (const p of points){
      sumE += p.E; sumN += p.N; sumZ += p.Z;
      if (p.E < minE) minE = p.E;
      if (p.E > maxE) maxE = p.E;
      if (p.N < minN) minN = p.N;
      if (p.N > maxN) maxN = p.N;
    }
    const offE = sumE / points.length;
    const offN = sumN / points.length;
    const offZ = sumZ / points.length;

    kvOffset.textContent = `${offE.toFixed(3)}, ${offN.toFixed(3)}, ${offZ.toFixed(3)}`;

    // Build lon/lat bbox corners (for tile request + merc bbox for UV normalization)
    const ll00 = idahoWestToLonLat(minE, minN);
    const ll10 = idahoWestToLonLat(maxE, minN);
    const ll01 = idahoWestToLonLat(minE, maxN);
    const ll11 = idahoWestToLonLat(maxE, maxN);

    const west  = Math.min(ll00.lon, ll10.lon, ll01.lon, ll11.lon);
    const east  = Math.max(ll00.lon, ll10.lon, ll01.lon, ll11.lon);
    const south = Math.min(ll00.lat, ll10.lat, ll01.lat, ll11.lat);
    const north = Math.max(ll00.lat, ll10.lat, ll01.lat, ll11.lat);

    const wm = lonLatToWebMerc(west, (south+north)/2);
    const em = lonLatToWebMerc(east, (south+north)/2);
    const sm = lonLatToWebMerc((west+east)/2, south);
    const nm = lonLatToWebMerc((west+east)/2, north);

    const bboxMerc = {
      minX: Math.min(wm.x, em.x),
      maxX: Math.max(wm.x, em.x),
      minY: Math.min(sm.y, nm.y),
      maxY: Math.max(sm.y, nm.y)
    };
    const mercWidth = bboxMerc.maxX - bboxMerc.minX;
    const mercHeight = bboxMerc.maxY - bboxMerc.minY;

    lastTileBbox = { west, south, east, north, mercWidth, mercHeight };

    const zEx = opts.zExaggeration;

    const positions = new Float32Array(points.length * 3);
    const uvs = new Float32Array(points.length * 2);
    const pts2d = new Array(points.length);

    for (let i=0; i<points.length; i++){
      const p = points[i];
      const x = (p.E - offE);
      const y = (p.Z - offZ) * zEx;
      const z = (p.N - offN);

      positions[i*3+0] = x;
      positions[i*3+1] = y;
      positions[i*3+2] = z;

      pts2d[i] = [x, z];

      // UV for tile drape (mercator-normalized)
      const ll = idahoWestToLonLat(p.E, p.N);
      const m = lonLatToWebMerc(ll.lon, ll.lat);
      const u = (m.x - bboxMerc.minX) / (mercWidth || 1);
      const v = 1 - (m.y - bboxMerc.minY) / (mercHeight || 1);
      uvs[i*2+0] = u;
      uvs[i*2+1] = v;
    }

    const delaunay = Delaunay.from(pts2d);
    const tri = delaunay.triangles;
    if (!tri || tri.length < 3) {
      throw new Error("Triangulation produced 0 triangles. Points may be collinear or too few after filtering.");
    }

    // Base geom
    let geom = new THREE.BufferGeometry();
    geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geom.setAttribute("uv", new THREE.BufferAttribute(uvs, 2));
    geom.setIndex(new THREE.BufferAttribute(tri, 1));
    geom.computeVertexNormals();

    const baseTriCount = Math.floor(tri.length / 3);

    // ✅ Refinement by subdivision (now keeps UVs correct)
    const levels = Math.floor(Number(subdivLevels.value) || 0);
    if (levels > 0){
      geom = subdivideIndexedGeometry(geom, levels);
    }

    const mat = new THREE.MeshStandardMaterial({
      color: 0xa8d7ff,
      metalness: 0.05,
      roughness: 0.92,
      transparent: true,
      opacity: opts.opacity,
      side: THREE.DoubleSide,
      wireframe: opts.wireframe,
      polygonOffset: true,
      polygonOffsetFactor: 1,
      polygonOffsetUnits: 1,
    });

    const mesh = new THREE.Mesh(geom, mat);
    mesh.frustumCulled = false;

    const onShadow = (shadowMode.value === "on");
    mesh.castShadow = onShadow;
    mesh.receiveShadow = onShadow;

    // Original points as dots (not refined)
    const ptsGeom = new THREE.BufferGeometry();
    ptsGeom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    const ptsMat = new THREE.PointsMaterial({
      color: 0xffd54a,
      size: opts.pointSize,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.85
    });
    const pts = new THREE.Points(ptsGeom, ptsMat);

    const box3 = new THREE.Box3().setFromBufferAttribute(mesh.geometry.getAttribute("position"));
    const pad = 0.05;
    const size = new THREE.Vector3(); box3.getSize(size);
    box3.expandByVector(size.multiplyScalar(pad));

    const refinedTriCount = mesh.geometry.getIndex()
      ? Math.floor(mesh.geometry.getIndex().array.length / 3)
      : Math.floor(mesh.geometry.getAttribute("position").count / 3);

    return { mesh, pts, box3, offZ, zEx, baseTriCount, refinedTriCount };
  }

  // Contour extraction (triangle-plane intersections)
  function buildContoursFromSurface(mesh, offZ, zEx, intervalReal, majorEvery){
    clearContours();
    if (!mesh || !intervalReal || intervalReal <= 0) return;

    const geom = mesh.geometry;
    const pos = geom.getAttribute("position");
    const arr = pos.array;
    const indexAttr = geom.getIndex();
    if (!indexAttr) return;
    const idx = indexAttr.array;

    // Real Z range from vertex Y
    let zMin = Infinity, zMax = -Infinity;
    for (let i=0; i<pos.count; i++){
      const y = arr[i*3+1];
      const zr = (y / zEx) + offZ;
      if (zr < zMin) zMin = zr;
      if (zr > zMax) zMax = zr;
    }
    if (!Number.isFinite(zMin) || !Number.isFinite(zMax) || zMax <= zMin) return;

    const eps = 1e-9;
    const start = Math.ceil((zMin - eps) / intervalReal) * intervalReal;
    const end   = Math.floor((zMax + eps) / intervalReal) * intervalReal;

    const minorVerts = [];
    const majorVerts = [];

    const pushSeg = (list, ax, ay, az, bx, by, bz) => {
      list.push(ax, ay, az, bx, by, bz);
    };

    for (let t=0; t<idx.length; t+=3){
      const ia = idx[t], ib = idx[t+1], ic = idx[t+2];

      const ax = arr[ia*3], ay = arr[ia*3+1], az = arr[ia*3+2];
      const bx = arr[ib*3], by = arr[ib*3+1], bz = arr[ib*3+2];
      const cx = arr[ic*3], cy = arr[ic*3+1], cz = arr[ic*3+2];

      const aZ = (ay / zEx) + offZ;
      const bZ = (by / zEx) + offZ;
      const cZ = (cy / zEx) + offZ;

      const triMin = Math.min(aZ,bZ,cZ);
      const triMax = Math.max(aZ,bZ,cZ);
      if (triMax < start || triMin > end) continue;

      const l0 = Math.ceil((triMin - eps) / intervalReal) * intervalReal;
      const l1 = Math.floor((triMax + eps) / intervalReal) * intervalReal;

      for (let L = l0; L <= l1 + eps; L += intervalReal){
        const pts = [];
        const levelY = (L - offZ) * zEx;
        const lift = 0.03; // reduce z-fighting

        const segPoint = (x0,y0,z0, Z0, x1,y1,z1, Z1) => {
          if ((Z0 < L && Z1 < L) || (Z0 > L && Z1 > L)) return;
          const d = (Z1 - Z0);
          if (Math.abs(d) < 1e-12) return;
          const tt = (L - Z0) / d;
          if (tt < -1e-9 || tt > 1+1e-9) return;
          const x = x0 + (x1 - x0) * tt;
          const z = z0 + (z1 - z0) * tt;
          pts.push([x, levelY + lift, z]);
        };

        segPoint(ax,ay,az, aZ, bx,by,bz, bZ);
        segPoint(bx,by,bz, bZ, cx,cy,cz, cZ);
        segPoint(cx,cy,cz, cZ, ax,ay,az, aZ);

        if (pts.length >= 2){
          const p0 = pts[0], p1 = pts[1];
          const k = Math.round(L / intervalReal);
          const isMajor = (majorEvery > 1) ? (k % majorEvery === 0) : true;
          const list = isMajor ? majorVerts : minorVerts;
          pushSeg(list, p0[0], p0[1], p0[2], p1[0], p1[1], p1[2]);
        }
      }
    }

    const segCount = Math.floor((minorVerts.length + majorVerts.length) / 6);
    kvSegs.textContent = String(segCount);

    if (minorVerts.length){
      const g = new THREE.BufferGeometry();
      g.setAttribute("position", new THREE.Float32BufferAttribute(minorVerts, 3));
      const m = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.28, depthWrite: false });
      contourMinor = new THREE.LineSegments(g, m);
      contourMinor.renderOrder = 10;
      scene.add(contourMinor);
    }

    if (majorVerts.length){
      const g = new THREE.BufferGeometry();
      g.setAttribute("position", new THREE.Float32BufferAttribute(majorVerts, 3));
      const m = new THREE.LineBasicMaterial({ color: 0xffd54a, transparent: true, opacity: 0.70, depthWrite: false });
      contourMajor = new THREE.LineSegments(g, m);
      contourMajor.renderOrder = 11;
      scene.add(contourMajor);
    }
  }

  async function rebuildTilesIfNeeded(force=false){
    try{
      clearImagery();

      if (!surfaceMesh) return;
      if (!lastTileBbox) return;

      const provider = tileProvider.value;
      if (provider === "none") return;

      const size = Number(tileTexSize.value) || 1024;

      // If nothing changed and not forced, no-op
      const b = lastTileBbox;
      if (!force &&
        lastTileState.provider === provider &&
        lastTileState.size === size &&
        lastTileState.west === b.west &&
        lastTileState.south === b.south &&
        lastTileState.east === b.east &&
        lastTileState.north === b.north
      ){
        return;
      }

      setStatus(true, `Fetching ${PROVIDERS[provider].name} tiles…`);

      const { texture, zoom, tiles } = await buildTileTexture(lastTileBbox, provider, size);

      // Overlay mesh uses SAME geometry (with UVs). Separate material so opacity is independent.
      const mat = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: Number(tileOpacity.value),
        depthWrite: false,
        toneMapped: false,
        side: THREE.DoubleSide
      });

      // Ensure it renders "on top" of the surface (prevents looking like it's under)
      mat.polygonOffset = true;
      mat.polygonOffsetFactor = -1;
      mat.polygonOffsetUnits = -1;

      imageryMesh = new THREE.Mesh(surfaceMesh.geometry, mat);
      imageryMesh.frustumCulled = false;
      imageryMesh.castShadow = false;
      imageryMesh.receiveShadow = false;
      imageryMesh.renderOrder = 5;

      // Only add if surface is visible
      if (showSurface.checked) scene.add(imageryMesh);

      lastTileState = { provider, size, west:b.west, south:b.south, east:b.east, north:b.north };

      setStatus(true, `Tiles ready: ${PROVIDERS[provider].name} z=${zoom} (${tiles} tiles).`);
    }catch(err){
      clearImagery();
      setStatus(false, `Tiles failed: ${err?.message || err}`);
      console.error(err);
    }
  }

  function renderFromText(text){
    clearSceneData();

    const { points, excludedZeroZ, deduped } = parseCsvText(text);

    kvCount.textContent = String(points.length);
    kvExcluded.textContent = String(excludedZeroZ);
    kvDeduped.textContent = String(deduped);

    const opts = {
      zExaggeration: Number(zScale.value),
      pointSize: Number(ptSize.value),
      opacity: Number(surfOpacity.value),
      wireframe: !!wireframe.checked
    };

    const { mesh, pts, box3, offZ, zEx, baseTriCount, refinedTriCount } = buildSurface(points, opts);

    surfaceMesh = mesh;
    pointsMesh = pts;
    lastBounds = box3;
    lastOffZ = offZ;
    lastZEx = zEx;

    kvTrisBase.textContent = String(baseTriCount);
    kvTrisRef.textContent = String(refinedTriCount);

    if (showSurface.checked) scene.add(surfaceMesh);
    if (showPoints.checked) scene.add(pointsMesh);

    boundsBox = buildBoundsBox(box3);
    scene.add(boundsBox);

    applyShadowQuality();
    applyShadowMode();
    updateSunForBounds(box3);
    updateCameraClippingForBox(box3);
    updateFogForBox(box3);

    if (contoursOn.checked){
      buildContoursFromSurface(
        surfaceMesh,
        lastOffZ,
        lastZEx,
        Number(contourInterval.value),
        Math.max(1, Math.floor(Number(contourMajorEvery.value) || 1))
      );
    }

    setStatus(true, `Rendered. Refinement level: ${Math.floor(Number(subdivLevels.value)||0)}. Contours: ${contoursOn.checked ? "on" : "off"}.`);
    fitViewToBox(box3);

    // ✅ Build tiles after surface exists
    rebuildTilesIfNeeded(true);
  }

  function refreshLabels(){
    const zs = Number(zScale.value);
    zScaleLabel.textContent = `${zs.toFixed(1)}×`;
    ptSizeLabel.textContent = `${Number(ptSize.value).toFixed(1)}`;
    surfOpacityLabel.textContent = `${Number(surfOpacity.value).toFixed(2)}`;
    sunAzLabel.textContent = `${Number(sunAz.value)}°`;
    sunElLabel.textContent = `${Number(sunEl.value)}°`;
    subdivLabel.textContent = `${Math.floor(Number(subdivLevels.value)||0)}`;
    tileOpacityLabel.textContent = `${Number(tileOpacity.value).toFixed(2)}`;
  }
  refreshLabels();

  // Exaggeration slider + input sync
  function setZScale(v){
    const x = Math.min(200, Math.max(0.1, Number(v) || 1));
    zScale.value = String(x);
    zScaleNum.value = String(x);
    refreshLabels();
  }
  zScale.addEventListener("input", () => { setZScale(zScale.value); if (surfaceMesh) btnRender.click(); });
  zScaleNum.addEventListener("change", () => { setZScale(zScaleNum.value); if (surfaceMesh) btnRender.click(); });

  ptSize.addEventListener("input", () => { refreshLabels(); if (pointsMesh) pointsMesh.material.size = Number(ptSize.value); });
  surfOpacity.addEventListener("input", () => { refreshLabels(); if (surfaceMesh) surfaceMesh.material.opacity = Number(surfOpacity.value); });
  wireframe.addEventListener("change", () => { if (surfaceMesh) surfaceMesh.material.wireframe = !!wireframe.checked; });

  showSurface.addEventListener("change", () => {
    if (!surfaceMesh) return;
    if (showSurface.checked){
      scene.add(surfaceMesh);
      if (imageryMesh) scene.add(imageryMesh);
    }else{
      scene.remove(surfaceMesh);
      if (imageryMesh) scene.remove(imageryMesh);
    }
  });
  showPoints.addEventListener("change", () => { if (!pointsMesh) return; showPoints.checked ? scene.add(pointsMesh) : scene.remove(pointsMesh); });
  showGrid.addEventListener("change", () => { grid.visible = !!showGrid.checked; });

  sunAz.addEventListener("input", () => { refreshLabels(); updateSunForBounds(lastBounds); });
  sunEl.addEventListener("input", () => { refreshLabels(); updateSunForBounds(lastBounds); });
  shadowQuality.addEventListener("change", () => { applyShadowQuality(); updateSunForBounds(lastBounds); });
  shadowMode.addEventListener("change", () => { applyShadowMode(); updateSunForBounds(lastBounds); });

  // Tiles controls
  tileOpacity.addEventListener("input", () => {
    refreshLabels();
    if (imageryMesh) imageryMesh.material.opacity = Number(tileOpacity.value);
  });
  tileProvider.addEventListener("change", () => {
    refreshLabels();
    if (!surfaceMesh) return;
    rebuildTilesIfNeeded(true);
  });
  tileTexSize.addEventListener("change", () => {
    if (!surfaceMesh) return;
    rebuildTilesIfNeeded(true);
  });
  btnRebuildTiles.addEventListener("click", () => {
    if (!surfaceMesh) { setStatus(false, "No surface yet."); return; }
    rebuildTilesIfNeeded(true);
  });

  // Refinement (requires re-render because geometry changes)
  subdivLevels.addEventListener("input", () => { refreshLabels(); });
  subdivLevels.addEventListener("change", () => { refreshLabels(); if (surfaceMesh) btnRender.click(); });

  // Contours
  btnRebuildContours.addEventListener("click", () => {
    try{
      if (!surfaceMesh) throw new Error("No surface yet.");
      if (!contoursOn.checked) { clearContours(); setStatus(true, "Contours are off."); return; }
      buildContoursFromSurface(
        surfaceMesh,
        lastOffZ,
        lastZEx,
        Number(contourInterval.value),
        Math.max(1, Math.floor(Number(contourMajorEvery.value) || 1))
      );
      setStatus(true, "Contours rebuilt.");
    }catch(err){
      setStatus(false, err?.message || String(err));
    }
  });

  contoursOn.addEventListener("change", () => {
    if (!surfaceMesh) return;
    if (!contoursOn.checked) { clearContours(); return; }
    btnRebuildContours.click();
  });

  contourInterval.addEventListener("change", () => { if (surfaceMesh && contoursOn.checked) btnRebuildContours.click(); });
  contourMajorEvery.addEventListener("change", () => { if (surfaceMesh && contoursOn.checked) btnRebuildContours.click(); });

  navModeSel.addEventListener("change", () => {
    const mode = navModeSel.value;
    if (mode === "orbit") {
      fpsEnabled = false;
      orbit.enabled = true;
      fps.unlock();
      setStatus(true, "Orbit mode enabled.");
    } else {
      fpsEnabled = true;
      orbit.enabled = false;
      setStatus(true, "First-person mode enabled. Click the canvas to lock pointer.");
    }
  });

  btnRender.addEventListener("click", () => {
    try {
      const text = csvTA.value.trim();
      if (!text) throw new Error("Paste CSV text or load a CSV file first.");
      renderFromText(text);
    } catch (err) {
      setStatus(false, err?.message || String(err));
      console.error(err);
    }
  });

  btnFit.addEventListener("click", () => {
    try {
      if (!surfaceMesh) throw new Error("Nothing to fit yet.");
      const posAttr = surfaceMesh.geometry.getAttribute("position");
      const box3 = new THREE.Box3().setFromBufferAttribute(posAttr);
      fitViewToBox(box3);
      updateSunForBounds(box3);
      setStatus(true, "Fit view.");
    } catch (err) {
      setStatus(false, err?.message || String(err));
    }
  });

  btnSample.addEventListener("click", () => {
    // Sample with subtle relief + gentle slope; good for contours + refinement
    const baseE = 2406000;
    const baseN = 666000;
    const rows = [];
    let p = 1;

    for (let j=0; j<45; j++){
      for (let i=0; i<45; i++){
        const E = baseE + i*40;
        const N = baseN + j*40;
        const dx = (i-22)/22;
        const dy = (j-22)/22;

        let Z = 2500
          + 0.6*(i/44)
          + 3.2*Math.exp(-(dx*dx + dy*dy)*1.8)
          + 0.9*Math.sin(i*0.22)*Math.cos(j*0.18);

        if ((i===0 && j===0) || (i===44 && j===44)) Z = 0;
        rows.push(`${p++},${N.toFixed(3)},${E.toFixed(3)},${Z.toFixed(3)},SAMPLE`);
      }
    }

    csvTA.value = rows.join("\n");
    setZScale(60);
    contourInterval.value = "0.5";
    contourMajorEvery.value = "5";
    sunEl.value = "14";
    sunAz.value = "315";
    subdivLevels.value = "2";
    tileProvider.value = "none";
    tileTexSize.value = "1024";
    tileOpacity.value = "0.30";
    refreshLabels();
    setStatus(true, "Sample loaded. Click Render Surface.");
  });

  btnClear.addEventListener("click", () => {
    csvTA.value = "";
    clearSceneData();
  });

  fileIn.addEventListener("change", async () => {
    const f = fileIn.files?.[0];
    if (!f) return;
    try{
      const text = await f.text();
      csvTA.value = text;
      setStatus(true, `Loaded: ${f.name}`);
    } catch (err){
      setStatus(false, `Failed to read file: ${err?.message || err}`);
    }
  });

  btnLoadProjectPointFile.addEventListener("click", async () => {
    try {
      await loadProjectPointFileIntoCsv();
    } catch (err) {
      setStatus(false, err?.message || String(err));
    }
  });

  projectPointFileSel.addEventListener("change", () => {
    btnLoadProjectPointFile.disabled = !projectPointFileSel.value;
  });

  // Animation loop
  let lastT = performance.now();

  function fpsUpdate(dt){
    if (!fpsEnabled || !fps.isLocked) return;

    const speed = (keys.has("ShiftLeft") || keys.has("ShiftRight")) ? 220 : 110;

    vel.set(0,0,0);
    if (keys.has("KeyW")) vel.z -= 1;
    if (keys.has("KeyS")) vel.z += 1;
    if (keys.has("KeyA")) vel.x -= 1;
    if (keys.has("KeyD")) vel.x += 1;
    if (keys.has("Space")) vel.y += 1;
    if (keys.has("ControlLeft") || keys.has("ControlRight")) vel.y -= 1;

    if (vel.lengthSq() > 0) vel.normalize().multiplyScalar(speed * dt);

    fps.moveRight(vel.x);
    fps.moveForward(vel.z);
    camera.position.addScaledVector(up, vel.y);
  }

  function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastT) / 1000);
    lastT = now;

    resize();
    if (orbit.enabled) orbit.update();
    fpsUpdate(dt);
    if (lastBounds) {
      updateCameraClippingForBox(lastBounds);
      updateFogForBox(lastBounds);
    }
    renderer.render(scene, camera);
  }
  animate();

  syncProjectPointFilesFromApi().catch((err) => {
    renderProjectPointFileChoices([]);
    projectPointFileHint.textContent = `Unable to load project point files for ${activeProjectId}: ${err?.message || err}`;
  });

  setStatus(true, "Render a surface. Map tiles: pick a provider (Esri/USGS) and they’ll drape at 30% opacity.");
</script>
</body>
</html>
