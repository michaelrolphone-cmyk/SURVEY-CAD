<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CSV → 3D Surface (Idaho West) — Three.js</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111824cc; --panel2:#0f1520cc;
      --text:#e8eef7; --muted:#9aa8bb; --accent:#ffd54a;
      --line:#2a3a52; --danger:#ff5a7a;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:var(--sans); overflow:hidden;}
    #wrap{position:fixed; inset:0; display:grid; grid-template-columns: 420px 1fr;}
    #ui{
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border-right:1px solid var(--line);
      padding:14px 14px 10px;
      display:flex; flex-direction:column; gap:10px;
      min-width:320px;
    }
    #viewport{position:relative;}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .row > * {flex: 0 0 auto;}
    .btn{
      appearance:none; border:1px solid var(--line); background:#0c1320;
      color:var(--text); padding:8px 10px; border-radius:10px; cursor:pointer;
      font-weight:600;
    }
    .btn:hover{border-color:#3a557a;}
    .btn.accent{border-color:#6b5a1a; background:linear-gradient(180deg,#2a230e,#171206); color:#ffe6a3;}
    .btn.danger{border-color:#632131; background:linear-gradient(180deg,#2a0f16,#1a0a0f); color:#ffb3c1;}
    .file{max-width:100%;}
    textarea{
      width:100%; height:220px; resize:vertical;
      border-radius:12px; border:1px solid var(--line);
      background:#070b10; color:var(--text); padding:10px;
      font-family:var(--mono); font-size:12px; line-height:1.25;
      outline:none;
    }
    .controls{
      border:1px solid var(--line); border-radius:12px; padding:10px;
      background:#070b10aa;
      display:grid; grid-template-columns: 1fr 1fr; gap:10px;
    }
    label{display:flex; flex-direction:column; gap:6px; font-size:12px; color:var(--muted);}
    input[type="range"]{width:100%;}
    input[type="number"], select{
      width:100%; border-radius:10px; border:1px solid var(--line);
      background:#0b1220; color:var(--text); padding:7px 8px; outline:none;
    }
    .kv{
      border:1px solid var(--line); border-radius:12px; padding:10px;
      background:#070b10aa;
      font-family:var(--mono); font-size:12px; color:var(--muted);
      white-space:pre-wrap;
    }
    .hint{ font-size:12px; color:var(--muted); line-height:1.35; }
    #fpOverlay{
      position:absolute; inset:0; display:none;
      align-items:flex-end; justify-content:center;
      padding:18px;
      pointer-events:none;
      font-family:var(--mono);
      color:#cfe0ff;
      text-shadow: 0 1px 0 #000;
    }
    #fpOverlay .box{
      background:#06101dcc; border:1px solid #2a3a52; border-radius:12px;
      padding:10px 12px;
    }
    #canvas{
      position:absolute; inset:0;
      display:block;
      width:100%;
      height:100%;
    }
  </style>
  
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<div id="wrap">
  <div id="ui">
    <div class="row">
      <input id="file" class="file" type="file" accept=".csv,text/csv" />
      <button id="btnRender" class="btn accent">Render</button>
      <button id="btnDemo" class="btn">Demo</button>
      <button id="btnClear" class="btn danger">Clear</button>
    </div>

    <textarea id="csv" spellcheck="false" placeholder="Paste CSV here: P,N,E,Z,D"></textarea>

    <div class="controls">
      <label>
        Navigation
        <select id="navMode">
          <option value="orbit" selected>Orbit</option>
          <option value="fp">First-person (pointer lock)</option>
        </select>
      </label>

      <label>
        Texture source
        <select id="texSource">
          <option value="esri" selected>Esri World Imagery (tiles)</option>
          <option value="usgs">USGS ImageryOnly (tiles, max z≈16)</option>
          <option value="none">None</option>
        </select>
      </label>

      <label>
        Grid resolution (adds vertices)
        <input id="gridRes" type="range" min="32" max="256" step="1" value="128" />
      </label>

      <label>
        Z exaggeration
        <input id="zExag" type="range" min="0.2" max="50" step="0.1" value="10" />
      </label>

      <label>
        IDW power
        <input id="idwPow" type="range" min="1" max="4" step="0.1" value="2" />
      </label>

      <label>
        Neighbors (K)
        <input id="knn" type="range" min="4" max="32" step="1" value="12" />
      </label>

      <label>
        Contour interval (feet)
        <input id="contInt" type="number" min="0.1" step="0.1" value="1" />
      </label>

      <label style="flex-direction:row; align-items:center; gap:10px; color:var(--text);">
        <input id="showContours" type="checkbox" checked />
        Show contours
      </label>

      <label style="flex-direction:row; align-items:center; gap:10px; color:var(--text);">
        <input id="shadows" type="checkbox" checked />
        Shadows
      </label>
    </div>

    <div id="status" class="kv">Drop CSV, or click Demo → Render.</div>
    <div class="hint">
      CSV format: <b>P,N,E,Z,D</b> (Northing/Easting in Idaho West State Plane, US-ft; Z in feet). Rows with <b>Z=0</b> are ignored.
      Contours are drawn over the mesh. Smoothing is achieved by increasing grid resolution (more vertices), not by averaging heights.
    </div>
  </div>

  <div id="viewport">
    <canvas id="canvas"></canvas>
    <div id="fpOverlay">
      <div class="box">Click scene to lock pointer • WASD move • Shift faster • Esc unlock</div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/PointerLockControls.js';

const $ = (id) => document.getElementById(id);

const canvas = $('canvas');
const viewport = $('viewport');
const statusEl = $('status');
const fpOverlay = $('fpOverlay');

function setStatus(msg){ statusEl.textContent = msg; }

const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x070b10);

const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2e7);
camera.position.set(0, 900, 900);

const orbit = new OrbitControls(camera, renderer.domElement);
orbit.enableDamping = true;
orbit.dampingFactor = 0.06;
orbit.target.set(0, 0, 0);

const fp = new PointerLockControls(camera, renderer.domElement);
let navMode = 'orbit';

// Lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.75);
scene.add(hemi);

const ambient = new THREE.AmbientLight(0xffffff, 0.20);
scene.add(ambient);


const sun = new THREE.DirectionalLight(0xffffff, 1.1);
sun.position.set(1200, 2200, 900);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.near = 10;
sun.shadow.camera.far = 10000;
sun.shadow.camera.left = -4000;
sun.shadow.camera.right = 4000;
sun.shadow.camera.top = 4000;
sun.shadow.camera.bottom = -4000;
scene.add(sun);

// Terrain group
const terrainGroup = new THREE.Group();
scene.add(terrainGroup);

let terrainMesh = null;
let contourLines = null;

function clearTerrain(){
  while (terrainGroup.children.length){
    const o = terrainGroup.children.pop();
    if (o.geometry?.dispose) o.geometry.dispose();
    if (o.material){
      const mats = Array.isArray(o.material) ? o.material : [o.material];
      for (const m of mats){
        if (m.map?.dispose) m.map.dispose();
        if (m.dispose) m.dispose();
      }
    }
  }
  terrainMesh = null;
  contourLines = null;
}

function resize(){
  const rect = viewport.getBoundingClientRect();
  const w = Math.max(1, Math.floor(rect.width));
  const h = Math.max(1, Math.floor(rect.height));
  renderer.setSize(w, h, false);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resize);
resize();

// -------------------- CSV parsing --------------------
function parseCSV(text){
  const lines = text.split(/\r?\n/);
  const pts = [];
  for (let raw of lines){
    const line = raw.trim();
    if (!line) continue;
    if (/^[a-z]/i.test(line) && line.toLowerCase().includes('north')) continue; // header-ish

    const parts = line.split(',');
    if (parts.length < 4) continue;

    const P = parts[0]?.trim();
    const N = Number(parts[1]);
    const E = Number(parts[2]);
    const Z = Number(parts[3]);
    const D = parts.slice(4).join(',').trim();

    if (!Number.isFinite(N) || !Number.isFinite(E) || !Number.isFinite(Z)) continue;
    if (Z === 0) continue; // exclude zero elevations
    pts.push({ P, N, E, Z, D });
  }
  return pts;
}

// -------------------- Idaho West (NAD83 / Idaho West, US-ft) inverse TM --------------------
const USFT_TO_M = 1200 / 3937; // exact
const GRS80_A = 6378137.0;
const GRS80_F = 1 / 298.257222101;
const GRS80_E2 = 2 * GRS80_F - GRS80_F * GRS80_F;
const EP2 = GRS80_E2 / (1 - GRS80_E2);

const IDW_LAT0 = 41.6666666666667 * Math.PI / 180;
const IDW_LON0 = -115.75 * Math.PI / 180;
const IDW_K0 = 0.999933333;
const IDW_FE_FT = 2624666.667; // ftUS
const IDW_FN_FT = 0.0;

const e1 = (1 - Math.sqrt(1 - GRS80_E2)) / (1 + Math.sqrt(1 - GRS80_E2));

function meridionalArc(phi){
  const e2 = GRS80_E2, e4 = e2*e2, e6 = e4*e2;
  return GRS80_A * (
    (1 - e2/4 - 3*e4/64 - 5*e6/256) * phi
    - (3*e2/8 + 3*e4/32 + 45*e6/1024) * Math.sin(2*phi)
    + (15*e4/256 + 45*e6/1024) * Math.sin(4*phi)
    - (35*e6/3072) * Math.sin(6*phi)
  );
}
const M0 = meridionalArc(IDW_LAT0);

function idahoWestToLonLat(E_ft, N_ft){
  const x = (E_ft - IDW_FE_FT) * USFT_TO_M;
  const y = (N_ft - IDW_FN_FT) * USFT_TO_M;

  const M = M0 + y / IDW_K0;
  const e2 = GRS80_E2, e4 = e2*e2, e6 = e4*e2;

  const mu = M / (GRS80_A * (1 - e2/4 - 3*e4/64 - 5*e6/256));

  const J1 = (3*e1/2 - 27*Math.pow(e1,3)/32);
  const J2 = (21*Math.pow(e1,2)/16 - 55*Math.pow(e1,4)/32);
  const J3 = (151*Math.pow(e1,3)/96);
  const J4 = (1097*Math.pow(e1,4)/512);

  const phi1 = mu + J1*Math.sin(2*mu) + J2*Math.sin(4*mu) + J3*Math.sin(6*mu) + J4*Math.sin(8*mu);

  const sin1 = Math.sin(phi1), cos1 = Math.cos(phi1), tan1 = Math.tan(phi1);
  const N1 = GRS80_A / Math.sqrt(1 - e2*sin1*sin1);
  const R1 = (GRS80_A * (1 - e2)) / Math.pow(1 - e2*sin1*sin1, 1.5);
  const T1 = tan1*tan1;
  const C1 = EP2*cos1*cos1;
  const D = x / (N1 * IDW_K0);

  const D2 = D*D, D3=D2*D, D4=D2*D2, D5=D4*D, D6=D3*D3;

  const lat = phi1 - (N1*tan1/R1) * (
    D2/2
    - (5 + 3*T1 + 10*C1 - 4*C1*C1 - 9*EP2) * D4/24
    + (61 + 90*T1 + 298*C1 + 45*T1*T1 - 252*EP2 - 3*C1*C1) * D6/720
  );

  const lon = IDW_LON0 + (1/cos1) * (
    D
    - (1 + 2*T1 + C1) * D3/6
    + (5 - 2*C1 + 28*T1 - 3*C1*C1 + 8*EP2 + 24*T1*T1) * D5/120
  );

  return { lon: lon * 180/Math.PI, lat: lat * 180/Math.PI };
}

function lonLatToWebMerc(lon, lat){
  const R = 6378137;
  const x = R * (lon * Math.PI/180);
  const clampedLat = Math.max(Math.min(lat, 85.05112878), -85.05112878);
  const y = R * Math.log(Math.tan(Math.PI/4 + (clampedLat*Math.PI/180)/2));
  return { x, y };
}

function lonLatToTileXY(lon, lat, z){
  const n = 2 ** z;
  const x = Math.floor((lon + 180) / 360 * n);
  const latRad = lat * Math.PI/180;
  const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n);
  return { x, y };
}

function chooseZoomForBbox(mercWidth, desiredPx, maxZ){
  const worldM = 2 * Math.PI * 6378137;
  const z = Math.log2((desiredPx * worldM) / (256 * mercWidth));
  return Math.max(0, Math.min(maxZ, Math.round(z)));
}

const PROVIDERS = {
  esri: {
    name: 'Esri World Imagery',
    maxZ: 19,
    url: (z,x,y) => `https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${z}/${y}/${x}`
  },
  usgs: {
    name: 'USGS ImageryOnly',
    maxZ: 16,
    url: (z,x,y) => `https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/${z}/${y}/${x}`
  }
};

async function fetchImageBitmap(url){
  const res = await fetch(url, { mode:'cors', credentials:'omit' });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const blob = await res.blob();
  return await createImageBitmap(blob);
}

async function buildTileTexture(bboxLonLat, providerKey, desiredSize){
  const prov = PROVIDERS[providerKey];
  const { west, south, east, north, mercWidth, mercHeight } = bboxLonLat;

  const z = chooseZoomForBbox(Math.max(mercWidth, mercHeight), desiredSize, prov.maxZ);

  const t0 = lonLatToTileXY(west, north, z);
  const t1 = lonLatToTileXY(east, south, z);

  const minX = Math.min(t0.x, t1.x), maxX = Math.max(t0.x, t1.x);
  const minY = Math.min(t0.y, t1.y), maxY = Math.max(t0.y, t1.y);

  const tilesW = (maxX - minX + 1);
  const tilesH = (maxY - minY + 1);
  const total = tilesW * tilesH;

  if (total > 120) throw new Error(`Too many tiles at z=${z} (${total}). Reduce area or texture size.`);

  const canvasTex = document.createElement('canvas');
  canvasTex.width = tilesW * 256;
  canvasTex.height = tilesH * 256;
  const ctx = canvasTex.getContext('2d');

  const jobs = [];
  for (let ty=minY; ty<=maxY; ty++) for (let tx=minX; tx<=maxX; tx++) jobs.push({ tx, ty });

  let done = 0;
  const concurrency = 8;
  const workers = Array.from({length: concurrency}, async () => {
    while (jobs.length){
      const job = jobs.pop();
      const url = prov.url(z, job.tx, job.ty);
      try{
        const bmp = await fetchImageBitmap(url);
        ctx.drawImage(bmp, (job.tx - minX) * 256, (job.ty - minY) * 256);
      }catch{
        // leave blank
      }finally{
        done++;
        if ((done % 10) === 0) setStatus(`Texture: ${prov.name} z=${z} … ${done}/${total} tiles`);
      }
    }
  });
  await Promise.all(workers);

  const out = document.createElement('canvas');
  out.width = out.height = desiredSize;
  out.getContext('2d').drawImage(canvasTex, 0, 0, out.width, out.height);

  const tex = new THREE.CanvasTexture(out);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
  tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
  tex.needsUpdate = true;
  return { texture: tex, zoom: z, tiles: total };
}

// -------------------- Interpolation (IDW on grid) --------------------
function buildBuckets(points, minE, minN, maxE, maxN){
  const w = maxE - minE;
  const h = maxN - minN;
  const bx = Math.max(16, Math.min(96, Math.floor(Math.sqrt(points.length))));
  const by = bx;
  const cellE = w / bx;
  const cellN = h / by;
  const buckets = Array.from({ length: bx * by }, () => []);
  for (let i=0;i<points.length;i++){
    const p = points[i];
    const ix = Math.max(0, Math.min(bx-1, Math.floor((p.E - minE) / cellE)));
    const iy = Math.max(0, Math.min(by-1, Math.floor((p.N - minN) / cellN)));
    buckets[iy*bx + ix].push(i);
  }
  return { buckets, bx, by, cellE, cellN };
}

function knnFromBuckets(points, bucketInfo, minE, minN, e, n, K){
  const { buckets, bx, by, cellE, cellN } = bucketInfo;
  const cx = Math.max(0, Math.min(bx-1, Math.floor((e - minE) / cellE)));
  const cy = Math.max(0, Math.min(by-1, Math.floor((n - minN) / cellN)));

  const best = []; // [{i, d2}] sorted asc
  const pushBest = (i, d2) => {
    let j = best.length;
    while (j>0 && best[j-1].d2 > d2) j--;
    best.splice(j, 0, { i, d2 });
    if (best.length > K) best.pop();
  };

  const maxR = Math.max(bx, by);
  for (let r=0; r<maxR; r++){
    let foundAny = false;
    const y0 = Math.max(0, cy-r), y1 = Math.min(by-1, cy+r);
    const x0 = Math.max(0, cx-r), x1 = Math.min(bx-1, cx+r);

    for (let y=y0; y<=y1; y++){
      for (let x=x0; x<=x1; x++){
        if (r>0 && x!==x0 && x!==x1 && y!==y0 && y!==y1) continue;
        const b = buckets[y*bx + x];
        if (!b.length) continue;
        foundAny = true;
        for (const idx of b){
          const p = points[idx];
          const de = p.E - e, dn = p.N - n;
          const d2 = de*de + dn*dn;
          if (d2 === 0) return [{ i: idx, d2: 0 }];
          if (best.length < K || d2 < best[best.length-1].d2) pushBest(idx, d2);
        }
      }
    }
    if (best.length >= K && foundAny) break;
  }
  return best;
}

function idwZ(points, bucketInfo, minE, minN, e, n, K, power){
  const nn = knnFromBuckets(points, bucketInfo, minE, minN, e, n, K);
  if (!nn.length) return 0;
  if (nn.length === 1 && nn[0].d2 === 0) return points[nn[0].i].Z;

  let num = 0, den = 0;
  for (const {i, d2} of nn){
    const w = 1 / Math.pow(d2, power/2);
    num += w * points[i].Z;
    den += w;
  }
  return den > 0 ? (num/den) : 0;
}

// -------------------- Contours (marching squares) --------------------
function buildContours(grid, Nx, Ny, minZ, maxZ, interval, dx, dy, minE, minN, centerE, centerN){
  if (!interval || interval <= 0) return null;

  const levels = [];
  const start = Math.ceil(minZ / interval) * interval;
  const end = Math.floor(maxZ / interval) * interval;
  for (let z = start; z <= end; z += interval) levels.push(z);

  if (levels.length > 220){
    const newInt = (end - start) / 200;
    interval = Math.max(interval, newInt);
    return buildContours(grid, Nx, Ny, minZ, maxZ, interval, dx, dy, minE, minN, centerE, centerN);
  }

  const table = {
    1:[[3,0]], 2:[[0,1]], 3:[[3,1]], 4:[[1,2]], 5:[[3,2],[0,1]],
    6:[[0,2]], 7:[[3,2]], 8:[[2,3]], 9:[[0,2]], 10:[[0,1],[2,3]],
    11:[[1,2]], 12:[[1,3]], 13:[[0,1]], 14:[[3,0]]
  };

  const edgePoint = (edge, t) => {
    switch(edge){
      case 0: return { x: t,   y: 0 };
      case 1: return { x: 1,   y: t };
      case 2: return { x: 1-t, y: 1 };
      case 3: return { x: 0,   y: 1-t };
    }
  };

  const pos = [];
  const EPS = 0.03;
  const at = (ix, iy) => grid[iy*Nx + ix];

  for (const level of levels){
    for (let iy=0; iy<Ny-1; iy++){
      for (let ix=0; ix<Nx-1; ix++){
        const a = at(ix, iy), b = at(ix+1, iy), c = at(ix+1, iy+1), d = at(ix, iy+1);

        let idx = 0;
        if (a > level) idx |= 1;
        if (b > level) idx |= 2;
        if (c > level) idx |= 4;
        if (d > level) idx |= 8;
        if (idx === 0 || idx === 15) continue;

        const segs = table[idx];
        if (!segs) continue;

        const interpT = (z1, z2) => {
          const denom = (z2 - z1);
          if (Math.abs(denom) < 1e-12) return 0.5;
          return (level - z1) / denom;
        };

        const edgeT = (edge) => {
          switch(edge){
            case 0: return interpT(a, b);
            case 1: return interpT(b, c);
            case 2: return interpT(c, d);
            case 3: return interpT(d, a);
          }
        };

        for (const [e0, e1] of segs){
          const p0 = edgePoint(e0, edgeT(e0));
          const p1 = edgePoint(e1, edgeT(e1));

          const E0 = minE + (ix + p0.x) * dx;
          const N0 = minN + (iy + p0.y) * dy;
          const E1 = minE + (ix + p1.x) * dx;
          const N1 = minN + (iy + p1.y) * dy;

          const x0 = E0 - centerE, z0 = N0 - centerN;
          const x1 = E1 - centerE, z1 = N1 - centerN;

          const y = (level - minZ) + EPS;
          pos.push(x0, y, z0, x1, y, z1);
        }
      }
    }
  }

  if (!pos.length) return null;

  const g = new THREE.BufferGeometry();
  g.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
  const m = new THREE.LineBasicMaterial({ color: 0x0099ff, transparent:true, opacity:0.85 });
  m.linewidth = 5;
  const lines = new THREE.LineSegments(g, m);
  lines.frustumCulled = false;
  return lines;
}

// -------------------- Build terrain --------------------
async function buildTerrain(points){
  if (points.length < 3){
    setStatus(`Need ≥3 points with nonzero Z. Got ${points.length}.`);
    return;
  }

  clearTerrain();

  let minE=Infinity, maxE=-Infinity, minN=Infinity, maxN=-Infinity, minZ=Infinity, maxZ=-Infinity;
  for (const p of points){
    if (p.E < minE) minE = p.E;
    if (p.E > maxE) maxE = p.E;
    if (p.N < minN) minN = p.N;
    if (p.N > maxN) maxN = p.N;
    if (p.Z < minZ) minZ = p.Z;
    if (p.Z > maxZ) maxZ = p.Z;
  }

  const padE = (maxE-minE)*0.03, padN = (maxN-minN)*0.03;
  minE -= padE; maxE += padE; minN -= padN; maxN += padN;

  const centerE = (minE + maxE) / 2;
  const centerN = (minN + maxN) / 2;

  const res = Number($('gridRes').value);
  const Nx = res, Ny = res;
  const dx = (maxE - minE) / (Nx - 1);
  const dy = (maxN - minN) / (Ny - 1);

  const K = Number($('knn').value);
  const power = Number($('idwPow').value);
  const interval = Number($('contInt').value);

  setStatus(`Interpolating grid ${Nx}×${Ny} (IDW p=${power}, K=${K}) …`);

  const bucketInfo = buildBuckets(points, minE, minN, maxE, maxN);
  const grid = new Float32Array(Nx * Ny);

  for (let iy=0; iy<Ny; iy++){
    for (let ix=0; ix<Nx; ix++){
      const E = minE + ix * dx;
      const N = minN + iy * dy;
      grid[iy*Nx + ix] = idwZ(points, bucketInfo, minE, minN, E, N, K, power);
    }
    if ((iy % 16) === 0) setStatus(`Interpolating … ${(iy+1)}/${Ny} rows`);
  }

  const positions = new Float32Array(Nx * Ny * 3);
  const uvs = new Float32Array(Nx * Ny * 2);
  const indices = [];

  setStatus(`Projecting Idaho West → lon/lat for UVs …`);

  const ll00 = idahoWestToLonLat(minE, minN);
  const ll10 = idahoWestToLonLat(maxE, minN);
  const ll01 = idahoWestToLonLat(minE, maxN);
  const ll11 = idahoWestToLonLat(maxE, maxN);

  const west  = Math.min(ll00.lon, ll10.lon, ll01.lon, ll11.lon);
  const east  = Math.max(ll00.lon, ll10.lon, ll01.lon, ll11.lon);
  const south = Math.min(ll00.lat, ll10.lat, ll01.lat, ll11.lat);
  const north = Math.max(ll00.lat, ll10.lat, ll01.lat, ll11.lat);

  const wm = lonLatToWebMerc(west, (south+north)/2);
  const em = lonLatToWebMerc(east, (south+north)/2);
  const sm = lonLatToWebMerc((west+east)/2, south);
  const nm = lonLatToWebMerc((west+east)/2, north);

  const bboxMerc = {
    minX: Math.min(wm.x, em.x),
    maxX: Math.max(wm.x, em.x),
    minY: Math.min(sm.y, nm.y),
    maxY: Math.max(sm.y, nm.y)
  };

  const mercWidth = bboxMerc.maxX - bboxMerc.minX;
  const mercHeight = bboxMerc.maxY - bboxMerc.minY;

  for (let iy=0; iy<Ny; iy++){
    for (let ix=0; ix<Nx; ix++){
      const E = minE + ix * dx;
      const N = minN + iy * dy;
      const z = grid[iy*Nx + ix];

      const x = E - centerE;
      const y = (z - minZ);
      const zc = N - centerN;

      const vi = (iy*Nx + ix) * 3;
      positions[vi+0] = x;
      positions[vi+1] = y;
      positions[vi+2] = zc;

      const ll = idahoWestToLonLat(E, N);
      const m = lonLatToWebMerc(ll.lon, ll.lat);
      const u = (m.x - bboxMerc.minX) / (mercWidth || 1);
      const v = 1 - (m.y - bboxMerc.minY) / (mercHeight || 1);

      const ui = (iy*Nx + ix) * 2;
      uvs[ui+0] = u;
      uvs[ui+1] = v;
    }
    if ((iy % 24) === 0) setStatus(`Projecting … ${(iy+1)}/${Ny} rows`);
  }

  for (let iy=0; iy<Ny-1; iy++){
    for (let ix=0; ix<Nx-1; ix++){
      const a = iy*Nx + ix;
      const b = iy*Nx + (ix+1);
      const c = (iy+1)*Nx + (ix+1);
      const d = (iy+1)*Nx + ix;
      indices.push(a, d, b,  b, d, c);

//      indices.push(a,b,d, b,c,d);
    }
  }

  const geom = new THREE.BufferGeometry();
  geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
  geom.setIndex(indices);
  geom.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.95, metalness: 0.5 });

  terrainMesh = new THREE.Mesh(geom, mat);
  terrainMesh.receiveShadow = true;
  terrainGroup.add(terrainMesh);

  const texMode = $('texSource').value;
  if (texMode !== 'none'){
    try{
      const desiredSize = 1024;
      setStatus(`Fetching imagery (${PROVIDERS[texMode].name}) …`);
      const { texture, zoom, tiles } = await buildTileTexture(
        { west, south, east, north, mercWidth, mercHeight },
        texMode,
        desiredSize
      );
      mat.map = texture;
      mat.side=THREE.DoubleSide;
      mat.needsUpdate = true;
      setStatus(`Imagery: ${PROVIDERS[texMode].name} z=${zoom} (${tiles} tiles). Building contours…`);
    }catch(e){
      setStatus(`Imagery failed: ${e?.message || e}. Rendering without texture.`);
    }
  }else{
    setStatus(`No texture. Building contours…`);
  }

  if ($('showContours').checked){
    contourLines = buildContours(grid, Nx, Ny, minZ, maxZ, interval, dx, dy, minE, minN, centerE, centerN);
    if (contourLines) terrainGroup.add(contourLines);
  }

  const ex = Number($('zExag').value);
  terrainGroup.scale.set(1, ex, 1);

  const sh = $('shadows').checked;
  renderer.shadowMap.enabled = sh;
  sun.castShadow = sh;

  const span = Math.max((maxE - minE), (maxN - minN));
  orbit.target.set(0, (maxZ - minZ) * 0.15, 0);
  camera.position.set(span*0.35, span*0.55, span*0.45);
  camera.near = 0.1;
  camera.far = Math.max(20000, span * 8);
  camera.updateProjectionMatrix();
  orbit.update();

  const s = Math.max(1200, span*0.8);
  sun.shadow.camera.left = -s;
  sun.shadow.camera.right = s;
  sun.shadow.camera.top = s;
  sun.shadow.camera.bottom = -s;
  sun.shadow.camera.far = Math.max(10000, span*4);
  sun.shadow.camera.updateProjectionMatrix();

  setStatus(
`Done.

Points: ${points.length}
Easting:  ${minE.toFixed(3)} .. ${maxE.toFixed(3)} (ft)
Northing: ${minN.toFixed(3)} .. ${maxN.toFixed(3)} (ft)
Z:        ${minZ.toFixed(3)} .. ${maxZ.toFixed(3)} (ft)

Lon/Lat bbox (approx):
W ${west.toFixed(6)}  E ${east.toFixed(6)}
S ${south.toFixed(6)} N ${north.toFixed(6)}
`
  );
}

// -------------------- Navigation modes --------------------
const keys = new Set();
window.addEventListener('keydown', (e)=> keys.add(e.code));
window.addEventListener('keyup', (e)=> keys.delete(e.code));

function setNavMode(mode){
  navMode = mode;
  if (navMode === 'fp'){
    fpOverlay.style.display = 'flex';
    orbit.enabled = false;
    scene.add(fp.getObject());
  }else{
    fpOverlay.style.display = 'none';
    orbit.enabled = true;
    try{ document.exitPointerLock?.(); }catch{}
  }
}
$('navMode').addEventListener('change', (e)=> setNavMode(e.target.value));
renderer.domElement.addEventListener('click', ()=>{
  if (navMode === 'fp') fp.lock();
});

let lastT = performance.now();
function tick(t){
  const dt = Math.min(0.05, (t - lastT) / 1000);
  lastT = t;

  if (navMode === 'orbit'){
    orbit.update();
  }else if (fp.isLocked){
    const speedBase = 260; // ft/s
    const speed = (keys.has('ShiftLeft') || keys.has('ShiftRight')) ? speedBase * 2.5 : speedBase;

    const dir = new THREE.Vector3();
    const fwd = new THREE.Vector3();
    camera.getWorldDirection(fwd);
    fwd.y = 0; fwd.normalize();
    const right = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0)).normalize();

    if (keys.has('KeyW')) dir.add(fwd);
    if (keys.has('KeyS')) dir.sub(fwd);
    if (keys.has('KeyA')) dir.sub(right);
    if (keys.has('KeyD')) dir.add(right);

    if (dir.lengthSq() > 0){
      dir.normalize().multiplyScalar(speed * dt);
      fp.getObject().position.add(dir);
    }
  }

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// -------------------- UI wiring --------------------
$('file').addEventListener('change', async (e)=>{
  const f = e.target.files?.[0];
  if (!f) return;
  const txt = await f.text();
  $('csv').value = txt;
  setStatus(`Loaded ${f.name} (${txt.length.toLocaleString()} chars). Click Render.`);
});

$('btnRender').addEventListener('click', async ()=>{
  const txt = $('csv').value || '';
  const pts = parseCSV(txt);
  await buildTerrain(pts);
});

$('btnDemo').addEventListener('click', ()=>{
  $('csv').value =
`1, 666102.348, 2406162.791, 2597.647, DEMO
2, 666102.399, 2406136.995, 2597.169, DEMO
3, 666085.547, 2406098.992, 2596.664, DEMO
4, 666059.268, 2406098.879, 2596.532, DEMO
5, 666048.323, 2406131.632, 2596.739, DEMO
6, 666058.793, 2406175.813, 2597.597, DEMO
7, 666085.389, 2406175.801, 2597.810, DEMO
8, 666090.000, 2406140.000, 2597.200, DEMO
`;
  setStatus('Demo loaded. Click Render.');
});

$('btnClear').addEventListener('click', ()=>{
  $('csv').value = '';
  clearTerrain();
  setStatus('Cleared.');
});

['gridRes','idwPow','knn','contInt','showContours','texSource','shadows' ].forEach(id=>{
  $(id).addEventListener('change', ()=>{
    if (($('csv').value||'').trim().length) $('btnRender').click();
  });
});
$('zExag').addEventListener('input', ()=>{
  terrainGroup.scale.y = Number($('zExag').value);
});

setNavMode('orbit');
setStatus(`Ready.`);
</script>
</body>
</html>
