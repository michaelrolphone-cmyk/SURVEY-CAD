<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Boundary Evidence Workbench — API-Driven Demo</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1621;
      --panel2:#121c2a;
      --line:#223046;
      --text:#e9eef6;
      --muted:#9aa7ba;
      --accent:#ffd54a;
      --good:#43d08a;
      --warn:#ffca5c;
      --bad:#ff6b6b;
      --shadow: 0 12px 35px rgba(0,0,0,.45);
      color-scheme: dark;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif}
    a{color:inherit}
    .app{display:flex;flex-direction:column;min-height:100vh}
    .topbar{
      position:sticky;top:0;z-index:50;
      background:linear-gradient(180deg, rgba(15,22,33,.92), rgba(11,15,20,.92));
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .row-between{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .pad{padding:14px 16px}
    .brand{display:flex;align-items:center;gap:10px}
    .badge{font-size:.75rem;color:var(--muted);border:1px solid var(--line);padding:4px 8px;border-radius:999px}
    .pill{font-size:.75rem;color:var(--muted);border:1px solid var(--line);padding:4px 8px;border-radius:999px;display:inline-flex;gap:6px;align-items:center}
    .pill.warn{border-color:rgba(255,202,92,.35);color:var(--warn)}
    .pill.bad{border-color:rgba(255,107,107,.35);color:var(--bad)}
    .pill.good{border-color:rgba(67,208,138,.35);color:var(--good)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .small{font-size:.85rem}
    .muted{color:var(--muted)}
    .nav{
      display:flex;gap:10px;align-items:center;
      padding:10px 16px;border-top:1px solid rgba(255,255,255,.03);
    }
    .tab{
      cursor:pointer;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      padding:8px 10px;border-radius:12px;
      color:var(--muted);
      user-select:none;
    }
    .tab.active{color:var(--text);border-color:rgba(255,213,74,.35);box-shadow:0 0 0 2px rgba(255,213,74,.10) inset}
    .content{flex:1;min-height:0}
    .grid2{display:grid;grid-template-columns: 1fr 1fr;gap:12px}
    @media (max-width: 980px){ .grid2{grid-template-columns: 1fr} }
    .card{
      background:linear-gradient(180deg, rgba(18,28,42,.98), rgba(15,22,33,.98));
      border:1px solid var(--line);
      border-radius:16px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .hd{padding:12px 14px;border-bottom:1px solid var(--line);font-weight:650;display:flex;align-items:center;justify-content:space-between;gap:10px}
    .bd{padding:12px 14px}
    .hr{height:1px;background:var(--line);margin:12px 0}
    input,select,textarea{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.25);
      color:var(--text);
      outline:none;
    }
    input:focus,select:focus,textarea:focus{
      border-color:rgba(255,213,74,.35);
      box-shadow:0 0 0 3px rgba(255,213,74,.12);
    }
    textarea{resize:vertical}
    .btn{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04);
      color:var(--text);
      padding:9px 11px;
      border-radius:12px;
      font-weight:600;
      user-select:none;
      text-decoration:none;
      display:inline-flex;align-items:center;justify-content:center;
    }
    .btn:hover{background:rgba(255,255,255,.06)}
    .btn.primary{
      border-color:rgba(255,213,74,.35);
      background:rgba(255,213,74,.10);
      color:var(--accent);
    }
    .btn.good{
      border-color:rgba(67,208,138,.35);
      background:rgba(67,208,138,.10);
      color:var(--good);
    }
    .btn.danger{
      border-color:rgba(255,107,107,.35);
      background:rgba(255,107,107,.10);
      color:var(--bad);
    }
    .tbl{width:100%;border-collapse:collapse}
    .tbl th,.tbl td{
      border-bottom:1px solid rgba(255,255,255,.08);
      padding:10px 8px;
      vertical-align:top;
    }
    .tbl th{color:var(--muted);font-size:.85rem;text-align:left;font-weight:650}
    .toast{
      position:fixed;right:16px;bottom:16px;
      width:min(420px, calc(100vw - 32px));
      background:rgba(15,22,33,.96);
      border:1px solid var(--line);
      border-radius:16px;
      box-shadow: var(--shadow);
      padding:12px 12px;
      opacity:0;transform: translateY(12px);
      pointer-events:none;
      transition: all .18s ease;
      z-index:150;
    }
    .toast.show{opacity:1;transform:none}
    .toast.good{border-color:rgba(67,208,138,.35)}
    .toast.warn{border-color:rgba(255,202,92,.35)}
    .toast.bad{border-color:rgba(255,107,107,.35)}
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="pad row-between">
        <div class="brand">
          <div style="width:34px;height:34px;border-radius:12px;background:rgba(255,213,74,.14);border:1px solid rgba(255,213,74,.28);display:flex;align-items:center;justify-content:center;">
            <span class="mono" style="color:var(--accent);font-weight:800;">BEW</span>
          </div>
          <div>
            <div style="font-weight:800;">Boundary Evidence Workbench</div>
            <div class="small muted">Evidence-first boundary analysis • demo client</div>
          </div>
                  </div>

        <div class="row">
          <span class="pill" id="autosavePill">Sync: <b class="mono" id="autosaveState">OK</b></span>
          <span class="pill" id="apiHealthPill">API: <b class="mono" id="apiHealth">…</b></span>
          <button class="btn" id="newProjectBtn">New</button>
          <button class="btn" id="duplicateProjectBtn">Duplicate</button>
          <button class="btn danger" id="deleteProjectBtn">Delete</button>
          <button class="btn" id="importBtn">Import</button>
          <button class="btn" id="exportBtn">Export</button>
          <button class="btn primary" id="printBtn">Print Outputs</button>
          <button class="btn" id="loadSampleBtn">Seed Sample Casefile (API)</button>
          <input id="hiddenImport" type="file" accept="application/json" style="display:none" />
        </div>
      </div>

      <div class="nav">
        <div class="tab active" data-tab="dashboard">Dashboard</div>
        <div class="tab" data-tab="evidence">Evidence</div>
        <div class="tab" data-tab="extract">Extract</div>
        <div class="tab" data-tab="matrix">Corner Matrix</div>
        <div class="tab" data-tab="traverse">Traverse</div>
        <div class="tab" data-tab="outputs">Outputs</div>
      </div>
    </div>

    <div class="content" id="main"></div>
  </div>

  <div class="toast" id="toast">
    <div style="font-weight:800" id="toastTitle">Saved</div>
    <div class="small muted" style="margin-top:4px" id="toastMsg">OK</div>
  </div>

<script>
(() => {
  "use strict";

  /***********************************************************
   * Boundary Evidence Workbench — API-driven client
   *
   * This file replaces the prototype's localStorage persistence
   * with the BEW backend OpenAPI spec (apispec.json).
   ***********************************************************/

  /* ----------------------------- DOM ----------------------------- */
  const $  = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  const elMain   = $("#main");
  const elToast  = $("#toast");
  const elToastT = $("#toastTitle");
  const elToastM = $("#toastMsg");

  const elNewProjectBtn = $("#newProjectBtn");
  const elDupProjectBtn = $("#duplicateProjectBtn");
  const elDelProjectBtn = $("#deleteProjectBtn");
  const elImportBtn     = $("#importBtn");
  const elExportBtn     = $("#exportBtn");
  const elPrintBtn      = $("#printBtn");
  const elHiddenImport  = $("#hiddenImport");

  const elAutosaveState = $("#autosaveState");
  const elApiHealth     = $("#apiHealth");
  const elLoadSampleBtn = $("#loadSampleBtn");

  /* ---------------------------- Helpers --------------------------- */
  const nowISO = () => new Date().toISOString();
  const esc = (s) => (s ?? "").toString()
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");

  const fmtDate = (iso) => {
    if (!iso) return "";
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return iso;
    return d.toISOString().slice(0,10);
  };
  const fmtDateTime = (iso) => {
    if (!iso) return "";
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return iso;
    return d.toLocaleString(undefined, { year:"numeric", month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
  };
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  function toast(title, msg, kind=""){
    elToastT.textContent = title;
    elToastM.textContent = msg;
    elToast.classList.remove("good","warn","bad");
    if (kind) elToast.classList.add(kind);
    elToast.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(()=> elToast.classList.remove("show"), 2600);
  }

  function downloadJson(obj, filename){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  /* -------------------------- Sync pill --------------------------- */
  let syncTimer = null;
  function setSyncState(state){ // OK | SYNCING | ERR
    elAutosaveState.textContent = state;
    elAutosaveState.style.color =
      state === "OK" ? "var(--good)" :
      state === "SYNCING" ? "var(--warn)" :
      "var(--bad)";
    if (state === "SYNCING"){
      clearTimeout(syncTimer);
      syncTimer = setTimeout(()=> {
        // don't auto-flip; next request decides
      }, 15000);
    }
  }
  function setApiHealthState(state){ // OK | ERR | …
    elApiHealth.textContent = state;
    elApiHealth.style.color =
      state === "OK" ? "var(--good)" :
      state === "ERR" ? "var(--bad)" :
      "var(--muted)";
  }

  /* ----------------------------- Modal ---------------------------- */
  const modalHost = (() => {
    const d = document.createElement("div");
    d.id = "modalHost";
    d.style.position = "fixed";
    d.style.inset = "0";
    d.style.zIndex = "200";
    d.style.display = "none";
    document.body.appendChild(d);
    return d;
  })();

  function openModal(innerHtml){
    modalHost.innerHTML = `
      <div class="modal-backdrop" data-act="closeModal" style="position:absolute;inset:0;background:rgba(0,0,0,.55);"></div>
      <div class="modal" style="position:relative;max-width:980px;margin:6vh auto;background:var(--panel);border:1px solid var(--line);border-radius:16px;box-shadow:0 20px 70px rgba(0,0,0,.55);">
        <div style="display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--line);">
          <div class="mono small muted">BEW • detail</div>
          <button class="btn" data-act="closeModal">Close</button>
        </div>
        <div style="padding:16px;max-height:80vh;overflow:auto;">
          ${innerHtml}
        </div>
      </div>`;
    modalHost.style.display = "block";
  }
  function closeModal(){
    modalHost.style.display = "none";
    modalHost.innerHTML = "";
  }

  const ACTIVE_KEY = "bew_active_casefile_v1";
  const pageParams = new URLSearchParams(window.location.search || "");
  const activeProjectId = pageParams.get("activeProjectId") || pageParams.get("projectId") || "";

  /* ----------------------------- API ------------------------------ */
  function urlFor(path){
    return path;
  }

  async function apiRequest(method, path, { query=null, json=null, formData=null, responseType="json" } = {}){
    const u = new URL(urlFor(path), window.location.origin);
    if (query){
      for (const [k,v] of Object.entries(query)){
        if (v === undefined || v === null || v === "") continue;
        u.searchParams.set(k, String(v));
      }
    }
    const opt = { method, headers: {} };
    if (method !== "GET") setSyncState("SYNCING");
    if (json !== null){
      opt.headers["Content-Type"] = "application/json";
      opt.body = JSON.stringify(json);
    } else if (formData){
      opt.body = formData;
    }

    let res;
    try{
      res = await fetch(u.toString(), opt);
    }catch(err){
      setApiHealthState("ERR");
      if (method !== "GET") setSyncState("ERR");
      throw new Error(`Network error: ${err?.message || err}`);
    }

    // update health indicator
    setApiHealthState(res.ok ? "OK" : "ERR");

    if (!res.ok){
      let detail = `${res.status} ${res.statusText}`;
      try{
        const j = await res.json();
        detail = j?.error || j?.message || detail;
      }catch(_){}
      if (method !== "GET") setSyncState("ERR");
      throw new Error(detail);
    }

    if (method !== "GET") setSyncState("OK");

    if (res.status === 204) return null;
    if (responseType === "blob") return await res.blob();
    if (responseType === "text") return await res.text();
    return await res.json();
  }

  const api = {
    health: () => apiRequest("GET","/health"),
    // Casefiles
    listCasefiles: (limit=200, offset=0) => apiRequest("GET","/casefiles",{ query:{limit,offset} }),
    getCasefile: (id) => apiRequest("GET",`/casefiles/${id}`),
    createCasefile: (name, jurisdiction="Idaho", notes="", initializeDefaults=true) =>
      apiRequest("POST","/casefiles",{ json:{ name, jurisdiction, notes, initializeDefaults } }),
    patchCasefile: (id, meta) => apiRequest("PATCH",`/casefiles/${id}`,{ json:{ meta } }),
    deleteCasefile: (id) => apiRequest("DELETE",`/casefiles/${id}`),
    duplicateCasefile: (id, name=null) => apiRequest("POST",`/casefiles/${id}:duplicate`,{ json: name?{name}:{}}),
    exportCasefile: (id) => apiRequest("GET",`/casefiles/${id}:export`),
    importCasefile: (bundle, rewriteIds=true) => apiRequest("POST","/casefiles:import",{ json:{ bundle, rewriteIds } }),

    // Evidence
    listEvidence: (casefileId, limit=200, offset=0) =>
      apiRequest("GET",`/casefiles/${casefileId}/evidence`,{ query:{limit,offset} }),
    createEvidence: (casefileId, body) =>
      apiRequest("POST",`/casefiles/${casefileId}/evidence`,{ json: body }),
    patchEvidence: (casefileId, evidenceId, body) =>
      apiRequest("PATCH",`/casefiles/${casefileId}/evidence/${evidenceId}`,{ json: body }),
    deleteEvidence: (casefileId, evidenceId) =>
      apiRequest("DELETE",`/casefiles/${casefileId}/evidence/${evidenceId}`),
    uploadEvidenceAttachment: (casefileId, evidenceId, file) => {
      const fd = new FormData();
      fd.append("file", file, file.name);
      return apiRequest("POST",`/casefiles/${casefileId}/evidence/${evidenceId}/attachment`,{ formData: fd });
    },
    deleteEvidenceAttachment: (casefileId, evidenceId) =>
      apiRequest("DELETE",`/casefiles/${casefileId}/evidence/${evidenceId}/attachment`),

    // Extractions
    listExtractions: (casefileId, limit=1000, offset=0) =>
      apiRequest("GET",`/casefiles/${casefileId}/extractions`,{ query:{limit,offset} }),
    createExtraction: (casefileId, body) =>
      apiRequest("POST",`/casefiles/${casefileId}/extractions`,{ json: body }),
    patchExtraction: (casefileId, extractionId, body) =>
      apiRequest("PATCH",`/casefiles/${casefileId}/extractions/${extractionId}`,{ json: body }),
    deleteExtraction: (casefileId, extractionId) =>
      apiRequest("DELETE",`/casefiles/${casefileId}/extractions/${extractionId}`),
    reorderExtractions: (casefileId, ids) =>
      apiRequest("POST",`/casefiles/${casefileId}/extractions:reorder`,{ json:{ ids } }),
    extractFromText: (casefileId, body) =>
      apiRequest("POST",`/casefiles/${casefileId}/extractions:extractFromText`,{ json: body }),

    // Corners + candidates
    listCorners: (casefileId, limit=500, offset=0) =>
      apiRequest("GET",`/casefiles/${casefileId}/corners`,{ query:{limit,offset} }),
    createCorner: (casefileId, body) =>
      apiRequest("POST",`/casefiles/${casefileId}/corners`,{ json: body }),
    patchCorner: (casefileId, cornerId, body) =>
      apiRequest("PATCH",`/casefiles/${casefileId}/corners/${cornerId}`,{ json: body }),
    deleteCorner: (casefileId, cornerId) =>
      apiRequest("DELETE",`/casefiles/${casefileId}/corners/${cornerId}`),

    listDecisions: (casefileId, limit=50, offset=0, cornerId=null) =>
      apiRequest("GET",`/casefiles/${casefileId}/decisions`,{ query:{limit,offset,cornerId} }),

    createCandidate: (casefileId, cornerId, body) =>
      apiRequest("POST",`/casefiles/${casefileId}/corners/${cornerId}/candidates`,{ json: body }),
    patchCandidate: (casefileId, cornerId, candidateId, body) =>
      apiRequest("PATCH",`/casefiles/${casefileId}/corners/${cornerId}/candidates/${candidateId}`,{ json: body }),
    deleteCandidate: (casefileId, cornerId, candidateId) =>
      apiRequest("DELETE",`/casefiles/${casefileId}/corners/${cornerId}/candidates/${candidateId}`),
    chooseCandidate: (casefileId, cornerId, candidateId) =>
      apiRequest("POST",`/casefiles/${casefileId}/corners/${cornerId}/candidates/${candidateId}:choose`),
    unchooseCandidate: (casefileId, cornerId, candidateId) =>
      apiRequest("POST",`/casefiles/${casefileId}/corners/${cornerId}/candidates/${candidateId}:unchoose`),
    saveCornerDecision: (casefileId, cornerId, justification) =>
      apiRequest("POST",`/casefiles/${casefileId}/corners/${cornerId}:saveDecision`,{ json:{ justification } }),

    // Traverse
    getTraverse: (casefileId) => apiRequest("GET",`/casefiles/${casefileId}/traverse`),
    patchTraverse: (casefileId, body) => apiRequest("PATCH",`/casefiles/${casefileId}/traverse`,{ json: body }),
    syncIncludedCalls: (casefileId) => apiRequest("POST",`/casefiles/${casefileId}/traverse:syncIncludedCalls`),
    runTraverse: (casefileId, body=null) => apiRequest("POST",`/casefiles/${casefileId}/traverse:run`,{ json: body || {} }),
    getTraverseResults: (casefileId) => apiRequest("GET",`/casefiles/${casefileId}/traverse/results`),

    // Project-linked Workbench
    getProjectWorkbench: (projectId) => apiRequest("GET",`/api/projects/${encodeURIComponent(projectId)}/workbench`),
    createProjectCasefile: (projectId, body={}) => apiRequest("POST",`/api/projects/${encodeURIComponent(projectId)}/workbench/casefile`,{ json: body }),
    syncProjectWorkbench: (projectId, body={}) => apiRequest("POST",`/api/projects/${encodeURIComponent(projectId)}/workbench/sync`,{ json: body }),

    // Outputs
    getPrintablePackage: (casefileId) => apiRequest("GET",`/casefiles/${casefileId}/outputs/package`)
  };

  /* ------------------------------ State ---------------------------- */
  const state = {
    tab: "dashboard",
    casefiles: [],
    activeId: null,
    active: null,        // Casefile
    evidence: null,      // EvidenceItem[]
    extractions: null,   // ExtractionCall[]
    corners: null,       // Corner[]
    decisions: null,     // DecisionLogEntry[]
    traverse: null,      // TraverseConfig
    traverseResults: null, // {lastRun, results}
    printable: null,     // PrintablePackage
    lastWarnings: [],
    renderSeq: 0
  };

  function haveActive(){ return !!state.active; }

  function sortExtractions(items){
    return [...items].sort((a,b) => {
      const ai = (a.orderIndex ?? 1e9);
      const bi = (b.orderIndex ?? 1e9);
      if (ai !== bi) return ai - bi;
      return (a.createdAt || "").localeCompare(b.createdAt || "");
    });
  }

  function evById(id){
    return (state.evidence || []).find(x => x.id === id) || null;
  }
  function exById(id){
    return (state.extractions || []).find(x => x.id === id) || null;
  }
  function cornerById(id){
    return (state.corners || []).find(x => x.id === id) || null;
  }

  /* --------------------------- Data loading ------------------------ */
  async function refreshCasefiles(){
    const r = await api.listCasefiles(500, 0);
    state.casefiles = r.items || [];
    fillProjectSelect();
  }

  function resolveCasefileId(payload){
    return payload?.id || payload?.casefile?.id || payload?.link?.casefileId || "";
  }

  function fillProjectSelect(){}

  async function setActiveCasefile(id){
    if (!id) return false;
    state.activeId = id;
    localStorage.setItem(ACTIVE_KEY, id);
    try{
      state.active = await api.getCasefile(id);
    }catch(err){
      state.activeId = null;
      state.active = null;
      throw err;
    }

    // reset caches (tab loads lazily)
    state.evidence = null;
    state.extractions = null;
    state.corners = null;
    state.decisions = null;
    state.traverse = null;
    state.traverseResults = null;
    state.printable = null;
    state.lastWarnings = [];
    return true;
  }

  async function ensureActiveCasefile(candidateIds = []){
    for (const id of candidateIds){
      if (!id) continue;
      try{
        await setActiveCasefile(id);
        return true;
      }catch(err){
        console.warn("[WORKBENCH] setActiveCasefile failed", id, err);
      }
    }
    return false;
  }

  async function refreshActiveCasefile(){
    if (!state.activeId) return;
    state.active = await api.getCasefile(state.activeId);
  }

  async function ensureEvidence(force=false){
    if (!state.activeId) return;
    if (!force && state.evidence) return;
    const r = await api.listEvidence(state.activeId, 500, 0);
    state.evidence = r.items || [];
  }

  async function ensureExtractions(force=false){
    if (!state.activeId) return;
    if (!force && state.extractions) return;
    const r = await api.listExtractions(state.activeId, 2000, 0);
    state.extractions = sortExtractions(r.items || []);
  }

  async function ensureCorners(force=false){
    if (!state.activeId) return;
    if (!force && state.corners) return;
    const r = await api.listCorners(state.activeId, 500, 0);
    state.corners = r.items || [];
  }

  async function ensureDecisions(force=false){
    if (!state.activeId) return;
    if (!force && state.decisions) return;
    const r = await api.listDecisions(state.activeId, 100, 0, null);
    state.decisions = r.items || [];
  }

  async function ensureTraverse(force=false){
    if (!state.activeId) return;
    if (!force && state.traverse) return;
    state.traverse = await api.getTraverse(state.activeId);
  }

  async function ensureTraverseResults(force=false){
    if (!state.activeId) return;
    if (!force && state.traverseResults) return;
    state.traverseResults = await api.getTraverseResults(state.activeId);
  }

  async function ensurePrintable(force=false){
    if (!state.activeId) return;
    if (!force && state.printable) return;
    state.printable = await api.getPrintablePackage(state.activeId);
  }

  async function ensureTabData(tab){
    if (!haveActive()) return;
    if (tab === "dashboard"){
      await Promise.all([ensureDecisions(), ensureTraverseResults()]);
      return;
    }
    if (tab === "evidence"){
      await ensureEvidence();
      return;
    }
    if (tab === "extract"){
      await Promise.all([ensureEvidence(), ensureExtractions()]);
      return;
    }
    if (tab === "matrix"){
      await Promise.all([ensureEvidence(), ensureCorners(), ensureDecisions()]);
      return;
    }
    if (tab === "traverse"){
      await Promise.all([ensureExtractions(), ensureTraverse(), ensureTraverseResults()]);
      return;
    }
    if (tab === "outputs"){
      await ensurePrintable();
      return;
    }
  }

  /* ---------------------------- Rendering -------------------------- */
  function setTab(tab){
    state.tab = tab;
    $$(".nav .tab").forEach(t => t.classList.toggle("active", t.dataset.tab === tab));
    render();
  }

  function viewDashboard(){
    const cf = state.active;
    const meta = cf.meta || {};
    const counts = cf.counts || {evidence:0, extractions:0, corners:0, decisions:0};

    const lastDecision = (state.decisions || [])[0];
    const tr = state.traverseResults?.results || null;

    return `
      <div class="pad">
        <div class="grid2">
          <div class="card">
            <div class="hd">Casefile Meta</div>
            <div class="bd">
              <div class="grid2">
                <div>
                  <div class="small muted">Name</div>
                  <input id="projName" type="text" value="${esc(meta.name||"")}" placeholder="Casefile name"/>
                </div>
                <div>
                  <div class="small muted">Jurisdiction</div>
                  <input id="projJur" type="text" value="${esc(meta.jurisdiction||"")}" placeholder="e.g., Idaho"/>
                </div>
              </div>
              <div style="margin-top:10px;">
                <div class="small muted">Notes</div>
                <textarea id="projNotes" rows="4" placeholder="Project notes...">${esc(meta.notes||"")}</textarea>
              </div>
              <div class="hr"></div>
              <div class="row">
                <span class="pill">Evidence: <b class="mono">${counts.evidence}</b></span>
                <span class="pill">Extractions: <b class="mono">${counts.extractions}</b></span>
                <span class="pill">Corners: <b class="mono">${counts.corners}</b></span>
                <span class="pill">Decisions: <b class="mono">${counts.decisions}</b></span>
              </div>
              <div class="small muted" style="margin-top:10px;">
                Created: ${fmtDateTime(meta.createdAt)} · Updated: ${fmtDateTime(meta.updatedAt)}
              </div>
            </div>
          </div>

          <div class="card">
            <div class="hd">Status</div>
            <div class="bd">
              <div class="row">
                <span class="pill">Traverse last run: <b class="mono">${state.traverseResults?.lastRun ? fmtDateTime(state.traverseResults.lastRun) : "—"}</b></span>
              </div>

              <div class="hr"></div>

              <div class="grid2">
                <div class="card" style="box-shadow:none;">
                  <div class="bd">
                    <div class="small muted">Latest decision</div>
                    <div style="margin-top:6px;">
                      ${lastDecision ? `
                        <div><b>${esc(lastDecision.action)}</b> · ${fmtDateTime(lastDecision.at)}</div>
                        <div class="muted small" style="margin-top:6px;">${esc(lastDecision.summary || "")}</div>
                      ` : `<div class="muted">No decisions yet.</div>`}
                    </div>
                  </div>
                </div>

                <div class="card" style="box-shadow:none;">
                  <div class="bd">
                    <div class="small muted">Traverse closure</div>
                    <div style="margin-top:6px;">
                      ${tr ? `
                        <div><b class="mono">${tr.closure?.distance?.toFixed?.(3) ?? "—"}</b> ${esc(tr.closure?.unit || "")}</div>
                        <div class="muted small">Precision: ${tr.closure?.precisionText || "—"}</div>
                      ` : `<div class="muted">No results yet. Run traverse.</div>`}
                    </div>
                  </div>
                </div>
              </div>

              <div class="hr"></div>
              <div class="row">
                <button class="btn" data-act="goto" data-tab="evidence">Open Evidence Library</button>
                <button class="btn" data-act="goto" data-tab="extract">Extract Calls</button>
                <button class="btn" data-act="goto" data-tab="matrix">Evidence Matrix</button>
                <button class="btn" data-act="goto" data-tab="traverse">Traverse</button>
                <button class="btn primary" data-act="goto" data-tab="outputs">Outputs</button>
              </div>
            </div>
          </div>
        </div>
      </div>`;
  }

  function viewEvidence(){
    const items = state.evidence || [];
    const rows = items.map(ev => {
      const att = ev.attachment;
      const attLabel = att ? `${esc(att.name)} · ${(att.size||0).toLocaleString()} bytes` : "—";
      const downloadUrl = att?.url || urlFor(`/casefiles/${state.activeId}/evidence/${ev.id}/attachment`);
      return `
        <tr>
          <td><div class="mono small">${esc(ev.type)}</div></td>
          <td>
            <div><b>${esc(ev.title)}</b></div>
            <div class="small muted">${esc(ev.source||"")} ${ev.date?("· "+esc(ev.date)):""}</div>
            <div class="small muted">${(ev.tags||[]).map(t=>`<span class="pill">${esc(t)}</span>`).join(" ")}</div>
          </td>
          <td class="small">${esc(attLabel)}</td>
          <td style="text-align:right;">
            <button class="btn" data-act="editEvidence" data-id="${esc(ev.id)}">Edit</button>
            <button class="btn" data-act="uploadEvidence" data-id="${esc(ev.id)}">Upload</button>
            ${att ? `<a class="btn" href="${esc(downloadUrl)}" target="_blank" rel="noopener">Download</a>
                    <button class="btn danger" data-act="deleteAttachment" data-id="${esc(ev.id)}">Remove</button>` : `<span class="muted small">No file</span>`}
            <button class="btn danger" data-act="deleteEvidence" data-id="${esc(ev.id)}">Delete</button>
          </td>
        </tr>`;
    }).join("");

    return `
      <div class="pad">
        <div class="grid2">
          <div class="card">
            <div class="hd">Add Evidence</div>
            <div class="bd">
              <div class="grid2">
                <div>
                  <div class="small muted">Type</div>
                  <select id="evType">
                    ${["Deed","ROS","Plat","Field Notes","Photo","Email","GIS","Other"].map(t=>`<option value="${esc(t)}">${esc(t)}</option>`).join("")}
                  </select>
                </div>
                <div>
                  <div class="small muted">Title</div>
                  <input id="evTitle" type="text" placeholder="e.g., Warranty Deed 2022-05-14"/>
                </div>
              </div>

              <div class="grid2" style="margin-top:10px;">
                <div>
                  <div class="small muted">Date (optional)</div>
                  <input id="evDate" type="text" placeholder="YYYY-MM-DD or freeform"/>
                </div>
                <div>
                  <div class="small muted">Source (optional)</div>
                  <input id="evSource" type="text" placeholder="Ada County Recorder, field photo, etc."/>
                </div>
              </div>

              <div style="margin-top:10px;">
                <div class="small muted">Tags (comma-separated)</div>
                <input id="evTags" type="text" placeholder="e.g., legal, basis, monument"/>
              </div>

              <div style="margin-top:10px;">
                <div class="small muted">Notes</div>
                <textarea id="evNotes" rows="4" placeholder="What does this evidence prove?"></textarea>
              </div>

              <div class="row" style="margin-top:10px;justify-content:space-between;">
                <div>
                  <div class="small muted">Attachment (optional)</div>
                  <input id="evFile" type="file"/>
                </div>
                <button class="btn primary" id="saveEvBtn">Save Evidence</button>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="hd">Evidence Library <span class="pill">${items.length} items</span></div>
            <div class="bd">
              ${items.length ? `
                <table class="tbl">
                  <thead><tr>
                    <th style="width:120px;">Type</th>
                    <th>Evidence</th>
                    <th style="width:220px;">Attachment</th>
                    <th style="width:320px;text-align:right;">Actions</th>
                  </tr></thead>
                  <tbody>${rows}</tbody>
                </table>
              ` : `<div class="muted">No evidence yet. Add your first deed/ROS/photo.</div>`}
            </div>
          </div>
        </div>
      </div>`;
  }

  function viewExtract(){
    const items = state.extractions || [];
    const evidenceOpts = (state.evidence || []).map(ev => `<option value="${esc(ev.id)}">${esc(ev.title)}</option>`).join("");
    const warnings = (state.lastWarnings || []).map(w => `<div class="pill warn">${esc(w)}</div>`).join("");

    const rows = items.map((c, idx) => {
      const ev = evById(c.evidenceId);
      return `
        <tr>
          <td class="mono small">${idx+1}</td>
          <td>
            <div><b class="mono">${esc(c.bearingText)}</b></div>
            <div class="small muted">${esc(c.label || "")} · ${esc(c.snippet || "")}</div>
          </td>
          <td class="mono">${Number(c.distance).toFixed(2)} ${esc(c.distanceUnit || "")}</td>
          <td><input type="checkbox" data-act="toggleInclude" data-id="${esc(c.id)}" ${c.include ? "checked":""}/></td>
          <td class="mono small">${Math.round((c.confidence||0)*100)}%</td>
          <td class="small muted">${esc(ev?.title || "")}</td>
          <td style="text-align:right;">
            <button class="btn" data-act="moveCallUp" data-id="${esc(c.id)}">↑</button>
            <button class="btn" data-act="moveCallDown" data-id="${esc(c.id)}">↓</button>
            <button class="btn" data-act="editCall" data-id="${esc(c.id)}">Edit</button>
            <button class="btn danger" data-act="deleteCall" data-id="${esc(c.id)}">Delete</button>
          </td>
        </tr>`;
    }).join("");

    return `
      <div class="pad">
        <div class="grid2">
          <div class="card">
            <div class="hd">Extract Calls from Text</div>
            <div class="bd">
              <div class="small muted">Evidence source</div>
              <select id="extractEvidenceId">${evidenceOpts}</select>
              <div style="margin-top:10px;" class="small muted">Paste deed/ROS call text (bearing + distance per line)</div>
              <textarea id="extractText" rows="10" placeholder="Example:
S 89°58'00&quot; W 315.27
N 00°00'27&quot; W 267.69
..."></textarea>

              <div class="row" style="margin-top:10px;justify-content:space-between;">
                <div class="row">
                  <div class="small muted">Unit</div>
                  <select id="extractUnit"><option value="ft">ft</option><option value="m">m</option></select>
                  <div class="small muted">Include by default</div>
                  <input id="extractInclude" type="checkbox" checked/>
                  <div class="small muted">Confidence</div>
                  <input id="extractConf" type="number" min="0" max="1" step="0.05" value="0.75" style="width:90px"/>
                </div>
                <button class="btn primary" id="runExtractBtn">Extract</button>
              </div>

              ${warnings ? `<div style="margin-top:10px;">${warnings}</div>` : ``}
            </div>

            <div class="hr"></div>

            <div class="bd">
              <div class="hd" style="padding:0;margin-bottom:8px;">Manual Call</div>
              <div class="grid2">
                <div>
                  <div class="small muted">Bearing text</div>
                  <input id="manualBearing" type="text" placeholder='N 45°01&apos;07&quot; E'/>
                </div>
                <div>
                  <div class="small muted">Distance</div>
                  <input id="manualDist" type="number" step="0.01" placeholder="0.00"/>
                </div>
              </div>
              <div class="row" style="margin-top:10px;justify-content:space-between;">
                <div class="row">
                  <div class="small muted">Evidence</div>
                  <select id="manualEvidenceId">${evidenceOpts}</select>
                  <div class="small muted">Unit</div>
                  <select id="manualUnit"><option value="ft">ft</option><option value="m">m</option></select>
                </div>
                <button class="btn" id="addManualBtn">Add Call</button>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="hd">Calls <span class="pill">${items.length} total</span></div>
            <div class="bd">
              ${items.length ? `
                <table class="tbl">
                  <thead><tr>
                    <th style="width:60px;">#</th>
                    <th>Call</th>
                    <th style="width:150px;">Distance</th>
                    <th style="width:80px;">Use</th>
                    <th style="width:90px;">Conf</th>
                    <th>Evidence</th>
                    <th style="width:260px;text-align:right;">Actions</th>
                  </tr></thead>
                  <tbody>${rows}</tbody>
                </table>
              ` : `<div class="muted">No calls yet. Paste text and Extract.</div>`}
            </div>
          </div>
        </div>
      </div>`;
  }

  function chosenCandidate(corner){
    return (corner.candidates || []).find(c => c.chosen) || null;
  }

  function viewMatrix(){
    const corners = state.corners || [];
    const rows = corners.map(c => {
      const chosen = chosenCandidate(c);
      return `
        <tr>
          <td><b>${esc(c.name)}</b><div class="small muted">${esc(c.plss||"")}</div></td>
          <td class="mono small">${esc(c.status)}</td>
          <td>${chosen ? esc(chosen.summary) : `<span class="muted">—</span>`}</td>
          <td class="mono">${chosen ? esc(chosen.weight) : ""}</td>
          <td style="text-align:right;">
            <button class="btn" data-act="openCorner" data-id="${esc(c.id)}">Open</button>
            <button class="btn danger" data-act="deleteCorner" data-id="${esc(c.id)}">Delete</button>
          </td>
        </tr>`;
    }).join("");

    const decRows = (state.decisions || []).slice(0,20).map(d => `
      <tr>
        <td class="small mono">${fmtDateTime(d.at)}</td>
        <td class="small mono">${esc(d.action)}</td>
        <td class="small">${esc(d.summary || "")}</td>
      </tr>
    `).join("");

    return `
      <div class="pad">
        <div class="grid2">
          <div class="card">
            <div class="hd">Corners</div>
            <div class="bd">
              <div class="grid2">
                <div>
                  <div class="small muted">Corner name</div>
                  <input id="newCornerName" type="text" placeholder="e.g., NW COR (Parcel)"/>
                </div>
                <div>
                  <div class="small muted">Status</div>
                  <select id="newCornerStatus">
                    ${["Existent","Obliterated","Lost","Unknown"].map(s=>`<option value="${esc(s)}">${esc(s)}</option>`).join("")}
                  </select>
                </div>
              </div>
              <div style="margin-top:10px;">
                <div class="small muted">PLSS / description</div>
                <input id="newCornerPlss" type="text" placeholder="Sec/T/R, corner tie, etc."/>
              </div>
              <div class="row" style="margin-top:10px;justify-content:flex-end;">
                <button class="btn primary" id="addCornerBtn">Add Corner</button>
              </div>
            </div>

            <div class="hr"></div>

            <div class="bd">
              ${corners.length ? `
                <table class="tbl">
                  <thead><tr>
                    <th>Corner</th>
                    <th style="width:130px;">Status</th>
                    <th>Chosen candidate</th>
                    <th style="width:70px;">W</th>
                    <th style="width:180px;text-align:right;">Actions</th>
                  </tr></thead>
                  <tbody>${rows}</tbody>
                </table>
              ` : `<div class="muted">No corners yet. Add one and start building candidates.</div>`}
            </div>
          </div>

          <div class="card">
            <div class="hd">Decision Log <span class="pill">latest 20</span></div>
            <div class="bd">
              ${(state.decisions && state.decisions.length) ? `
                <table class="tbl">
                  <thead><tr><th style="width:180px;">Time</th><th style="width:180px;">Action</th><th>Summary</th></tr></thead>
                  <tbody>${decRows}</tbody>
                </table>
              ` : `<div class="muted">No decisions yet.</div>`}
            </div>
          </div>
        </div>
      </div>`;
  }

  function viewTraverse(){
    const tr = state.traverse || state.active.traverse || { start:{N:10000,E:10000}, basis:{label:"",rotationDeg:0}, calls:[], lastRun:null };
    const results = state.traverseResults?.results || null;

    const calls = tr.calls || [];
    const callRows = calls.map((id, i) => {
      const ex = exById(id);
      return `
        <tr>
          <td class="mono small">${i+1}</td>
          <td class="mono">${esc(ex?.bearingText || "(missing)")}</td>
          <td class="mono">${ex ? `${Number(ex.distance).toFixed(2)} ${esc(ex.distanceUnit)}` : "—"}</td>
          <td class="small muted">${esc(evById(ex?.evidenceId)?.title || "")}</td>
          <td style="text-align:right;">
            <button class="btn" data-act="moveTraverseUp" data-idx="${i}">↑</button>
            <button class="btn" data-act="moveTraverseDown" data-idx="${i}">↓</button>
          </td>
        </tr>`;
    }).join("");

    const pts = results?.points || [];
    const ptRows = pts.map(p => `
      <tr>
        <td class="mono small">${esc(p.name)}</td>
        <td class="mono">${Number(p.N).toFixed(3)}</td>
        <td class="mono">${Number(p.E).toFixed(3)}</td>
        <td class="small muted">${esc(p.note || "")}</td>
      </tr>
    `).join("");

    return `
      <div class="pad">
        <div class="grid2">
          <div class="card">
            <div class="hd">Traverse Configuration</div>
            <div class="bd">
              <div class="grid2">
                <div>
                  <div class="small muted">Start Northing</div>
                  <input id="trStartN" type="number" step="0.001" value="${esc(tr.start?.N ?? 10000)}"/>
                </div>
                <div>
                  <div class="small muted">Start Easting</div>
                  <input id="trStartE" type="number" step="0.001" value="${esc(tr.start?.E ?? 10000)}"/>
                </div>
              </div>
              <div class="grid2" style="margin-top:10px;">
                <div>
                  <div class="small muted">Basis label</div>
                  <input id="trBasisLabel" type="text" value="${esc(tr.basis?.label || "")}" placeholder="Assumed / Grid / True / Record..."/>
                </div>
                <div>
                  <div class="small muted">Rotation (deg)</div>
                  <input id="trRotation" type="number" step="0.0001" value="${esc(tr.basis?.rotationDeg ?? 0)}"/>
                </div>
              </div>
              <div class="row" style="margin-top:10px;justify-content:space-between;">
                <div class="row">
                  <span class="pill">Calls configured: <b class="mono">${calls.length}</b></span>
                  <span class="pill">Last run: <b class="mono">${state.traverseResults?.lastRun ? fmtDateTime(state.traverseResults.lastRun) : "—"}</b></span>
                </div>
                <button class="btn primary" id="saveTraverseBtn">Save Config</button>
              </div>

              <div class="hr"></div>

              <div class="row" style="justify-content:space-between;">
                <div class="row">
                  <button class="btn" id="syncIncludedBtn">Sync from Included Calls</button>
                  <button class="btn good" id="runTraverseBtn">Run Traverse</button>
                </div>
                <button class="btn" data-act="goto" data-tab="extract">Edit Calls</button>
              </div>
            </div>

            <div class="hr"></div>

            <div class="bd">
              <div class="hd" style="padding:0;margin-bottom:8px;">Configured Calls (order matters)</div>
              ${calls.length ? `
                <table class="tbl">
                  <thead><tr><th style="width:60px;">#</th><th>Bearing</th><th style="width:160px;">Distance</th><th>Evidence</th><th style="width:140px;text-align:right;">Order</th></tr></thead>
                  <tbody>${callRows}</tbody>
                </table>
              ` : `<div class="muted">No traverse call list. Click “Sync from Included Calls”.</div>`}
            </div>
          </div>

          <div class="card">
            <div class="hd">Results</div>
            <div class="bd">
              ${results ? `
                <div class="row">
                  <span class="pill">Closure: <b class="mono">${results.closure?.distance?.toFixed?.(3) ?? "—"}</b> ${esc(results.closure?.unit || "")}</span>
                  <span class="pill">Precision: <b class="mono">${esc(results.closure?.precisionText || "—")}</b></span>
                  <span class="pill">Total dist: <b class="mono">${results.totalDistance?.toFixed?.(2) ?? "—"}</b> ${esc(results.distanceUnit || "")}</span>
                </div>
                <div class="hr"></div>
                <table class="tbl">
                  <thead><tr><th style="width:120px;">Point</th><th style="width:160px;">Northing</th><th style="width:160px;">Easting</th><th>Note</th></tr></thead>
                  <tbody>${ptRows}</tbody>
                </table>
              ` : `<div class="muted">No results. Click “Run Traverse”.</div>`}
            </div>
          </div>
        </div>
      </div>`;
  }

  function viewOutputs(){
    const pkg = state.printable;
    if (!pkg){
      return `<div class="pad"><div class="card"><div class="bd">Loading outputs...</div></div></div>`;
    }

    const evRows = (pkg.evidenceRegister || []).map(ev => `
      <tr>
        <td class="mono small">${esc(ev.type)}</td>
        <td><b>${esc(ev.title)}</b><div class="small muted">${esc(ev.source||"")} ${ev.date?("· "+esc(ev.date)):""}</div></td>
        <td class="small muted">${(ev.tags||[]).join(", ")}</td>
      </tr>
    `).join("");

    const callRows = (pkg.includedCalls || []).map((c,i) => `
      <tr>
        <td class="mono small">${i+1}</td>
        <td class="mono">${esc(c.bearingText)}</td>
        <td class="mono">${Number(c.distance).toFixed(2)} ${esc(c.distanceUnit)}</td>
        <td class="small muted">${esc(evById(c.evidenceId)?.title || "")}</td>
      </tr>
    `).join("");

    const cornerRows = (pkg.cornerSelections || []).map(s => {
      const chosen = s.chosenCandidate;
      return `
        <tr>
          <td><b>${esc(s.corner.name)}</b><div class="small muted">${esc(s.corner.plss || "")}</div></td>
          <td class="mono small">${esc(s.corner.status)}</td>
          <td>${chosen ? esc(chosen.summary) : `<span class="muted">—</span>`}</td>
          <td class="mono">${chosen ? esc(chosen.weight) : ""}</td>
          <td class="small muted">${chosen ? esc(chosen.justification || "") : ""}</td>
        </tr>`;
    }).join("");

    const tr = pkg.traverse?.results || null;

    return `
      <div class="pad">
        <div class="card">
          <div class="hd">Printable Package</div>
          <div class="bd">
            <div class="row">
              <span class="pill">Generated: <b class="mono">${fmtDateTime(pkg.generatedAt)}</b></span>
              <span class="pill">Casefile: <b class="mono">${esc(pkg.casefile?.meta?.name || "")}</b></span>
              <button class="btn" id="refreshOutputsBtn">Refresh</button>
              <button class="btn good" id="printNowBtn">Print</button>
            </div>
          </div>
        </div>

        <div class="grid2" style="margin-top:12px;">
          <div class="card">
            <div class="hd">Evidence Register</div>
            <div class="bd">
              <table class="tbl">
                <thead><tr><th style="width:120px;">Type</th><th>Evidence</th><th style="width:220px;">Tags</th></tr></thead>
                <tbody>${evRows}</tbody>
              </table>
            </div>
          </div>

          <div class="card">
            <div class="hd">Included Calls</div>
            <div class="bd">
              <table class="tbl">
                <thead><tr><th style="width:60px;">#</th><th>Bearing</th><th style="width:160px;">Distance</th><th>Evidence</th></tr></thead>
                <tbody>${callRows}</tbody>
              </table>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <div class="hd">Corner Selections</div>
          <div class="bd">
            <table class="tbl">
              <thead><tr><th>Corner</th><th style="width:130px;">Status</th><th>Chosen</th><th style="width:60px;">W</th><th>Justification</th></tr></thead>
              <tbody>${cornerRows}</tbody>
            </table>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <div class="hd">Traverse Summary</div>
          <div class="bd">
            ${tr ? `
              <div class="row">
                <span class="pill">Closure: <b class="mono">${tr.closure?.distance?.toFixed?.(3) ?? "—"}</b> ${esc(tr.closure?.unit||"")}</span>
                <span class="pill">Precision: <b class="mono">${esc(tr.closure?.precisionText||"—")}</b></span>
                <span class="pill">Calls: <b class="mono">${(tr.segments||[]).length}</b></span>
              </div>
            ` : `<div class="muted">No traverse results included in package.</div>`}
          </div>
        </div>
      </div>`;
  }

  async function render(){
    const seq = ++state.renderSeq;
    elMain.innerHTML = `<div class="pad"><div class="card"><div class="bd muted">Loading…</div></div></div>`;

    try{
      if (!state.activeId){
        const saved = localStorage.getItem(ACTIVE_KEY);
        if (saved) state.activeId = saved;
      }

      await ensureTabData(state.tab);
      if (seq !== state.renderSeq) return;

      if (!haveActive()){
        elMain.innerHTML = `<div class="pad"><div class="card"><div class="bd">
          <div class="pill warn">No active casefile</div>
          <div style="margin-top:10px;"><b>No casefile is currently loaded.</b></div>
          <div class="small muted" style="margin-top:10px;">Create one with <span class="mono">New</span> or verify server status.</div>
        </div></div></div>`;
        return;
      }

      if (state.tab === "dashboard") elMain.innerHTML = viewDashboard();
      else if (state.tab === "evidence") elMain.innerHTML = viewEvidence();
      else if (state.tab === "extract") elMain.innerHTML = viewExtract();
      else if (state.tab === "matrix") elMain.innerHTML = viewMatrix();
      else if (state.tab === "traverse") elMain.innerHTML = viewTraverse();
      else if (state.tab === "outputs") elMain.innerHTML = viewOutputs();

      wirePerRenderHandlers();
    }catch(err){
      elMain.innerHTML = `<div class="pad"><div class="card"><div class="bd">
        <div class="pill bad">Error</div>
        <div style="margin-top:10px;"><b>${esc(err.message || err)}</b></div>
        <div class="small muted" style="margin-top:10px;">Check server status.</div>
      </div></div></div>`;
      toast("Error", err.message || String(err), "bad");
    }
  }

  /* ---------------------- Per-render handlers ---------------------- */
  const debounceMap = new Map();
  function debounce(key, ms, fn){
    clearTimeout(debounceMap.get(key));
    debounceMap.set(key, setTimeout(fn, ms));
  }

  function wirePerRenderHandlers(){
    // Dashboard meta autosave
    if (state.tab === "dashboard"){
      const name = $("#projName");
      const jur  = $("#projJur");
      const notes = $("#projNotes");
      if (name) name.addEventListener("input", () => debounce("meta", 350, saveMetaFromDashboard));
      if (jur)  jur.addEventListener("input",  () => debounce("meta", 350, saveMetaFromDashboard));
      if (notes) notes.addEventListener("input",() => debounce("meta", 450, saveMetaFromDashboard));
    }

    // Evidence add
    if (state.tab === "evidence"){
      const btn = $("#saveEvBtn");
      if (btn) btn.addEventListener("click", saveEvidenceFromForm);
    }

    // Extract tab
    if (state.tab === "extract"){
      const btn = $("#runExtractBtn");
      if (btn) btn.addEventListener("click", runExtractionFromText);
      const add = $("#addManualBtn");
      if (add) add.addEventListener("click", addManualCall);
    }

    // Matrix tab
    if (state.tab === "matrix"){
      const add = $("#addCornerBtn");
      if (add) add.addEventListener("click", addCornerFromForm);
    }

    // Traverse tab
    if (state.tab === "traverse"){
      const save = $("#saveTraverseBtn");
      if (save) save.addEventListener("click", saveTraverseConfig);
      const sync = $("#syncIncludedBtn");
      if (sync) sync.addEventListener("click", syncIncludedCalls);
      const run = $("#runTraverseBtn");
      if (run) run.addEventListener("click", runTraverse);
    }

    // Outputs tab
    if (state.tab === "outputs"){
      const r = $("#refreshOutputsBtn");
      if (r) r.addEventListener("click", async () => { await ensurePrintable(true); render(); });
      const p = $("#printNowBtn");
      if (p) p.addEventListener("click", () => setTimeout(()=>window.print(), 50));
    }
  }

  /* --------------------------- Actions ----------------------------- */
  async function saveMetaFromDashboard(){
    if (!state.activeId) return;
    const meta = {
      name: $("#projName")?.value?.trim() || (state.active?.meta?.name || "Untitled"),
      jurisdiction: $("#projJur")?.value ?? "",
      notes: $("#projNotes")?.value ?? ""
    };
    try{
      await api.patchCasefile(state.activeId, meta);
      await refreshCasefiles();
      await refreshActiveCasefile();
      toast("Saved", "Casefile meta updated.", "good");
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  function parseTags(str){
    return (str || "").split(",").map(s=>s.trim()).filter(Boolean).slice(0, 30);
  }

  async function saveEvidenceFromForm(){
    if (!state.activeId) return;
    const type = $("#evType")?.value || "Other";
    const title = ($("#evTitle")?.value || "").trim();
    if (!title){
      toast("Missing", "Evidence title is required.", "warn");
      return;
    }
    const date = ($("#evDate")?.value || "").trim() || null;
    const source = ($("#evSource")?.value || "").trim();
    const tags = parseTags($("#evTags")?.value || "");
    const notes = ($("#evNotes")?.value || "").trim();
    const file = $("#evFile")?.files?.[0] || null;

    try{
      const ev = await api.createEvidence(state.activeId, { type, title, date, source, tags, notes });
      if (file){
        await api.uploadEvidenceAttachment(state.activeId, ev.id, file);
      }
      await Promise.all([ensureEvidence(true), refreshActiveCasefile(), refreshCasefiles()]);
      toast("Saved", "Evidence added.", "good");

      // reset form
      $("#evTitle").value = "";
      $("#evDate").value = "";
      $("#evSource").value = "";
      $("#evTags").value = "";
      $("#evNotes").value = "";
      $("#evFile").value = "";
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function editEvidence(evidenceId){
    await ensureEvidence();
    const ev = evById(evidenceId);
    if (!ev) return;

    openModal(`
      <div class="grid2">
        <div>
          <div class="small muted">Type</div>
          <select id="mEvType">
            ${["Deed","ROS","Plat","Field Notes","Photo","Email","GIS","Other"].map(t=>`<option value="${esc(t)}" ${t===ev.type?"selected":""}>${esc(t)}</option>`).join("")}
          </select>
        </div>
        <div>
          <div class="small muted">Title</div>
          <input id="mEvTitle" type="text" value="${esc(ev.title)}"/>
        </div>
      </div>
      <div class="grid2" style="margin-top:10px;">
        <div>
          <div class="small muted">Date</div>
          <input id="mEvDate" type="text" value="${esc(ev.date||"")}"/>
        </div>
        <div>
          <div class="small muted">Source</div>
          <input id="mEvSource" type="text" value="${esc(ev.source||"")}"/>
        </div>
      </div>
      <div style="margin-top:10px;">
        <div class="small muted">Tags</div>
        <input id="mEvTags" type="text" value="${esc((ev.tags||[]).join(", "))}"/>
      </div>
      <div style="margin-top:10px;">
        <div class="small muted">Notes</div>
        <textarea id="mEvNotes" rows="5">${esc(ev.notes||"")}</textarea>
      </div>
      <div class="row" style="margin-top:12px;justify-content:flex-end;">
        <button class="btn primary" id="mEvSave">Save</button>
      </div>
    `);

    $("#mEvSave").addEventListener("click", async () => {
      try{
        await api.patchEvidence(state.activeId, evidenceId, {
          type: $("#mEvType").value,
          title: $("#mEvTitle").value.trim(),
          date: ($("#mEvDate").value.trim() || null),
          source: $("#mEvSource").value.trim(),
          tags: parseTags($("#mEvTags").value),
          notes: $("#mEvNotes").value
        });
        closeModal();
        await ensureEvidence(true);
        await Promise.all([refreshActiveCasefile(), refreshCasefiles()]);
        toast("Saved","Evidence updated.","good");
        render();
      }catch(err){
        toast("Error", err.message || String(err), "bad");
      }
    });
  }

  const hiddenUpload = (() => {
    const i = document.createElement("input");
    i.type = "file";
    i.style.display = "none";
    document.body.appendChild(i);
    return i;
  })();

  async function uploadEvidenceFile(evidenceId){
    hiddenUpload.value = "";
    hiddenUpload.onchange = async () => {
      const f = hiddenUpload.files?.[0];
      if (!f) return;
      try{
        await api.uploadEvidenceAttachment(state.activeId, evidenceId, f);
        await ensureEvidence(true);
        await Promise.all([refreshActiveCasefile(), refreshCasefiles()]);
        toast("Uploaded","Attachment saved.","good");
        render();
      }catch(err){
        toast("Error", err.message || String(err), "bad");
      }
    };
    hiddenUpload.click();
  }

  async function deleteEvidence(evidenceId){
    const ok = confirm("Delete this evidence item? This will also delete its attachment and any linked extractions remain but will reference a missing evidence.");
    if (!ok) return;
    try{
      await api.deleteEvidence(state.activeId, evidenceId);
      await ensureEvidence(true);
      await Promise.all([refreshActiveCasefile(), refreshCasefiles()]);
      toast("Deleted","Evidence removed.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function deleteAttachment(evidenceId){
    const ok = confirm("Remove the attachment file from this evidence item?");
    if (!ok) return;
    try{
      await api.deleteEvidenceAttachment(state.activeId, evidenceId);
      await ensureEvidence(true);
      toast("Removed","Attachment removed.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function runExtractionFromText(){
    const evidenceId = $("#extractEvidenceId")?.value;
    const text = $("#extractText")?.value || "";
    if (!evidenceId || !text.trim()){
      toast("Missing", "Select evidence and paste text to extract.", "warn");
      return;
    }
    const defaultUnit = $("#extractUnit")?.value || "ft";
    const includeByDefault = !!$("#extractInclude")?.checked;
    const defaultConfidence = clamp(Number($("#extractConf")?.value ?? 0.75), 0, 1);
    try{
      const r = await api.extractFromText(state.activeId, { evidenceId, page: 1, text, defaultUnit, includeByDefault, defaultConfidence });
      state.lastWarnings = r.warnings || [];
      await ensureExtractions(true);
      await refreshActiveCasefile();
      toast("Extracted", `Created ${r.created?.length || 0} calls.`, "good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function addManualCall(){
    const bearingText = ($("#manualBearing")?.value || "").trim();
    const distance = Number($("#manualDist")?.value);
    const evidenceId = $("#manualEvidenceId")?.value;
    const unit = $("#manualUnit")?.value || "ft";

    if (!bearingText || !Number.isFinite(distance)){
      toast("Missing", "Bearing and distance are required.", "warn");
      return;
    }
    if (!evidenceId){
      toast("Missing","Choose evidence for this call.","warn");
      return;
    }
    try{
      await api.createExtraction(state.activeId, { evidenceId, page:1, snippet:"(manual entry)", label:"", bearingText, distance, distanceUnit: unit, include:true, confidence: 0.9 });
      await ensureExtractions(true);
      await refreshActiveCasefile();
      toast("Saved","Call added.","good");
      $("#manualBearing").value = "";
      $("#manualDist").value = "";
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function toggleInclude(extractionId, include){
    try{
      await api.patchExtraction(state.activeId, extractionId, { include });
      await ensureExtractions(true);
      await refreshActiveCasefile();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function deleteCall(extractionId){
    const ok = confirm("Delete this extracted call?");
    if (!ok) return;
    try{
      await api.deleteExtraction(state.activeId, extractionId);
      await Promise.all([ensureExtractions(true), ensureTraverse(true), ensureTraverseResults(true), refreshActiveCasefile()]);
      toast("Deleted","Call removed.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function moveCall(extractionId, dir){
    await ensureExtractions();
    const ids = state.extractions.map(x => x.id);
    const i = ids.indexOf(extractionId);
    if (i < 0) return;
    const j = i + dir;
    if (j < 0 || j >= ids.length) return;
    [ids[i], ids[j]] = [ids[j], ids[i]];
    try{
      await api.reorderExtractions(state.activeId, ids);
      await ensureExtractions(true);
      toast("Saved","Order updated.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function editCall(extractionId){
    await ensureExtractions();
    const c = exById(extractionId);
    if (!c) return;

    openModal(`
      <div class="grid2">
        <div>
          <div class="small muted">Bearing</div>
          <input id="mCallBearing" type="text" value="${esc(c.bearingText)}"/>
        </div>
        <div>
          <div class="small muted">Distance</div>
          <input id="mCallDist" type="number" step="0.01" value="${esc(c.distance)}"/>
        </div>
      </div>
      <div class="grid2" style="margin-top:10px;">
        <div>
          <div class="small muted">Unit</div>
          <select id="mCallUnit">
            ${["ft","m","ch"].map(u=>`<option value="${esc(u)}" ${u===(c.distanceUnit||"ft")?"selected":""}>${esc(u)}</option>`).join("")}
          </select>
        </div>
        <div>
          <div class="small muted">Confidence</div>
          <input id="mCallConf" type="number" min="0" max="1" step="0.05" value="${esc(c.confidence ?? 0.75)}"/>
        </div>
      </div>
      <div style="margin-top:10px;">
        <div class="small muted">Label</div>
        <input id="mCallLabel" type="text" value="${esc(c.label||"")}"/>
      </div>
      <div style="margin-top:10px;">
        <div class="small muted">Snippet</div>
        <textarea id="mCallSnippet" rows="4">${esc(c.snippet||"")}</textarea>
      </div>
      <div class="row" style="margin-top:12px;justify-content:flex-end;">
        <button class="btn primary" id="mCallSave">Save</button>
      </div>
    `);

    $("#mCallSave").addEventListener("click", async () => {
      try{
        await api.patchExtraction(state.activeId, extractionId, {
          bearingText: $("#mCallBearing").value.trim(),
          distance: Number($("#mCallDist").value),
          distanceUnit: $("#mCallUnit").value,
          confidence: clamp(Number($("#mCallConf").value), 0, 1),
          label: $("#mCallLabel").value.trim(),
          snippet: $("#mCallSnippet").value
        });
        closeModal();
        await ensureExtractions(true);
        toast("Saved","Call updated.","good");
        render();
      }catch(err){
        toast("Error", err.message || String(err), "bad");
      }
    });
  }

  async function addCornerFromForm(){
    const name = ($("#newCornerName")?.value || "").trim();
    if (!name){
      toast("Missing","Corner name required.","warn");
      return;
    }
    const status = $("#newCornerStatus")?.value || "Unknown";
    const plss = ($("#newCornerPlss")?.value || "").trim();
    try{
      await api.createCorner(state.activeId, { name, status, plss });
      await Promise.all([ensureCorners(true), ensureDecisions(true), refreshActiveCasefile()]);
      toast("Saved","Corner added.","good");
      $("#newCornerName").value = "";
      $("#newCornerPlss").value = "";
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function deleteCorner(cornerId){
    const ok = confirm("Delete this corner and all its candidates?");
    if (!ok) return;
    try{
      await api.deleteCorner(state.activeId, cornerId);
      await Promise.all([ensureCorners(true), ensureDecisions(true), refreshActiveCasefile()]);
      toast("Deleted","Corner removed.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function openCorner(cornerId){
    await ensureCorners();
    const c = cornerById(cornerId);
    if (!c) return;

    const evOpts = (state.evidence || []).map(ev => `<option value="${esc(ev.id)}">${esc(ev.title)}</option>`).join("");
    const candRows = (c.candidates || []).map(cd => `
      <tr>
        <td class="mono small">${esc(cd.kind)}</td>
        <td>${esc(cd.summary)}</td>
        <td class="mono">${esc(cd.weight)}</td>
        <td class="mono">${cd.chosen ? "✓" : ""}</td>
        <td style="text-align:right;">
          ${cd.chosen ? `<button class="btn" data-act="unchooseCandidate" data-corner="${esc(c.id)}" data-id="${esc(cd.id)}">Unchoose</button>`
                      : `<button class="btn primary" data-act="chooseCandidate" data-corner="${esc(c.id)}" data-id="${esc(cd.id)}">Choose</button>`}
          <button class="btn danger" data-act="deleteCandidate" data-corner="${esc(c.id)}" data-id="${esc(cd.id)}">Delete</button>
        </td>
      </tr>
    `).join("");

    const chosen = chosenCandidate(c);
    openModal(`
      <div class="grid2">
        <div>
          <div class="small muted">Corner name</div>
          <input id="mCornerName" type="text" value="${esc(c.name)}"/>
        </div>
        <div>
          <div class="small muted">Status</div>
          <select id="mCornerStatus">
            ${["Existent","Obliterated","Lost","Unknown"].map(s=>`<option value="${esc(s)}" ${s===c.status?"selected":""}>${esc(s)}</option>`).join("")}
          </select>
        </div>
      </div>
      <div style="margin-top:10px;">
        <div class="small muted">PLSS / description</div>
        <input id="mCornerPlss" type="text" value="${esc(c.plss||"")}"/>
      </div>

      <div class="row" style="margin-top:12px;justify-content:flex-end;">
        <button class="btn primary" id="mCornerSave">Save Corner</button>
      </div>

      <div class="hr"></div>

      <div class="hd" style="padding:0;margin-bottom:8px;">Candidates</div>
      ${(c.candidates||[]).length ? `
        <table class="tbl">
          <thead><tr><th style="width:140px;">Kind</th><th>Summary</th><th style="width:60px;">W</th><th style="width:60px;">Chosen</th><th style="width:240px;text-align:right;">Actions</th></tr></thead>
          <tbody>${candRows}</tbody>
        </table>
      ` : `<div class="muted">No candidates yet.</div>`}

      <div class="hr"></div>

      <div class="hd" style="padding:0;margin-bottom:8px;">Add Candidate</div>
      <div class="grid2">
        <div>
          <div class="small muted">Kind</div>
          <select id="mCandKind">${["Monument","Occupation","Record Call","Parol","Other"].map(k=>`<option value="${esc(k)}">${esc(k)}</option>`).join("")}</select>
        </div>
        <div>
          <div class="small muted">Weight (1-5)</div>
          <input id="mCandWeight" type="number" min="1" max="5" step="1" value="3"/>
        </div>
      </div>
      <div style="margin-top:10px;">
        <div class="small muted">Evidence ref (optional)</div>
        <select id="mCandEvidence">
          <option value="">(none)</option>
          ${evOpts}
        </select>
      </div>
      <div style="margin-top:10px;">
        <div class="small muted">Summary</div>
        <input id="mCandSummary" type="text" placeholder='Found 5/8" RB w/cap, etc.'/>
      </div>
      <div class="row" style="margin-top:12px;justify-content:flex-end;">
        <button class="btn" id="mCandAdd">Add</button>
      </div>

      <div class="hr"></div>

      <div class="hd" style="padding:0;margin-bottom:8px;">Justification for chosen (if required)</div>
      <textarea id="mJustification" rows="4" placeholder="Explain why a weaker candidate was chosen over stronger alternatives.">${esc(chosen?.justification||"")}</textarea>
      <div class="row" style="margin-top:12px;justify-content:flex-end;">
        <button class="btn good" id="mSaveDecision">Save Decision</button>
      </div>
    `);

    $("#mCornerSave").addEventListener("click", async () => {
      try{
        await api.patchCorner(state.activeId, c.id, {
          name: $("#mCornerName").value.trim(),
          status: $("#mCornerStatus").value,
          plss: $("#mCornerPlss").value.trim()
        });
        await ensureCorners(true);
        toast("Saved","Corner updated.","good");
        closeModal();
        render();
      }catch(err){
        toast("Error", err.message || String(err), "bad");
      }
    });

    $("#mCandAdd").addEventListener("click", async () => {
      const summary = ($("#mCandSummary").value || "").trim();
      if (!summary){
        toast("Missing","Candidate summary required.","warn");
        return;
      }
      try{
        await api.createCandidate(state.activeId, c.id, {
          kind: $("#mCandKind").value,
          summary,
          weight: clamp(Number($("#mCandWeight").value || 3), 1, 5),
          refEvidenceId: ($("#mCandEvidence").value || null) || null
        });
        await Promise.all([ensureCorners(true), ensureDecisions(true)]);
        toast("Saved","Candidate added.","good");
        closeModal();
        openCorner(c.id); // reopen with refreshed data
      }catch(err){
        toast("Error", err.message || String(err), "bad");
      }
    });

    $("#mSaveDecision").addEventListener("click", async () => {
      try{
        await api.saveCornerDecision(state.activeId, c.id, $("#mJustification").value || "");
        await Promise.all([ensureCorners(true), ensureDecisions(true)]);
        toast("Saved","Decision saved.","good");
        closeModal();
        render();
      }catch(err){
        toast("Error", err.message || String(err), "bad");
      }
    });
  }

  async function chooseCandidate(cornerId, candidateId){
    try{
      await api.chooseCandidate(state.activeId, cornerId, candidateId);
      await Promise.all([ensureCorners(true), ensureDecisions(true), refreshActiveCasefile()]);
      toast("Saved","Candidate chosen.","good");
      closeModal();
      openCorner(cornerId);
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function unchooseCandidate(cornerId, candidateId){
    try{
      await api.unchooseCandidate(state.activeId, cornerId, candidateId);
      await Promise.all([ensureCorners(true), ensureDecisions(true), refreshActiveCasefile()]);
      toast("Saved","Candidate unchosen.","good");
      closeModal();
      openCorner(cornerId);
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function deleteCandidate(cornerId, candidateId){
    const ok = confirm("Delete this candidate?");
    if (!ok) return;
    try{
      await api.deleteCandidate(state.activeId, cornerId, candidateId);
      await Promise.all([ensureCorners(true), ensureDecisions(true), refreshActiveCasefile()]);
      toast("Deleted","Candidate removed.","good");
      closeModal();
      openCorner(cornerId);
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function saveTraverseConfig(){
    const startN = Number($("#trStartN")?.value);
    const startE = Number($("#trStartE")?.value);
    const basisLabel = $("#trBasisLabel")?.value || "";
    const rotationDeg = Number($("#trRotation")?.value || 0);
    if (!Number.isFinite(startN) || !Number.isFinite(startE)){
      toast("Missing","Valid start N/E required.","warn");
      return;
    }
    try{
      await api.patchTraverse(state.activeId, { start:{N:startN,E:startE}, basis:{label:basisLabel, rotationDeg} });
      await Promise.all([ensureTraverse(true), refreshActiveCasefile()]);
      toast("Saved","Traverse config updated.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function syncIncludedCalls(){
    try{
      await api.syncIncludedCalls(state.activeId);
      await Promise.all([ensureTraverse(true), ensureTraverseResults(true), refreshActiveCasefile()]);
      toast("Synced","Traverse call list synced from included calls.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function runTraverse(){
    try{
      await api.runTraverse(state.activeId, {});
      await ensureTraverseResults(true);
      toast("Computed","Traverse results updated.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function moveTraverseCall(idx, dir){
    await ensureTraverse();
    const calls = [...(state.traverse.calls || [])];
    const j = idx + dir;
    if (j < 0 || j >= calls.length) return;
    [calls[idx], calls[j]] = [calls[j], calls[idx]];
    try{
      await api.patchTraverse(state.activeId, { calls });
      await ensureTraverse(true);
      toast("Saved","Traverse call order updated.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  /* ---------------------------- Topbar ---------------------------- */
  async function doNewProject(){
    const name = prompt("New casefile name:", "New Boundary Casefile");
    if (!name) return;
    try{
      const cf = await api.createCasefile(name, "Idaho", "", true);
      await refreshCasefiles();
      await setActiveCasefile(cf.id);
      toast("Created","Casefile created.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function doDuplicateProject(){
    if (!state.activeId) return;
    const name = prompt("Name for duplicate casefile (optional):", "");
    try{
      const cf = await api.duplicateCasefile(state.activeId, name.trim() ? name.trim() : null);
      await refreshCasefiles();
      await setActiveCasefile(cf.id);
      toast("Duplicated","Casefile duplicated.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function doDeleteProject(){
    if (!state.activeId) return;
    const nm = state.active?.meta?.name || "this casefile";
    const ok = confirm(`Delete "${nm}"? This cannot be undone.`);
    if (!ok) return;
    try{
      await api.deleteCasefile(state.activeId);
      state.activeId = null;
      state.active = null;
      localStorage.removeItem(ACTIVE_KEY);
      await refreshCasefiles();
      if (state.casefiles.length){
        await setActiveCasefile(state.casefiles[0].id);
      }
      toast("Deleted","Casefile deleted.","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function doExportProject(){
    if (!state.activeId) return;
    try{
      const bundle = await api.exportCasefile(state.activeId);
      const safeName = (state.active?.meta?.name || "casefile").replace(/[^\w\-]+/g,"_").slice(0,60);
      downloadJson(bundle, `${safeName}.bew.json`);
      toast("Exported","Downloaded .bew.json bundle.","good");
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function doImportProject(file){
    try{
      const text = await file.text();
      const bundle = JSON.parse(text);
      const created = await api.importCasefile(bundle, true);
      await refreshCasefiles();
      await setActiveCasefile(created.id);
      toast("Imported","Casefile imported (IDs rewritten).","good");
      render();
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  async function doPrintOutputs(){
    setTab("outputs");
    // ensure outputs loaded then print
    await ensurePrintable(true);
    render();
    setTimeout(()=>window.print(), 80);
  }

  async function seedSampleCasefile(){
    try{
      const cf = await api.createCasefile("Sample Casefile (API)", "Idaho", "Seeded demo data created by the client.", true);

      // Evidence
      const deed = await api.createEvidence(cf.id, { type:"Deed", title:"Warranty Deed (Demo)", date:"2022-05-14", source:"Ada County Recorder (demo)", tags:["legal","calls"], notes:"Demo placeholder. Replace with actual deed text." });
      const ros  = await api.createEvidence(cf.id, { type:"ROS", title:"Record of Survey 95051440 (Demo)", date:"1995-05-14", source:"Ada County ROS (demo)", tags:["ros","basis"], notes:"Demo placeholder for ROS notes." });
      const photo= await api.createEvidence(cf.id, { type:"Photo", title:'Found 5/8" RB w/ cap (Demo)', date:fmtDate(nowISO()), source:"Field photo (demo)", tags:["monument"], notes:"Demo placeholder photo slot (no binary uploaded)." });

      // Calls
      const calls = [
        {bearing:"S 89°58'00\" W", distance:315.27, unit:"ft"},
        {bearing:"N 00°00'27\" W", distance:267.69, unit:"ft"},
        {bearing:"N 89°57'43\" E", distance:315.13, unit:"ft"},
        {bearing:"S 00°02'17\" E", distance:267.72, unit:"ft"},
      ];
      const createdCallIds = [];
      for (let i=0;i<calls.length;i++){
        const c = calls[i];
        const ex = await api.createExtraction(cf.id, {
          evidenceId: deed.id, page:1, snippet:"…(demo) boundary call…", label:`Call ${i+1}`,
          bearingText: c.bearing, distance: c.distance, distanceUnit: c.unit, include:true, confidence:0.85
        });
        createdCallIds.push(ex.id);
      }
      // Traverse: set calls list to created call ids
      await api.patchTraverse(cf.id, { start:{N:10000,E:10000}, basis:{label:"Assumed/Grid North (demo)", rotationDeg:0}, calls: createdCallIds });

      // Corners + candidates
      const nw = await api.createCorner(cf.id, { name:"NW COR (Parcel)", plss:"Within Sec/T/R (demo)", status:"Existent" });
      await api.createCandidate(cf.id, nw.id, { kind:"Monument", refEvidenceId: photo.id, summary:'Found 5/8" rebar w/cap', weight:5 });
      await api.createCandidate(cf.id, nw.id, { kind:"Record Call", refEvidenceId: ros.id, summary:'ROS shows set 1/2" RB', weight:3 });
      // choose first candidate (need id; list corners returns with candidates; easiest: reload corners)
      let corners = (await api.listCorners(cf.id, 200, 0)).items;
      let nwFresh = corners.find(x=>x.id===nw.id);
      let first = nwFresh?.candidates?.[0];
      if (first) await api.chooseCandidate(cf.id, nw.id, first.id);

      const ne = await api.createCorner(cf.id, { name:"NE COR (Parcel)", plss:"Within Sec/T/R (demo)", status:"Obliterated" });
      await api.createCandidate(cf.id, ne.id, { kind:"Occupation", refEvidenceId: deed.id, summary:"Fence corner long-standing", weight:3 });
      await api.createCandidate(cf.id, ne.id, { kind:"Record Call", refEvidenceId: deed.id, summary:"Deed call corner", weight:2 });
      corners = (await api.listCorners(cf.id, 200, 0)).items;
      let neFresh = corners.find(x=>x.id===ne.id);
      let occ = neFresh?.candidates?.find(x=>x.kind==="Occupation") || neFresh?.candidates?.[0];
      if (occ) {
        await api.chooseCandidate(cf.id, ne.id, occ.id);
        await api.saveCornerDecision(cf.id, ne.id, "Occupation consistent w/ record dimensions; no monument recovered.");
      }

      // Select new casefile
      await refreshCasefiles();
      await setActiveCasefile(cf.id);
      toast("Seeded","Sample casefile created via API.","good");
      setTab("dashboard");
    }catch(err){
      toast("Error", err.message || String(err), "bad");
    }
  }

  /* ------------------------ Event delegation ----------------------- */
  document.addEventListener("click", (e) => {
    const t = e.target.closest("[data-act]");
    if (!t) return;

    const act = t.dataset.act;
    const id = t.dataset.id;
    const tab = t.dataset.tab;

    if (act === "goto"){ setTab(tab); return; }
    if (act === "closeModal"){ closeModal(); return; }

    if (act === "editEvidence"){ editEvidence(id); return; }
    if (act === "uploadEvidence"){ uploadEvidenceFile(id); return; }
    if (act === "deleteEvidence"){ deleteEvidence(id); return; }
    if (act === "deleteAttachment"){ deleteAttachment(id); return; }

    if (act === "moveCallUp"){ moveCall(id, -1); return; }
    if (act === "moveCallDown"){ moveCall(id, +1); return; }
    if (act === "editCall"){ editCall(id); return; }
    if (act === "deleteCall"){ deleteCall(id); return; }

    if (act === "openCorner"){ openCorner(id); return; }
    if (act === "deleteCorner"){ deleteCorner(id); return; }

    if (act === "chooseCandidate"){ chooseCandidate(t.dataset.corner, id); return; }
    if (act === "unchooseCandidate"){ unchooseCandidate(t.dataset.corner, id); return; }
    if (act === "deleteCandidate"){ deleteCandidate(t.dataset.corner, id); return; }

    if (act === "moveTraverseUp"){ moveTraverseCall(Number(t.dataset.idx), -1); return; }
    if (act === "moveTraverseDown"){ moveTraverseCall(Number(t.dataset.idx), +1); return; }
  });

  document.addEventListener("change", (e) => {
    const t = e.target.closest("[data-act]");
    if (!t) return;
    const act = t.dataset.act;
    if (act === "toggleInclude"){
      toggleInclude(t.dataset.id, !!t.checked).then(()=>{ if(state.tab==="extract") render(); });
    }
  });

  /* ------------------------------ Boot ----------------------------- */
  async function boot(){
    setApiHealthState("…");
    setSyncState("OK");


    // nav tabs
    $$(".nav .tab").forEach(t => t.addEventListener("click", () => setTab(t.dataset.tab)));

    // topbar
    elNewProjectBtn.addEventListener("click", doNewProject);
    elDupProjectBtn.addEventListener("click", doDuplicateProject);
    elDelProjectBtn.addEventListener("click", doDeleteProject);
    elExportBtn.addEventListener("click", doExportProject);
    elImportBtn.addEventListener("click", () => {
      elHiddenImport.click();
    });
    elHiddenImport.addEventListener("change", () => {
      const f = elHiddenImport.files?.[0];
      if (!f) return;
      doImportProject(f);
      elHiddenImport.value = "";
    });
    elPrintBtn.addEventListener("click", doPrintOutputs);

    if (activeProjectId){
      elLoadSampleBtn.style.display = "none";
      elNewProjectBtn.style.display = "none";
      elDupProjectBtn.style.display = "none";
      elDelProjectBtn.style.display = "none";
      elImportBtn.style.display = "none";
    }

    elLoadSampleBtn.addEventListener("click", () => {
      const ok = confirm("Create a NEW sample casefile via API? (Does not overwrite existing.)");
      if (!ok) return;
      seedSampleCasefile();
    });

    try{
      await initData();
    }catch(err){
      setApiHealthState("ERR");
      toast("Error", err?.message || String(err), "bad");
      render();
    }
  }

  async function initData(){
    try{
      await api.health();
      setApiHealthState("OK");
    }catch(_){
      setApiHealthState("ERR");
    }

    let pinnedCasefileId = "";
    if (activeProjectId){
      try{
        const linked = await api.syncProjectWorkbench(activeProjectId, {});
        pinnedCasefileId = resolveCasefileId(linked);
      }catch(err){
        toast("Warning", "Project sync unavailable. Falling back to local casefile bootstrap.", "warn");
        console.warn("[WORKBENCH] project sync bootstrap failed", err);
      }
    }

    let casefilesLoaded = false;
    try{
      await refreshCasefiles();
      casefilesLoaded = true;
    }catch(err){
      state.casefiles = [];
      toast("Warning", "Casefiles API is temporarily unavailable. Retrying may restore project data.", "warn");
      console.warn("[WORKBENCH] casefile list bootstrap failed", err);
    }

    if (activeProjectId){
      const linkedExists = pinnedCasefileId && state.casefiles.some(x=>x.id===pinnedCasefileId);
      if (!linkedExists){
        try{
          const created = await api.createProjectCasefile(activeProjectId, {});
          pinnedCasefileId = resolveCasefileId(created) || pinnedCasefileId;
          try{
            await refreshCasefiles();
            casefilesLoaded = true;
          }catch(err){
            state.casefiles = [];
            console.warn("[WORKBENCH] casefile refresh after project create failed", err);
          }
        }catch(err){
          toast("Warning", "Could not create project-linked casefile. Creating a local casefile instead.", "warn");
          console.warn("[WORKBENCH] project-linked casefile bootstrap failed", err);
        }
      }
    }

    async function createAndActivateFallbackCasefile(){
      let cf = null;
      if (activeProjectId){
        try{
          cf = await api.createProjectCasefile(activeProjectId, {});
        }catch(err){
          console.warn("[WORKBENCH] project-linked casefile create failed, retrying via sync", err);
        }
        if (!resolveCasefileId(cf)){
          const synced = await api.syncProjectWorkbench(activeProjectId, { forceNewCasefile: true });
          cf = resolveCasefileId(synced) ? synced : cf;
        }
        const createdId = resolveCasefileId(cf);
        try{
          await refreshCasefiles();
          casefilesLoaded = true;
        }catch(err){
          state.casefiles = [];
          console.warn("[WORKBENCH] casefile refresh after project fallback create failed", err);
        }
        const activated = await ensureActiveCasefile([createdId, pinnedCasefileId, state.casefiles?.[0]?.id || ""]);
        if (!activated){
          throw new Error("Unable to create or activate a project-linked casefile.");
        }
        return true;
      }

      cf = await api.createCasefile("New Boundary Casefile", "Idaho", "", true);
      const createdId = resolveCasefileId(cf);
      try{
        await refreshCasefiles();
        casefilesLoaded = true;
      }catch(err){
        state.casefiles = [];
        console.warn("[WORKBENCH] casefile refresh after local fallback create failed", err);
      }
      return await ensureActiveCasefile([createdId, state.casefiles?.[0]?.id || ""]);
    }

    if (!casefilesLoaded){
      try{
        await createAndActivateFallbackCasefile();
      }catch(err){
        console.warn("[WORKBENCH] fallback bootstrap unavailable while casefiles API is down", err);
      }
      await ensureTabData(state.tab);
      render();
      return;
    }

    if (!state.casefiles.length){
      await createAndActivateFallbackCasefile();
    } else {
      const saved = localStorage.getItem(ACTIVE_KEY);
      const pickDefault = (saved && state.casefiles.some(x=>x.id===saved)) ? saved : state.casefiles[0].id;
      const pick = (activeProjectId && pinnedCasefileId) ? pinnedCasefileId : pickDefault;
      const activated = await ensureActiveCasefile([pick, pickDefault, state.casefiles[0]?.id || ""]);
      if (!activated){
        await createAndActivateFallbackCasefile();
      }
    }
    await ensureTabData(state.tab);
    render();
  }

  // Kick off
  boot();

})();
</script>
</body>
</html>
