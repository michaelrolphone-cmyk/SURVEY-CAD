<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Survey Sketch — Points & Bearings</title>
  <style>
    :root{
      --bg:#0b0b0b;
      --panel:#111;
      --panel2:#151515;
      --text:#e8e8e8;
      --muted:#9aa0a6;
      --accent:#ffd54a;
      --line:#ffffff;
      --pt:#ff2b2b;
      --num:#ffffff;
      --code:#39ff79;
      --notes:#3aa3ff;
      --warn:#ff6b6b;
      --ok:#46d36b;
      --border:#2a2a2a;
      --bad:#ff4d4d;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:13px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }
    .app{
      height:100vh;
      display:grid;
      grid-template-columns: 440px 1fr;
    }
    .panel{
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border-right:1px solid var(--border);
      padding:12px 12px 10px;
      overflow:auto;
    }
    .panel h1{
      font-size:14px;
      margin:0 0 10px;
      letter-spacing:.4px;
    }
    .row{ display:flex; gap:8px; align-items:center; }
    .col{ display:flex; flex-direction:column; gap:8px; }
    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .grid3{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; }
    .section{
      border:1px solid var(--border);
      border-radius:10px;
      padding:10px;
      background:#0f0f0f;
      margin-bottom:10px;
    }
    .section .title{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      margin-bottom:8px;
      gap:10px;
    }
    .section .title b{ font-size:12px; }
    .section .title span{ color:var(--muted); font-size:11px; }
    label{
      display:flex;
      flex-direction:column;
      gap:4px;
      color:var(--muted);
      font-size:11px;
    }
    input, select, textarea, button{
      font:inherit;
      color:var(--text);
      background:#0b0b0b;
      border:1px solid var(--border);
      border-radius:8px;
      padding:8px 9px;
      outline:none;
    }
    textarea{ min-height:64px; resize:vertical; }
    input[type="file"]{ padding:6px; }
    button{
      cursor:pointer;
      background:#141414;
      transition:.15s transform ease, .15s background ease, .15s border-color ease;
      user-select:none;
    }
    button:hover{ background:#1a1a1a; border-color:#3a3a3a; }
    button:active{ transform:translateY(1px); }
    button.primary{
      border-color:#5c4b14;
      background:#201a09;
    }
    button.primary:hover{ background:#2a210b; }
    button.danger{
      border-color:#5c1b1b;
      background:#210b0b;
      color:#ffd9d9;
    }
    button.danger:hover{ background:#2b0f0f; }
    button.ok{
      border-color:#1f5c2d;
      background:#0c1f10;
      color:#dbffe5;
    }
    button.ok:hover{ background:#0f2a15; }
    .pill{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding:5px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      color:var(--muted);
      font-size:11px;
      background:#0c0c0c;
      max-width:100%;
    }
    .pill b{ color:var(--text); font-weight:600; }
    .pill .clip{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:260px;
      display:inline-block;
      vertical-align:bottom;
    }
    .hint{
      color:var(--muted);
      font-size:11px;
      margin-top:6px;
    }
    .status{
      border-left:3px solid var(--border);
      padding:8px 10px;
      border-radius:8px;
      background:#0c0c0c;
      color:var(--muted);
      font-size:11px;
      margin-top:8px;
      white-space:pre-wrap;
    }
    .status.warn{ border-left-color:var(--warn); }
    .status.ok{ border-left-color:var(--ok); }

    .canvasWrap{
      position:relative;
      overflow:hidden;
      background:#000;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      cursor:crosshair;
    }
    .hud{
      position:absolute;
      left:10px;
      bottom:10px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      pointer-events:none;
    }
    .hud .pill{ pointer-events:none; }

    .kbd{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
      color:var(--muted);
      font-size:11px;
      margin-top:8px;
    }
    .kbd div{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 8px;
      border:1px dashed #2a2a2a;
      border-radius:8px;
      background:#0c0c0c;
    }
    .kbd code{
      color:var(--text);
      background:#111;
      padding:1px 6px;
      border-radius:6px;
      border:1px solid #2a2a2a;
    }
    .mini{
      font-size:10px;
      color:var(--muted);
    }
    .sep{ height:1px; background:var(--border); margin:8px 0; }
    .inline{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .inline label{
      flex-direction:row;
      align-items:center;
      gap:8px;
      font-size:11px;
      margin:0;
    }
    .inline input[type="checkbox"]{
      width:16px; height:16px; padding:0;
    }

    /* Points list */
    .tableWrap{
      border:1px solid var(--border);
      border-radius:10px;
      overflow:hidden;
      background:#0b0b0b;
    }
    .tableTools{
      display:flex;
      gap:8px;
      padding:8px;
      border-bottom:1px solid var(--border);
      background:#0c0c0c;
      align-items:center;
      flex-wrap:wrap;
    }
    .tableTools input{ flex:1; min-width:140px; }
    table{
      width:100%;
      border-collapse:collapse;
      font-size:11px;
    }
    thead th{
      position:sticky;
      top:0;
      background:#0f0f0f;
      border-bottom:1px solid var(--border);
      padding:6px 6px;
      text-align:left;
      color:var(--muted);
      font-weight:600;
      z-index:1;
    }
    tbody td{
      border-bottom:1px solid #1a1a1a;
      padding:6px;
      vertical-align:middle;
    }
    tbody tr:hover{ background:#0f0f0f; }
    tbody tr.sel{ outline:1px solid #5c4b14; background:#151006; }
    .cellInput{
      width:100%;
      padding:6px 6px;
      border-radius:7px;
      border:1px solid #2a2a2a;
      background:#0b0b0b;
      color:var(--text);
      font-size:11px;
    }
    .cellInput.bad{
      border-color: var(--bad);
      box-shadow: 0 0 0 1px rgba(255,77,77,0.25) inset;
    }
    .cellBtn{
      padding:6px 8px;
      border-radius:8px;
      border:1px solid #2a2a2a;
      background:#121212;
      color:var(--text);
      font-size:11px;
      cursor:pointer;
    }
    .cellBtn:hover{ border-color:#3a3a3a; background:#171717; }
    .cellBtn.danger{
      border-color:#5c1b1b;
      background:#210b0b;
      color:#ffd9d9;
    }
    .cellBtn.danger:hover{ background:#2b0f0f; border-color:#743030; }
    .scrollBody{
      max-height:300px;
      overflow:auto;
    }
  </style>
</head>
<body>
<div class="app">
  <div class="panel">
    <h1>Survey Sketch — Points & Bearings</h1>

    <div class="section">
      <div class="title">
        <b>Tool</b>
        <span id="toolHint">Select/Move</span>
      </div>
      <div class="grid2">
        <button id="toolSelect" class="primary">Select / Move</button>
        <button id="toolAddPoint">Add Point</button>
        <button id="toolLine2pt">Line: 2 Points</button>
        <button id="toolLineDB">Line: Dist/Bearing</button>
        <button id="toolPointOnLine">Point on Line</button>
        <button id="toolPan">Pan</button>
      </div>

      <div class="grid2" style="margin-top:8px;">
        <button id="undoBtn">Undo</button>
        <button id="redoBtn">Redo</button>
      </div>

      <div class="grid2" style="margin-top:8px;">
        <button id="zoomExtents" class="ok">Zoom Extents</button>
        <button id="zoomAllAndCenter">Center (0,0)</button>
      </div>

      <div class="hint">
        <b>Locked by default:</b> points/lines won’t drag-move unless you <b>double-click</b> them to toggle “movable”.
        <br>Multi-select: hold <b>Shift</b> while clicking points/lines.
      </div>
      <div class="kbd">
        <div><span>Toggle movable</span><code>DblClick</code></div>
        <div><span>Pan while holding</span><code>Space</code></div>
        <div><span>Undo</span><code>Ctrl+Z</code></div>
        <div><span>Redo</span><code>Ctrl+Y</code></div>
        <div><span>Delete selected</span><code>Del</code></div>
        <div><span>Zoom</span><code>Wheel</code></div>
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>CSV</b>
        <span>number,x,y,z,code,notes</span>
      </div>
      <label>
        Import points CSV
        <input id="csvIn" type="file" accept=".csv,.txt" />
      </label>
      <div class="row" style="margin-top:8px;">
        <label style="flex:1;">
          On import
          <select id="importMode">
            <option value="merge">Merge by point number (update existing)</option>
            <option value="skip">Skip duplicates</option>
            <option value="rename">Auto-rename duplicates (next open number)</option>
          </select>
        </label>
      </div>
      <div class="inline" style="margin-top:8px;">
        <label><input id="autoZoomAfterImport" type="checkbox" checked /> Auto-zoom after import</label>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="exportCsv" class="ok" style="flex:1;">Export Points CSV</button>
      </div>
      <div class="hint">Header row optional. Extra columns ignored.</div>
    </div>

    <div class="section">
      <div class="title">
        <b>Add / Edit Point</b>
        <span>click canvas in Add Point</span>
      </div>
      <div class="grid2">
        <label>Number (blank = auto)
          <input id="ptNum" placeholder="auto" />
        </label>
        <label>Z
          <input id="ptZ" placeholder="0" />
        </label>
      </div>
      <div class="grid2">
        <label>Code
          <input id="ptCode" placeholder="CODE" />
        </label>
        <label class="mini">Notes/Desc
          <input id="ptNotes" placeholder="notes" />
        </label>
      </div>
      <div class="grid2">
        <label>X
          <input id="ptX" placeholder="(selected)" />
        </label>
        <label>Y
          <input id="ptY" placeholder="(selected)" />
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="applyPoint" class="ok">Apply to Selected Point</button>
        <button id="focusSelected">Center on Selection</button>
      </div>
      <div class="hint">
        Point marker: <span style="color:var(--pt)">red X</span> · Number: <span style="color:var(--num)">white</span> · Code: <span style="color:var(--code)">green</span> · Notes: <span style="color:var(--notes)">blue</span>
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Line: Distance / Bearing</b>
        <span>select start point</span>
      </div>
      <div class="grid2">
        <label>Distance
          <input id="dist" placeholder="100.00" />
        </label>
        <label>Bearing / Azimuth
          <input id="bearing" placeholder='N15-15-15W  or  N15.1515W  or  123.45' />
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="setStartFromSel" class="primary">Use Selected Point as Start</button>
        <button id="makeLineDB" class="ok">Create Point + Line</button>
      </div>
      <div class="hint">
        Bearing formats accepted:
        <br>• Quadrant: <b>N15-15-15W</b>, <b>N15.1515W</b>, <b>S12-30E</b>
        <br>• Azimuth degrees from North (clockwise): <b>123.45</b>
        <br>(No degree symbol required.)
      </div>
      <div class="sep"></div>
      <div class="grid2">
        <button id="lineBetweenSelected" class="ok">Line Between Selected Points</button>
        <button id="clearConstruction">Clear Construction</button>
      </div>
      <div class="hint">
        If you have <b>2</b> points selected → one line.
        If you have <b>3+</b> points selected → chain lines in selection order (P1–P2, P2–P3, ...).
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Line Ops</b>
        <span>select lines (Shift for multi)</span>
      </div>
      <div class="grid2">
        <button id="extendToIntersect" class="primary">Extend → Intersect (new point)</button>
        <button id="trimToIntersect">Trim (grip) → Intersect</button>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="pointAtIntersection" class="ok">Create Point @ Intersection</button>
        <button id="trimOverlap">Trim Overlap (colinear)</button>
      </div>
      <div class="hint">
        • <b>Extend → Intersect</b> creates a <b>new point</b> at the intersection and re-ends the active line there (original endpoint point does not move).
        <br>• <b>Trim</b> uses the selected line’s grip (nearest endpoint where you clicked) and shortens by moving that endpoint.
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Point on Line</b>
        <span>select a line</span>
      </div>
      <div class="grid3">
        <label>Station
          <input id="station" placeholder="25.00" />
        </label>
        <label>Offset (+left)
          <input id="offset" placeholder="0.00" />
        </label>
        <label>From
          <select id="stationFrom">
            <option value="a">Line A-end</option>
            <option value="b">Line B-end</option>
          </select>
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="makePointOnLine" class="ok">Create Point</button>
        <button id="swapLineEnds">Swap Line Ends</button>
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Selection</b>
        <span id="selSummary">none</span>
      </div>
      <div class="grid2">
        <button id="deleteSelected" class="danger">Delete Selected</button>
        <button id="clearSelection">Clear Selection</button>
      </div>
      <div id="status" class="status">Ready.</div>
    </div>

    <div class="section">
      <div class="title">
        <b>Points List</b>
        <span>edit inline</span>
      </div>

      <div class="tableWrap">
        <div class="tableTools">
          <input id="ptFilter" placeholder="Filter: number / code / notes" />
          <button id="refreshPoints" class="cellBtn">Refresh</button>
          <button id="sortPoints" class="cellBtn">Sort: Num</button>
        </div>

        <div class="scrollBody">
          <table>
            <thead>
              <tr>
                <th style="width:78px;">#</th>
                <th style="width:90px;">X</th>
                <th style="width:90px;">Y</th>
                <th style="width:60px;">Z</th>
                <th style="width:90px;">Code</th>
                <th>Notes</th>
                <th style="width:110px;">Actions</th>
              </tr>
            </thead>
            <tbody id="pointsTbody"></tbody>
          </table>
        </div>
      </div>

      <div class="hint">
        Editing updates immediately (with validation for point number uniqueness).
      </div>
    </div>
  </div>

  <div class="canvasWrap">
    <canvas id="c"></canvas>
    <div class="hud">
      <span class="pill"><b>Tool</b> <span id="hudTool">Select/Move</span></span>
      <span class="pill"><b>Mouse</b> <span id="hudMouse">x: 0, y: 0</span></span>
      <span class="pill"><b>Scale</b> <span id="hudZoom">1.00</span></span>
      <span class="pill"><b>Sel</b> <span id="hudSel" class="clip">none</span></span>
      <span class="pill"><b>Undo</b> <span id="hudUndo">0</span></span>
      <span class="pill"><b>Redo</b> <span id="hudRedo">0</span></span>
    </div>
  </div>
</div>

<script>
(() => {
  // -------------------------
  // Utilities
  // -------------------------
  const EPS = 1e-9;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist2 = (ax,ay,bx,by)=>{ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };
  const dist = (ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
  const fmt = (n)=> (Number.isFinite(n) ? (Math.abs(n) < 1e6 ? n.toFixed(3) : n.toExponential(6)) : "NaN");
  const parseNum = (s, def=0) => {
    const n = Number(String(s).trim());
    return Number.isFinite(n) ? n : def;
  };
  const isEditableTarget = (t) => {
    if (!t) return false;
    const tag = (t.tagName || "").toUpperCase();
    return tag === "INPUT" || tag === "TEXTAREA" || t.isContentEditable || tag === "SELECT";
  };

  function setStatus(msg, kind="") {
    const el = $("#status");
    el.textContent = msg;
    el.className = "status" + (kind ? " " + kind : "");
  }

  function parseQuadrantAngleDegrees(midRaw) {
    let mid = String(midRaw ?? "").trim();
    if (!mid) return null;

    mid = mid
      .replace(/\s+/g, "-")
      .replace(/DEG|°/gi, "-")
      .replace(/MIN|'/gi, "-")
      .replace(/SEC|"/gi, "-")
      .replace(/:+/g, "-")
      .replace(/[^0-9.+-]+/g, "-")
      .replace(/-+/g, "-")
      .replace(/^-|-$/g, "");

    if (!mid) return null;

    if (!mid.includes("-")) {
      const a = Number(mid);
      if (!Number.isFinite(a)) return null;
      return Math.abs(a);
    }

    const parts = mid.split("-").filter(Boolean);
    if (!parts.length) return null;

    const d = Number(parts[0]);
    const m = parts.length > 1 ? Number(parts[1]) : 0;
    const s = parts.length > 2 ? Number(parts[2]) : 0;
    if (![d,m,s].every(Number.isFinite)) return null;

    const deg = Math.abs(d) + (Math.abs(m)/60) + (Math.abs(s)/3600);
    return deg;
  }

  function bearingToAzimuthRad(input) {
    const raw = String(input ?? "").trim();
    if (!raw) return null;

    if (/^[+-]?\d+(\.\d+)?$/.test(raw)) {
      const deg = parseFloat(raw);
      return (deg * Math.PI) / 180;
    }

    const m = raw.trim().toUpperCase().match(/^([NS])\s*(.+?)\s*([EW])$/);
    if (!m) return null;

    const q1 = m[1];
    const q2 = m[3];
    const mid = m[2];

    const angle = parseQuadrantAngleDegrees(mid);
    if (angle == null) return null;

    let azDeg;
    if (q1==="N" && q2==="E") azDeg = angle;
    else if (q1==="S" && q2==="E") azDeg = 180 - angle;
    else if (q1==="S" && q2==="W") azDeg = 180 + angle;
    else if (q1==="N" && q2==="W") azDeg = 360 - angle;
    else return null;

    return (azDeg * Math.PI) / 180;
  }

  function azimuthRadToQuadrantString(az) {
    let deg = (az * 180/Math.PI) % 360;
    if (deg < 0) deg += 360;

    let q1="N", q2="E", ang=deg;
    if (deg >= 0 && deg <= 90) { q1="N"; q2="E"; ang=deg; }
    else if (deg > 90 && deg < 180) { q1="S"; q2="E"; ang=180-deg; }
    else if (deg >= 180 && deg < 270) { q1="S"; q2="W"; ang=deg-180; }
    else { q1="N"; q2="W"; ang=360-deg; }

    const d = Math.floor(ang + 1e-10);
    const mFloat = (ang - d) * 60;
    const m = Math.floor(mFloat + 1e-10);
    const s = (mFloat - m) * 60;
    const sRound = Math.round(s*1000)/1000;
    return `${q1}${d}-${String(m).padStart(2,"0")}-${String(sRound.toFixed(3)).padStart(6,"0")}${q2}`;
  }

  function lineLineIntersection(p1, p2, p3, p4) {
    const x1=p1.x, y1=p1.y, x2=p2.x, y2=p2.y;
    const x3=p3.x, y3=p3.y, x4=p4.x, y4=p4.y;
    const dx12 = x2-x1, dy12=y2-y1;
    const dx34 = x4-x3, dy34=y4-y3;
    const denom = dx12*dy34 - dy12*dx34;
    if (Math.abs(denom) < EPS) return null;
    const dx13 = x3-x1, dy13 = y3-y1;
    const t = (dx13*dy34 - dy13*dx34) / denom;
    const u = (dx13*dy12 - dy13*dx12) / denom;
    return { x: x1 + t*dx12, y: y1 + t*dy12, t, u };
  }

  function pointOnLineParam(p, a, b) {
    const dx = b.x-a.x, dy=b.y-a.y;
    const len2 = dx*dx + dy*dy;
    if (len2 < EPS) return 0;
    return ((p.x-a.x)*dx + (p.y-a.y)*dy) / len2;
  }

  function segmentClosestPoint(p, a, b) {
    const abx = b.x-a.x, aby=b.y-a.y;
    const apx = p.x-a.x, apy=p.y-a.y;
    const ab2 = abx*abx + aby*aby;
    let t = ab2 > EPS ? (apx*abx + apy*aby) / ab2 : 0;
    t = clamp(t, 0, 1);
    return { x: a.x + t*abx, y: a.y + t*aby, t };
  }

  function isColinearOverlap(a1,a2,b1,b2) {
    const ax=a2.x-a1.x, ay=a2.y-a1.y;
    const cross1 = ax*(b1.y-a1.y) - ay*(b1.x-a1.x);
    const cross2 = ax*(b2.y-a1.y) - ay*(b2.x-a1.x);
    if (Math.abs(cross1) > 1e-7 || Math.abs(cross2) > 1e-7) return null;

    const useX = Math.abs(ax) >= Math.abs(ay);
    const proj = (p)=> useX ? p.x : p.y;

    const A0 = proj(a1), A1 = proj(a2);
    const B0 = proj(b1), B1 = proj(b2);

    const aMin = Math.min(A0,A1), aMax=Math.max(A0,A1);
    const bMin = Math.min(B0,B1), bMax=Math.max(B0,B1);
    const oMin = Math.max(aMin,bMin);
    const oMax = Math.min(aMax,bMax);
    if (oMax <= oMin + 1e-9) return null;

    return { useX, oMin, oMax };
  }

  // -------------------------
  // DOM
  // -------------------------
  const $ = (q)=>document.querySelector(q);

  const canvas = $("#c");
  const ctx = canvas.getContext("2d");

  const hudTool = $("#hudTool");
  const hudMouse = $("#hudMouse");
  const hudZoom = $("#hudZoom");
  const hudSel = $("#hudSel");
  const hudUndo = $("#hudUndo");
  const hudRedo = $("#hudRedo");
  const selSummary = $("#selSummary");
  const toolHint = $("#toolHint");

  // -------------------------
  // Model
  // -------------------------
  let nextId = 1;
  const points = new Map(); // id -> {id,num,x,y,z,code,notes,movable}
  const lines = new Map();  // id -> {id,a,b,movable}

  // Selection
  let selectedPointId = null;   // primary (last clicked point)
  let selectedPointIds = [];    // ordered selection (last is primary)
  let selectedLines = [];       // [{ lineId, grip, t }]
  let lastSelectedLineId = null;

  // Construction
  let tool = "select";
  let construction = { startPointId: null, startPointId2: null };

  // View transform
  const MIN_SCALE = 0.0005;
  const MAX_SCALE = 5000;
  const view = { scale: 20, panX: 0, panY: 0 };
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  // Mouse
  const mouse = {
    x: 0, y: 0,
    wx: 0, wy: 0,
    down: false,
    button: 0,
    drag: false,
    dragStartX: 0, dragStartY: 0,
    dragStartPanX: 0, dragStartPanY: 0,
    dragStartWorldX: 0, dragStartWorldY: 0,
    dragObj: null
  };

  // -------------------------
  // Undo/Redo history (snapshot-based)
  // -------------------------
  const history = {
    undo: [],
    redo: [],
    max: 200,
    push(label="") {
      this.undo.push({ state: serializeState(), label, ts: Date.now() });
      if (this.undo.length > this.max) this.undo.shift();
      this.redo.length = 0;
      updateUndoRedoHUD();
    },
    undoAction() {
      if (!this.undo.length) { setStatus("Nothing to undo.", "warn"); return; }
      const cur = serializeState();
      const prev = this.undo.pop().state;
      this.redo.push({ state: cur, label:"", ts: Date.now() });
      restoreState(prev);
      setStatus("Undo.", "ok");
      updateUndoRedoHUD();
    },
    redoAction() {
      if (!this.redo.length) { setStatus("Nothing to redo.", "warn"); return; }
      const cur = serializeState();
      const next = this.redo.pop().state;
      this.undo.push({ state: cur, label:"", ts: Date.now() });
      restoreState(next);
      setStatus("Redo.", "ok");
      updateUndoRedoHUD();
    },
    popUndoIfNoOp(markerState) {
      // markerState: serialized JSON string of state after push, before operation
      // If current state equals markerState, remove last undo entry.
      const now = serializeState();
      if (now === markerState && this.undo.length) {
        this.undo.pop();
        updateUndoRedoHUD();
      }
    }
  };

  function serializeState() {
    const pts = Array.from(points.values()).map(p => ({...p}));
    const lns = Array.from(lines.values()).map(l => ({...l}));
    return JSON.stringify({
      nextId,
      points: pts,
      lines: lns,
      selection: {
        selectedPointId,
        selectedPointIds: [...selectedPointIds],
        selectedLines: selectedLines.map(s => ({...s})),
        lastSelectedLineId
      },
      construction: {...construction},
      view: {...view}
    });
  }

  function restoreState(json) {
    const s = JSON.parse(json);
    nextId = s.nextId ?? 1;

    points.clear();
    for (const p of (s.points || [])) points.set(p.id, {...p});

    lines.clear();
    for (const l of (s.lines || [])) lines.set(l.id, {...l});

    selectedPointId = s.selection?.selectedPointId ?? null;
    selectedPointIds = s.selection?.selectedPointIds ?? [];
    selectedLines = s.selection?.selectedLines ?? [];
    lastSelectedLineId = s.selection?.lastSelectedLineId ?? null;

    construction = s.construction ?? { startPointId:null, startPointId2:null };

    if (s.view) {
      view.scale = s.view.scale ?? view.scale;
      view.panX = s.view.panX ?? view.panX;
      view.panY = s.view.panY ?? view.panY;
    }

    updatePointEditorFromSelection();
    schedulePointsTableRender();
    updateUndoRedoHUD();
  }

  function updateUndoRedoHUD() {
    hudUndo.textContent = String(history.undo.length);
    hudRedo.textContent = String(history.redo.length);
    $("#undoBtn").disabled = history.undo.length === 0;
    $("#redoBtn").disabled = history.redo.length === 0;
  }

  // -------------------------
  // Transform helpers
  // -------------------------
  function worldToScreen(x,y){
    return {
      x: (x * view.scale) + view.panX,
      y: (-y * view.scale) + view.panY
    };
  }
  function screenToWorld(x,y){
    return {
      x: (x - view.panX) / view.scale,
      y: -((y - view.panY) / view.scale)
    };
  }

  function getMaxPointNumber() {
    let m = 0;
    for (const p of points.values()) m = Math.max(m, Number(p.num) || 0);
    return m;
  }
  function nextOpenPointNumber(start=null) {
    const used = new Set();
    for (const p of points.values()) used.add(String(p.num));
    let n = start ?? (getMaxPointNumber() + 1);
    n = Math.max(1, Math.floor(Number(n) || 1));
    while (used.has(String(n))) n++;
    return n;
  }
  function pointNumberExists(numStr, excludeId=null) {
    const ns = String(numStr);
    for (const p of points.values()) {
      if (excludeId != null && p.id === excludeId) continue;
      if (String(p.num) === ns) return true;
    }
    return false;
  }

  function addPoint({num, x, y, z=0, code="", notes="", movable=false}) {
    const id = nextId++;
    points.set(id, {
      id,
      num: String(num),
      x: Number(x),
      y: Number(y),
      z: Number(z),
      code: String(code ?? ""),
      notes: String(notes ?? ""),
      movable: !!movable
    });
    schedulePointsTableRender();
    return id;
  }

  function addLine(aPointId, bPointId, movable=false) {
    const id = nextId++;
    lines.set(id, { id, a: aPointId, b: bPointId, movable: !!movable });
    return id;
  }

  function deletePoint(pid) {
    if (!points.has(pid)) return;
    for (const [lid, ln] of Array.from(lines.entries())) {
      if (ln.a === pid || ln.b === pid) lines.delete(lid);
    }
    points.delete(pid);
    selectedPointIds = selectedPointIds.filter(id => id !== pid);
    selectedPointId = selectedPointIds.length ? selectedPointIds[selectedPointIds.length-1] : null;
    selectedLines = selectedLines.filter(s => lines.has(s.lineId));
    lastSelectedLineId = lines.has(lastSelectedLineId) ? lastSelectedLineId : null;
    updatePointEditorFromSelection();
    schedulePointsTableRender();
  }

  function deleteLine(lid) {
    lines.delete(lid);
    selectedLines = selectedLines.filter(s => s.lineId !== lid);
    if (lastSelectedLineId === lid) lastSelectedLineId = null;
  }

  // -------------------------
  // Picking
  // -------------------------
  function pickPoint(screenX, screenY, thresholdPx=10) {
    let best = null;
    let bestD2 = thresholdPx*thresholdPx;
    for (const p of points.values()) {
      const s = worldToScreen(p.x, p.y);
      const d2 = dist2(screenX, screenY, s.x, s.y);
      if (d2 <= bestD2) {
        bestD2 = d2;
        best = p.id;
      }
    }
    return best;
  }

  function pickLine(screenX, screenY, thresholdPx=8) {
    const w = screenToWorld(screenX, screenY);
    let best = null;
    let bestDist = thresholdPx / Math.max(view.scale, MIN_SCALE);
    let bestGrip = "a";
    let bestT = 0;

    for (const ln of lines.values()) {
      const pa = points.get(ln.a);
      const pb = points.get(ln.b);
      if (!pa || !pb) continue;

      const cp = segmentClosestPoint({x:w.x,y:w.y}, pa, pb);
      const d = dist(w.x, w.y, cp.x, cp.y);
      if (d <= bestDist) {
        bestDist = d;
        best = ln.id;
        bestT = cp.t;
        bestGrip = (cp.t <= 0.5) ? "a" : "b";
      }
    }
    return best ? { lineId: best, grip: bestGrip, t: bestT } : null;
  }

  function setSelectionFromPick({pointId=null, linePick=null, additive=false}) {
    if (pointId != null) {
      if (!additive) selectedPointIds = [pointId];
      else {
        const idx = selectedPointIds.indexOf(pointId);
        if (idx >= 0) selectedPointIds.splice(idx, 1);
        else selectedPointIds.push(pointId);
      }
      selectedPointId = selectedPointIds.length ? selectedPointIds[selectedPointIds.length-1] : null;
      if (!additive) { selectedLines = []; lastSelectedLineId = null; }
      updatePointEditorFromSelection();
      schedulePointsTableRender();
      return;
    }

    if (linePick) {
      if (!additive) selectedLines = [{ lineId: linePick.lineId, grip: linePick.grip, t: linePick.t }];
      else {
        const idx = selectedLines.findIndex(s => s.lineId === linePick.lineId);
        if (idx >= 0) selectedLines.splice(idx, 1);
        else selectedLines.push({ lineId: linePick.lineId, grip: linePick.grip, t: linePick.t });
      }
      lastSelectedLineId = selectedLines.length ? selectedLines[selectedLines.length-1].lineId : null;
      if (!additive) { selectedPointIds = []; selectedPointId = null; }
      updatePointEditorFromSelection();
      schedulePointsTableRender();
      return;
    }

    if (!additive) {
      selectedPointIds = [];
      selectedPointId = null;
      selectedLines = [];
      lastSelectedLineId = null;
      updatePointEditorFromSelection();
      schedulePointsTableRender();
    }
  }

  function selectionSummary() {
    const pts = selectedPointIds.length ? `Pts:${selectedPointIds.length} [${selectedPointIds.map(id=>points.get(id)?.num ?? "?").join(", ")}]` : "";
    const lns = selectedLines.length ? `Lines:${selectedLines.length}` : "";
    return [pts, lns].filter(Boolean).join(" + ") || "none";
  }

  function updateSelectionHUD() {
    const s = selectionSummary();
    selSummary.textContent = s;
    hudSel.textContent = s;
  }

  // -------------------------
  // Rendering
  // -------------------------
  function resize() {
    const rect = canvas.getBoundingClientRect();
    dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    if (view.panX === 0 && view.panY === 0) {
      view.panX = rect.width * 0.5;
      view.panY = rect.height * 0.5;
    }
  }

  function draw() {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,W,H);

    drawGrid(W,H);

    // lines
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#fff";
    for (const ln of lines.values()) {
      const a = points.get(ln.a);
      const b = points.get(ln.b);
      if (!a || !b) continue;
      const sa = worldToScreen(a.x,a.y);
      const sb = worldToScreen(b.x,b.y);
      ctx.beginPath();
      ctx.moveTo(sa.x, sa.y);
      ctx.lineTo(sb.x, sb.y);
      ctx.stroke();

      // show "movable" hint: faint yellow dash near mid
      if (ln.movable) {
        const mx = (sa.x+sb.x)/2, my=(sa.y+sb.y)/2;
        ctx.save();
        ctx.strokeStyle = "rgba(255,213,74,0.9)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(mx-6, my);
        ctx.lineTo(mx+6, my);
        ctx.stroke();
        ctx.restore();
      }
    }

    // highlight selected lines
    if (selectedLines.length) {
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#ffd54a";
      for (const s of selectedLines) {
        const ln = lines.get(s.lineId);
        if (!ln) continue;
        const a = points.get(ln.a), b = points.get(ln.b);
        if (!a || !b) continue;
        const sa = worldToScreen(a.x,a.y);
        const sb = worldToScreen(b.x,b.y);
        ctx.beginPath();
        ctx.moveTo(sa.x, sa.y);
        ctx.lineTo(sb.x, sb.y);
        ctx.stroke();

        const gripPt = (s.grip === "a") ? a : b;
        const sg = worldToScreen(gripPt.x, gripPt.y);
        ctx.fillStyle = "rgba(255,213,74,0.12)";
        ctx.strokeStyle = "#ffd54a";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.rect(sg.x-6, sg.y-6, 12, 12);
        ctx.fill();
        ctx.stroke();
      }
      ctx.restore();
    }

    // points
    for (const p of points.values()) {
      const sp = worldToScreen(p.x,p.y);

      // marker
      ctx.strokeStyle = "#ff2b2b";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(sp.x-5, sp.y-5);
      ctx.lineTo(sp.x+5, sp.y+5);
      ctx.moveTo(sp.x-5, sp.y+5);
      ctx.lineTo(sp.x+5, sp.y-5);
      ctx.stroke();

      // movable hint: small yellow ring
      if (p.movable) {
        ctx.save();
        ctx.strokeStyle = "rgba(255,213,74,0.95)";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, 8, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // labels
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textBaseline = "middle";

      ctx.fillStyle = "#ffffff";
      ctx.fillText(String(p.num), sp.x + 8, sp.y - 10);

      if (p.code) {
        ctx.fillStyle = "#39ff79";
        ctx.fillText(String(p.code), sp.x + 8, sp.y + 2);
      }
      if (p.notes) {
        ctx.fillStyle = "#3aa3ff";
        ctx.fillText(String(p.notes), sp.x + 8, sp.y + 14);
      }
    }

    // highlight selected points
    if (selectedPointIds.length) {
      ctx.save();
      for (const pid of selectedPointIds) {
        const p = points.get(pid);
        if (!p) continue;
        const sp = worldToScreen(p.x,p.y);
        ctx.strokeStyle = (pid === selectedPointId) ? "#ffd54a" : "rgba(255,213,74,0.55)";
        ctx.lineWidth = (pid === selectedPointId) ? 2 : 1.5;
        ctx.beginPath();
        ctx.rect(sp.x-9, sp.y-9, 18, 18);
        ctx.stroke();
      }
      ctx.restore();
    }

    // crosshair & snap box
    drawCrosshair(W,H);

    // HUD
    hudMouse.textContent = `x: ${fmt(mouse.wx)}, y: ${fmt(mouse.wy)}`;
    hudZoom.textContent = `${view.scale.toFixed(4)} px/unit`;
    updateSelectionHUD();
    updateUndoRedoHUD();

    requestAnimationFrame(draw);
  }

  function drawGrid(W,H) {
    const stepWorld = pickGridStep();
    const stepPx = stepWorld * view.scale;
    if (stepPx < 30) return;

    const leftWorld = screenToWorld(0,0).x;
    const rightWorld = screenToWorld(W,0).x;
    const topWorld = screenToWorld(0,0).y;
    const botWorld = screenToWorld(0,H).y;

    const x0 = Math.floor(leftWorld/stepWorld)*stepWorld;
    const x1 = Math.ceil(rightWorld/stepWorld)*stepWorld;
    const y0 = Math.floor(botWorld/stepWorld)*stepWorld;
    const y1 = Math.ceil(topWorld/stepWorld)*stepWorld;

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.lineWidth = 1;

    for (let x = x0; x <= x1; x += stepWorld) {
      const sx = worldToScreen(x,0).x;
      ctx.beginPath();
      ctx.moveTo(sx,0);
      ctx.lineTo(sx,H);
      ctx.stroke();
    }
    for (let y = y0; y <= y1; y += stepWorld) {
      const sy = worldToScreen(0,y).y;
      ctx.beginPath();
      ctx.moveTo(0,sy);
      ctx.lineTo(W,sy);
      ctx.stroke();
    }
    ctx.restore();
  }

  function pickGridStep() {
    const targetPx = 80;
    const step = targetPx / Math.max(view.scale, MIN_SCALE);
    const pow = Math.pow(10, Math.floor(Math.log10(step)));
    const candidates = [1,2,5,10].map(m => m*pow);
    let best = candidates[0], bestErr = Math.abs(best - step);
    for (const c of candidates) {
      const err = Math.abs(c - step);
      if (err < bestErr) { bestErr = err; best = c; }
    }
    return best;
  }

  function drawCrosshair(W,H) {
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(mouse.x, 0);
    ctx.lineTo(mouse.x, H);
    ctx.moveTo(0, mouse.y);
    ctx.lineTo(W, mouse.y);
    ctx.stroke();

    const snapId = pickPoint(mouse.x, mouse.y, 10);
    const boxSize = 14;
    ctx.strokeStyle = snapId ? "rgba(255,213,74,0.9)" : "rgba(255,255,255,0.4)";
    ctx.beginPath();
    if (snapId) {
      const p = points.get(snapId);
      const sp = worldToScreen(p.x,p.y);
      ctx.rect(sp.x - boxSize/2, sp.y - boxSize/2, boxSize, boxSize);
    } else {
      ctx.rect(mouse.x - boxSize/2, mouse.y - boxSize/2, boxSize, boxSize);
    }
    ctx.stroke();
    ctx.restore();
  }

  // -------------------------
  // Tool + UI wiring
  // -------------------------
  function setTool(t) {
    tool = t;
    const names = {
      select:"Select/Move",
      addPoint:"Add Point",
      line2pt:"Line: 2 Points",
      lineDB:"Line: Dist/Bearing",
      pointOnLine:"Point on Line",
      pan:"Pan"
    };
    const label = names[t] ?? t;
    hudTool.textContent = label;
    toolHint.textContent = label;

    for (const id of ["toolSelect","toolAddPoint","toolLine2pt","toolLineDB","toolPointOnLine","toolPan"]) {
      $("#"+id).classList.remove("primary");
    }
    const map = {
      select:"toolSelect",
      addPoint:"toolAddPoint",
      line2pt:"toolLine2pt",
      lineDB:"toolLineDB",
      pointOnLine:"toolPointOnLine",
      pan:"toolPan"
    };
    const btn = map[t];
    if (btn) $("#"+btn).classList.add("primary");

    setStatus(`Tool: ${label}`, "");
  }

  $("#toolSelect").addEventListener("click", ()=>setTool("select"));
  $("#toolAddPoint").addEventListener("click", ()=>setTool("addPoint"));
  $("#toolLine2pt").addEventListener("click", ()=>{ construction.startPointId = null; setTool("line2pt"); });
  $("#toolLineDB").addEventListener("click", ()=>setTool("lineDB"));
  $("#toolPointOnLine").addEventListener("click", ()=>setTool("pointOnLine"));
  $("#toolPan").addEventListener("click", ()=>setTool("pan"));

  $("#undoBtn").addEventListener("click", ()=>history.undoAction());
  $("#redoBtn").addEventListener("click", ()=>history.redoAction());

  $("#zoomExtents").addEventListener("click", () => zoomExtents());
  $("#zoomAllAndCenter").addEventListener("click", () => {
    history.push("center");
    const rect = canvas.getBoundingClientRect();
    view.panX = rect.width * 0.5;
    view.panY = rect.height * 0.5;
    setStatus("Centered view on (0,0).", "ok");
  });

  $("#clearSelection").addEventListener("click", () => {
    selectedPointIds = [];
    selectedPointId = null;
    selectedLines = [];
    lastSelectedLineId = null;
    updatePointEditorFromSelection();
    schedulePointsTableRender();
    setStatus("Selection cleared.", "");
  });

  $("#clearConstruction").addEventListener("click", () => {
    construction.startPointId = null;
    construction.startPointId2 = null;
    setStatus("Construction cleared.", "");
  });

  $("#deleteSelected").addEventListener("click", () => doDeleteSelected());

  function doDeleteSelected() {
    if (selectedPointIds.length) {
      history.push("delete points");
      const nums = selectedPointIds.map(id => points.get(id)?.num ?? "?");
      for (const id of [...selectedPointIds].reverse()) deletePoint(id);
      setStatus(`Deleted point(s): ${nums.join(", ")}.`, "warn");
      return;
    }
    if (selectedLines.length) {
      history.push("delete lines");
      const ids = selectedLines.map(s=>s.lineId);
      for (const id of ids) deleteLine(id);
      setStatus(`Deleted ${ids.length} line(s).`, "warn");
      return;
    }
    setStatus("Nothing selected.", "warn");
  }

  $("#focusSelected").addEventListener("click", () => {
    const rect = canvas.getBoundingClientRect();
    const cx = rect.width*0.5, cy = rect.height*0.5;
    if (selectedPointId && points.has(selectedPointId)) {
      history.push("focus point");
      const p = points.get(selectedPointId);
      view.panX = cx - p.x*view.scale;
      view.panY = cy + p.y*view.scale;
      setStatus("Centered on selected point.", "ok");
      return;
    }
    if (lastSelectedLineId && lines.has(lastSelectedLineId)) {
      const ln = lines.get(lastSelectedLineId);
      const a = points.get(ln.a), b = points.get(ln.b);
      if (a && b) {
        history.push("focus line");
        const mx = (a.x+b.x)/2, my=(a.y+b.y)/2;
        view.panX = cx - mx*view.scale;
        view.panY = cy + my*view.scale;
        setStatus("Centered on selected line.", "ok");
        return;
      }
    }
    setStatus("Nothing to center on.", "warn");
  });

  function updatePointEditorFromSelection() {
    const p = selectedPointId ? points.get(selectedPointId) : null;
    if (p) {
      $("#ptNum").value = p.num;
      $("#ptX").value = p.x;
      $("#ptY").value = p.y;
      $("#ptZ").value = p.z;
      $("#ptCode").value = p.code;
      $("#ptNotes").value = p.notes;
    } else {
      $("#ptX").value = "";
      $("#ptY").value = "";
    }
  }

  $("#applyPoint").addEventListener("click", () => {
    if (!selectedPointId || !points.has(selectedPointId)) {
      setStatus("Select a point to apply edits.", "warn");
      return;
    }
    history.push("edit point");
    const p = points.get(selectedPointId);

    const newNum = String($("#ptNum").value || p.num).trim();
    if (newNum !== p.num) {
      if (pointNumberExists(newNum, p.id)) {
        setStatus(`Point number ${newNum} already exists.`, "warn");
        history.undoAction(); // roll back push if invalid
        history.redo.pop();   // keep redo consistent (undoAction pushed redo)
        return;
      }
      p.num = newNum;
    }

    p.x = parseNum($("#ptX").value, p.x);
    p.y = parseNum($("#ptY").value, p.y);
    p.z = parseNum($("#ptZ").value, p.z);
    p.code = String($("#ptCode").value ?? p.code);
    p.notes = String($("#ptNotes").value ?? p.notes);

    schedulePointsTableRender();
    setStatus(`Updated point ${p.num}.`, "ok");
  });

  // -------------------------
  // View: Zoom extents
  // -------------------------
  function zoomExtents() {
    if (points.size === 0) {
      setStatus("No points to zoom to.", "warn");
      return;
    }
    history.push("zoom extents");
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const p of points.values()) {
      minX = Math.min(minX, p.x);
      minY = Math.min(minY, p.y);
      maxX = Math.max(maxX, p.x);
      maxY = Math.max(maxY, p.y);
    }
    const rect = canvas.getBoundingClientRect();
    const pad = 60;
    const w = Math.max(1, rect.width - pad*2);
    const h = Math.max(1, rect.height - pad*2);

    const dx = maxX - minX;
    const dy = maxY - minY;

    const safeDx = dx < EPS ? 1 : dx;
    const safeDy = dy < EPS ? 1 : dy;

    const scaleX = w / safeDx;
    const scaleY = h / safeDy;
    const newScale = clamp(Math.min(scaleX, scaleY) * 0.95, MIN_SCALE, MAX_SCALE);

    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;

    view.scale = newScale;
    view.panX = rect.width * 0.5 - cx * view.scale;
    view.panY = rect.height * 0.5 + cy * view.scale;

    setStatus(`Zoomed to extents.\nX: [${fmt(minX)}, ${fmt(maxX)}]\nY: [${fmt(minY)}, ${fmt(maxY)}]`, "ok");
  }

  // -------------------------
  // Line creation
  // -------------------------
  $("#setStartFromSel").addEventListener("click", () => {
    if (!selectedPointId) {
      setStatus("Select a start point first.", "warn");
      return;
    }
    construction.startPointId = selectedPointId;
    setStatus(`Start point set to ${points.get(selectedPointId)?.num ?? "?"}.`, "ok");
  });

  function resolveDesiredPointNumber(inputValue) {
    const raw = String(inputValue ?? "").trim();
    if (!raw) return nextOpenPointNumber();
    const requested = Number(raw);
    if (!Number.isFinite(requested)) return nextOpenPointNumber();
    const reqInt = Math.max(1, Math.floor(requested));
    if (!pointNumberExists(String(reqInt))) return reqInt;
    return nextOpenPointNumber(reqInt);
  }

  function clearPointNumberField() {
    $("#ptNum").value = "";
  }

  $("#makeLineDB").addEventListener("click", () => {
    const startId = construction.startPointId ?? selectedPointId;
    if (!startId || !points.has(startId)) {
      setStatus("Select a start point (or click 'Use Selected Point as Start').", "warn");
      return;
    }
    const d = parseNum($("#dist").value, NaN);
    const az = bearingToAzimuthRad($("#bearing").value);
    if (!Number.isFinite(d) || d <= 0) { setStatus("Distance must be a positive number.", "warn"); return; }
    if (az == null) { setStatus("Bearing/Azimuth not recognized.", "warn"); return; }

    history.push("line dist/bearing");

    const sp = points.get(startId);
    const dx = Math.sin(az);
    const dy = Math.cos(az);
    const x2 = sp.x + dx*d;
    const y2 = sp.y + dy*d;

    const num = resolveDesiredPointNumber($("#ptNum").value);
    const z = parseNum($("#ptZ").value, 0);
    const code = String($("#ptCode").value || "");
    const notes = String($("#ptNotes").value || "");
    const pid2 = addPoint({ num, x:x2, y:y2, z, code, notes, movable:false });
    const lid = addLine(startId, pid2, false);

    selectedPointIds = [pid2];
    selectedPointId = pid2;
    selectedLines = [{ lineId: lid, grip: "b", t: 1 }];
    lastSelectedLineId = lid;

    updatePointEditorFromSelection();
    clearPointNumberField();
    setStatus(`Created point ${points.get(pid2).num} and line from ${sp.num}.\nAz: ${azimuthRadToQuadrantString(az)}  Dist: ${d}`, "ok");
  });

  $("#lineBetweenSelected").addEventListener("click", () => {
    if (selectedPointIds.length < 2) {
      setStatus("Select at least two points (Shift-click to multi-select).", "warn");
      return;
    }
    const ids = selectedPointIds.filter(id => points.has(id));
    if (ids.length < 2) {
      setStatus("Selected points are invalid.", "warn");
      return;
    }

    history.push("line between points");

    let created = 0;
    let lastLine = null;

    if (ids.length === 2) {
      lastLine = addLine(ids[0], ids[1], false);
      created = 1;
    } else {
      for (let i=0; i<ids.length-1; i++) {
        lastLine = addLine(ids[i], ids[i+1], false);
        created++;
      }
    }

    selectedLines = lastLine ? [{ lineId: lastLine, grip:"b", t: 1 }] : [];
    lastSelectedLineId = lastLine;

    const nums = ids.map(id => points.get(id)?.num ?? "?");
    setStatus(`Created ${created} line(s) using point selection order:\n${nums.join(" → ")}`, "ok");
  });

  // -------------------------
  // Line ops: extend / trim / intersection / overlap
  // -------------------------
  function getTwoSelectedLines() {
    if (selectedLines.length < 2) return null;
    const aSel = selectedLines[selectedLines.length - 2];
    const bSel = selectedLines[selectedLines.length - 1];
    const la = lines.get(aSel.lineId);
    const lb = lines.get(bSel.lineId);
    if (!la || !lb) return null;
    const a1 = points.get(la.a), a2 = points.get(la.b);
    const b1 = points.get(lb.a), b2 = points.get(lb.b);
    if (!a1 || !a2 || !b1 || !b2) return null;
    return { aSel, bSel, la, lb, a1, a2, b1, b2 };
  }

  function intersectionPointDefaults() {
    const z = parseNum($("#ptZ").value, 0);
    let code = String($("#ptCode").value || "").trim();
    const notes = String($("#ptNotes").value || "").trim();
    if (!code) code = "INT";
    return { z, code, notes };
  }

  $("#extendToIntersect").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) { setStatus("Select two lines (Shift-click) to extend.", "warn"); return; }

    const hit = lineLineIntersection(s.a1, s.a2, s.b1, s.b2);
    if (!hit) { setStatus("Lines are parallel/colinear; no unique intersection.", "warn"); return; }

    // Active = last selected line
    const activeSel = s.bSel;
    const ln = lines.get(activeSel.lineId);
    const A = points.get(ln.a), B = points.get(ln.b);
    if (!A || !B) return;

    const t = pointOnLineParam({x:hit.x,y:hit.y}, A, B);

    if (t >= 0 && t <= 1) {
      setStatus("Intersection already lies on the active segment. (Extend does nothing.)", "ok");
      return;
    }

    history.push("extend to intersect (new point)");

    // Create NEW point at intersection (do not move existing endpoint point)
    const num = resolveDesiredPointNumber($("#ptNum").value);
    const { z, code, notes } = intersectionPointDefaults();
    const pidNew = addPoint({ num, x: hit.x, y: hit.y, z, code, notes, movable:false });

    // If t<0, extension is beyond A-end -> re-end A at new point (A becomes interior, unchanged)
    // If t>1, extension is beyond B-end -> re-end B at new point
    if (t < 0) ln.a = pidNew;
    else ln.b = pidNew;

    // keep line's movable flag as-is
    // Selection: select new point + active line
    selectedPointIds = [pidNew];
    selectedPointId = pidNew;
    selectedLines = [{ lineId: ln.id, grip: (t < 0 ? "a" : "b"), t: clamp(t,0,1) }];
    lastSelectedLineId = ln.id;
    updatePointEditorFromSelection();
    clearPointNumberField();

    setStatus(
      `Extended active line to intersection WITHOUT moving the original endpoint.\n` +
      `Created point ${points.get(pidNew).num} at (${fmt(hit.x)}, ${fmt(hit.y)}).`,
      "ok"
    );
  });

  $("#trimToIntersect").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) { setStatus("Select two lines (Shift-click) to trim.", "warn"); return; }
    const hit = lineLineIntersection(s.a1, s.a2, s.b1, s.b2);
    if (!hit) { setStatus("Lines are parallel/colinear; no unique intersection.", "warn"); return; }

    history.push("trim to intersect");

    // Trim uses grip on ACTIVE line (moves that endpoint)
    const active = s.bSel;
    const ln = lines.get(active.lineId);
    const gripPid = (active.grip === "a") ? ln.a : ln.b;
    const gp = points.get(gripPid);
    gp.x = hit.x; gp.y = hit.y;

    schedulePointsTableRender();
    setStatus(`Trimmed active line (grip ${active.grip.toUpperCase()}) to intersection at (${fmt(hit.x)}, ${fmt(hit.y)}).`, "ok");
  });

  $("#pointAtIntersection").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) { setStatus("Select two lines (Shift-click) to create an intersection point.", "warn"); return; }
    const hit = lineLineIntersection(s.a1, s.a2, s.b1, s.b2);
    if (!hit) { setStatus("Lines are parallel/colinear; no unique intersection.", "warn"); return; }

    history.push("create point at intersection");

    const num = resolveDesiredPointNumber($("#ptNum").value);
    const z = parseNum($("#ptZ").value, 0);
    const code = String($("#ptCode").value || "");
    const notes = String($("#ptNotes").value || "");
    const pid = addPoint({ num, x: hit.x, y: hit.y, z, code, notes, movable:false });

    selectedPointIds = [pid];
    selectedPointId = pid;
    selectedLines = [];
    lastSelectedLineId = null;
    updatePointEditorFromSelection();
    clearPointNumberField();

    setStatus(`Created point ${points.get(pid).num} at intersection (${fmt(hit.x)}, ${fmt(hit.y)}).`, "ok");
  });

  $("#trimOverlap").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) { setStatus("Select two colinear overlapping lines (Shift-click).", "warn"); return; }

    const ov = isColinearOverlap(s.a1,s.a2,s.b1,s.b2);
    if (!ov) { setStatus("No colinear overlap detected (or lines not colinear).", "warn"); return; }

    history.push("trim overlap");

    const active = s.bSel;
    const ln = lines.get(active.lineId);
    const pA = points.get(ln.a), pB = points.get(ln.b);
    if (!pA || !pB) return;

    const proj = (p)=> ov.useX ? p.x : p.y;

    const grip = active.grip;
    const gPid = (grip === "a") ? ln.a : ln.b;
    const oPid = (grip === "a") ? ln.b : ln.a;
    const gp = points.get(gPid);
    const op = points.get(oPid);

    const gVal = proj(gp);
    const candidates = [ov.oMin, ov.oMax];

    let best = candidates[0];
    let bestD = Math.abs(gVal - best);
    for (const c of candidates.slice(1)) {
      const d = Math.abs(gVal - c);
      if (d < bestD) { bestD = d; best = c; }
    }

    const denom = (ov.useX ? (op.x - gp.x) : (op.y - gp.y));
    if (Math.abs(denom) < EPS) {
      setStatus("Cannot trim overlap (degenerate line).", "warn");
      return;
    }
    const t = (best - (ov.useX ? gp.x : gp.y)) / denom;
    gp.x = gp.x + t*(op.x - gp.x);
    gp.y = gp.y + t*(op.y - gp.y);

    schedulePointsTableRender();
    setStatus("Trimmed overlap on active line at overlap boundary.", "ok");
  });

  // -------------------------
  // Point on line
  // -------------------------
  $("#makePointOnLine").addEventListener("click", () => {
    if (!lastSelectedLineId || !lines.has(lastSelectedLineId)) {
      setStatus("Select a line first.", "warn");
      return;
    }
    const ln = lines.get(lastSelectedLineId);
    const pa = points.get(ln.a), pb = points.get(ln.b);
    if (!pa || !pb) return;

    const station = parseNum($("#station").value, NaN);
    const offset = parseNum($("#offset").value, 0);
    if (!Number.isFinite(station)) { setStatus("Station must be a number.", "warn"); return; }

    const from = $("#stationFrom").value;
    const A = (from === "a") ? pa : pb;
    const B = (from === "a") ? pb : pa;

    const vx = B.x - A.x, vy = B.y - A.y;
    const L = Math.hypot(vx,vy);
    if (L < EPS) { setStatus("Line is too short.", "warn"); return; }

    history.push("point on line");

    const t = station / L;
    const x = A.x + vx * t;
    const y = A.y + vy * t;

    const nx = -vy / L;
    const ny =  vx / L;

    const x2 = x + nx * offset;
    const y2 = y + ny * offset;

    const num = resolveDesiredPointNumber($("#ptNum").value);
    const z = parseNum($("#ptZ").value, 0);
    const code = String($("#ptCode").value || "");
    const notes = String($("#ptNotes").value || "");
    const pid = addPoint({ num, x:x2, y:y2, z, code, notes, movable:false });

    selectedPointIds = [pid];
    selectedPointId = pid;
    selectedLines = [];
    lastSelectedLineId = null;
    updatePointEditorFromSelection();
    clearPointNumberField();

    setStatus(`Created point ${points.get(pid).num} on line at station ${station} offset ${offset}.`, "ok");
  });

  $("#swapLineEnds").addEventListener("click", () => {
    if (!lastSelectedLineId || !lines.has(lastSelectedLineId)) {
      setStatus("Select a line first.", "warn");
      return;
    }
    history.push("swap line ends");
    const ln = lines.get(lastSelectedLineId);
    const tmp = ln.a; ln.a = ln.b; ln.b = tmp;
    setStatus("Swapped line ends A ↔ B.", "ok");
  });

  // -------------------------
  // CSV import / export
  // -------------------------
  function parseCSV(text) {
    const rows = [];
    let i=0, field="", row=[], inQuotes=false;

    const pushField = () => { row.push(field); field=""; };
    const pushRow = () => { rows.push(row); row=[]; };

    while (i < text.length) {
      const c = text[i];
      if (inQuotes) {
        if (c === '"') {
          if (text[i+1] === '"') { field += '"'; i+=2; continue; }
          inQuotes = false; i++; continue;
        } else {
          field += c; i++; continue;
        }
      } else {
        if (c === '"') { inQuotes = true; i++; continue; }
        if (c === ',') { pushField(); i++; continue; }
        if (c === '\n') { pushField(); pushRow(); i++; continue; }
        if (c === '\r') { i++; continue; }
        field += c; i++; continue;
      }
    }
    pushField();
    pushRow();
    if (rows.length && rows[rows.length-1].every(v => String(v).trim()==="")) rows.pop();
    return rows;
  }

  function normalizeHeader(h) {
    return String(h||"").trim().toLowerCase().replace(/\s+/g,"");
  }

  $("#csvIn").addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const text = await f.text();
    const rows = parseCSV(text);
    if (!rows.length) { setStatus("CSV appears empty.", "warn"); return; }

    history.push("csv import");

    let startRow = 0;
    let idx = { num:0, x:1, y:2, z:3, code:4, notes:5 };
    const h = rows[0].map(normalizeHeader);
    const headerLikely = h.includes("number") || h.includes("num") || h.includes("x") || h.includes("y");
    if (headerLikely) {
      startRow = 1;
      const map = new Map(h.map((v,i)=>[v,i]));
      const pick = (...names)=> {
        for (const n of names) if (map.has(n)) return map.get(n);
        return null;
      };
      idx.num = pick("number","num","pt","point","pointnumber") ?? 0;
      idx.x = pick("x","e","east","easting") ?? 1;
      idx.y = pick("y","n","north","northing") ?? 2;
      idx.z = pick("z","elev","elevation") ?? 3;
      idx.code = pick("code","desc","description") ?? 4;
      idx.notes = pick("notes","note","comments","comment") ?? 5;
    }

    const mode = $("#importMode").value;
    const byNum = new Map();
    for (const p of points.values()) byNum.set(String(p.num), p.id);

    let added=0, updated=0, skipped=0, renamed=0;

    for (let r = startRow; r < rows.length; r++) {
      const row = rows[r];
      const numRaw = (row[idx.num] ?? "").toString().trim();
      const xRaw = row[idx.x];
      const yRaw = row[idx.y];
      if (!numRaw || xRaw==null || yRaw==null) { skipped++; continue; }

      const x = Number(String(xRaw).trim());
      const y = Number(String(yRaw).trim());
      if (!Number.isFinite(x) || !Number.isFinite(y)) { skipped++; continue; }

      const z = parseNum(row[idx.z], 0);
      const code = String(row[idx.code] ?? "");
      const notes = String(row[idx.notes] ?? "");

      let num = numRaw;

      if (byNum.has(num)) {
        if (mode === "merge") {
          const pid = byNum.get(num);
          const p = points.get(pid);
          p.x = x; p.y = y; p.z = z; p.code = code; p.notes = notes;
          updated++;
          continue;
        }
        if (mode === "skip") {
          skipped++;
          continue;
        }
        if (mode === "rename") {
          const open = nextOpenPointNumber(1);
          num = String(open);
          renamed++;
        }
      }

      const pid = addPoint({ num, x, y, z, code, notes, movable:false });
      byNum.set(String(num), pid);
      added++;
    }

    setStatus(`CSV import done.
Added: ${added}
Updated: ${updated}
Renamed: ${renamed}
Skipped: ${skipped}`, "ok");

    $("#csvIn").value = "";
    schedulePointsTableRender();
    if ($("#autoZoomAfterImport").checked) zoomExtents();
  });

  $("#exportCsv").addEventListener("click", () => {
    const rows = [];
    rows.push(["number","x","y","z","code","notes"]);
    const sorted = Array.from(points.values()).sort((a,b)=>Number(a.num)-Number(b.num));
    for (const p of sorted) {
      rows.push([p.num, p.x, p.y, p.z, p.code, p.notes].map(v => csvEscape(v)));
    }
    const csv = rows.map(r=>r.join(",")).join("\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "points.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    setStatus("Exported points.csv", "ok");
  });

  function csvEscape(v) {
    const s = String(v ?? "");
    if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  }

  // -------------------------
  // Points List (table) — inline editing
  // -------------------------
  let pointsSortMode = "num";
  let pointsTableDirty = true;
  let pointsTableRaf = null;

  function schedulePointsTableRender() {
    pointsTableDirty = true;
    if (pointsTableRaf) return;
    pointsTableRaf = requestAnimationFrame(() => {
      pointsTableRaf = null;
      if (pointsTableDirty) renderPointsTable();
      pointsTableDirty = false;
    });
  }

  function getFilteredSortedPoints() {
    const filter = String($("#ptFilter").value || "").trim().toLowerCase();
    let arr = Array.from(points.values());

    if (filter) {
      arr = arr.filter(p => {
        const hay = `${p.num} ${p.code} ${p.notes}`.toLowerCase();
        return hay.includes(filter);
      });
    }

    if (pointsSortMode === "num") arr.sort((a,b)=> (Number(a.num)||0) - (Number(b.num)||0));
    else if (pointsSortMode === "id") arr.sort((a,b)=>a.id-b.id);
    else if (pointsSortMode === "code") arr.sort((a,b)=>String(a.code).localeCompare(String(b.code)));
    return arr;
  }

  function renderPointsTable() {
    const tbody = $("#pointsTbody");
    const frag = document.createDocumentFragment();
    tbody.innerHTML = "";

    const arr = getFilteredSortedPoints();
    for (const p of arr) {
      const tr = document.createElement("tr");
      if (selectedPointIds.includes(p.id)) tr.classList.add("sel");

      const cellInput = (value, field) => {
        const td = document.createElement("td");
        const inp = document.createElement("input");
        inp.className = "cellInput";
        inp.value = value;
        inp.dataset.pid = p.id;
        inp.dataset.field = field;
        inp.addEventListener("keydown", (e) => e.stopPropagation());
        inp.addEventListener("input", onPointCellInput);
        td.appendChild(inp);
        return { td, inp };
      };

      const numCell = cellInput(p.num, "num");
      const xCell = cellInput(p.x, "x");
      const yCell = cellInput(p.y, "y");
      const zCell = cellInput(p.z, "z");
      const codeCell = cellInput(p.code, "code");
      const notesCell = cellInput(p.notes, "notes");

      const tdAct = document.createElement("td");
      tdAct.style.whiteSpace = "nowrap";

      const btnSel = document.createElement("button");
      btnSel.className = "cellBtn";
      btnSel.textContent = "Select";
      btnSel.addEventListener("click", (e) => {
        e.preventDefault(); e.stopPropagation();
        selectedPointIds = [p.id];
        selectedPointId = p.id;
        selectedLines = [];
        lastSelectedLineId = null;
        updatePointEditorFromSelection();
        schedulePointsTableRender();
        setStatus(`Selected point ${p.num}.`, "ok");
      });

      const btnMov = document.createElement("button");
      btnMov.className = "cellBtn";
      btnMov.style.marginLeft = "6px";
      btnMov.textContent = p.movable ? "Lock" : "Unlock";
      btnMov.addEventListener("click", (e) => {
        e.preventDefault(); e.stopPropagation();
        history.push("toggle point movable");
        p.movable = !p.movable;
        schedulePointsTableRender();
        setStatus(`Point ${p.num} is now ${p.movable ? "MOVABLE" : "LOCKED"}.`, "ok");
      });

      const btnDel = document.createElement("button");
      btnDel.className = "cellBtn danger";
      btnDel.style.marginLeft = "6px";
      btnDel.textContent = "Delete";
      btnDel.addEventListener("click", (e) => {
        e.preventDefault(); e.stopPropagation();
        history.push("delete point");
        deletePoint(p.id);
        setStatus(`Deleted point ${p.num}.`, "warn");
      });

      tdAct.appendChild(btnSel);
      tdAct.appendChild(btnMov);
      tdAct.appendChild(btnDel);

      tr.appendChild(numCell.td);
      tr.appendChild(xCell.td);
      tr.appendChild(yCell.td);
      tr.appendChild(zCell.td);
      tr.appendChild(codeCell.td);
      tr.appendChild(notesCell.td);
      tr.appendChild(tdAct);

      frag.appendChild(tr);

      if (pointNumberExists(numCell.inp.value, p.id)) numCell.inp.classList.add("bad");
    }

    tbody.appendChild(frag);
    updateSelectionHUD();
  }

  function onPointCellInput(e) {
    const inp = e.target;
    const pid = Number(inp.dataset.pid);
    const field = inp.dataset.field;
    const p = points.get(pid);
    if (!p) return;

    // Snapshot once at first change in a focus session
    if (!inp._historyPushed) {
      history.push("edit point table");
      inp._historyPushed = true;
      setTimeout(() => { inp._historyPushed = false; }, 0);
    }

    if (field === "num") {
      const raw = String(inp.value).trim();
      if (!raw || pointNumberExists(raw, p.id)) { inp.classList.add("bad"); return; }
      inp.classList.remove("bad");
      p.num = raw;
      if (selectedPointId === pid) $("#ptNum").value = raw;
      return;
    }

    if (field === "x" || field === "y" || field === "z") {
      const val = Number(String(inp.value).trim());
      if (!Number.isFinite(val)) { inp.classList.add("bad"); return; }
      inp.classList.remove("bad");
      p[field] = val;
      if (selectedPointId === pid) {
        if (field === "x") $("#ptX").value = val;
        if (field === "y") $("#ptY").value = val;
        if (field === "z") $("#ptZ").value = val;
      }
      return;
    }

    if (field === "code" || field === "notes") {
      inp.classList.remove("bad");
      p[field] = String(inp.value);
      if (selectedPointId === pid) {
        if (field === "code") $("#ptCode").value = p.code;
        if (field === "notes") $("#ptNotes").value = p.notes;
      }
      return;
    }
  }

  $("#ptFilter").addEventListener("input", () => schedulePointsTableRender());
  $("#refreshPoints").addEventListener("click", () => schedulePointsTableRender());
  $("#sortPoints").addEventListener("click", () => {
    pointsSortMode = (pointsSortMode === "num") ? "code" : (pointsSortMode === "code" ? "id" : "num");
    $("#sortPoints").textContent = `Sort: ${pointsSortMode === "num" ? "Num" : (pointsSortMode === "code" ? "Code" : "ID")}`;
    schedulePointsTableRender();
  });

  // -------------------------
  // Canvas interaction
  // -------------------------
  function updateMouseFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
    const w = screenToWorld(mouse.x, mouse.y);
    mouse.wx = w.x;
    mouse.wy = w.y;
  }

  function beginDrag(obj) {
    mouse.drag = true;
    mouse.dragObj = obj;
    mouse.dragStartX = mouse.x;
    mouse.dragStartY = mouse.y;
    mouse.dragStartPanX = view.panX;
    mouse.dragStartPanY = view.panY;
    mouse.dragStartWorldX = mouse.wx;
    mouse.dragStartWorldY = mouse.wy;
  }

  function endDrag() {
    mouse.drag = false;
    mouse.dragObj = null;
  }

  function toolIsPan() {
    return tool === "pan" || keys.space || mouse.button === 1;
  }

  const keys = { space:false, shift:false };

  window.addEventListener("keydown", (e) => {
    const typing = isEditableTarget(e.target);

    if (e.code === "Space") {
      keys.space = true;
      if (!typing) e.preventDefault();
    }
    if (e.key === "Shift") keys.shift = true;

    if (!typing && (e.key === "Delete")) {
      e.preventDefault();
      doDeleteSelected();
    }

    // Undo/Redo
    if (!typing && (e.ctrlKey || e.metaKey) && !e.altKey) {
      const key = e.key.toLowerCase();
      if (key === "z") {
        e.preventDefault();
        if (e.shiftKey) history.redoAction();
        else history.undoAction();
      } else if (key === "y") {
        e.preventDefault();
        history.redoAction();
      }
    }
  });

  window.addEventListener("keyup", (e) => {
    if (e.code === "Space") keys.space = false;
    if (e.key === "Shift") keys.shift = false;
  });

  // Double-click toggles movable on a point/line
  canvas.addEventListener("dblclick", (e) => {
    updateMouseFromEvent(e);
    const pid = pickPoint(mouse.x, mouse.y, 10);
    const lpick = pid ? null : pickLine(mouse.x, mouse.y, 8);

    if (pid) {
      history.push("toggle point movable");
      const p = points.get(pid);
      p.movable = !p.movable;
      setStatus(`Point ${p.num} is now ${p.movable ? "MOVABLE (drag enabled)" : "LOCKED (drag disabled)"}.`, "ok");
      schedulePointsTableRender();
      return;
    }
    if (lpick) {
      history.push("toggle line movable");
      const ln = lines.get(lpick.lineId);
      ln.movable = !ln.movable;
      setStatus(`Line ${ln.id} is now ${ln.movable ? "MOVABLE (drag enabled)" : "LOCKED (drag disabled)"}.`, "ok");
      schedulePointsTableRender();
      return;
    }
  });

  canvas.addEventListener("mousedown", (e) => {
    updateMouseFromEvent(e);
    mouse.down = true;
    mouse.button = e.button;

    const additive = e.shiftKey;

    if (toolIsPan()) {
      beginDrag({type:"pan"});
      return;
    }

    const pid = pickPoint(mouse.x, mouse.y, 10);
    const lpick = pid ? null : pickLine(mouse.x, mouse.y, 8);

    if (tool === "select") {
      if (pid) {
        setSelectionFromPick({pointId: pid, additive});
        // Drag only if point is movable
        const p = points.get(pid);
        if (selectedPointId === pid && p?.movable) {
          const marker = serializeState();
          history.push("move point");
          mouse._dragUndoMarker = marker;
          beginDrag({type:"point", id: pid, _moved:false});
        }
        return;
      }
      if (lpick) {
        setSelectionFromPick({linePick: lpick, additive});
        const ln = lines.get(lpick.lineId);
        if (ln?.movable) {
          const marker = serializeState();
          history.push("move line");
          mouse._dragUndoMarker = marker;
          beginDrag({type:"line", id: lpick.lineId, _moved:false});
        }
        return;
      }
      setSelectionFromPick({pointId:null, linePick:null, additive});
      return;
    }

    if (tool === "addPoint") {
      history.push("add point");
      const num = resolveDesiredPointNumber($("#ptNum").value);
      const z = parseNum($("#ptZ").value, 0);
      const code = String($("#ptCode").value || "");
      const notes = String($("#ptNotes").value || "");
      const pidNew = addPoint({ num, x: mouse.wx, y: mouse.wy, z, code, notes, movable:false });

      selectedPointIds = [pidNew];
      selectedPointId = pidNew;
      selectedLines = [];
      lastSelectedLineId = null;
      updatePointEditorFromSelection();
      clearPointNumberField();

      setStatus(`Added point ${points.get(pidNew).num} at (${fmt(mouse.wx)}, ${fmt(mouse.wy)}).`, "ok");
      schedulePointsTableRender();
      return;
    }

    if (tool === "line2pt") {
      if (!construction.startPointId) {
        history.push("line 2pt start");
        if (pid) {
          construction.startPointId = pid;
          setStatus(`Line start set: point ${points.get(pid).num}. Click endpoint (point or empty space).`, "ok");
          return;
        } else {
          const num = nextOpenPointNumber();
          const pidNew = addPoint({ num, x: mouse.wx, y: mouse.wy, z:0, code:"", notes:"", movable:false });
          construction.startPointId = pidNew;
          selectedPointIds = [pidNew];
          selectedPointId = pidNew;
          updatePointEditorFromSelection();
          setStatus(`Created start point ${points.get(pidNew).num}. Click endpoint.`, "ok");
          return;
        }
      } else {
        history.push("line 2pt end");
        let endId = pid;
        if (!endId) {
          const num = nextOpenPointNumber();
          endId = addPoint({ num, x: mouse.wx, y: mouse.wy, z:0, code:"", notes:"", movable:false });
        }
        if (endId === construction.startPointId) {
          setStatus("Endpoint cannot be the same as start point.", "warn");
          return;
        }
        const lid = addLine(construction.startPointId, endId, false);
        selectedLines = [{ lineId: lid, grip:"b", t: 1 }];
        lastSelectedLineId = lid;
        selectedPointIds = [endId];
        selectedPointId = endId;
        construction.startPointId = null;
        updatePointEditorFromSelection();
        setStatus(`Created line to point ${points.get(endId).num}.`, "ok");
        schedulePointsTableRender();
        return;
      }
    }

    if (tool === "lineDB") {
      if (pid) {
        construction.startPointId = pid;
        selectedPointIds = [pid];
        selectedPointId = pid;
        updatePointEditorFromSelection();
        schedulePointsTableRender();
        setStatus(`Start point set: ${points.get(pid).num}. Enter dist/bearing then click "Create Point + Line".`, "ok");
        return;
      }
      setStatus("Select a start point first (click a point).", "warn");
      return;
    }

    if (tool === "pointOnLine") {
      if (lpick) {
        setSelectionFromPick({ linePick: lpick, additive });
        setStatus("Line selected for station/offset. Enter station/offset and click 'Create Point'.", "ok");
        return;
      }
      setStatus("Select a line (click near it).", "warn");
      return;
    }
  });

  canvas.addEventListener("mousemove", (e) => {
    updateMouseFromEvent(e);
    if (!mouse.drag) return;

    if (mouse.dragObj?.type === "pan") {
      const dx = mouse.x - mouse.dragStartX;
      const dy = mouse.y - mouse.dragStartY;
      view.panX = mouse.dragStartPanX + dx;
      view.panY = mouse.dragStartPanY + dy;
      return;
    }

    if (mouse.dragObj?.type === "point") {
      const pid = mouse.dragObj.id;
      const p = points.get(pid);
      if (!p) return;

      if (!mouse.dragObj._orig) mouse.dragObj._orig = { x:p.x, y:p.y };
      p.x = mouse.wx;
      p.y = mouse.wy;

      if (Math.abs(p.x - mouse.dragObj._orig.x) > 1e-12 || Math.abs(p.y - mouse.dragObj._orig.y) > 1e-12) {
        mouse.dragObj._moved = true;
      }

      if (selectedPointId === pid) {
        $("#ptX").value = p.x;
        $("#ptY").value = p.y;
      }
      schedulePointsTableRender();
      return;
    }

    if (mouse.dragObj?.type === "line") {
      const lid = mouse.dragObj.id;
      const ln = lines.get(lid);
      if (!ln) return;
      const a = points.get(ln.a), b = points.get(ln.b);
      if (!a || !b) return;

      const dx = mouse.wx - mouse.dragStartWorldX;
      const dy = mouse.wy - mouse.dragStartWorldY;

      if (!mouse.dragObj._orig) {
        mouse.dragObj._orig = { ax:a.x, ay:a.y, bx:b.x, by:b.y };
      }
      a.x = mouse.dragObj._orig.ax + dx;
      a.y = mouse.dragObj._orig.ay + dy;
      b.x = mouse.dragObj._orig.bx + dx;
      b.y = mouse.dragObj._orig.by + dy;

      if (Math.abs(dx) > 1e-12 || Math.abs(dy) > 1e-12) mouse.dragObj._moved = true;

      schedulePointsTableRender();
      return;
    }
  });

  canvas.addEventListener("mouseup", () => {
    mouse.down = false;
    if (mouse.drag) {
      // If no movement happened, remove the undo entry we pushed
      if (mouse.dragObj && mouse.dragObj.type !== "pan") {
        if (!mouse.dragObj._moved) {
          // last push was the move action
          history.undo.pop();
          updateUndoRedoHUD();
        } else {
          setStatus("Move committed. (Undo available)", "ok");
        }
      }
      endDrag();
      updatePointEditorFromSelection();
      schedulePointsTableRender();
    }
  });
  canvas.addEventListener("mouseleave", () => {
    mouse.down = false;
    endDrag();
  });

  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    updateMouseFromEvent(e);

    const before = screenToWorld(mouse.x, mouse.y);
    const zoomFactor = Math.exp(-e.deltaY * 0.0015);
    const newScale = clamp(view.scale * zoomFactor, MIN_SCALE, MAX_SCALE);
    view.scale = newScale;

    view.panX = mouse.x - before.x * view.scale;
    view.panY = mouse.y + before.y * view.scale;

  }, {passive:false});

  // -------------------------
  // Derived info / tool hint
  // -------------------------
  function updateDerivedSelectionInfo() {
    if (lastSelectedLineId && lines.has(lastSelectedLineId)) {
      const ln = lines.get(lastSelectedLineId);
      const a = points.get(ln.a), b = points.get(ln.b);
      if (a && b) {
        const dx = b.x-a.x, dy=b.y-a.y;
        const L = Math.hypot(dx,dy);
        const az = Math.atan2(dx, dy);
        const brg = azimuthRadToQuadrantString(az);
        const baseName = ({
          select:"Select/Move",
          addPoint:"Add Point",
          line2pt:"Line: 2 Points",
          lineDB:"Line: Dist/Bearing",
          pointOnLine:"Point on Line",
          pan:"Pan"
        })[tool] ?? tool;
        toolHint.textContent = `${baseName} — L=${L.toFixed(3)}  ${brg}`;
        return;
      }
    }
    const names = {
      select:"Select/Move",
      addPoint:"Add Point",
      line2pt:"Line: 2 Points",
      lineDB:"Line: Dist/Bearing",
      pointOnLine:"Point on Line",
      pan:"Pan"
    };
    toolHint.textContent = names[tool] ?? tool;
  }
  setInterval(updateDerivedSelectionInfo, 250);

  // -------------------------
  // Boot
  // -------------------------
  function boot() {
    resize();
    window.addEventListener("resize", resize);
    setTool("select");
    updatePointEditorFromSelection();
    schedulePointsTableRender();
    updateUndoRedoHUD();
    requestAnimationFrame(draw);

    setStatus(
      "Ready.\n" +
      "Changes in this build:\n" +
      "• Extend → Intersect now creates a NEW point at intersection; original endpoint point does not move.\n" +
      "• Drag-move is LOCKED by default; double-click a point/line to toggle MOVABLE.\n" +
      "• Undo/Redo added (Ctrl+Z / Ctrl+Y, buttons).",
      "ok"
    );
  }

  boot();

  // -------------------------
  // (Re)usable: Create point numbers
  // -------------------------
  function resolveDesiredPointNumber(inputValue) {
    const raw = String(inputValue ?? "").trim();
    if (!raw) return nextOpenPointNumber();
    const requested = Number(raw);
    if (!Number.isFinite(requested)) return nextOpenPointNumber();
    const reqInt = Math.max(1, Math.floor(requested));
    if (!pointNumberExists(String(reqInt))) return reqInt;
    return nextOpenPointNumber(reqInt);
  }

})();
</script>
</body>
</html>
