<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LineSmith — Points & Bearings</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
  />
  <style>
    :root{
      --bg:#0b0b0b;
      --panel:#111;
      --panel2:#151515;
      --text:#e8e8e8;
      --muted:#9aa0a6;
      --accent:#ffd54a;
      --line:#ffffff;
      --pt:#ff2b2b;
      --num:#ffffff;
      --code:#39ff79;
      --notes:#3aa3ff;
      --warn:#ff6b6b;
      --ok:#46d36b;
      --border:#2a2a2a;
      --bad:#ff4d4d;
      --overlay: rgba(0,0,0,0.55);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:13px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }
    .app{
      height:100vh;
      display:grid;
      grid-template-columns: 1fr minmax(320px, 440px);
      grid-template-areas:"canvas panel";
    }
    .panel{
      grid-area:panel;
      position:relative;
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border-left:1px solid var(--border);
      padding:12px 12px 10px;
      overflow-y:auto;
      overflow-x:visible;
      z-index:5;
    }
    .app.panelCollapsed{
      grid-template-columns: 1fr 0;
    }
    .app.panelCollapsed .panel{
      border-left:none;
      padding:0;
      overflow:hidden;
      pointer-events:none;
    }
    .panelCollapseHandle{
      position:absolute;
      top:50%;
      left:-14px;
      transform:translateY(-50%);
      width:28px;
      height:64px;
      border:1px solid var(--border);
      border-right:none;
      border-radius:12px 0 0 12px;
      background:#101010;
      color:var(--text);
      font-size:18px;
      line-height:1;
      z-index:8;
      padding:0;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .drawerEdgeExpand{
      position:absolute;
      top:50%;
      right:0;
      transform:translateY(-50%);
      width:30px;
      height:72px;
      border:1px solid var(--border);
      border-right:none;
      border-radius:12px 0 0 12px;
      background:#101010;
      color:var(--text);
      font-size:18px;
      line-height:1;
      z-index:7;
      padding:0;
      display:none;
      align-items:center;
      justify-content:center;
    }
    .app.panelCollapsed .drawerEdgeExpand{ display:flex; }
    .panel h1{
      font-size:14px;
      margin:0 0 10px;
      letter-spacing:.4px;
    }
    .row{ display:flex; gap:8px; align-items:center; }
    .col{ display:flex; flex-direction:column; gap:8px; }
    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .grid3{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; }
    .section{
      border:1px solid var(--border);
      border-radius:10px;
      padding:10px;
      background:#0f0f0f;
      margin-bottom:10px;
    }
    .section .title{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      margin-bottom:8px;
      gap:10px;
    }
    .section .title b{ font-size:12px; }
    .section .title span{ color:var(--muted); font-size:11px; }
    label{
      display:flex;
      flex-direction:column;
      gap:4px;
      color:var(--muted);
      font-size:11px;
    }
    input, select, textarea, button{
      font:inherit;
      color:var(--text);
      background:#0b0b0b;
      border:1px solid var(--border);
      border-radius:8px;
      padding:8px 9px;
      outline:none;
    }
    textarea{ min-height:64px; resize:vertical; }
    input[type="file"]{ padding:6px; }
    button{
      cursor:pointer;
      background:#141414;
      transition:.15s transform ease, .15s background ease, .15s border-color ease;
      user-select:none;
    }
    button:hover{ background:#1a1a1a; border-color:#3a3a3a; }
    button:active{ transform:translateY(1px); }
    button.primary{
      border-color:#5c4b14;
      background:#201a09;
    }
    button.primary:hover{ background:#2a210b; }
    button.danger{
      border-color:#5c1b1b;
      background:#210b0b;
      color:#ffd9d9;
    }
    button.danger:hover{ background:#2b0f0f; }
    button.ok{
      border-color:#1f5c2d;
      background:#0c1f10;
      color:#dbffe5;
    }
    button.ok:hover{ background:#0f2a15; }
    .pill{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding:5px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      color:var(--muted);
      font-size:11px;
      background:#0c0c0c;
      max-width:100%;
    }
    .pill b{ color:var(--text); font-weight:600; }
    .pill .clip{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:260px;
      display:inline-block;
      vertical-align:bottom;
    }
    .hint{
      color:var(--muted);
      font-size:11px;
      margin-top:6px;
    }
    .status{
      border-left:3px solid var(--border);
      padding:8px 10px;
      border-radius:8px;
      background:#0c0c0c;
      color:var(--muted);
      font-size:11px;
      margin-top:8px;
      white-space:pre-wrap;
    }
    .status.warn{ border-left-color:var(--warn); }
    .status.ok{ border-left-color:var(--ok); }
    .inspectorCard{
      margin-top:8px;
      border:1px solid var(--border);
      border-radius:8px;
      padding:8px;
      background:#0c0c0c;
      font-size:11px;
    }
    .inspectorRow{ display:flex; justify-content:space-between; gap:8px; margin-bottom:4px; }
    .inspectorRow:last-child{ margin-bottom:0; }
    .inspectorRow b{ color:var(--text); }
    .inspectorLinks{ display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
    .inspectorLinks a{ color:var(--accent); text-decoration:none; border:1px solid #2a3550; border-radius:999px; padding:3px 8px; font-size:11px; }
    .inspectorLinks a:hover{ background:#182238; }

    .canvasWrap{
      grid-area:canvas;
      position:relative;
      overflow:hidden;
      background:#000;
    }
    .drawerToggle{
      display:none;
      position:absolute;
      top:10px;
      right:10px;
      z-index:7;
      border:1px solid var(--border);
      border-radius:999px;
      padding:8px 12px;
      background:#101010;
      color:var(--text);
    }
    .quickTools{
      position:absolute;
      top:10px;
      left:10px;
      z-index:6;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      max-width:min(100% - 130px, 920px);
      padding:8px;
      border:1px solid var(--border);
      border-radius:12px;
      background:rgba(8,8,8,0.92);
      backdrop-filter:blur(4px);
    }
    .quickToolBtn{
      width:34px;
      height:34px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius:8px;
      padding:0;
      font-size:14px;
    }
    .quickToolBtn.primary{
      border-color:#5c4b14;
      background:#201a09;
      color:#ffe7a0;
    }
    .quickToolBtn i{ pointer-events:none; }
    .quickToolDivider{
      width:1px;
      margin:2px 1px;
      background:var(--border);
    }
    .workflowToast{
      position:absolute;
      top:58px;
      right:10px;
      z-index:6;
      width:min(340px, calc(100% - 20px));
      border:1px solid var(--border);
      border-radius:10px;
      background:rgba(15,15,15,0.94);
      padding:10px;
      box-shadow:0 8px 20px rgba(0,0,0,0.35);
      backdrop-filter:blur(3px);
    }
    .workflowToast.hidden{ display:none; }
    .workflowToastTitle{ font-weight:700; margin-bottom:4px; }
    .workflowToastMessage{ color:var(--muted); font-size:11px; margin-bottom:8px; }
    .workflowToastSteps{ list-style:none; margin:0; padding:0; display:grid; gap:5px; }
    .workflowToastSteps li{
      font-size:11px;
      color:var(--muted);
      border:1px solid #2b2b2b;
      border-radius:7px;
      padding:5px 7px;
    }
    .workflowToastSteps li.active{
      color:#ffe7a0;
      border-color:#5c4b14;
      background:#201a09;
    }
    .workflowToastSteps li.done{
      color:#9fd9ac;
      border-color:#285836;
      background:#102116;
    }
    .quickToolField{
      display:inline-flex;
      flex-direction:row;
      align-items:center;
      gap:6px;
      color:var(--muted);
      font-size:11px;
      border:1px solid var(--border);
      border-radius:8px;
      background:#121212;
      padding:0 8px;
      min-height:34px;
    }
    .quickToolField input[type="checkbox"]{
      margin:0;
      width:14px;
      height:14px;
      padding:0;
      border-radius:4px;
      flex:0 0 auto;
    }
    .quickToolField select{
      border:0;
      background:transparent;
      color:var(--text);
      padding:0;
      min-height:22px;
      min-width:140px;
    }
    .quickToolField select:focus{ outline:none; }
    .mapBackdrop{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      opacity:0;
      transition:opacity .15s ease;
    }
    .mapBackdrop.on{ opacity:1; }
    .mapBackdrop .leaflet-container{
      width:100%;
      height:100%;
      background:#000;
    }
    canvas{
      position:relative;
      z-index:1;
      width:100%;
      height:100%;
      display:block;
      cursor:crosshair;
      touch-action:none;
    }
    .hud{
      position:absolute;
      left:10px;
      bottom:10px;
      z-index:2;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      pointer-events:none;
    }
    .hud .pill{ pointer-events:none; }
    .commandBar{
      position:absolute;
      left:10px;
      right:10px;
      bottom:52px;
      z-index:2;
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px;
      border:1px solid var(--border);
      border-radius:10px;
      background:rgba(10,10,10,0.9);
      backdrop-filter:blur(4px);
    }
    .commandBar input{ flex:1; min-width:220px; background:#070707; }
    .commandBar .hintText{ color:var(--muted); font-size:11px; white-space:nowrap; }

    .kbd{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
      color:var(--muted);
      font-size:11px;
      margin-top:8px;
    }
    .kbd div{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 8px;
      border:1px dashed #2a2a2a;
      border-radius:8px;
      background:#0c0c0c;
    }
    .kbd code{
      color:var(--text);
      background:#111;
      padding:1px 6px;
      border-radius:6px;
      border:1px solid #2a2a2a;
    }
    .mini{ font-size:10px; color:var(--muted); }
    .sep{ height:1px; background:var(--border); margin:8px 0; }
    .inline{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .inline label{
      flex-direction:row;
      align-items:center;
      gap:8px;
      font-size:11px;
      margin:0;
    }
    .inline input[type="checkbox"]{
      width:16px; height:16px; padding:0;
    }

    /* Modal (Points Manager) */
    .modalOverlay{
      position:fixed;
      inset:0;
      background:var(--overlay);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:9999;
      padding:18px;
    }
    .hidden{ display:none !important; }
    .modalWindow{
      position:absolute;
      width:min(1100px, calc(100vw - 36px));
      height:min(640px, calc(100vh - 36px));
      min-width: 720px;
      min-height: 360px;
      background:linear-gradient(180deg,#0f0f0f,#0b0b0b);
      border:1px solid var(--border);
      border-radius:14px;
      box-shadow: 0 20px 80px rgba(0,0,0,0.6);
      overflow:hidden;
      resize:both;
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:#0c0c0c;
      cursor:move;
      user-select:none;
      gap:10px;
    }
    .modalHeader b{ font-size:12px; letter-spacing:.3px; }
    .modalHeader .right{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .modalHeader .right .pill{ pointer-events:none; }
    .modalHeader button{
      cursor:pointer;
      padding:6px 10px;
      border-radius:10px;
      background:#141414;
      border:1px solid #2a2a2a;
    }
    .modalHeader button:hover{ background:#1a1a1a; border-color:#3a3a3a; }
    .modalBody{
      padding:10px;
      height:calc(100% - 44px);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .connectLinesModalWindow{
      position:relative;
      width:min(360px, calc(100vw - 36px));
      height:auto;
      min-width:0;
      min-height:0;
      resize:none;
    }
    .connectLinesModalWindow .modalHeader{ cursor:default; }
    .connectLinesModalBody{
      height:auto;
      overflow:visible;
      flex-direction:row;
      justify-content:flex-end;
    }
    .tableWrap{
      border:1px solid var(--border);
      border-radius:12px;
      overflow:hidden;
      background:#0b0b0b;
      height:100%;
      display:flex;
      flex-direction:column;
      min-height: 0;
    }
    .tableTools{
      display:flex;
      gap:8px;
      padding:8px;
      border-bottom:1px solid var(--border);
      background:#0c0c0c;
      align-items:center;
      flex-wrap:wrap;
    }
    .tableTools input{ flex:1; min-width:220px; }
    table{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    thead th{
      position:sticky;
      top:0;
      background:#0f0f0f;
      border-bottom:1px solid var(--border);
      padding:8px 8px;
      text-align:left;
      color:var(--muted);
      font-weight:600;
      z-index:1;
      white-space:nowrap;
    }
    tbody td{
      border-bottom:1px solid #1a1a1a;
      padding:7px 8px;
      vertical-align:middle;
    }
    tbody tr:hover{ background:#0f0f0f; }
    tbody tr.sel{ outline:1px solid #5c4b14; background:#151006; }
    .cellInput{
      width:100%;
      padding:7px 8px;
      border-radius:10px;
      border:1px solid #2a2a2a;
      background:#0b0b0b;
      color:var(--text);
      font-size:12px;
    }
    .cellInput.bad{
      border-color: var(--bad);
      box-shadow: 0 0 0 1px rgba(255,77,77,0.25) inset;
    }
    .cellBtn{
      padding:7px 10px;
      border-radius:10px;
      border:1px solid #2a2a2a;
      background:#121212;
      color:var(--text);
      font-size:12px;
      cursor:pointer;
      white-space:nowrap;
    }
    .cellBtn:hover{ border-color:#3a3a3a; background:#171717; }
    .cellBtn.danger{
      border-color:#5c1b1b;
      background:#210b0b;
      color:#ffd9d9;
    }
    .cellBtn.danger:hover{ background:#2b0f0f; border-color:#743030; }
    .scrollBody{
      overflow:auto;
      flex:1;
      min-height: 0;
    }

    @media (max-width: 960px) {
      .app{ grid-template-columns:1fr; grid-template-areas:"canvas"; }
      .panel{
        position:fixed;
        top:0;
        right:0;
        height:100vh;
        width:min(88vw, 420px);
        transform:translateX(100%);
        transition:transform .2s ease;
        box-shadow:-18px 0 50px rgba(0,0,0,.45);
      }
      .app.panelCollapsed{
        grid-template-columns:1fr;
      }
      .app.panelCollapsed .panel{
        padding:12px 12px 10px;
      }
      .panelCollapseHandle,
      .drawerEdgeExpand{ display:none !important; }
      .app.drawerOpen .panel{ transform:translateX(0); }
      .drawerToggle{ display:block; }
      .quickTools{ max-width:calc(100% - 20px); }
      .workflowToast{
        top:auto;
        right:8px;
        bottom:110px;
        left:8px;
        width:auto;
      }
      .commandBar{
        left:8px;
        right:8px;
        bottom:58px;
        flex-wrap:wrap;
      }
      .commandBar .hintText{ white-space:normal; }
    }
  </style>
</head>
<body>
<div class="app" id="appShell">
  <div class="panel">
    <button id="panelCollapseHandle" class="panelCollapseHandle" aria-label="Collapse controls drawer" title="Collapse controls drawer">→</button>
    <h1>LineSmith — Points & Bearings</h1>

    <div class="section">
      <div class="title">
        <b>Tool</b>
        <span id="toolHint">Select/Move</span>
      </div>
      <div class="grid2">
        <button id="toolSelect" class="primary">Select / Move</button>
        <button id="toolAddPoint">Add Point</button>
        <button id="toolLine2pt">Line: 2 Points</button>
        <button id="toolLineDB">Line: Dist/Bearing</button>
        <button id="toolPointOnLine">Point on Line</button>
        <button id="toolPan">Pan</button>
      </div>

      <div class="grid2" style="margin-top:8px;">
        <button id="undoBtn">Undo</button>
        <button id="redoBtn">Redo</button>
      </div>

      <div class="grid2" style="margin-top:8px;">
        <button id="zoomExtents" class="ok">Zoom Extents</button>
        <button id="zoomAllAndCenter">Center (0,0)</button>
      </div>

      <div class="hint">
        <b>Locked by default:</b> points/lines won’t drag-move unless you <b>double-click</b> them to toggle “movable”.
        <br><b>Multi-select:</b> hold <b>Shift</b> while clicking.
        <br><b>Window select:</b> Shift+drag in empty space (desktop) or long-press blank space then drag (mobile).
      </div>
      <div class="kbd">
        <div><span>Toggle movable</span><code>DblClick</code></div>
        <div><span>Marquee select</span><code>Drag</code></div>
        <div><span>Add to selection</span><code>Shift</code></div>
        <div><span>Pan while holding</span><code>Space</code></div>
        <div><span>Undo</span><code>Ctrl+Z</code></div>
        <div><span>Redo</span><code>Ctrl+Y</code></div>
        <div><span>Delete selected</span><code>Del</code></div>
        <div><span>Zoom</span><code>Wheel</code></div>
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Project Drawing Saves</b>
        <span>named differential history</span>
      </div>
      <div class="grid2">
        <label style="grid-column:1/-1;">Drawing name
          <input id="drawingName" placeholder="Boundary Base Map" />
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="saveDrawingToProject" class="ok">Save Drawing to Project</button>
        <button id="restoreDrawingVersion">Restore Saved Version…</button>
      </div>
      <div class="hint mini" id="drawingSaveHint">Open LineSmith from an active SurveyFoundry project to enable project-linked drawing saves.</div>
      <div class="hint mini" id="collabStatus">Collaboration: offline</div>
    </div>

    <div class="section">
      <div class="title">
        <b>CSV</b>
        <span>number,x,y,z,code,notes</span>
      </div>
      <label>
        Import points CSV
        <input id="csvIn" type="file" accept=".csv,.txt" />
      </label>
      <div class="row" style="margin-top:8px;">
        <label style="flex:1;">
          On import
          <select id="importMode">
            <option value="merge">Merge by point number (update existing)</option>
            <option value="skip">Skip duplicates</option>
            <option value="rename">Auto-rename duplicates (next open number)</option>
          </select>
        </label>
      </div>

      <!-- ADDED: coordinate order selector (fixes X/Y swap root cause for headerless N,E CSVs) -->
      <div class="row" style="margin-top:8px;">
        <label style="flex:1;">
          Coordinate columns (headerless CSV only)
          <select id="csvCoordOrder">
            <option value="xy">Assume X,Y (Easting,Northing)</option>
            <option value="yx">Assume Y,X (Northing,Easting) — swap on import</option>
          </select>
        </label>
      </div>

      <div class="inline" style="margin-top:8px;">
        <label><input id="autoZoomAfterImport" type="checkbox" checked /> Auto-zoom after import</label>
      </div>

      <!-- ADDED: one-click repair for already imported swapped datasets -->
      <div class="row" style="margin-top:8px;">
        <button id="swapXYAll" class="danger" style="flex:1;">Swap X↔Y for ALL Points</button>
      </div>
      <div class="hint mini">
        If your drawing came in “transposed”, that’s X/Y swapped in the point data (common when a headerless CSV is N,E instead of E,N).
        This button fixes existing points (Undo works). For future imports, set “Coordinate columns” to Y,X.
      </div>

      <div class="row" style="margin-top:8px;">
        <button id="exportCsv" class="ok" style="flex:1;">Export Points CSV</button>
      </div>
      <div class="hint">Header row optional. Extra columns ignored.</div>
    </div>

    <div class="section">
      <div class="title">
        <b>Add / Edit Point</b>
        <span>click canvas in Add Point</span>
      </div>
      <div class="grid2">
        <label>Number (blank = auto)
          <input id="ptNum" placeholder="auto" />
        </label>
        <label>Z
          <input id="ptZ" placeholder="0" />
        </label>
      </div>
      <div class="grid2">
        <label>Code
          <input id="ptCode" placeholder="CODE" />
        </label>
        <label class="mini">Notes/Desc
          <input id="ptNotes" placeholder="notes" />
        </label>
      </div>
      <div class="grid2">
        <label>X
          <input id="ptX" placeholder="(selected)" />
        </label>
        <label>Y
          <input id="ptY" placeholder="(selected)" />
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="applyPoint" class="ok">Apply to Selected Point</button>
        <button id="focusSelected">Center on Selection</button>
      </div>
      <div class="hint">
        Marker: <span style="color:var(--pt)">red X</span> · Number: <span style="color:var(--num)">white</span> · Code: <span style="color:var(--code)">green</span> · Notes: <span style="color:var(--notes)">blue</span>
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Display</b>
        <span>point label visibility</span>
      </div>
      <div class="inline">
        <label><input id="showPointCodes" type="checkbox" checked /> Draw point codes</label>
        <label><input id="showPointNotes" type="checkbox" checked /> Draw point notes</label>
      </div>
      <div class="sep"></div>
      <div class="inline">
        <label><input id="mapLayerEnabled" type="checkbox" /> Show map layer behind canvas</label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <label>Map tiles
          <select id="mapTileType">
            <option value="satellite" selected>Satellite</option>
            <option value="osmStandard">OpenStreetMap Standard</option>
            <option value="osmHumanitarian">OpenStreetMap Humanitarian</option>
            <option value="osmCycle">OpenStreetMap Cycle</option>
          </select>
        </label>
        <label>Map opacity
          <input id="mapOpacity" type="range" min="0" max="100" step="1" value="66" />
          <span class="mini" id="mapOpacityValue">66%</span>
        </label>
      </div>
      <div class="hint mini">Point numbers are always shown. Toggle codes/notes anytime while sketching. Map layer defaults to 66% opacity when enabled.</div>
    </div>

    <div class="section">
      <div class="title">
        <b>Line: Distance / Bearing</b>
        <span>select start point</span>
      </div>
      <div class="grid2">
        <label>Distance
          <input id="dist" placeholder="100.00" />
        </label>
        <label>Bearing / Azimuth
          <input id="bearing" placeholder='N15-15-15W  or  N15.1515W  or  123.45' />
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="setStartFromSel" class="primary">Use Selected Point as Start</button>
        <button id="makeLineDB" class="ok">Create Point + Line</button>
      </div>
      <div class="hint">
        Bearing formats accepted:
        <br>• Quadrant: <b>N15-15-15W</b>, <b>N15.1515W</b>, <b>S12-30E</b>
        <br>• Azimuth degrees from North (clockwise): <b>123.45</b>
      </div>
      <div class="sep"></div>
      <div class="grid2">
        <button id="lineBetweenSelected" class="ok">Line Between Selected Points</button>
        <button id="clearConstruction">Clear Construction</button>
      </div>
      <div class="hint">
        If you have <b>2</b> points selected → one line.
        If you have <b>3+</b> points selected → chain lines in selection order (P1–P2, P2–P3, ...).
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Line Ops</b>
        <span>select lines (Shift for multi)</span>
      </div>
      <div class="grid2">
        <button id="extendToIntersect" class="primary">Extend → Intersect (new point)</button>
        <button id="trimToIntersect">Trim (grip) → Intersect</button>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="pointAtIntersection" class="ok">Create Point @ Intersection</button>
        <button id="trimOverlap">Trim Overlap (colinear)</button>
      </div>
      <div class="hint">
        • <b>Extend → Intersect</b> creates a <b>new point</b> at the intersection and re-ends the active line there (original endpoint point does not move).
        <br>• <b>Trim</b> uses the selected line’s grip (nearest endpoint where you clicked) and shortens by moving that endpoint.
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Point on Line</b>
        <span>select a line</span>
      </div>
      <div class="grid3">
        <label>Station
          <input id="station" placeholder="25.00" />
        </label>
        <label>Offset (+left)
          <input id="offset" placeholder="0.00" />
        </label>
        <label>From
          <select id="stationFrom">
            <option value="a">Line A-end</option>
            <option value="b">Line B-end</option>
          </select>
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="makePointOnLine" class="ok">Create Point</button>
        <button id="swapLineEnds">Swap Line Ends</button>
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Selection</b>
        <span id="selSummary">none</span>
      </div>
      <div class="grid2">
        <button id="deleteSelected" class="danger">Delete Selected</button>
        <button id="clearSelection">Clear Selection</button>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="rotateSelectionReference" class="primary">Rotate Selection (Reference)</button>
      </div>
      <div class="hint mini">Pick base point → reference angle point → target angle point.</div>
      <div id="pointInspector" class="inspectorCard">Select one point to inspect point details.</div>
      <div id="lineInspector" class="inspectorCard">Select one line or two points to inspect bearing + distance.</div>
      <div id="status" class="status">Ready.</div>
    </div>

    <div class="section">
      <div class="title">
        <b>Points Manager</b>
        <span id="pointsCount">0 points</span>
      </div>
      <div class="grid2">
        <button id="openPointsManager" class="primary">Open Points List / Editor</button>
        <button id="closePointsManager" disabled>Close</button>
      </div>
      <div class="hint">
        Opens a resizable modal for wide columns (number, X, Y, Z, code, notes) without squeezing the sidebar.
      </div>
    </div>

  </div>

  <div class="canvasWrap">
    <button id="drawerEdgeExpand" class="drawerEdgeExpand" aria-label="Expand controls drawer" title="Expand controls drawer">←</button>
    <button id="drawerToggle" class="drawerToggle">Tools</button>
    <div id="quickTools" class="quickTools" aria-label="LineSmith quick tools">
      <button id="quickSave" class="quickToolBtn" title="Save Drawing to Project" aria-label="Save Drawing to Project"><i class="fa-solid fa-floppy-disk"></i></button>
      <label class="quickToolField" title="Show map layer behind canvas"><input id="quickMapLayerEnabled" type="checkbox" /> Map</label>
      <div class="quickToolField" title="Map tiles">
        <select id="quickMapTileType" aria-label="Quick Map Tile Type">
          <option value="satellite" selected>Satellite</option>
          <option value="osmStandard">OSM Standard</option>
          <option value="osmHumanitarian">OSM Humanitarian</option>
          <option value="osmCycle">OSM Cycle</option>
        </select>
      </div>
      <label class="quickToolField" title="Toggle point code labels"><input id="quickShowPointCodes" type="checkbox" checked /> Codes</label>
      <label class="quickToolField" title="Toggle point notes labels"><input id="quickShowPointNotes" type="checkbox" checked /> Notes</label>
      <span class="quickToolDivider" aria-hidden="true"></span>
      <button id="quickSelect" class="quickToolBtn primary" title="Select / Move" aria-label="Select / Move"><i class="fa-solid fa-arrow-pointer"></i></button>
      <button id="quickAddPoint" class="quickToolBtn" title="Add Point" aria-label="Add Point"><i class="fa-solid fa-circle-plus"></i></button>
      <button id="quickLineByPoints" class="quickToolBtn" title="Line by Points" aria-label="Line by Points"><i class="fa-solid fa-share-nodes"></i></button>
      <span class="quickToolDivider" aria-hidden="true"></span>
      <button id="quickUndo" class="quickToolBtn" title="Undo" aria-label="Undo"><i class="fa-solid fa-rotate-left"></i></button>
      <button id="quickRedo" class="quickToolBtn" title="Redo" aria-label="Redo"><i class="fa-solid fa-rotate-right"></i></button>
      <button id="quickZoomExtents" class="quickToolBtn" title="Zoom Extents" aria-label="Zoom Extents"><i class="fa-solid fa-expand"></i></button>
      <button id="quickCenter" class="quickToolBtn" title="Center (0,0)" aria-label="Center"><i class="fa-solid fa-crosshairs"></i></button>
      <span class="quickToolDivider" aria-hidden="true"></span>
      <button id="quickExtend" class="quickToolBtn" title="Extend to Intersect" aria-label="Extend"><i class="fa-solid fa-up-right-and-down-left-from-center"></i></button>
      <button id="quickTrimIntersect" class="quickToolBtn" title="Trim to Intersect" aria-label="Trim / Intersect"><i class="fa-solid fa-scissors"></i></button>
      <button id="quickRotateSelection" class="quickToolBtn" title="Rotate Selection (Reference)" aria-label="Rotate Selection"><i class="fa-solid fa-rotate"></i></button>
      <button id="quickPointManager" class="quickToolBtn" title="Open Points Manager" aria-label="Point Manager"><i class="fa-solid fa-list"></i></button>
    </div>
    <div id="mapBackdrop" class="mapBackdrop"><div id="mapLayer"></div></div>
    <canvas id="c"></canvas>
    <div id="workflowToast" class="workflowToast hidden" role="status" aria-live="polite" aria-atomic="true">
      <div id="workflowToastTitle" class="workflowToastTitle"></div>
      <div id="workflowToastMessage" class="workflowToastMessage"></div>
      <ol id="workflowToastSteps" class="workflowToastSteps"></ol>
    </div>
    <div class="commandBar" aria-label="LineSmith command line">
      <input id="commandInput" type="text" placeholder="Command (line, move, rotate, inverse). Example: line 101 205" aria-label="LineSmith command line input" />
      <button id="runCommand" class="primary">Run</button>
      <span class="hintText">LINE p1 p2 · MOVE dx dy · ROTATE · INVERSE p1 p2</span>
    </div>
    <div class="hud">
      <span class="pill"><b>Tool</b> <span id="hudTool">Select/Move</span></span>
      <span class="pill"><b>Mouse</b> <span id="hudMouse">x: 0, y: 0</span></span>
      <span class="pill"><b>Scale</b> <span id="hudZoom">1.00</span></span>
      <span class="pill"><b>Sel</b> <span id="hudSel" class="clip">none</span></span>
      <span class="pill"><b>Undo</b> <span id="hudUndo">0</span></span>
      <span class="pill"><b>Redo</b> <span id="hudRedo">0</span></span>
    </div>
  </div>
</div>

<!-- Points Manager Modal -->
<div id="pointsModal" class="modalOverlay hidden" aria-hidden="true">
  <div id="pointsModalWindow" class="modalWindow">
    <div id="pointsModalHeader" class="modalHeader">
      <b>Points Manager</b>
      <div class="right">
        <span class="pill"><b>Total</b> <span id="modalPointsCount">0</span></span>
        <button id="pointsModalClose" class="cellBtn">Close</button>
      </div>
    </div>

    <div class="modalBody">
      <div class="tableWrap">
        <div class="tableTools">
          <input id="ptFilter" placeholder="Filter: number / code / notes" />
          <button id="refreshPoints" class="cellBtn">Refresh</button>
          <button id="sortPoints" class="cellBtn">Sort: Num</button>
          <span class="pill"><b>Tip</b> <span class="clip">Shift-click + drag window to multi-select</span></span>
        </div>

        <div class="scrollBody">
          <table>
            <thead>
              <tr>
                <th style="width:90px;">#</th>
                <th style="width:140px;">X</th>
                <th style="width:140px;">Y</th>
                <th style="width:110px;">Z</th>
                <th style="width:140px;">Code</th>
                <th>Notes</th>
                <th style="width:240px;">Actions</th>
              </tr>
            </thead>
            <tbody id="pointsTbody"></tbody>
          </table>
        </div>
      </div>

      <div class="hint">
        Edits validate point number uniqueness. Press <b>Esc</b> to close the modal.
      </div>
    </div>
  </div>
</div>

<div id="connectLinesModal" class="modalOverlay hidden" aria-hidden="true">
  <div class="modalWindow connectLinesModalWindow">
    <div class="modalHeader">
      <b>Connect Lines</b>
    </div>
    <div class="modalBody connectLinesModalBody">
      <button id="connectLinesSequential" class="primary">Sequentially</button>
      <button id="connectLinesByDistance">By Distance</button>
    </div>
  </div>
</div>

<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>
<script>
(() => {
  // -------------------------
  // Utilities
  // -------------------------
  const EPS = 1e-9;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist2 = (ax,ay,bx,by)=>{ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };
  const dist = (ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
  const fmt = (n)=> (Number.isFinite(n) ? (Math.abs(n) < 1e6 ? n.toFixed(3) : n.toExponential(6)) : "NaN");
  const POINTFORGE_IMPORT_STORAGE_KEY = "lineSmithPointforgeImport";
  const PROJECT_FILE_STORAGE_PREFIX = "surveyfoundryProjectFile";
  const PROJECT_DRAWING_STORAGE_PREFIX = "surveyfoundryLineSmithDrawing";
  const PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY = "lineSmithProjectBrowserDrawingImport";
  const PROJECT_LAST_DRAWING_STORAGE_PREFIX = "surveyfoundryLastLineSmithDrawing";

  const parseNum = (s, def=0) => {
    const n = Number(String(s).trim());
    return Number.isFinite(n) ? n : def;
  };
  const isEditableTarget = (t) => {
    if (!t) return false;
    const tag = (t.tagName || "").toUpperCase();
    return tag === "INPUT" || tag === "TEXTAREA" || t.isContentEditable || tag === "SELECT";
  };
  const $ = (q)=>document.querySelector(q);

  const queryParams = new URLSearchParams(window.location.search);
  const activeProjectId = queryParams.get("activeProjectId") || "";
  const activeProjectName = queryParams.get("activeProjectName") || "";
  const collabRoomParam = queryParams.get("drawingId") || queryParams.get("collabRoom") || "";
  let activeDrawingStorageKey = "";
  let lastSavedDrawingSnapshot = "";

  const collab = {
    socket: null,
    roomId: "",
    clientId: "",
    color: "#ffffff",
    peers: new Map(),
    remoteCursors: new Map(),
    stateDebounce: null,
    applyingRemoteState: false,
    enabled: false
  };

  function setStatus(msg, kind="") {
    const el = $("#status");
    el.textContent = msg;
    el.className = "status" + (kind ? " " + kind : "");
  }

  const workflowToastState = {
    active: false,
    title: "",
    message: "",
    steps: [],
    currentStepIndex: -1
  };

  const lineIntersectionCommandSession = {
    active: false,
    mode: ""
  };

  function renderWorkflowToast() {
    const root = $("#workflowToast");
    const titleEl = $("#workflowToastTitle");
    const messageEl = $("#workflowToastMessage");
    const stepsEl = $("#workflowToastSteps");
    if (!root || !titleEl || !messageEl || !stepsEl) return;

    if (!workflowToastState.active || !workflowToastState.steps.length) {
      root.classList.add("hidden");
      titleEl.textContent = "";
      messageEl.textContent = "";
      stepsEl.innerHTML = "";
      return;
    }

    root.classList.remove("hidden");
    titleEl.textContent = workflowToastState.title;
    messageEl.textContent = workflowToastState.message;
    stepsEl.innerHTML = "";

    workflowToastState.steps.forEach((step, idx) => {
      const li = document.createElement("li");
      li.textContent = step;
      if (idx < workflowToastState.currentStepIndex) li.classList.add("done");
      else if (idx === workflowToastState.currentStepIndex) li.classList.add("active");
      stepsEl.appendChild(li);
    });
  }

  function hideWorkflowToast() {
    workflowToastState.active = false;
    workflowToastState.title = "";
    workflowToastState.message = "";
    workflowToastState.steps = [];
    workflowToastState.currentStepIndex = -1;
    renderWorkflowToast();
  }

  function showWorkflowToast({ title, message, steps, currentStepIndex }) {
    workflowToastState.active = true;
    workflowToastState.title = String(title || "");
    workflowToastState.message = String(message || "");
    workflowToastState.steps = Array.isArray(steps) ? steps.map((item) => String(item)) : [];
    workflowToastState.currentStepIndex = clamp(Number(currentStepIndex) || 0, 0, Math.max(0, workflowToastState.steps.length - 1));
    renderWorkflowToast();
  }

  function syncLineIntersectionCommandToast() {
    if (!lineIntersectionCommandSession.active) return;
    const selectedCount = Math.min(2, selectedLines.length);
    const isExtend = lineIntersectionCommandSession.mode === "extend";
    const isTrim = lineIntersectionCommandSession.mode === "trim";
    const firstStep = isTrim ? "Select trim boundary line" : "Select first line";
    const secondStep = isTrim ? "Select line to trim (click desired side)" : "Select second line";
    showWorkflowToast({
      title: isExtend ? "Extend to Intersect Workflow" : "Trim to Intersect Workflow",
      message: selectedCount < 2
        ? `${selectedCount === 0 ? firstStep : secondStep} (${selectedCount === 0 ? "click line" : "click next line"}; Shift-click still supports normal multi-select).`
        : "Two lines selected. Running command...",
      steps: [
        firstStep,
        secondStep,
        isExtend ? "Extend active line to intersection" : "Trim active line to intersection"
      ],
      currentStepIndex: selectedCount
    });
  }

  function startLineIntersectionCommand(mode) {
    lineIntersectionCommandSession.active = true;
    lineIntersectionCommandSession.mode = mode;
    setTool("select");
    syncLineIntersectionCommandToast();
    setStatus(`Line ${mode}: select two lines to continue.`, "warn");
  }

  function stopLineIntersectionCommand() {
    lineIntersectionCommandSession.active = false;
    lineIntersectionCommandSession.mode = "";
    syncToolWorkflowToast();
  }

  function deepClone(value) {
    return JSON.parse(JSON.stringify(value));
  }

  function isPlainObject(value) {
    return !!value && typeof value === "object" && !Array.isArray(value);
  }

  function diffState(previous, next) {
    if (Object.is(previous, next)) return undefined;
    if (Array.isArray(previous) && Array.isArray(next)) {
      if (previous.length !== next.length) return deepClone(next);
      const out = [];
      let changed = false;
      for (let i = 0; i < next.length; i += 1) {
        const child = diffState(previous[i], next[i]);
        out[i] = child;
        if (child !== undefined) changed = true;
      }
      return changed ? out : undefined;
    }
    if (isPlainObject(previous) && isPlainObject(next)) {
      const keys = new Set([...Object.keys(previous), ...Object.keys(next)]);
      const out = {};
      let changed = false;
      for (const key of keys) {
        if (!(key in next)) {
          out[key] = { __deleted: true };
          changed = true;
          continue;
        }
        const child = diffState(previous[key], next[key]);
        if (child !== undefined) {
          out[key] = child;
          changed = true;
        }
      }
      return changed ? out : undefined;
    }
    return deepClone(next);
  }

  function applyStateDiff(base, diff) {
    if (diff === undefined) return deepClone(base);
    if (Array.isArray(diff)) {
      const source = Array.isArray(base) ? base : [];
      return diff.map((part, index) => applyStateDiff(source[index], part));
    }
    if (isPlainObject(diff)) {
      if (diff.__deleted) return undefined;
      const source = isPlainObject(base) ? base : {};
      const out = {};
      const keys = new Set([...Object.keys(source), ...Object.keys(diff)]);
      for (const key of keys) {
        if (!(key in diff)) {
          out[key] = deepClone(source[key]);
          continue;
        }
        const merged = applyStateDiff(source[key], diff[key]);
        if (merged !== undefined) out[key] = merged;
      }
      return out;
    }
    return deepClone(diff);
  }

  // -------------------------
  // Bearing parsing
  // -------------------------
  function parseQuadrantAngleDegrees(midRaw) {
    let mid = String(midRaw ?? "").trim();
    if (!mid) return null;

    mid = mid
      .replace(/\s+/g, "-")
      .replace(/DEG|°/gi, "-")
      .replace(/MIN|'/gi, "-")
      .replace(/SEC|"/gi, "-")
      .replace(/:+/g, "-")
      .replace(/[^0-9.+-]+/g, "-")
      .replace(/-+/g, "-")
      .replace(/^-|-$/g, "");

    if (!mid) return null;

    if (!mid.includes("-")) {
      const a = Number(mid);
      if (!Number.isFinite(a)) return null;
      return Math.abs(a);
    }

    const parts = mid.split("-").filter(Boolean);
    if (!parts.length) return null;

    const d = Number(parts[0]);
    const m = parts.length > 1 ? Number(parts[1]) : 0;
    const s = parts.length > 2 ? Number(parts[2]) : 0;
    if (![d,m,s].every(Number.isFinite)) return null;

    const deg = Math.abs(d) + (Math.abs(m)/60) + (Math.abs(s)/3600);
    return deg;
  }

  function bearingToAzimuthRad(input) {
    const raw = String(input ?? "").trim();
    if (!raw) return null;

    // numeric azimuth
    if (/^[+-]?\d+(\.\d+)?$/.test(raw)) {
      const deg = parseFloat(raw);
      return (deg * Math.PI) / 180;
    }

    // quadrant
    const m = raw.trim().toUpperCase().match(/^([NS])\s*(.+?)\s*([EW])$/);
    if (!m) return null;

    const q1 = m[1];
    const q2 = m[3];
    const mid = m[2];

    const angle = parseQuadrantAngleDegrees(mid);
    if (angle == null) return null;

    let azDeg;
    if (q1==="N" && q2==="E") azDeg = angle;
    else if (q1==="S" && q2==="E") azDeg = 180 - angle;
    else if (q1==="S" && q2==="W") azDeg = 180 + angle;
    else if (q1==="N" && q2==="W") azDeg = 360 - angle;
    else return null;

    return (azDeg * Math.PI) / 180;
  }

  function azimuthRadToQuadrantString(az) {
    let deg = (az * 180/Math.PI) % 360;
    if (deg < 0) deg += 360;

    let q1="N", q2="E", ang=deg;
    if (deg >= 0 && deg <= 90) { q1="N"; q2="E"; ang=deg; }
    else if (deg > 90 && deg < 180) { q1="S"; q2="E"; ang=180-deg; }
    else if (deg >= 180 && deg < 270) { q1="S"; q2="W"; ang=deg-180; }
    else { q1="N"; q2="W"; ang=360-deg; }

    const d = Math.floor(ang + 1e-10);
    const mFloat = (ang - d) * 60;
    const m = Math.floor(mFloat + 1e-10);
    const s = (mFloat - m) * 60;
    const sRound = Math.round(s*1000)/1000;
    return `${q1}${d}-${String(m).padStart(2,"0")}-${String(sRound.toFixed(3)).padStart(6,"0")}${q2}`;
  }

  function lineMeasurement(a, b) {
    if (!a || !b) return null;
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const distance = Math.hypot(dx, dy);
    if (!(distance > EPS)) return null;
    const az = Math.atan2(dx, dy);
    return {
      distance,
      bearing: azimuthRadToQuadrantString(az),
      angle: Math.atan2(-(b.y - a.y), b.x - a.x)
    };
  }

  function rectsOverlap(a, b, padding = 4) {
    return !(a.x + a.w + padding <= b.x || b.x + b.w + padding <= a.x || a.y + a.h + padding <= b.y || b.y + b.h + padding <= a.y);
  }

  function rotatedRectAabb(cx, cy, width, height, angle) {
    const hw = width / 2;
    const hh = height / 2;
    const c = Math.cos(angle);
    const ss = Math.sin(angle);
    const pts = [
      { x: -hw, y: -hh },
      { x: hw, y: -hh },
      { x: hw, y: hh },
      { x: -hw, y: hh }
    ].map((p) => ({ x: cx + (p.x * c - p.y * ss), y: cy + (p.x * ss + p.y * c) }));
    const xs = pts.map((p) => p.x);
    const ys = pts.map((p) => p.y);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }

  // -------------------------
  // Geometry helpers
  // -------------------------
  function lineLineIntersection(p1, p2, p3, p4) {
    const x1=p1.x, y1=p1.y, x2=p2.x, y2=p2.y;
    const x3=p3.x, y3=p3.y, x4=p4.x, y4=p4.y;
    const dx12 = x2-x1, dy12=y2-y1;
    const dx34 = x4-x3, dy34=y4-y3;
    const denom = dx12*dy34 - dy12*dx34;
    if (Math.abs(denom) < EPS) return null;
    const dx13 = x3-x1, dy13 = y3-y1;
    const t = (dx13*dy34 - dy13*dx34) / denom;
    const u = (dx13*dy12 - dy13*dx12) / denom;
    return { x: x1 + t*dx12, y: y1 + t*dy12, t, u };
  }

  function pointOnLineParam(p, a, b) {
    const dx = b.x-a.x, dy=b.y-a.y;
    const len2 = dx*dx + dy*dy;
    if (len2 < EPS) return 0;
    return ((p.x-a.x)*dx + (p.y-a.y)*dy) / len2;
  }

  function segmentClosestPoint(p, a, b) {
    const abx = b.x-a.x, aby=b.y-a.y;
    const apx = p.x-a.x, apy=p.y-a.y;
    const ab2 = abx*abx + aby*aby;
    let t = ab2 > EPS ? (apx*abx + apy*aby) / ab2 : 0;
    t = clamp(t, 0, 1);
    return { x: a.x + t*abx, y: a.y + t*aby, t };
  }

  function isColinearOverlap(a1,a2,b1,b2) {
    const ax=a2.x-a1.x, ay=a2.y-a1.y;
    const cross1 = ax*(b1.y-a1.y) - ay*(b1.x-a1.x);
    const cross2 = ax*(b2.y-a1.y) - ay*(b2.x-a1.x);
    if (Math.abs(cross1) > 1e-7 || Math.abs(cross2) > 1e-7) return null;

    const useX = Math.abs(ax) >= Math.abs(ay);
    const proj = (p)=> useX ? p.x : p.y;

    const A0 = proj(a1), A1 = proj(a2);
    const B0 = proj(b1), B1 = proj(b2);

    const aMin = Math.min(A0,A1), aMax=Math.max(A0,A1);
    const bMin = Math.min(B0,B1), bMax=Math.max(B0,B1);
    const oMin = Math.max(aMin,bMin);
    const oMax = Math.min(aMax,bMax);
    if (oMax <= oMin + 1e-9) return null;

    return { useX, oMin, oMax };
  }

  function rectNorm(x0,y0,x1,y1){
    return {
      minX: Math.min(x0,x1),
      maxX: Math.max(x0,x1),
      minY: Math.min(y0,y1),
      maxY: Math.max(y0,y1),
      w: Math.abs(x1-x0),
      h: Math.abs(y1-y0),
      cx: (x0+x1)/2,
      cy: (y0+y1)/2
    };
  }
  function pointInRect(p, r){
    return p.x >= r.minX && p.x <= r.maxX && p.y >= r.minY && p.y <= r.maxY;
  }
  function orient(a,b,c){
    return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
  }
  function onSeg(a,b,c){
    return Math.min(a.x,b.x)-EPS <= c.x && c.x <= Math.max(a.x,b.x)+EPS &&
           Math.min(a.y,b.y)-EPS <= c.y && c.y <= Math.max(a.y,b.y)+EPS;
  }
  function segIntersect(a,b,c,d){
    const o1 = orient(a,b,c);
    const o2 = orient(a,b,d);
    const o3 = orient(c,d,a);
    const o4 = orient(c,d,b);

    if ((o1>0 && o2<0 || o1<0 && o2>0) && (o3>0 && o4<0 || o3<0 && o4>0)) return true;
    if (Math.abs(o1) < EPS && onSeg(a,b,c)) return true;
    if (Math.abs(o2) < EPS && onSeg(a,b,d)) return true;
    if (Math.abs(o3) < EPS && onSeg(c,d,a)) return true;
    if (Math.abs(o4) < EPS && onSeg(c,d,b)) return true;
    return false;
  }
  function segIntersectsRect(p1,p2,r){
    if (pointInRect(p1,r) || pointInRect(p2,r)) return true;
    const topL = {x:r.minX,y:r.minY}, topR = {x:r.maxX,y:r.minY};
    const botL = {x:r.minX,y:r.maxY}, botR = {x:r.maxX,y:r.maxY};
    // Edges (note: in screen coords, y grows down, but intersection math is unaffected)
    if (segIntersect(p1,p2, topL, topR)) return true;
    if (segIntersect(p1,p2, topR, botR)) return true;
    if (segIntersect(p1,p2, botR, botL)) return true;
    if (segIntersect(p1,p2, botL, topL)) return true;
    return false;
  }

  // -------------------------
  // DOM
  // -------------------------
  const canvas = $("#c");
  const ctx = canvas.getContext("2d");
  const appShell = $("#appShell");
  const drawerToggle = $("#drawerToggle");
  const panelCollapseHandle = $("#panelCollapseHandle");
  const drawerEdgeExpand = $("#drawerEdgeExpand");
  const mapBackdrop = $("#mapBackdrop");
  const mapEnabledInput = $("#mapLayerEnabled");
  const mapTileTypeInput = $("#mapTileType");
  const mapOpacityInput = $("#mapOpacity");
  const mapOpacityValue = $("#mapOpacityValue");
  const quickMapEnabledInput = $("#quickMapLayerEnabled");
  const quickMapTileTypeInput = $("#quickMapTileType");
  const showPointCodesInput = $("#showPointCodes");
  const showPointNotesInput = $("#showPointNotes");
  const quickShowPointCodesInput = $("#quickShowPointCodes");
  const quickShowPointNotesInput = $("#quickShowPointNotes");

  const hudTool = $("#hudTool");
  const hudMouse = $("#hudMouse");
  const hudZoom = $("#hudZoom");
  const hudSel = $("#hudSel");
  const hudUndo = $("#hudUndo");
  const hudRedo = $("#hudRedo");
  const selSummary = $("#selSummary");
  const lineInspector = $("#lineInspector");
  const pointInspector = $("#pointInspector");
  const toolHint = $("#toolHint");
  const commandInput = $("#commandInput");
  const runCommandBtn = $("#runCommand");

  const pointsCount = $("#pointsCount");
  const modal = $("#pointsModal");
  const modalWindow = $("#pointsModalWindow");
  const modalHeader = $("#pointsModalHeader");
  const modalClose = $("#pointsModalClose");
  const modalPointsCount = $("#modalPointsCount");
  const openPointsManagerBtn = $("#openPointsManager");
  const closePointsManagerBtn = $("#closePointsManager");
  const connectLinesModal = $("#connectLinesModal");
  const connectLinesSequentialBtn = $("#connectLinesSequential");
  const connectLinesByDistanceBtn = $("#connectLinesByDistance");

  // -------------------------
  // Model
  // -------------------------
  let nextId = 1;
  const points = new Map(); // id -> {id,num,x,y,z,code,notes,movable}
  const lines = new Map();  // id -> {id,a,b,movable}

  // Selection
  let selectedPointId = null;   // primary point
  let selectedPointIds = [];    // multi points (ordered)
  let selectedLines = [];       // [{ lineId, grip, t }]
  let lastSelectedLineId = null;
  const rotateSelectionSession = {
    active: false,
    step: 0,
    basePoint: null,
    fromPoint: null,
    awaitingSelection: false
  };
  let lastUnlockedEntity = null; // { type: "point"|"line", id }
  let pendingEscapeLockEntity = null;

  // Construction
  let tool = "select";
  let construction = { startPointId: null };

  // View transform
  const MIN_SCALE = 0.0005;
  const MAX_SCALE = 5000;
  const view = { scale: 20, panX: 0, panY: 0 };
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  // Mouse
  const mouse = {
    x: 0, y: 0,
    wx: 0, wy: 0,
    down: false,
    button: 0,
    drag: false,
    dragStartX: 0, dragStartY: 0,
    dragStartPanX: 0, dragStartPanY: 0,
    dragStartWorldX: 0, dragStartWorldY: 0,
    dragObj: null
  };

  const mobileInteraction = {
    longPressMs: 450,
    moveTolerance: 10,
    pointerDown: false,
    moved: false,
    activePointerId: null,
    downX: 0,
    downY: 0,
    longPressTimer: null,
    suppressClick: false
  };

  const touchGesture = {
    mode: null,
    points: new Map(),
    startDistance: 0,
    startScale: 0,
    startPanX: 0,
    startPanY: 0,
    startCenter: null,
    boxSelectActive: false
  };

  const labelVisibility = {
    codes: true,
    notes: true
  };

  const mapLayerState = {
    enabled: false,
    tileType: "satellite",
    opacity: 0.66
  };
  let mapViewportSignature = "";

  const FEET_TO_METERS = 0.3048006096012192;
  let mapGeoreference = null;
  const ADA_CPF_PDF_BASE = "https://gisprod.adacounty.id.gov/apps/acdscpf/CpfPdfs/";

  const MAP_TILESETS = {
    satellite: {
      url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
      options: {
        maxZoom: 20,
        attribution: "Tiles &copy; Esri"
      }
    },
    osmStandard: {
      url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      options: {
        maxZoom: 20,
        attribution: "&copy; OpenStreetMap contributors"
      }
    },
    osmHumanitarian: {
      url: "https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png",
      options: {
        maxZoom: 20,
        attribution: "&copy; OpenStreetMap contributors, Tiles style by HOT"
      }
    },
    osmCycle: {
      url: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
      options: {
        maxZoom: 20,
        attribution: "&copy; OpenStreetMap contributors, Map style: OpenTopoMap"
      }
    }
  };

  let mapInstance = null;
  let mapTileLayer = null;

  function isMovable(value) {
    return value === true;
  }

  function scaleToLeafletZoom(scale) {
    if (!Number.isFinite(scale) || scale <= 0) return 2;
    const zoom = Math.log2((scale * 360) / 256);
    return clamp(zoom, 1, 22);
  }

  function clampLatLng(lat, lng) {
    return {
      lat: clamp(lat, -85, 85),
      lng: clamp(lng, -180, 180)
    };
  }

  function worldToApproxLatLng(x, y) {
    return clampLatLng(y, x);
  }

  function solveLinear3x3(matrix, vector) {
    const m = matrix.map((row, rowIdx) => [...row, vector[rowIdx]]);
    const n = 3;
    for (let col = 0; col < n; col++) {
      let pivot = col;
      for (let row = col + 1; row < n; row++) {
        if (Math.abs(m[row][col]) > Math.abs(m[pivot][col])) pivot = row;
      }
      if (Math.abs(m[pivot][col]) < 1e-12) return null;
      if (pivot !== col) {
        const tmp = m[col];
        m[col] = m[pivot];
        m[pivot] = tmp;
      }
      const div = m[col][col];
      for (let k = col; k <= n; k++) m[col][k] /= div;
      for (let row = 0; row < n; row++) {
        if (row === col) continue;
        const factor = m[row][col];
        for (let k = col; k <= n; k++) m[row][k] -= factor * m[col][k];
      }
    }
    return [m[0][n], m[1][n], m[2][n]];
  }

  function buildGeoreferenceTransform(pointsList) {
    if (!Array.isArray(pointsList) || pointsList.length < 3) return null;
    let sumX = 0, sumY = 0, sumXX = 0, sumXY = 0, sumYY = 0;
    let sumLat = 0, sumLng = 0, sumXLat = 0, sumYLat = 0, sumXLng = 0, sumYLng = 0;

    for (const pt of pointsList) {
      const x = Number(pt.x);
      const y = Number(pt.y);
      const lat = Number(pt.lat);
      const lng = Number(pt.lng);
      if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(lat) || !Number.isFinite(lng)) {
        continue;
      }
      sumX += x;
      sumY += y;
      sumXX += x * x;
      sumXY += x * y;
      sumYY += y * y;
      sumLat += lat;
      sumLng += lng;
      sumXLat += x * lat;
      sumYLat += y * lat;
      sumXLng += x * lng;
      sumYLng += y * lng;
    }

    const n = pointsList.length;
    const normal = [
      [sumXX, sumXY, sumX],
      [sumXY, sumYY, sumY],
      [sumX,  sumY,  n]
    ];

    const latCoeffs = solveLinear3x3(normal, [sumXLat, sumYLat, sumLat]);
    const lngCoeffs = solveLinear3x3(normal, [sumXLng, sumYLng, sumLng]);
    if (!latCoeffs || !lngCoeffs) return null;

    return {
      lat: { ax: latCoeffs[0], by: latCoeffs[1], c: latCoeffs[2] },
      lng: { ax: lngCoeffs[0], by: lngCoeffs[1], c: lngCoeffs[2] }
    };
  }

  function worldToLatLng(x, y) {
    if (mapGeoreference) {
      const lat = mapGeoreference.lat.ax * x + mapGeoreference.lat.by * y + mapGeoreference.lat.c;
      const lng = mapGeoreference.lng.ax * x + mapGeoreference.lng.by * y + mapGeoreference.lng.c;
      if (Number.isFinite(lat) && Number.isFinite(lng)) {
        return clampLatLng(lat, lng);
      }
    }
    return worldToApproxLatLng(x, y);
  }

  function sanitizeMapGeoreference(candidate) {
    if (!candidate) return null;
    const latAx = Number(candidate?.lat?.ax);
    const latBy = Number(candidate?.lat?.by);
    const latC = Number(candidate?.lat?.c);
    const lngAx = Number(candidate?.lng?.ax);
    const lngBy = Number(candidate?.lng?.by);
    const lngC = Number(candidate?.lng?.c);
    if (
      !Number.isFinite(latAx) ||
      !Number.isFinite(latBy) ||
      !Number.isFinite(latC) ||
      !Number.isFinite(lngAx) ||
      !Number.isFinite(lngBy) ||
      !Number.isFinite(lngC)
    ) {
      return null;
    }
    return {
      lat: { ax: latAx, by: latBy, c: latC },
      lng: { ax: lngAx, by: lngBy, c: lngC }
    };
  }

  function scaleToLeafletZoomForLat(scale, lat) {
    if (!Number.isFinite(scale) || scale <= 0) return 2;
    if (!mapGeoreference) return scaleToLeafletZoom(scale);
    const feetPerPixel = 1 / scale;
    const metersPerPixel = feetPerPixel * FEET_TO_METERS;
    const cosLat = Math.max(0.01, Math.cos((lat * Math.PI) / 180));
    const zoom = Math.log2((156543.03392 * cosLat) / Math.max(1e-9, metersPerPixel));
    return clamp(zoom, 1, 22);
  }

  function syncViewToGeoreference(payload) {
    const geo = payload?.georeference;
    const pointsList = Array.isArray(geo?.points) ? geo.points.filter((pt)=>
      Number.isFinite(Number(pt?.x)) &&
      Number.isFinite(Number(pt?.y)) &&
      Number.isFinite(Number(pt?.lat)) &&
      Number.isFinite(Number(pt?.lng))
    ) : [];
    if (!pointsList.length) return false;
    mapGeoreference = buildGeoreferenceTransform(pointsList);
    return mapGeoreference != null;
  }

  function ensureMapLayer() {
    if (mapInstance || !window.L) return;
    mapInstance = L.map("mapLayer", {
      zoomControl: false,
      attributionControl: true,
      dragging: false,
      scrollWheelZoom: false,
      doubleClickZoom: false,
      boxZoom: false,
      keyboard: false,
      tap: false,
      touchZoom: false,
      zoomSnap: 0,
      zoomDelta: 0.25
    });
    applyMapTileType();
    applyMapOpacity();
    syncMapToView(true);
  }

  function applyMapTileType() {
    if (mapTileTypeInput) mapTileTypeInput.value = mapLayerState.tileType;
    if (quickMapTileTypeInput) quickMapTileTypeInput.value = mapLayerState.tileType;
    if (!mapInstance) return;
    const tile = MAP_TILESETS[mapLayerState.tileType] || MAP_TILESETS.satellite;
    if (mapTileLayer) mapInstance.removeLayer(mapTileLayer);
    mapTileLayer = L.tileLayer(tile.url, tile.options).addTo(mapInstance);
  }

  function applyMapOpacity() {
    if (mapBackdrop) {
      mapBackdrop.style.opacity = String(mapLayerState.opacity);
    }
    if (mapOpacityValue) {
      mapOpacityValue.textContent = `${Math.round(mapLayerState.opacity * 100)}%`;
    }
  }

  function syncMapToView(force=false) {
    if (!mapLayerState.enabled || !mapInstance) return;
    const rect = canvas.getBoundingClientRect();
    if (!rect.width || !rect.height) return;
    const viewportSignature = `${Math.round(rect.width)}x${Math.round(rect.height)}`;
    if (force || mapViewportSignature !== viewportSignature) {
      mapViewportSignature = viewportSignature;
      mapInstance.invalidateSize(false);
    }
    const center = screenToWorld(rect.width * 0.5, rect.height * 0.5);
    const ll = worldToLatLng(center.x, center.y);
    const zoom = scaleToLeafletZoomForLat(view.scale, ll.lat);
    mapInstance.setView([ll.lat, ll.lng], zoom, { animate: false });
  }

  function setMapLayerEnabled(enabled) {
    mapLayerState.enabled = enabled === true;
    if (mapEnabledInput) mapEnabledInput.checked = mapLayerState.enabled;
    if (quickMapEnabledInput) quickMapEnabledInput.checked = mapLayerState.enabled;
    if (mapLayerState.enabled) {
      ensureMapLayer();
      if (points.size > 0) {
        zoomExtents({ skipHistory: true, silent: true });
      }
    }
    mapBackdrop.classList.toggle("on", mapLayerState.enabled);
    if (mapLayerState.enabled) {
      syncMapToView(true);
    }
  }

  // -------------------------
  // Undo/Redo (snapshot-based)
  // -------------------------
  const history = {
    undo: [],
    redo: [],
    max: 200,
    push(label="") {
      this.undo.push({ state: serializeState(), label, ts: Date.now() });
      if (this.undo.length > this.max) this.undo.shift();
      this.redo.length = 0;
      updateUndoRedoHUD();
      scheduleCollabStateSync();
    },
    undoAction() {
      if (!this.undo.length) { setStatus("Nothing to undo.", "warn"); return; }
      const cur = serializeState();
      const prev = this.undo.pop().state;
      this.redo.push({ state: cur, label:"", ts: Date.now() });
      restoreState(prev);
      setStatus("Undo.", "ok");
      updateUndoRedoHUD();
      scheduleCollabStateSync();
    },
    redoAction() {
      if (!this.redo.length) { setStatus("Nothing to redo.", "warn"); return; }
      const cur = serializeState();
      const next = this.redo.pop().state;
      this.undo.push({ state: cur, label:"", ts: Date.now() });
      restoreState(next);
      setStatus("Redo.", "ok");
      updateUndoRedoHUD();
      scheduleCollabStateSync();
    }
  };

  function serializeState() {
    const pts = Array.from(points.values()).map(p => ({...p}));
    const lns = Array.from(lines.values()).map(l => ({...l}));
    return JSON.stringify({
      nextId,
      points: pts,
      lines: lns,
      selection: {
        selectedPointId,
        selectedPointIds: [...selectedPointIds],
        selectedLines: selectedLines.map(s => ({...s})),
        lastSelectedLineId
      },
      construction: {...construction},
      view: {...view},
      mapGeoreference: mapGeoreference ? {
        lat: { ...mapGeoreference.lat },
        lng: { ...mapGeoreference.lng }
      } : null,
      modal: { open: !modal.classList.contains("hidden"), left: modalWindow.style.left, top: modalWindow.style.top, w: modalWindow.style.width, h: modalWindow.style.height }
    });
  }

  function restoreState(json, { skipSync = false } = {}) {
    const s = JSON.parse(json);
    nextId = s.nextId ?? 1;

    points.clear();
    for (const p of (s.points || [])) points.set(p.id, { ...p, movable: isMovable(p.movable) });

    lines.clear();
    for (const l of (s.lines || [])) lines.set(l.id, { ...l, movable: isMovable(l.movable) });

    selectedPointId = s.selection?.selectedPointId ?? null;
    selectedPointIds = s.selection?.selectedPointIds ?? [];
    selectedLines = s.selection?.selectedLines ?? [];
    lastSelectedLineId = s.selection?.lastSelectedLineId ?? null;

    construction = s.construction ?? { startPointId:null };

    if (s.view) {
      view.scale = s.view.scale ?? view.scale;
      view.panX = s.view.panX ?? view.panX;
      view.panY = s.view.panY ?? view.panY;
    }

    mapGeoreference = sanitizeMapGeoreference(s.mapGeoreference);

    updatePointEditorFromSelection();
    schedulePointsTableRender();
    updateUndoRedoHUD();
    updateCounts();

    // Restore modal geometry (don’t auto-open/close during undo/redo; keep current visibility)
    if (s.modal) {
      if (s.modal.left) modalWindow.style.left = s.modal.left;
      if (s.modal.top) modalWindow.style.top = s.modal.top;
      if (s.modal.w) modalWindow.style.width = s.modal.w;
      if (s.modal.h) modalWindow.style.height = s.modal.h;
    }

    if (mapLayerState.enabled) syncMapToView(true);
    if (!skipSync) scheduleCollabStateSync();
  }

  function resolveCollabRoomId() {
    if (activeDrawingStorageKey) return activeDrawingStorageKey;
    if (activeProjectId) {
      const drawingName = String($("#drawingName")?.value || "").trim() || "default";
      const drawingId = normalizeDrawingId(drawingName);
      return drawingStorageKey(activeProjectId, drawingId);
    }
    return collabRoomParam || "global";
  }

  function setCollabStatus(text) {
    const el = $("#collabStatus");
    if (el) el.textContent = `Collaboration: ${text}`;
  }

  function sendCollabMessage(payload) {
    if (!collab.enabled || !collab.socket || collab.socket.readyState !== WebSocket.OPEN) return;
    collab.socket.send(JSON.stringify(payload));
  }

  function scheduleCollabStateSync() {
    if (!collab.enabled || collab.applyingRemoteState) return;
    if (collab.stateDebounce) clearTimeout(collab.stateDebounce);
    collab.stateDebounce = setTimeout(() => {
      collab.stateDebounce = null;
      sendCollabMessage({ type: "state", state: serializeState() });
    }, 120);
  }

  function connectCollaboration() {
    const roomId = resolveCollabRoomId();
    if (!roomId) return;
    collab.roomId = roomId;
    collab.enabled = true;

    const scheme = window.location.protocol === "https:" ? "wss" : "ws";
    const wsUrl = `${scheme}://${window.location.host}/ws/lineforge?room=${encodeURIComponent(roomId)}`;
    setCollabStatus(`connecting (${roomId})…`);
    const socket = new WebSocket(wsUrl);
    collab.socket = socket;

    socket.addEventListener("open", () => {
      setCollabStatus(`connected (${roomId})`);
    });

    socket.addEventListener("close", () => {
      setCollabStatus("offline");
      collab.remoteCursors.clear();
      collab.peers.clear();
    });

    socket.addEventListener("message", (event) => {
      let message;
      try {
        message = JSON.parse(event.data);
      } catch {
        return;
      }

      if (message.type === "welcome") {
        collab.clientId = message.clientId || "";
        collab.color = message.color || "#ffffff";
        collab.peers.clear();
        for (const peer of (message.peers || [])) {
          collab.peers.set(peer.clientId, { color: peer.color || "#ffffff" });
        }
        if (message.state) {
          collab.applyingRemoteState = true;
          restoreState(message.state, { skipSync: true });
          collab.applyingRemoteState = false;
        }
        return;
      }

      if (message.type === "peer-joined") {
        collab.peers.set(message.clientId, { color: message.color || "#ffffff" });
        return;
      }

      if (message.type === "peer-left") {
        collab.peers.delete(message.clientId);
        collab.remoteCursors.delete(message.clientId);
        return;
      }

      if (message.type === "cursor") {
        collab.remoteCursors.set(message.clientId, {
          color: message.color || collab.peers.get(message.clientId)?.color || "#ffffff",
          x: Number(message.cursor?.x) || 0,
          y: Number(message.cursor?.y) || 0,
          at: Number(message.at) || Date.now()
        });
        return;
      }

      if (message.type === "state" && message.state) {
        collab.applyingRemoteState = true;
        restoreState(message.state, { skipSync: true });
        collab.applyingRemoteState = false;
      }
    });
  }

  function broadcastCursor() {
    sendCollabMessage({
      type: "cursor",
      cursor: {
        x: mouse.wx,
        y: mouse.wy
      }
    });
  }

  function drawRemoteCursors() {
    if (!collab.remoteCursors.size) return;
    const expiryMs = 8000;
    const now = Date.now();
    for (const [clientId, cursor] of collab.remoteCursors.entries()) {
      if (now - cursor.at > expiryMs) {
        collab.remoteCursors.delete(clientId);
        continue;
      }
      const sp = worldToScreen(cursor.x, cursor.y);
      ctx.save();
      ctx.strokeStyle = cursor.color;
      ctx.fillStyle = cursor.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(sp.x - 8, sp.y);
      ctx.lineTo(sp.x + 8, sp.y);
      ctx.moveTo(sp.x, sp.y - 8);
      ctx.lineTo(sp.x, sp.y + 8);
      ctx.stroke();
      ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(clientId.slice(0, 6), sp.x + 10, sp.y - 10);
      ctx.restore();
    }
  }

  function updateUndoRedoHUD() {
    hudUndo.textContent = String(history.undo.length);
    hudRedo.textContent = String(history.redo.length);
    $("#undoBtn").disabled = history.undo.length === 0;
    $("#redoBtn").disabled = history.redo.length === 0;
  }

  // -------------------------
  // Transform helpers
  // -------------------------
  function worldToScreen(x,y){
    return {
      x: (x * view.scale) + view.panX,
      y: (-y * view.scale) + view.panY
    };
  }
  function screenToWorld(x,y){
    return {
      x: (x - view.panX) / view.scale,
      y: -((y - view.panY) / view.scale)
    };
  }

  // -------------------------
  // Model helpers
  // -------------------------
  function getMaxPointNumber() {
    let m = 0;
    for (const p of points.values()) m = Math.max(m, Number(p.num) || 0);
    return m;
  }
  function nextOpenPointNumber(start=null) {
    const used = new Set();
    for (const p of points.values()) used.add(String(p.num));
    let n = start ?? (getMaxPointNumber() + 1);
    n = Math.max(1, Math.floor(Number(n) || 1));
    while (used.has(String(n))) n++;
    return n;
  }
  function pointNumberExists(numStr, excludeId=null) {
    const ns = String(numStr);
    for (const p of points.values()) {
      if (excludeId != null && p.id === excludeId) continue;
      if (String(p.num) === ns) return true;
    }
    return false;
  }
  function resolveDesiredPointNumber(inputValue) {
    const raw = String(inputValue ?? "").trim();
    if (!raw) return nextOpenPointNumber();
    const requested = Number(raw);
    if (!Number.isFinite(requested)) return nextOpenPointNumber();
    const reqInt = Math.max(1, Math.floor(requested));
    if (!pointNumberExists(String(reqInt))) return reqInt;
    return nextOpenPointNumber(reqInt);
  }

  function findPointIdByNumber(pointNumber) {
    const desired = String(pointNumber ?? "").trim();
    if (!desired) return null;
    for (const p of points.values()) {
      if (String(p.num) === desired) return p.id;
    }
    return null;
  }

  function moveSelectionByDelta(dx, dy) {
    const ids = getRotatablePointIdsFromSelection();
    if (!ids.length) return 0;
    for (const pid of ids) {
      const p = points.get(pid);
      if (!p) continue;
      p.x += dx;
      p.y += dy;
    }
    return ids.length;
  }

  function addPoint({num, x, y, z=0, code="", notes="", movable=false}) {
    const id = nextId++;
    points.set(id, {
      id,
      num: String(num),
      x: Number(x),
      y: Number(y),
      z: Number(z),
      code: String(code ?? ""),
      notes: String(notes ?? ""),
      movable: !!movable
    });
    schedulePointsTableRender();
    updateCounts();
    return id;
  }

  function addLine(aPointId, bPointId, movable=false) {
    const id = nextId++;
    lines.set(id, { id, a: aPointId, b: bPointId, movable: !!movable });
    updateCounts();
    return id;
  }

  function deletePoint(pid) {
    if (!points.has(pid)) return;
    for (const [lid, ln] of Array.from(lines.entries())) {
      if (ln.a === pid || ln.b === pid) lines.delete(lid);
    }
    points.delete(pid);
    selectedPointIds = selectedPointIds.filter(id => id !== pid);
    selectedPointId = selectedPointIds.length ? selectedPointIds[selectedPointIds.length-1] : null;
    selectedLines = selectedLines.filter(s => lines.has(s.lineId));
    lastSelectedLineId = lines.has(lastSelectedLineId) ? lastSelectedLineId : null;
    updatePointEditorFromSelection();
    schedulePointsTableRender();
    updateCounts();
  }

  function deleteLine(lid) {
    lines.delete(lid);
    selectedLines = selectedLines.filter(s => s.lineId !== lid);
    if (lastSelectedLineId === lid) lastSelectedLineId = null;
    updateCounts();
  }

  function getRotatablePointIdsFromSelection() {
    const ids = new Set();
    for (const pid of selectedPointIds) {
      if (points.has(pid)) ids.add(pid);
    }
    for (const sel of selectedLines) {
      const ln = lines.get(sel.lineId);
      if (!ln) continue;
      if (points.has(ln.a)) ids.add(ln.a);
      if (points.has(ln.b)) ids.add(ln.b);
    }
    return [...ids];
  }

  const rotateWorkflowSteps = [
    "Select items to rotate",
    "Select a point to rotate around",
    "Select a basis of rotation",
    "Select a target rotation"
  ];

  function getToolWorkflowToastPayload(activeTool = tool) {
    if (activeTool === "select") {
      return {
        title: "Select / Move Workflow",
        message: "Click items to select, or drag a window to select multiple items.",
        steps: ["Click item(s) or drag a selection window"],
        currentStepIndex: 0
      };
    }

    if (activeTool === "addPoint") {
      return {
        title: "Add Point Workflow",
        message: "Click anywhere on the canvas to place a point.",
        steps: ["Click canvas to place a point"],
        currentStepIndex: 0
      };
    }

    if (activeTool === "line2pt") {
      const hasStart = construction.startPointId !== null;
      return {
        title: "Line: 2 Points Workflow",
        message: hasStart
          ? "Now click an endpoint (point or open space) to finish the line."
          : "Click a start point, or click empty space to create one.",
        steps: [
          "Pick line start point",
          "Pick line end point"
        ],
        currentStepIndex: hasStart ? 1 : 0
      };
    }

    if (activeTool === "lineDB") {
      const hasStart = construction.startPointId !== null;
      return {
        title: "Line: Dist/Bearing Workflow",
        message: hasStart
          ? "Enter distance + bearing, then click Create Point + Line."
          : "Click a start point on the canvas first.",
        steps: [
          "Select start point",
          "Enter distance + bearing",
          "Click Create Point + Line"
        ],
        currentStepIndex: hasStart ? 2 : 0
      };
    }

    if (activeTool === "pointOnLine") {
      const hasLine = lastSelectedLineId != null && lines.has(lastSelectedLineId);
      return {
        title: "Point on Line Workflow",
        message: hasLine
          ? "Enter station/offset values, then click Create Point."
          : "Click near a line to select it first.",
        steps: [
          "Select line",
          "Enter station + offset",
          "Click Create Point"
        ],
        currentStepIndex: hasLine ? 2 : 0
      };
    }

    if (activeTool === "pan") {
      return {
        title: "Pan Workflow",
        message: "Press and drag on the canvas to move your view.",
        steps: ["Drag the canvas to pan"],
        currentStepIndex: 0
      };
    }

    return null;
  }

  function syncToolWorkflowToast() {
    if (lineIntersectionCommandSession.active) return;
    if (rotateSelectionSession.active) return;
    const payload = getToolWorkflowToastPayload(tool);
    if (!payload) {
      hideWorkflowToast();
      return;
    }
    showWorkflowToast(payload);
  }

  function syncRotateWorkflowToast() {
    if (!rotateSelectionSession.active) {
      syncToolWorkflowToast();
      return;
    }
    const stepIndex = rotateSelectionSession.awaitingSelection ? 0 : clamp(rotateSelectionSession.step + 1, 1, rotateWorkflowSteps.length - 1);
    showWorkflowToast({
      title: "Rotate Selection Workflow",
      message: rotateWorkflowSteps[stepIndex],
      steps: rotateWorkflowSteps,
      currentStepIndex: stepIndex
    });
  }

  function cancelRotateSelectionSession(silent=true) {
    rotateSelectionSession.active = false;
    rotateSelectionSession.step = 0;
    rotateSelectionSession.basePoint = null;
    rotateSelectionSession.fromPoint = null;
    rotateSelectionSession.awaitingSelection = false;
    syncToolWorkflowToast();
    if (!silent) setStatus("Rotate selection canceled.", "warn");
  }

  function startRotateSelectionSession() {
    rotateSelectionSession.active = true;
    rotateSelectionSession.step = 0;
    rotateSelectionSession.basePoint = null;
    rotateSelectionSession.fromPoint = null;
    const rotateIds = getRotatablePointIdsFromSelection();
    rotateSelectionSession.awaitingSelection = !rotateIds.length;

    if (rotateSelectionSession.awaitingSelection) {
      setTool("select");
      setStatus("Select items to rotate with a window or click selection, then continue the rotate picks.", "warn");
    } else {
      setStatus("Rotate selection: click base point.", "ok");
    }
    syncRotateWorkflowToast();
  }

  function resolveRotatePickWorldPoint(screenX, screenY) {
    const pid = pickPoint(screenX, screenY, 12);
    if (pid && points.has(pid)) {
      const p = points.get(pid);
      return { x: p.x, y: p.y, label: `point ${p.num}` };
    }
    const w = screenToWorld(screenX, screenY);
    return { x: w.x, y: w.y, label: `(${fmt(w.x)}, ${fmt(w.y)})` };
  }

  function rotateSelectedFromReference(basePoint, fromPoint, toPoint) {
    const rotateIds = getRotatablePointIdsFromSelection();
    if (!rotateIds.length) {
      setStatus("Select at least one point or line to rotate.", "warn");
      cancelRotateSelectionSession(true);
      return;
    }

    const baseAngle = Math.atan2(fromPoint.y - basePoint.y, fromPoint.x - basePoint.x);
    const targetAngle = Math.atan2(toPoint.y - basePoint.y, toPoint.x - basePoint.x);
    const delta = targetAngle - baseAngle;
    const cos = Math.cos(delta);
    const sin = Math.sin(delta);

    history.push("rotate selection (reference)");
    for (const pid of rotateIds) {
      const p = points.get(pid);
      if (!p) continue;
      const dx = p.x - basePoint.x;
      const dy = p.y - basePoint.y;
      p.x = basePoint.x + (dx * cos - dy * sin);
      p.y = basePoint.y + (dx * sin + dy * cos);
    }

    updatePointEditorFromSelection();
    schedulePointsTableRender();
    const deltaDeg = (delta * 180 / Math.PI);
    setStatus(`Rotated ${rotateIds.length} point(s) by ${fmt(deltaDeg)}° about ${fmt(basePoint.x)}, ${fmt(basePoint.y)}.`, "ok");
  }

  function handleRotateSelectionCanvasPick(screenX, screenY) {
    if (rotateSelectionSession.awaitingSelection) {
      const rotateIds = getRotatablePointIdsFromSelection();
      if (!rotateIds.length) {
        setStatus("Select items to rotate before picking a rotate point.", "warn");
        syncRotateWorkflowToast();
        return;
      }
      rotateSelectionSession.awaitingSelection = false;
      rotateSelectionSession.step = 0;
      setStatus("Selection captured. Click base point.", "ok");
      syncRotateWorkflowToast();
    }

    const picked = resolveRotatePickWorldPoint(screenX, screenY);
    if (rotateSelectionSession.step === 0) {
      rotateSelectionSession.basePoint = picked;
      rotateSelectionSession.step = 1;
      setStatus(`Base point set at ${picked.label}. Click reference-angle point.`, "ok");
      syncRotateWorkflowToast();
      return;
    }

    if (rotateSelectionSession.step === 1) {
      const base = rotateSelectionSession.basePoint;
      if (dist(base.x, base.y, picked.x, picked.y) < 1e-9) {
        setStatus("Reference-angle point must differ from base point.", "warn");
        return;
      }
      rotateSelectionSession.fromPoint = picked;
      rotateSelectionSession.step = 2;
      setStatus(`Reference angle set from base to ${picked.label}. Click target-angle point.`, "ok");
      syncRotateWorkflowToast();
      return;
    }

    const base = rotateSelectionSession.basePoint;
    if (dist(base.x, base.y, picked.x, picked.y) < 1e-9) {
      setStatus("Target-angle point must differ from base point.", "warn");
      return;
    }

    rotateSelectedFromReference(base, rotateSelectionSession.fromPoint, picked);
    cancelRotateSelectionSession(true);
  }

  // -------------------------
  // Picking
  // -------------------------
  function pickPoint(screenX, screenY, thresholdPx=10) {
    let best = null;
    let bestD2 = thresholdPx*thresholdPx;
    for (const p of points.values()) {
      const s = worldToScreen(p.x, p.y);
      const d2 = dist2(screenX, screenY, s.x, s.y);
      if (d2 <= bestD2) {
        bestD2 = d2;
        best = p.id;
      }
    }
    return best;
  }

  function pickLine(screenX, screenY, thresholdPx=8) {
    const w = screenToWorld(screenX, screenY);
    let best = null;
    let bestDist = thresholdPx / Math.max(view.scale, MIN_SCALE);
    let bestGrip = "a";
    let bestT = 0;

    for (const ln of lines.values()) {
      const pa = points.get(ln.a);
      const pb = points.get(ln.b);
      if (!pa || !pb) continue;

      const cp = segmentClosestPoint({x:w.x,y:w.y}, pa, pb);
      const d = dist(w.x, w.y, cp.x, cp.y);
      if (d <= bestDist) {
        bestDist = d;
        best = ln.id;
        bestT = cp.t;
        bestGrip = (cp.t <= 0.5) ? "a" : "b";
      }
    }
    return best ? { lineId: best, grip: bestGrip, t: bestT } : null;
  }

  function selectionSummary() {
    const pts = selectedPointIds.length ? `Pts:${selectedPointIds.length} [${selectedPointIds.map(id=>points.get(id)?.num ?? "?").join(", ")}]` : "";
    const lns = selectedLines.length ? `Lines:${selectedLines.length}` : "";
    return [pts, lns].filter(Boolean).join(" + ") || "none";
  }
  function updateSelectionHUD() {
    const s = selectionSummary();
    selSummary.textContent = s;
    hudSel.textContent = s;
  }

  // -------------------------
  // Rendering
  // -------------------------
  function resize() {
    const rect = canvas.getBoundingClientRect();
    dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    if (view.panX === 0 && view.panY === 0) {
      view.panX = rect.width * 0.5;
      view.panY = rect.height * 0.5;
    }
    if (mapLayerState.enabled) syncMapToView(true);
  }

  function pickGridStep() {
    const targetPx = 80;
    const step = targetPx / Math.max(view.scale, MIN_SCALE);
    const pow = Math.pow(10, Math.floor(Math.log10(step)));
    const candidates = [1,2,5,10].map(m => m*pow);
    let best = candidates[0], bestErr = Math.abs(best - step);
    for (const c of candidates) {
      const err = Math.abs(c - step);
      if (err < bestErr) { bestErr = err; best = c; }
    }
    return best;
  }

  function drawGrid(W,H) {
    const stepWorld = pickGridStep();
    const stepPx = stepWorld * view.scale;
    if (stepPx < 30) return;

    const leftWorld = screenToWorld(0,0).x;
    const rightWorld = screenToWorld(W,0).x;
    const topWorld = screenToWorld(0,0).y;
    const botWorld = screenToWorld(0,H).y;

    const x0 = Math.floor(leftWorld/stepWorld)*stepWorld;
    const x1 = Math.ceil(rightWorld/stepWorld)*stepWorld;
    const y0 = Math.floor(botWorld/stepWorld)*stepWorld;
    const y1 = Math.ceil(topWorld/stepWorld)*stepWorld;

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.lineWidth = 1;

    for (let x = x0; x <= x1; x += stepWorld) {
      const sx = worldToScreen(x,0).x;
      ctx.beginPath();
      ctx.moveTo(sx,0);
      ctx.lineTo(sx,H);
      ctx.stroke();
    }
    for (let y = y0; y <= y1; y += stepWorld) {
      const sy = worldToScreen(0,y).y;
      ctx.beginPath();
      ctx.moveTo(0,sy);
      ctx.lineTo(W,sy);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawCrosshair(W,H) {
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(mouse.x, 0);
    ctx.lineTo(mouse.x, H);
    ctx.moveTo(0, mouse.y);
    ctx.lineTo(W, mouse.y);
    ctx.stroke();

    const snapId = pickPoint(mouse.x, mouse.y, 10);
    const boxSize = 14;
    ctx.strokeStyle = snapId ? "rgba(255,213,74,0.9)" : "rgba(255,255,255,0.4)";
    ctx.beginPath();
    if (snapId) {
      const p = points.get(snapId);
      const sp = worldToScreen(p.x,p.y);
      ctx.rect(sp.x - boxSize/2, sp.y - boxSize/2, boxSize, boxSize);
    } else {
      ctx.rect(mouse.x - boxSize/2, mouse.y - boxSize/2, boxSize, boxSize);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawMarquee() {
    if (!mouse.drag || mouse.dragObj?.type !== "marquee") return;
    const r = rectNorm(mouse.dragObj.x0, mouse.dragObj.y0, mouse.dragObj.x1, mouse.dragObj.y1);
    ctx.save();
    ctx.strokeStyle = "rgba(255,213,74,0.95)";
    ctx.lineWidth = 1.5;
    ctx.setLineDash([6,4]);
    ctx.strokeRect(r.minX, r.minY, r.maxX-r.minX, r.maxY-r.minY);
    ctx.setLineDash([]);
    ctx.fillStyle = "rgba(255,213,74,0.08)";
    ctx.fillRect(r.minX, r.minY, r.maxX-r.minX, r.maxY-r.minY);
    ctx.restore();
  }

  function drawRotateSelectionPreview() {
    if (!rotateSelectionSession.active || rotateSelectionSession.step < 1 || !rotateSelectionSession.basePoint) return;

    const base = worldToScreen(rotateSelectionSession.basePoint.x, rotateSelectionSession.basePoint.y);
    const cursor = worldToScreen(mouse.wx, mouse.wy);

    ctx.save();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,213,74,0.95)";
    ctx.beginPath();
    ctx.moveTo(base.x, base.y);
    ctx.lineTo(cursor.x, cursor.y);
    ctx.stroke();

    if (rotateSelectionSession.step >= 2 && rotateSelectionSession.fromPoint) {
      const from = worldToScreen(rotateSelectionSession.fromPoint.x, rotateSelectionSession.fromPoint.y);
      ctx.strokeStyle = "rgba(57,255,121,0.95)";
      ctx.beginPath();
      ctx.moveTo(base.x, base.y);
      ctx.lineTo(from.x, from.y);
      ctx.stroke();
    }

    ctx.restore();
  }

  function draw() {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.clearRect(0,0,W,H);
    if (!mapLayerState.enabled) {
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,W,H);
    }

    drawGrid(W,H);
    if (mapLayerState.enabled) syncMapToView();

    const blockedTextRects = [];

    // lines
    ctx.lineWidth = 1;
    const lineLabelCandidates = [];
    for (const ln of lines.values()) {
      const a = points.get(ln.a);
      const b = points.get(ln.b);
      if (!a || !b) continue;
      const sa = worldToScreen(a.x,a.y);
      const sb = worldToScreen(b.x,b.y);
      ctx.strokeStyle = isMovable(ln.movable) ? "#800000" : "#fff";
      ctx.beginPath();
      ctx.moveTo(sa.x, sa.y);
      ctx.lineTo(sb.x, sb.y);
      ctx.stroke();

      if (isMovable(ln.movable)) {
        const mx = (sa.x+sb.x)/2, my=(sa.y+sb.y)/2;
        ctx.save();
        ctx.strokeStyle = "rgba(255,213,74,0.9)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(mx-6, my);
        ctx.lineTo(mx+6, my);
        ctx.stroke();
        ctx.restore();
      }

      lineLabelCandidates.push({ a, b, sa, sb });
    }

    // highlight selected lines
    if (selectedLines.length) {
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#ffd54a";
      for (const s of selectedLines) {
        const ln = lines.get(s.lineId);
        if (!ln) continue;
        const a = points.get(ln.a), b = points.get(ln.b);
        if (!a || !b) continue;
        const sa = worldToScreen(a.x,a.y);
        const sb = worldToScreen(b.x,b.y);
        ctx.beginPath();
        ctx.moveTo(sa.x, sa.y);
        ctx.lineTo(sb.x, sb.y);
        ctx.stroke();

        const gripPt = (s.grip === "a") ? a : b;
        const sg = worldToScreen(gripPt.x, gripPt.y);
        ctx.fillStyle = "rgba(255,213,74,0.12)";
        ctx.strokeStyle = "#ffd54a";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.rect(sg.x-6, sg.y-6, 12, 12);
        ctx.fill();
        ctx.stroke();
      }
      ctx.restore();
    }

    // points
    for (const p of points.values()) {
      const sp = worldToScreen(p.x,p.y);

      // marker
      ctx.strokeStyle = "#ff2b2b";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(sp.x-5, sp.y-5);
      ctx.lineTo(sp.x+5, sp.y+5);
      ctx.moveTo(sp.x-5, sp.y+5);
      ctx.lineTo(sp.x+5, sp.y-5);
      ctx.stroke();

      // movable hint ring
      if (isMovable(p.movable)) {
        ctx.save();
        ctx.strokeStyle = "rgba(255,213,74,0.95)";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, 8, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // labels
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textBaseline = "middle";

      ctx.fillStyle = "#ffffff";
      const numText = String(p.num);
      ctx.fillText(numText, sp.x + 8, sp.y - 10);
      blockedTextRects.push({ x: sp.x + 8, y: sp.y - 16, w: ctx.measureText(numText).width, h: 12 });

      if (labelVisibility.codes && p.code) {
        ctx.fillStyle = "#39ff79";
        const codeText = String(p.code);
        ctx.fillText(codeText, sp.x + 8, sp.y + 2);
        blockedTextRects.push({ x: sp.x + 8, y: sp.y - 4, w: ctx.measureText(codeText).width, h: 12 });
      }
      if (labelVisibility.notes && p.notes) {
        ctx.fillStyle = "#3aa3ff";
        const notesText = String(p.notes);
        ctx.fillText(notesText, sp.x + 8, sp.y + 14);
        blockedTextRects.push({ x: sp.x + 8, y: sp.y + 8, w: ctx.measureText(notesText).width, h: 12 });
      }
    }

    ctx.save();
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "#ffd54a";
    for (const c of lineLabelCandidates) {
      const measure = lineMeasurement(c.a, c.b);
      if (!measure) continue;
      const label = `${measure.bearing} • ${measure.distance.toFixed(3)}`;
      const labelW = ctx.measureText(label).width;
      const dx = c.sb.x - c.sa.x;
      const dy = c.sb.y - c.sa.y;
      const pixelLength = Math.hypot(dx, dy);
      if (pixelLength < labelW + 24) continue;

      let angle = measure.angle;
      if (angle > Math.PI / 2 || angle < -Math.PI / 2) angle += Math.PI;
      const mx = (c.sa.x + c.sb.x) * 0.5;
      const my = (c.sa.y + c.sb.y) * 0.5;
      const offset = 11;
      const nx = -dy / Math.max(pixelLength, EPS);
      const ny = dx / Math.max(pixelLength, EPS);
      const cx = mx + nx * offset;
      const cy = my + ny * offset;
      const candidateAabb = rotatedRectAabb(cx, cy, labelW + 6, 16, angle);
      if (blockedTextRects.some((r) => rectsOverlap(r, candidateAabb))) continue;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label, 0, 0);
      ctx.restore();

      blockedTextRects.push(candidateAabb);
    }
    ctx.restore();

    // highlight selected points
    if (selectedPointIds.length) {
      ctx.save();
      for (const pid of selectedPointIds) {
        const p = points.get(pid);
        if (!p) continue;
        const sp = worldToScreen(p.x,p.y);
        ctx.strokeStyle = (pid === selectedPointId) ? "#ffd54a" : "rgba(255,213,74,0.55)";
        ctx.lineWidth = (pid === selectedPointId) ? 2 : 1.5;
        ctx.beginPath();
        ctx.rect(sp.x-9, sp.y-9, 18, 18);
        ctx.stroke();
      }
      ctx.restore();
    }

    // marquee (selection window)
    drawMarquee();

    drawRotateSelectionPreview();

    // crosshair & snap box
    drawCrosshair(W,H);
    drawRemoteCursors();

    // HUD
    hudMouse.textContent = `x: ${fmt(mouse.wx)}, y: ${fmt(mouse.wy)}`;
    hudZoom.textContent = `${view.scale.toFixed(4)} px/unit`;
    updateSelectionHUD();
    updateUndoRedoHUD();

    requestAnimationFrame(draw);
  }

  // -------------------------
  // Tool + UI wiring
  // -------------------------
  function setTool(t) {
    tool = t;
    const names = {
      select:"Select/Move",
      addPoint:"Add Point",
      line2pt:"Line: 2 Points",
      lineDB:"Line: Dist/Bearing",
      pointOnLine:"Point on Line",
      pan:"Pan"
    };
    const label = names[t] ?? t;
    hudTool.textContent = label;
    toolHint.textContent = label;

    for (const id of ["toolSelect","toolAddPoint","toolLine2pt","toolLineDB","toolPointOnLine","toolPan"]) {
      $("#"+id).classList.remove("primary");
    }
    for (const id of ["quickSelect","quickAddPoint","quickLineByPoints"]) {
      const quick = $("#" + id);
      if (quick) quick.classList.remove("primary");
    }
    const map = {
      select:"toolSelect",
      addPoint:"toolAddPoint",
      line2pt:"toolLine2pt",
      lineDB:"toolLineDB",
      pointOnLine:"toolPointOnLine",
      pan:"toolPan"
    };
    const btn = map[t];
    if (btn) $("#"+btn).classList.add("primary");

    const quickMap = {
      select:"quickSelect",
      addPoint:"quickAddPoint",
      line2pt:"quickLineByPoints"
    };
    const quickBtn = quickMap[t];
    if (quickBtn) {
      const quickEl = $("#" + quickBtn);
      if (quickEl) quickEl.classList.add("primary");
    }

    setStatus(`Tool: ${label}`, "");
    syncToolWorkflowToast();
  }

  function runCommandLine(rawCommand) {
    const normalized = String(rawCommand ?? "").trim();
    if (!normalized) {
      setStatus("Enter a command. Try: line 101 205", "warn");
      return false;
    }

    const parts = normalized.split(/\s+/);
    const cmd = parts[0].toLowerCase();

    if (cmd === "line") {
      if (parts.length < 3) {
        setStatus("Usage: line <point1> <point2>", "warn");
        return false;
      }
      const aId = findPointIdByNumber(parts[1]);
      const bId = findPointIdByNumber(parts[2]);
      if (!aId || !bId) {
        setStatus("LINE failed: one or both point numbers were not found.", "warn");
        return false;
      }
      if (aId === bId) {
        setStatus("LINE failed: choose two different points.", "warn");
        return false;
      }
      history.push("command: line");
      const lid = addLine(aId, bId, false);
      selectedPointIds = [aId, bId];
      selectedPointId = bId;
      selectedLines = [{ lineId: lid, grip: "b", t: 1 }];
      lastSelectedLineId = lid;
      updatePointEditorFromSelection();
      setStatus(`Command LINE: created line ${lid} from ${parts[1]} to ${parts[2]}.`, "ok");
      return true;
    }

    if (cmd === "move") {
      if (parts.length < 3) {
        setStatus("Usage: move <dx> <dy> (acts on selected points/lines)", "warn");
        return false;
      }
      const dx = Number(parts[1]);
      const dy = Number(parts[2]);
      if (!Number.isFinite(dx) || !Number.isFinite(dy)) {
        setStatus("MOVE failed: dx/dy must be numeric.", "warn");
        return false;
      }
      const affectedPreview = getRotatablePointIdsFromSelection();
      if (!affectedPreview.length) {
        setStatus("MOVE failed: select at least one point or line first.", "warn");
        return false;
      }
      history.push("command: move");
      const moved = moveSelectionByDelta(dx, dy);
      setStatus(`Command MOVE: shifted ${moved} point(s) by Δx=${fmt(dx)}, Δy=${fmt(dy)}.`, "ok");
      return true;
    }

    if (cmd === "rotate") {
      startRotateSelectionSession();
      return true;
    }

    if (cmd === "inverse") {
      if (parts.length < 3) {
        setStatus("Usage: inverse <point1> <point2>", "warn");
        return false;
      }
      const aId = findPointIdByNumber(parts[1]);
      const bId = findPointIdByNumber(parts[2]);
      if (!aId || !bId) {
        setStatus("INVERSE failed: one or both point numbers were not found.", "warn");
        return false;
      }
      if (aId === bId) {
        setStatus("INVERSE failed: choose two different points.", "warn");
        return false;
      }
      const a = points.get(aId);
      const b = points.get(bId);
      const measure = lineMeasurement(a, b);
      if (!measure) {
        setStatus("INVERSE failed: unable to compute bearing/distance.", "warn");
        return false;
      }
      selectedPointIds = [aId, bId];
      selectedPointId = bId;
      selectedLines = [];
      lastSelectedLineId = null;
      setStatus(`Command INVERSE ${parts[1]}→${parts[2]}: Dist ${measure.distance.toFixed(3)}  Bearing ${measure.bearing}`, "ok");
      return true;
    }

    setStatus(`Unknown command: ${parts[0]}. Supported: line, move, rotate, inverse.`, "warn");
    return false;
  }

  runCommandBtn?.addEventListener("click", () => {
    if (runCommandLine(commandInput?.value || "")) {
      if (commandInput) commandInput.value = "";
    }
  });
  commandInput?.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    e.preventDefault();
    if (runCommandLine(commandInput.value || "")) {
      commandInput.value = "";
    }
  });

  $("#toolSelect").addEventListener("click", ()=>setTool("select"));
  $("#toolAddPoint").addEventListener("click", ()=>setTool("addPoint"));
  $("#toolLine2pt").addEventListener("click", ()=>{ construction.startPointId = null; setTool("line2pt"); });
  $("#toolLineDB").addEventListener("click", ()=>setTool("lineDB"));

  function setPointCodeVisibility(enabled) {
    labelVisibility.codes = !!enabled;
    if (showPointCodesInput) showPointCodesInput.checked = labelVisibility.codes;
    if (quickShowPointCodesInput) quickShowPointCodesInput.checked = labelVisibility.codes;
  }

  function setPointNotesVisibility(enabled) {
    labelVisibility.notes = !!enabled;
    if (showPointNotesInput) showPointNotesInput.checked = labelVisibility.notes;
    if (quickShowPointNotesInput) quickShowPointNotesInput.checked = labelVisibility.notes;
  }

  function setMapTileType(tileType) {
    mapLayerState.tileType = String(tileType || "satellite");
    if (mapTileTypeInput) mapTileTypeInput.value = mapLayerState.tileType;
    if (quickMapTileTypeInput) quickMapTileTypeInput.value = mapLayerState.tileType;
    applyMapTileType();
    syncMapToView(true);
  }

  showPointCodesInput?.addEventListener("change", () => {
    setPointCodeVisibility(showPointCodesInput.checked);
    setStatus(`Point code labels ${labelVisibility.codes ? "shown" : "hidden"}.`, "ok");
  });

  quickShowPointCodesInput?.addEventListener("change", () => {
    setPointCodeVisibility(quickShowPointCodesInput.checked);
    setStatus(`Point code labels ${labelVisibility.codes ? "shown" : "hidden"}.`, "ok");
  });

  showPointNotesInput?.addEventListener("change", () => {
    setPointNotesVisibility(showPointNotesInput.checked);
    setStatus(`Point notes labels ${labelVisibility.notes ? "shown" : "hidden"}.`, "ok");
  });

  quickShowPointNotesInput?.addEventListener("change", () => {
    setPointNotesVisibility(quickShowPointNotesInput.checked);
    setStatus(`Point notes labels ${labelVisibility.notes ? "shown" : "hidden"}.`, "ok");
  });

  mapEnabledInput.addEventListener("change", () => {
    setMapLayerEnabled(mapEnabledInput.checked);
    setStatus(`Map layer ${mapLayerState.enabled ? "enabled" : "disabled"}.`, "ok");
  });
  quickMapEnabledInput?.addEventListener("change", () => {
    setMapLayerEnabled(quickMapEnabledInput.checked);
    setStatus(`Map layer ${mapLayerState.enabled ? "enabled" : "disabled"}.`, "ok");
  });
  mapTileTypeInput.addEventListener("change", () => {
    setMapTileType(mapTileTypeInput.value);
  });
  quickMapTileTypeInput?.addEventListener("change", () => {
    setMapTileType(quickMapTileTypeInput.value);
  });
  mapOpacityInput.addEventListener("input", () => {
    mapLayerState.opacity = clamp(parseNum(mapOpacityInput.value, 10) / 100, 0, 1);
    applyMapOpacity();
  });

  setPointCodeVisibility(true);
  setPointNotesVisibility(true);
  if (quickMapEnabledInput) quickMapEnabledInput.checked = mapEnabledInput.checked;
  if (quickMapTileTypeInput) quickMapTileTypeInput.value = mapTileTypeInput.value;
  $("#toolPointOnLine").addEventListener("click", ()=>setTool("pointOnLine"));
  $("#toolPan").addEventListener("click", ()=>setTool("pan"));

  if (drawerToggle) {
    drawerToggle.addEventListener("click", () => {
      const isOpen = appShell?.classList.contains("drawerOpen");
      setDrawerOpen(!isOpen);
    });
  }
  if (panelCollapseHandle) {
    panelCollapseHandle.addEventListener("click", () => setPanelCollapsed(true));
  }
  if (drawerEdgeExpand) {
    drawerEdgeExpand.addEventListener("click", () => setPanelCollapsed(false));
  }

  window.addEventListener("resize", () => {
    if (!isMobileViewport()) setDrawerOpen(false);
    setPanelCollapsed(false);
  });

  $("#undoBtn").addEventListener("click", ()=>history.undoAction());
  $("#redoBtn").addEventListener("click", ()=>history.redoAction());

  $("#quickSave")?.addEventListener("click", () => $("#saveDrawingToProject").click());
  $("#quickSelect")?.addEventListener("click", () => setTool("select"));
  $("#quickAddPoint")?.addEventListener("click", () => setTool("addPoint"));
  function startLineByPointsFromToolbar() {
    if (selectedPointIds.length >= 2) {
      runLineBetweenSelectedPoints({ returnToSelectionTool: true });
      return;
    }
    construction.startPointId = null;
    setTool("line2pt");
  }

  $("#quickLineByPoints")?.addEventListener("click", () => startLineByPointsFromToolbar());
  $("#quickUndo")?.addEventListener("click", () => history.undoAction());
  $("#quickRedo")?.addEventListener("click", () => history.redoAction());
  $("#quickZoomExtents")?.addEventListener("click", () => zoomExtents());
  $("#quickCenter")?.addEventListener("click", () => $("#zoomAllAndCenter").click());
  $("#quickExtend")?.addEventListener("click", () => $("#extendToIntersect").click());
  $("#quickTrimIntersect")?.addEventListener("click", () => $("#trimToIntersect").click());
  $("#quickRotateSelection")?.addEventListener("click", () => startRotateSelectionSession());
  $("#quickPointManager")?.addEventListener("click", () => openPointsManagerBtn?.click());

  $("#zoomExtents").addEventListener("click", () => zoomExtents());
  $("#zoomAllAndCenter").addEventListener("click", () => {
    history.push("center");
    const rect = canvas.getBoundingClientRect();
    view.panX = rect.width * 0.5;
    view.panY = rect.height * 0.5;
    setStatus("Centered view on (0,0).", "ok");
  });

  $("#clearSelection").addEventListener("click", () => clearSelection());
  $("#rotateSelectionReference").addEventListener("click", () => startRotateSelectionSession());
  $("#clearConstruction").addEventListener("click", () => {
    construction.startPointId = null;
    setStatus("Construction cleared.", "");
  });
  $("#deleteSelected").addEventListener("click", () => doDeleteSelected());

  function clearSelection() {
    selectedPointIds = [];
    selectedPointId = null;
    selectedLines = [];
    lastSelectedLineId = null;
    updatePointEditorFromSelection();
    schedulePointsTableRender();
    setStatus("Selection cleared.", "");
  }

  function rememberLastUnlockedEntity(type, id, isUnlocked) {
    if (isUnlocked) {
      lastUnlockedEntity = { type, id };
      return;
    }
    if (lastUnlockedEntity?.type === type && lastUnlockedEntity?.id === id) {
      lastUnlockedEntity = null;
      pendingEscapeLockEntity = null;
    }
  }

  function lockLastUnlockedEntityFromEscape() {
    if (!lastUnlockedEntity) return false;
    const { type, id } = lastUnlockedEntity;

    if (type === "point") {
      const p = points.get(id);
      if (!p || !isMovable(p.movable)) return false;
      history.push("lock point by escape");
      p.movable = false;
      setStatus(`Locked point ${p.num} via Escape.`, "ok");
    } else if (type === "line") {
      const ln = lines.get(id);
      if (!ln || !isMovable(ln.movable)) return false;
      history.push("lock line by escape");
      ln.movable = false;
      setStatus(`Locked line ${ln.id} via Escape.`, "ok");
    } else {
      return false;
    }

    lastUnlockedEntity = null;
    pendingEscapeLockEntity = null;
    schedulePointsTableRender();
    return true;
  }

  function hasSelection() {
    return selectedPointIds.length > 0 || selectedLines.length > 0;
  }

  function cancelActiveCanvasCommand() {
    let canceled = false;

    if (rotateSelectionSession.active) {
      cancelRotateSelectionSession(true);
      canceled = true;
    }

    if (lineIntersectionCommandSession.active) {
      stopLineIntersectionCommand();
      canceled = true;
    }

    if (construction.startPointId !== null) {
      construction.startPointId = null;
      canceled = true;
    }

    if (tool !== "select" && tool !== "pan") {
      setTool("select");
      canceled = true;
    }

    if (canceled) {
      setStatus("Command canceled. Selection kept (right-click again to clear selection).", "warn");
    }

    return canceled;
  }

  function runCanvasCancelOrClearAction({ trigger = "generic" } = {}) {
    if (modalIsOpen()) return;
    if (cancelActiveCanvasCommand()) {
      pendingEscapeLockEntity = null;
      return;
    }
    if (hasSelection()) {
      clearSelection();
      pendingEscapeLockEntity = null;
      return;
    }

    if (trigger === "escape" && lastUnlockedEntity) {
      const sameEntityPending = pendingEscapeLockEntity
        && pendingEscapeLockEntity.type === lastUnlockedEntity.type
        && pendingEscapeLockEntity.id === lastUnlockedEntity.id;

      if (sameEntityPending) {
        lockLastUnlockedEntityFromEscape();
      } else {
        pendingEscapeLockEntity = { ...lastUnlockedEntity };
        setStatus("Press Escape again to lock the last unlocked point/line.", "warn");
      }
      return;
    }

    pendingEscapeLockEntity = null;
  }

  function doDeleteSelected() {
    const hasPts = selectedPointIds.length > 0;
    const hasLns = selectedLines.length > 0;
    if (!hasPts && !hasLns) { setStatus("Nothing selected.", "warn"); return; }

    history.push("delete selected");

    const pointIds = [...selectedPointIds];
    const lineIds = [...new Set(selectedLines.map(s => s.lineId))];

    clearSelection();

    for (const pid of pointIds) deletePoint(pid);
    for (const lid of lineIds) if (lines.has(lid)) deleteLine(lid);

    setStatus(`Deleted ${pointIds.length} point(s) and ${lineIds.length} line(s) (where applicable).`, "warn");
  }

  $("#focusSelected").addEventListener("click", () => {
    const rect = canvas.getBoundingClientRect();
    const cx = rect.width*0.5, cy = rect.height*0.5;
    if (selectedPointId && points.has(selectedPointId)) {
      history.push("focus point");
      const p = points.get(selectedPointId);
      view.panX = cx - p.x*view.scale;
      view.panY = cy + p.y*view.scale;
      setStatus("Centered on selected point.", "ok");
      return;
    }
    if (lastSelectedLineId && lines.has(lastSelectedLineId)) {
      const ln = lines.get(lastSelectedLineId);
      const a = points.get(ln.a), b = points.get(ln.b);
      if (a && b) {
        history.push("focus line");
        const mx = (a.x+b.x)/2, my=(a.y+b.y)/2;
        view.panX = cx - mx*view.scale;
        view.panY = cy + my*view.scale;
        setStatus("Centered on selected line.", "ok");
        return;
      }
    }
    setStatus("Nothing to center on.", "warn");
  });

  // -------------------------
  // Modal (Points Manager)
  // -------------------------
  function modalIsOpen(){
    return !modal.classList.contains("hidden") || !connectLinesModal.classList.contains("hidden");
  }

  function askConnectLinesOrder() {
    return new Promise((resolve) => {
      connectLinesModal.classList.remove("hidden");
      connectLinesModal.setAttribute("aria-hidden", "false");

      function cleanup(choice) {
        connectLinesModal.classList.add("hidden");
        connectLinesModal.setAttribute("aria-hidden", "true");
        connectLinesSequentialBtn.removeEventListener("click", onSequential);
        connectLinesByDistanceBtn.removeEventListener("click", onByDistance);
        window.removeEventListener("keydown", onKeydown);
        resolve(choice);
      }

      const onSequential = () => cleanup("sequential");
      const onByDistance = () => cleanup("distance");
      const onKeydown = (e) => {
        if (e.key === "Escape") {
          e.preventDefault();
          cleanup("sequential");
        }
      };

      connectLinesSequentialBtn.addEventListener("click", onSequential);
      connectLinesByDistanceBtn.addEventListener("click", onByDistance);
      window.addEventListener("keydown", onKeydown);
      connectLinesSequentialBtn.focus();
    });
  }

  function openModal() {
    modal.classList.remove("hidden");
    modal.setAttribute("aria-hidden","false");
    closePointsManagerBtn.disabled = false;

    if (!modalWindow.style.left || !modalWindow.style.top) {
      const vw = window.innerWidth, vh = window.innerHeight;
      const w = Math.min(1100, vw - 36);
      const h = Math.min(640, vh - 36);
      modalWindow.style.width = w + "px";
      modalWindow.style.height = h + "px";
      modalWindow.style.left = Math.max(18, (vw - w)/2) + "px";
      modalWindow.style.top = Math.max(18, (vh - h)/2) + "px";
    }

    schedulePointsTableRender();
    updateCounts();
    $("#ptFilter").focus();
  }

  function closeModal() {
    modal.classList.add("hidden");
    modal.setAttribute("aria-hidden","true");
    closePointsManagerBtn.disabled = true;
  }

  openPointsManagerBtn.addEventListener("click", openModal);
  closePointsManagerBtn.addEventListener("click", closeModal);
  modalClose.addEventListener("click", closeModal);

  modal.addEventListener("mousedown", (e) => {
    if (e.target === modal) closeModal();
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && modalIsOpen() && !isEditableTarget(e.target)) {
      e.preventDefault();
      closeModal();
    }
  });

  let modalDrag = null;
  modalHeader.addEventListener("mousedown", (e) => {
    if (e.target.closest("button") || isEditableTarget(e.target)) return;
    e.preventDefault();
    const rect = modalWindow.getBoundingClientRect();
    modalDrag = {
      offX: e.clientX - rect.left,
      offY: e.clientY - rect.top
    };
  });
  window.addEventListener("mousemove", (e) => {
    if (!modalDrag) return;
    const vw = window.innerWidth, vh = window.innerHeight;
    const r = modalWindow.getBoundingClientRect();
    let left = e.clientX - modalDrag.offX;
    let top = e.clientY - modalDrag.offY;
    left = clamp(left, 10 - r.width + 80, vw - 80);
    top = clamp(top, 10, vh - 60);
    modalWindow.style.left = left + "px";
    modalWindow.style.top = top + "px";
  });
  window.addEventListener("mouseup", ()=>{ modalDrag = null; });

  // -------------------------
  // Point editor panel
  // -------------------------
  function parseCpfInstruments(value = "") {
    const raw = String(value ?? "").trim();
    if (!raw) return [];
    const normalized = raw.replace(/^CPNFS?:\s*/i, "");
    const parts = normalized
      .split(/\.\.\.|[,;|\n]+/)
      .map((item) => item.trim())
      .filter(Boolean);
    return [...new Set(parts)];
  }

  function buildCpfInstrumentUrl(instrument) {
    return ADA_CPF_PDF_BASE + encodeURIComponent(String(instrument).trim()) + ".pdf";
  }

  function updatePointInspectorFromSelection() {
    pointInspector.innerHTML = "";
    const p = selectedPointId ? points.get(selectedPointId) : null;
    if (!p) {
      pointInspector.textContent = "Select one point to inspect point details.";
      return;
    }
    const rows = [
      ["Point", p.num],
      ["X", p.x],
      ["Y", p.y],
      ["Z", p.z],
      ["Code", p.code || "—"]
    ];
    for (const [label, value] of rows) {
      const row = document.createElement("div");
      row.className = "inspectorRow";
      const left = document.createElement("span");
      left.textContent = label;
      const right = document.createElement("b");
      right.textContent = String(value);
      row.append(left, right);
      pointInspector.appendChild(row);
    }

    const cpfInstruments = parseCpfInstruments(p.notes);
    const cpfRow = document.createElement("div");
    cpfRow.className = "inspectorRow";
    const cpfLabel = document.createElement("span");
    cpfLabel.textContent = "CP&F";
    const cpfValue = document.createElement("b");
    cpfValue.textContent = cpfInstruments.length ? cpfInstruments.join(", ") : "None";
    cpfRow.append(cpfLabel, cpfValue);
    pointInspector.appendChild(cpfRow);

    if (cpfInstruments.length) {
      const links = document.createElement("div");
      links.className = "inspectorLinks";
      for (const instrument of cpfInstruments) {
        const a = document.createElement("a");
        a.href = buildCpfInstrumentUrl(instrument);
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = `Open ${instrument}`;
        links.appendChild(a);
      }
      pointInspector.appendChild(links);
    }
  }

  function updatePointEditorFromSelection() {
    const p = selectedPointId ? points.get(selectedPointId) : null;
    if (p) {
      $("#ptNum").value = p.num;
      $("#ptX").value = p.x;
      $("#ptY").value = p.y;
      $("#ptZ").value = p.z;
      $("#ptCode").value = p.code;
      $("#ptNotes").value = p.notes;
    } else {
      $("#ptX").value = "";
      $("#ptY").value = "";
    }
    updatePointInspectorFromSelection();
  }

  $("#applyPoint").addEventListener("click", () => {
    if (!selectedPointId || !points.has(selectedPointId)) {
      setStatus("Select a point to apply edits.", "warn");
      return;
    }
    const p = points.get(selectedPointId);

    const proposedNum = String($("#ptNum").value || p.num).trim();
    if (proposedNum !== p.num && pointNumberExists(proposedNum, p.id)) {
      setStatus(`Point number ${proposedNum} already exists.`, "warn");
      return;
    }

    history.push("edit point");

    p.num = proposedNum;
    p.x = parseNum($("#ptX").value, p.x);
    p.y = parseNum($("#ptY").value, p.y);
    p.z = parseNum($("#ptZ").value, p.z);
    p.code = String($("#ptCode").value ?? p.code);
    p.notes = String($("#ptNotes").value ?? p.notes);

    schedulePointsTableRender();
    setStatus(`Updated point ${p.num}.`, "ok");
    updateCounts();
  });

  // -------------------------
  // Zoom extents
  // -------------------------
  function zoomExtents(options = {}) {
    const { skipHistory = false, silent = false } = options;
    if (points.size === 0) {
      if (!silent) setStatus("No points to zoom to.", "warn");
      return false;
    }
    if (!skipHistory) history.push("zoom extents");
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const p of points.values()) {
      minX = Math.min(minX, p.x);
      minY = Math.min(minY, p.y);
      maxX = Math.max(maxX, p.x);
      maxY = Math.max(maxY, p.y);
    }
    const rect = canvas.getBoundingClientRect();
    const pad = 60;
    const w = Math.max(1, rect.width - pad*2);
    const h = Math.max(1, rect.height - pad*2);

    const dx = maxX - minX;
    const dy = maxY - minY;

    const safeDx = dx < EPS ? 1 : dx;
    const safeDy = dy < EPS ? 1 : dy;

    const scaleX = w / safeDx;
    const scaleY = h / safeDy;
    const newScale = clamp(Math.min(scaleX, scaleY) * 0.95, MIN_SCALE, MAX_SCALE);

    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;

    view.scale = newScale;
    view.panX = rect.width * 0.5 - cx * view.scale;
    view.panY = rect.height * 0.5 + cy * view.scale;

    if (!silent) {
      setStatus(`Zoomed to extents.\nX: [${fmt(minX)}, ${fmt(maxX)}]\nY: [${fmt(minY)}, ${fmt(maxY)}]`, "ok");
    }
    return true;
  }

  // -------------------------
  // CSV import / export
  // -------------------------
  function parseCSV(text) {
    const rows = [];
    let i=0, field="", row=[], inQuotes=false;

    const pushField = () => { row.push(field); field=""; };
    const pushRow = () => { rows.push(row); row=[]; };

    while (i < text.length) {
      const c = text[i];
      if (inQuotes) {
        if (c === '"') {
          if (text[i+1] === '"') { field += '"'; i+=2; continue; }
          inQuotes = false; i++; continue;
        } else {
          field += c; i++; continue;
        }
      } else {
        if (c === '"') { inQuotes = true; i++; continue; }
        if (c === ',') { pushField(); i++; continue; }
        if (c === '\n') { pushField(); pushRow(); i++; continue; }
        if (c === '\r') { i++; continue; }
        field += c; i++; continue;
      }
    }
    pushField();
    pushRow();
    if (rows.length && rows[rows.length-1].every(v => String(v).trim()==="")) rows.pop();
    return rows;
  }
  function normalizeHeader(h) {
    return String(h||"").trim().toLowerCase().replace(/\s+/g,"");
  }
  function csvEscape(v) {
    const s = String(v ?? "");
    if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  }

  // ADDED: Swap all points X/Y (undoable)
  $("#swapXYAll").addEventListener("click", () => {
    if (points.size === 0) { setStatus("No points to swap.", "warn"); return; }
    history.push("swap x y all");
    for (const p of points.values()) {
      const t = p.x;
      p.x = p.y;
      p.y = t;
    }
    schedulePointsTableRender();
    updatePointEditorFromSelection();
    setStatus("Swapped X↔Y for ALL points. (Undo available)", "ok");
  });

  function importCsvText(text, sourceLabel = "CSV import") {
    const rows = parseCSV(text);
    if (!rows.length) { setStatus("CSV appears empty.", "warn"); return false; }

    history.push("csv import");

    let startRow = 0;
    let idx = { num:0, x:1, y:2, z:3, code:4, notes:5 };
    const h = rows[0].map(normalizeHeader);
    const headerLikely = h.includes("number") || h.includes("num") || h.includes("x") || h.includes("y") || h.includes("northing") || h.includes("easting") || h.includes("n") || h.includes("e");
    if (headerLikely) {
      startRow = 1;
      const map = new Map(h.map((v,i)=>[v,i]));
      const pick = (...names)=> {
        for (const n of names) if (map.has(n)) return map.get(n);
        return null;
      };
      idx.num = pick("number","num","pt","point","pointnumber") ?? 0;
      idx.x = pick("x","e","east","easting") ?? 1;
      idx.y = pick("y","n","north","northing") ?? 2;
      idx.z = pick("z","elev","elevation") ?? 3;
      idx.code = pick("code","desc","description") ?? 4;
      idx.notes = pick("notes","note","comments","comment") ?? 5;
    }

    const mode = $("#importMode").value;
    const coordOrder = $("#csvCoordOrder").value; // "xy" | "yx" (used ONLY when header is absent)

    const byNum = new Map();
    for (const p of points.values()) byNum.set(String(p.num), p.id);

    let added=0, updated=0, skipped=0, renamed=0;
    let swappedApplied = 0;

    for (let r = startRow; r < rows.length; r++) {
      const row = rows[r];
      const numRaw = (row[idx.num] ?? "").toString().trim();
      const xRaw = row[idx.x];
      const yRaw = row[idx.y];
      if (!numRaw || xRaw==null || yRaw==null) { skipped++; continue; }

      let x = Number(String(xRaw).trim());
      let y = Number(String(yRaw).trim());
      if (!Number.isFinite(x) || !Number.isFinite(y)) { skipped++; continue; }

      // FIX: root cause for headerless N,E files
      // If there is NO real header and user says columns are Y,X (N,E),
      // then swap parsed values so internal point data remains x=easting, y=northing.
      if (!headerLikely && coordOrder === "yx") {
        const t = x; x = y; y = t;
        swappedApplied++;
      }

      const z = parseNum(row[idx.z], 0);
      const code = String(row[idx.code] ?? "");
      const notes = String(row[idx.notes] ?? "");

      let num = numRaw;

      if (byNum.has(num)) {
        if (mode === "merge") {
          const pid = byNum.get(num);
          const p = points.get(pid);
          p.x = x; p.y = y; p.z = z; p.code = code; p.notes = notes;
          updated++;
          continue;
        }
        if (mode === "skip") { skipped++; continue; }
        if (mode === "rename") {
          const open = nextOpenPointNumber(1);
          num = String(open);
          renamed++;
        }
      }

      const pid = addPoint({ num, x, y, z, code, notes, movable:false });
      byNum.set(String(num), pid);
      added++;
    }

    setStatus(`${sourceLabel} done.
Added: ${added}
Updated: ${updated}
Renamed: ${renamed}
Skipped: ${skipped}
Coord-swap applied (headerless only): ${swappedApplied}`, "ok");

    schedulePointsTableRender();
    if ($("#autoZoomAfterImport").checked) zoomExtents();
    return true;
  }

  function tryImportPointforgePayload() {
    const params = new URLSearchParams(window.location.search);
    if (params.get("source") !== "pointforge") return false;

    const raw = localStorage.getItem(POINTFORGE_IMPORT_STORAGE_KEY);
    if (!raw) {
      setStatus("PointForge launch detected, but no import payload was found in local storage.", "warn");
      return false;
    }

    try {
      const payload = JSON.parse(raw);
      if (!payload?.csv) {
        setStatus("PointForge payload was invalid (missing CSV content).", "warn");
        return false;
      }
      importCsvText(payload.csv, "PointForge import");
      const aligned = syncViewToGeoreference(payload);
      setMapLayerEnabled(true);
      if (aligned && mapLayerState.enabled) {
        syncMapToView(true);
      }
      localStorage.removeItem(POINTFORGE_IMPORT_STORAGE_KEY);
      return true;
    } catch (_err) {
      setStatus("PointForge payload could not be parsed.", "warn");
      return false;
    }
  }


  function projectFileStorageKey(projectId) {
    return `${PROJECT_FILE_STORAGE_PREFIX}:${projectId}`;
  }

  function projectLastDrawingStorageKey(projectId) {
    return `${PROJECT_LAST_DRAWING_STORAGE_PREFIX}:${projectId}`;
  }

  function saveLastOpenedProjectDrawing(projectId, storageKey) {
    if (!projectId || !storageKey) return;
    localStorage.setItem(projectLastDrawingStorageKey(projectId), storageKey);
  }

  function loadLastOpenedProjectDrawing(projectId) {
    if (!projectId) return "";
    return String(localStorage.getItem(projectLastDrawingStorageKey(projectId)) || "").trim();
  }

  function drawingStorageKey(projectId, drawingId) {
    return `${PROJECT_DRAWING_STORAGE_PREFIX}:${projectId}:${drawingId}`;
  }

  function normalizeDrawingId(name = "") {
    const slug = String(name || "")
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
    return slug || `drawing-${Date.now()}`;
  }

  function getSerializableStateObject() {
    return JSON.parse(serializeState());
  }

  function markDrawingAsSaved() {
    lastSavedDrawingSnapshot = serializeState();
  }

  function hasUnsavedDrawingChanges() {
    if (!lastSavedDrawingSnapshot) return false;
    return serializeState() !== lastSavedDrawingSnapshot;
  }

  function loadStoredDrawingRecord(storageKey) {
    if (!storageKey) return null;
    try {
      const raw = localStorage.getItem(storageKey);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed?.versions)) return null;
      return parsed;
    } catch {
      return null;
    }
  }

  function materializeDrawingVersion(record, versionIndex = -1) {
    if (!record?.versions?.length) return null;
    const targetIndex = versionIndex >= 0 ? Math.min(versionIndex, record.versions.length - 1) : record.versions.length - 1;
    let state = deepClone(record.versions[0]?.baseState || null);
    if (!state) return null;
    for (let i = 1; i <= targetIndex; i += 1) {
      state = applyStateDiff(state, record.versions[i]?.diffFromPrevious);
    }
    if (!state.mapGeoreference) {
      const fallbackGeoreference = sanitizeMapGeoreference(record.latestMapGeoreference);
      if (fallbackGeoreference) state.mapGeoreference = fallbackGeoreference;
    }
    return state;
  }

  function restoreDrawingVersion(storageKey, versionIndex = -1) {
    const record = loadStoredDrawingRecord(storageKey);
    if (!record) return false;
    const state = materializeDrawingVersion(record, versionIndex);
    if (!state) return false;
    restoreState(JSON.stringify(state));
    markDrawingAsSaved();
    return true;
  }

  function upsertProjectDrawingResource({ projectId, drawingId, drawingName, storageKey, versionCount, latestVersionId, latestMapGeoreference }) {
    if (!projectId) return;
    const key = projectFileStorageKey(projectId);
    const raw = localStorage.getItem(key);
    if (!raw) return;
    let projectFile;
    try {
      projectFile = JSON.parse(raw);
    } catch {
      return;
    }
    if (!Array.isArray(projectFile?.folders)) return;
    const drawingsFolder = projectFile.folders.find((folder) => folder.key === "drawings");
    if (!drawingsFolder) return;
    if (!Array.isArray(drawingsFolder.index)) drawingsFolder.index = [];
    const resourceId = `linesmith-${drawingId}`;
    const existing = drawingsFolder.index.find((entry) => entry.id === resourceId);
    const next = {
      id: resourceId,
      folder: "drawings",
      title: drawingName,
      exportFormat: "json",
      reference: {
        type: "local-storage",
        value: storageKey,
        resolverHint: "linesmith-drawing-history",
        metadata: {
          drawingId,
          drawingName,
          versionCount,
          latestVersionId,
          latestSavedAt: new Date().toISOString(),
          latestMapGeoreference,
        },
      },
    };
    if (existing) Object.assign(existing, next);
    else drawingsFolder.index.push(next);
    drawingsFolder.index.sort((a, b) => {
      const aSaved = Date.parse(a?.reference?.metadata?.latestSavedAt || a?.reference?.metadata?.savedAt || "");
      const bSaved = Date.parse(b?.reference?.metadata?.latestSavedAt || b?.reference?.metadata?.savedAt || "");
      const aValue = Number.isFinite(aSaved) ? aSaved : Number.NEGATIVE_INFINITY;
      const bValue = Number.isFinite(bSaved) ? bSaved : Number.NEGATIVE_INFINITY;
      return bValue - aValue;
    });
    localStorage.setItem(key, JSON.stringify(projectFile));
  }

  function saveDrawingToProject() {
    if (!activeProjectId) {
      setStatus("Open LineSmith from an active project to save drawing history.", "warn");
      return false;
    }
    const drawingNameInput = $("#drawingName");
    const hint = $("#drawingSaveHint");
    let drawingName = String(drawingNameInput?.value || "").trim();
    if (!drawingName) {
      const response = window.prompt("Name this drawing before saving:", "Boundary Base Map");
      drawingName = String(response || "").trim();
      if (!drawingName) {
        setStatus("Enter a drawing name before saving.", "warn");
        return false;
      }
      if (drawingNameInput) drawingNameInput.value = drawingName;
    }

    const drawingId = normalizeDrawingId(drawingName);
    const storageKey = drawingStorageKey(activeProjectId, drawingId);
    const now = new Date().toISOString();
    const currentState = getSerializableStateObject();
    const existing = loadStoredDrawingRecord(storageKey);

    let record;
    if (!existing || !existing.versions?.length) {
      record = {
        schemaVersion: "1.0.0",
        projectId: activeProjectId,
        projectName: activeProjectName,
        drawingId,
        drawingName,
        createdAt: now,
        updatedAt: now,
        versions: [
          {
            versionId: `v-${Date.now()}`,
            savedAt: now,
            label: drawingName,
            baseState: currentState,
          },
        ],
      };
    } else {
      const prevState = materializeDrawingVersion(existing, -1);
      const diff = diffState(prevState, currentState);
      const changePatch = diff === undefined ? {} : diff;
      record = existing;
      record.updatedAt = now;
      record.drawingName = drawingName;
      record.versions.push({
        versionId: `v-${Date.now()}`,
        savedAt: now,
        label: drawingName,
        diffFromPrevious: changePatch,
      });
    }
    record.latestMapGeoreference = sanitizeMapGeoreference(currentState.mapGeoreference);

    localStorage.setItem(storageKey, JSON.stringify(record));
    activeDrawingStorageKey = storageKey;
    saveLastOpenedProjectDrawing(activeProjectId, storageKey);
    upsertProjectDrawingResource({
      projectId: activeProjectId,
      drawingId,
      drawingName,
      storageKey,
      versionCount: record.versions.length,
      latestVersionId: record.versions[record.versions.length - 1]?.versionId || null,
      latestMapGeoreference: record.latestMapGeoreference,
    });
    if (hint) hint.textContent = `Saved ${record.versions.length} version(s) for "${drawingName}" in project ${activeProjectId}.`;
    setStatus(`Saved drawing "${drawingName}" to project history (${record.versions.length} version${record.versions.length === 1 ? "" : "s"}).`, "ok");
    markDrawingAsSaved();
    return true;
  }

  function promptRestoreDrawingVersion() {
    const storageKey = activeDrawingStorageKey;
    if (!storageKey) {
      setStatus("No project-linked drawing has been loaded yet.", "warn");
      return;
    }
    const record = loadStoredDrawingRecord(storageKey);
    if (!record?.versions?.length) {
      setStatus("No saved versions were found for this drawing.", "warn");
      return;
    }
    const options = record.versions
      .map((version, index) => `${index + 1}: ${version.savedAt}`)
      .join("\n");
    const response = window.prompt(`Restore which version for ${record.drawingName}?\n${options}\nEnter version number:`, String(record.versions.length));
    if (response === null) return;
    const parsed = Number(response);
    if (!Number.isFinite(parsed) || parsed < 1 || parsed > record.versions.length) {
      setStatus("Invalid version number.", "warn");
      return;
    }
    history.push("restore drawing version");
    const ok = restoreDrawingVersion(storageKey, parsed - 1);
    if (!ok) {
      setStatus("Failed to restore the selected drawing version.", "warn");
      return;
    }
    setStatus(`Restored drawing version ${parsed} of ${record.versions.length}.`, "ok");
  }

  function tryImportProjectBrowserDrawingPayload() {
    if (queryParams.get("source") !== "project-browser-drawing") return false;
    const raw = localStorage.getItem(PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY);
    if (!raw) {
      setStatus("Project Browser drawing launch detected, but payload is missing.", "warn");
      return false;
    }
    try {
      const payload = JSON.parse(raw);
      const storageKey = payload?.storageKey;
      if (!storageKey) {
        setStatus("Project Browser drawing payload was invalid.", "warn");
        return false;
      }
      const restored = restoreDrawingVersion(storageKey, -1);
      if (!restored) {
        setStatus("Drawing file could not be opened from project storage.", "warn");
        return false;
      }
      activeDrawingStorageKey = storageKey;
    saveLastOpenedProjectDrawing(activeProjectId, storageKey);
      const drawingName = String(payload?.drawingName || "").trim();
      if (drawingName) $("#drawingName").value = drawingName;
      localStorage.removeItem(PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY);
      setStatus(`Opened drawing "${drawingName || "Project Drawing"}" from Project Browser.`, "ok");
      return true;
    } catch {
      setStatus("Project Browser drawing payload could not be parsed.", "warn");
      return false;
    }
  }


  function tryRestoreLastOpenedProjectDrawing() {
    if (queryParams.get("source")) return false;
    if (!activeProjectId) return false;
    const storageKey = loadLastOpenedProjectDrawing(activeProjectId);
    if (!storageKey) return false;
    const restored = restoreDrawingVersion(storageKey, -1);
    if (!restored) return false;
    activeDrawingStorageKey = storageKey;
    const record = loadStoredDrawingRecord(storageKey);
    const drawingName = String(record?.drawingName || "").trim();
    if (drawingName) $("#drawingName").value = drawingName;
    setStatus(`Opened last drawing for project ${activeProjectName || activeProjectId}.`, "ok");
    return true;
  }

  $("#saveDrawingToProject").addEventListener("click", saveDrawingToProject);
  $("#restoreDrawingVersion").addEventListener("click", promptRestoreDrawingVersion);

  $("#csvIn").addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const text = await f.text();
    importCsvText(text);
    $("#csvIn").value = "";
  });

  $("#exportCsv").addEventListener("click", () => {
    const rows = [];
    rows.push(["number","x","y","z","code","notes"]);
    const sorted = Array.from(points.values()).sort((a,b)=>Number(a.num)-Number(b.num));
    for (const p of sorted) rows.push([p.num, p.x, p.y, p.z, p.code, p.notes].map(v => csvEscape(v)));
    const csv = rows.map(r=>r.join(",")).join("\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "points.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    setStatus("Exported points.csv", "ok");
  });

  // -------------------------
  // Points table (modal) — inline editing
  // -------------------------
  let pointsSortMode = "num";
  let pointsTableDirty = true;
  let pointsTableRaf = null;

  function schedulePointsTableRender() {
    pointsTableDirty = true;
    if (pointsTableRaf) return;
    pointsTableRaf = requestAnimationFrame(() => {
      pointsTableRaf = null;
      if (pointsTableDirty) renderPointsTable();
      pointsTableDirty = false;
    });
  }

  function getFilteredSortedPoints() {
    const filter = String($("#ptFilter").value || "").trim().toLowerCase();
    let arr = Array.from(points.values());

    if (filter) {
      arr = arr.filter(p => {
        const hay = `${p.num} ${p.code} ${p.notes}`.toLowerCase();
        return hay.includes(filter);
      });
    }

    if (pointsSortMode === "num") arr.sort((a,b)=> (Number(a.num)||0) - (Number(b.num)||0));
    else if (pointsSortMode === "id") arr.sort((a,b)=>a.id-b.id);
    else if (pointsSortMode === "code") arr.sort((a,b)=>String(a.code).localeCompare(String(b.code)));
    return arr;
  }

  function renderPointsTable() {
    if (!modalIsOpen()) return;

    const tbody = $("#pointsTbody");
    const frag = document.createDocumentFragment();
    tbody.innerHTML = "";

    const arr = getFilteredSortedPoints();
    for (const p of arr) {
      const tr = document.createElement("tr");
      if (selectedPointIds.includes(p.id)) tr.classList.add("sel");

      const cellInput = (value, field) => {
        const td = document.createElement("td");
        const inp = document.createElement("input");
        inp.className = "cellInput";
        inp.value = value;
        inp.dataset.pid = p.id;
        inp.dataset.field = field;
        inp.addEventListener("keydown", (e) => e.stopPropagation());
        inp.addEventListener("input", onPointCellInput);
        td.appendChild(inp);
        return { td, inp };
      };

      const numCell = cellInput(p.num, "num");
      const xCell = cellInput(p.x, "x");
      const yCell = cellInput(p.y, "y");
      const zCell = cellInput(p.z, "z");
      const codeCell = cellInput(p.code, "code");
      const notesCell = cellInput(p.notes, "notes");

      const tdAct = document.createElement("td");
      tdAct.style.whiteSpace = "nowrap";

      const btnSel = document.createElement("button");
      btnSel.className = "cellBtn";
      btnSel.textContent = "Select";
      btnSel.addEventListener("click", (e) => {
        e.preventDefault(); e.stopPropagation();
        selectedPointIds = [p.id];
        selectedPointId = p.id;
        selectedLines = [];
        lastSelectedLineId = null;
        updatePointEditorFromSelection();
        schedulePointsTableRender();
        setStatus(`Selected point ${p.num}.`, "ok");
      });

      const btnMov = document.createElement("button");
      btnMov.className = "cellBtn";
      btnMov.style.marginLeft = "8px";
      btnMov.textContent = isMovable(p.movable) ? "Lock" : "Unlock";
      btnMov.addEventListener("click", (e) => {
        e.preventDefault(); e.stopPropagation();
        history.push("toggle point movable");
        p.movable = !isMovable(p.movable);
        schedulePointsTableRender();
        setStatus(`Point ${p.num} is now ${isMovable(p.movable) ? "MOVABLE" : "LOCKED"}.`, "ok");
      });

      const btnDel = document.createElement("button");
      btnDel.className = "cellBtn danger";
      btnDel.style.marginLeft = "8px";
      btnDel.textContent = "Delete";
      btnDel.addEventListener("click", (e) => {
        e.preventDefault(); e.stopPropagation();
        history.push("delete point");
        deletePoint(p.id);
        setStatus(`Deleted point ${p.num}.`, "warn");
      });

      tdAct.appendChild(btnSel);
      tdAct.appendChild(btnMov);
      tdAct.appendChild(btnDel);

      tr.appendChild(numCell.td);
      tr.appendChild(xCell.td);
      tr.appendChild(yCell.td);
      tr.appendChild(zCell.td);
      tr.appendChild(codeCell.td);
      tr.appendChild(notesCell.td);
      tr.appendChild(tdAct);

      frag.appendChild(tr);

      if (pointNumberExists(numCell.inp.value, p.id)) numCell.inp.classList.add("bad");
    }

    tbody.appendChild(frag);
    updateSelectionHUD();
    updateCounts();
  }

  let tableEditPushed = false;
  let tableEditTimer = null;

  function pushTableEditHistoryOnce() {
    if (tableEditPushed) return;
    tableEditPushed = true;
    history.push("edit point table");
    clearTimeout(tableEditTimer);
    tableEditTimer = setTimeout(()=>{ tableEditPushed = false; }, 900);
  }

  function onPointCellInput(e) {
    const inp = e.target;
    const pid = Number(inp.dataset.pid);
    const field = inp.dataset.field;
    const p = points.get(pid);
    if (!p) return;

    pushTableEditHistoryOnce();

    if (field === "num") {
      const raw = String(inp.value).trim();
      if (!raw || pointNumberExists(raw, p.id)) { inp.classList.add("bad"); return; }
      inp.classList.remove("bad");
      p.num = raw;
      if (selectedPointId === pid) $("#ptNum").value = raw;
      updateCounts();
      return;
    }

    if (field === "x" || field === "y" || field === "z") {
      const val = Number(String(inp.value).trim());
      if (!Number.isFinite(val)) { inp.classList.add("bad"); return; }
      inp.classList.remove("bad");
      p[field] = val;
      if (selectedPointId === pid) {
        if (field === "x") $("#ptX").value = val;
        if (field === "y") $("#ptY").value = val;
        if (field === "z") $("#ptZ").value = val;
      }
      return;
    }

    if (field === "code" || field === "notes") {
      inp.classList.remove("bad");
      p[field] = String(inp.value);
      if (selectedPointId === pid) {
        if (field === "code") $("#ptCode").value = p.code;
        if (field === "notes") $("#ptNotes").value = p.notes;
      }
      return;
    }
  }

  $("#ptFilter").addEventListener("input", () => schedulePointsTableRender());
  $("#refreshPoints").addEventListener("click", () => schedulePointsTableRender());
  $("#sortPoints").addEventListener("click", () => {
    pointsSortMode = (pointsSortMode === "num") ? "code" : (pointsSortMode === "code" ? "id" : "num");
    $("#sortPoints").textContent = `Sort: ${pointsSortMode === "num" ? "Num" : (pointsSortMode === "code" ? "Code" : "ID")}`;
    schedulePointsTableRender();
  });

  // -------------------------
  // Line creation & ops (unchanged behavior)
  // -------------------------
  $("#setStartFromSel").addEventListener("click", () => {
    if (!selectedPointId) { setStatus("Select a start point first.", "warn"); return; }
    construction.startPointId = selectedPointId;
    setStatus(`Start point set to ${points.get(selectedPointId)?.num ?? "?"}.`, "ok");
    syncToolWorkflowToast();
  });

  function clearPointNumberField() { $("#ptNum").value = ""; }

  $("#makeLineDB").addEventListener("click", () => {
    const startId = construction.startPointId ?? selectedPointId;
    if (!startId || !points.has(startId)) {
      setStatus("Select a start point (or click 'Use Selected Point as Start').", "warn");
      return;
    }
    const d = parseNum($("#dist").value, NaN);
    const az = bearingToAzimuthRad($("#bearing").value);
    if (!Number.isFinite(d) || d <= 0) { setStatus("Distance must be a positive number.", "warn"); return; }
    if (az == null) { setStatus("Bearing/Azimuth not recognized.", "warn"); return; }

    history.push("line dist/bearing");

    const sp = points.get(startId);
    const dx = Math.sin(az);
    const dy = Math.cos(az);
    const x2 = sp.x + dx*d;
    const y2 = sp.y + dy*d;

    const num = resolveDesiredPointNumber($("#ptNum").value);
    const z = parseNum($("#ptZ").value, 0);
    const code = String($("#ptCode").value || "");
    const notes = String($("#ptNotes").value || "");
    const pid2 = addPoint({ num, x:x2, y:y2, z, code, notes, movable:false });
    const lid = addLine(startId, pid2, false);

    selectedPointIds = [pid2];
    selectedPointId = pid2;
    selectedLines = [{ lineId: lid, grip: "b", t: 1 }];
    lastSelectedLineId = lid;

    updatePointEditorFromSelection();
    clearPointNumberField();
    setStatus(`Created point ${points.get(pid2).num} and line from ${sp.num}.\nAz: ${azimuthRadToQuadrantString(az)}  Dist: ${d}`, "ok");
    syncToolWorkflowToast();
  });

  async function runLineBetweenSelectedPoints({ returnToSelectionTool = false } = {}) {
    if (selectedPointIds.length < 2) {
      setStatus("Select at least two points (Shift-click to multi-select, or window-drag).", "warn");
      return;
    }
    const ids = selectedPointIds.filter(id => points.has(id));
    if (ids.length < 2) { setStatus("Selected points are invalid.", "warn"); return; }

    function pointComparatorByNumber(aId, bId) {
      const a = points.get(aId);
      const b = points.get(bId);
      const aNumRaw = Number.parseFloat(String(a?.num ?? ""));
      const bNumRaw = Number.parseFloat(String(b?.num ?? ""));
      const aFinite = Number.isFinite(aNumRaw);
      const bFinite = Number.isFinite(bNumRaw);
      if (aFinite && bFinite && aNumRaw !== bNumRaw) return aNumRaw - bNumRaw;
      if (aFinite !== bFinite) return aFinite ? -1 : 1;
      return String(a?.num ?? "").localeCompare(String(b?.num ?? ""), undefined, { numeric: true, sensitivity: "base" });
    }

    function arePointsDirectlyConnected(aId, bId) {
      for (const ln of lines.values()) {
        if ((ln.a === aId && ln.b === bId) || (ln.a === bId && ln.b === aId)) return true;
      }
      return false;
    }

    function getDistanceBetweenPoints(aId, bId) {
      const a = points.get(aId);
      const b = points.get(bId);
      if (!a || !b) return Number.POSITIVE_INFINITY;
      return dist(a.x, a.y, b.x, b.y);
    }

    function shouldSuggestNearestNonConnectedOrder(pointIds) {
      if (pointIds.length <= 2) return false;
      const sequentialIds = [...pointIds].sort(pointComparatorByNumber);
      for (let i = 0; i < sequentialIds.length - 1; i += 1) {
        const currentId = sequentialIds[i];
        const sequentialId = sequentialIds[i + 1];
        const sequentialDistance = getDistanceBetweenPoints(currentId, sequentialId);
        let nearestNonConnectedDistance = Number.POSITIVE_INFINITY;
        for (const candidateId of sequentialIds) {
          if (candidateId === currentId || arePointsDirectlyConnected(currentId, candidateId)) continue;
          const candidateDistance = getDistanceBetweenPoints(currentId, candidateId);
          if (candidateDistance < nearestNonConnectedDistance) nearestNonConnectedDistance = candidateDistance;
        }
        if (Number.isFinite(nearestNonConnectedDistance) && nearestNonConnectedDistance + EPS < sequentialDistance) return true;
      }
      return false;
    }

    function buildNearestNonConnectedOrder(pointIds) {
      if (pointIds.length <= 2) return [...pointIds];
      const order = [pointIds[0]];
      const remaining = new Set(pointIds.slice(1));
      while (remaining.size) {
        const currentId = order[order.length - 1];
        const candidates = [...remaining];
        let bestId = null;
        let bestDistance = Number.POSITIVE_INFINITY;
        for (const candidateId of candidates) {
          if (arePointsDirectlyConnected(currentId, candidateId)) continue;
          const candidateDistance = getDistanceBetweenPoints(currentId, candidateId);
          if (candidateDistance < bestDistance) {
            bestDistance = candidateDistance;
            bestId = candidateId;
          }
        }
        if (bestId == null) {
          for (const candidateId of candidates) {
            const candidateDistance = getDistanceBetweenPoints(currentId, candidateId);
            if (candidateDistance < bestDistance) {
              bestDistance = candidateDistance;
              bestId = candidateId;
            }
          }
        }
        order.push(bestId);
        remaining.delete(bestId);
      }
      return order;
    }

    function createLinesFromOrderedPoints(orderedIds) {
      let created = 0;
      let lastLine = null;
      if (orderedIds.length === 2) {
        lastLine = addLine(orderedIds[0], orderedIds[1], false);
        created = 1;
      } else {
        for (let i = 0; i < orderedIds.length - 1; i += 1) {
          lastLine = addLine(orderedIds[i], orderedIds[i + 1], false);
          created += 1;
        }
      }
      return { created, lastLine };
    }

    let connectIds = ids;
    let connectionLabel = "selection order";
    if (shouldSuggestNearestNonConnectedOrder(ids)) {
      const orderChoice = await askConnectLinesOrder();
      if (orderChoice === "distance") {
        connectIds = buildNearestNonConnectedOrder(ids);
        connectionLabel = "nearest non-connected selected points";
      }
    }

    history.push("line between points");
    const { created, lastLine } = createLinesFromOrderedPoints(connectIds);

    selectedLines = lastLine ? [{ lineId: lastLine, grip:"b", t: 1 }] : [];
    lastSelectedLineId = lastLine;

    const nums = connectIds.map(id => points.get(id)?.num ?? "?");
    setStatus(`Created ${created} line(s) using ${connectionLabel}:\n${nums.join(" → ")}`, "ok");
    if (returnToSelectionTool) setTool("select");
  }

  $("#lineBetweenSelected").addEventListener("click", () => {
    runLineBetweenSelectedPoints();
  });

  function getTwoSelectedLines() {
    if (selectedLines.length < 2) return null;
    const aSel = selectedLines[selectedLines.length - 2];
    const bSel = selectedLines[selectedLines.length - 1];
    const la = lines.get(aSel.lineId);
    const lb = lines.get(bSel.lineId);
    if (!la || !lb) return null;
    const a1 = points.get(la.a), a2 = points.get(la.b);
    const b1 = points.get(lb.a), b2 = points.get(lb.b);
    if (!a1 || !a2 || !b1 || !b2) return null;
    return { aSel, bSel, la, lb, a1, a2, b1, b2 };
  }

  function intersectionPointDefaults() {
    const z = parseNum($("#ptZ").value, 0);
    let code = String($("#ptCode").value || "").trim();
    const notes = String($("#ptNotes").value || "").trim();
    if (!code) code = "INT";
    return { z, code, notes };
  }

  function trimGripFromClickSide(activeSelection, hitParam) {
    if (!Number.isFinite(hitParam)) return activeSelection.grip;
    if (!Number.isFinite(activeSelection?.t)) return activeSelection.grip;
    if (Math.abs(activeSelection.t - hitParam) < 1e-9) return activeSelection.grip;
    return activeSelection.t < hitParam ? "a" : "b";
  }

  $("#extendToIntersect").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) {
      startLineIntersectionCommand("extend");
      return;
    }

    stopLineIntersectionCommand();
    const hit = lineLineIntersection(s.a1, s.a2, s.b1, s.b2);
    if (!hit) { setStatus("Lines are parallel/colinear; no unique intersection.", "warn"); return; }

    const activeSel = s.bSel;
    const ln = lines.get(activeSel.lineId);
    const A = points.get(ln.a), B = points.get(ln.b);
    if (!A || !B) return;

    const t = pointOnLineParam({x:hit.x,y:hit.y}, A, B);
    if (t >= 0 && t <= 1) {
      setStatus("Intersection already lies on the active segment. (Extend does nothing.)", "ok");
      return;
    }

    history.push("extend to intersect (new point)");

    const num = resolveDesiredPointNumber($("#ptNum").value);
    const { z, code, notes } = intersectionPointDefaults();
    const pidNew = addPoint({ num, x: hit.x, y: hit.y, z, code, notes, movable:false });

    if (t < 0) ln.a = pidNew;
    else ln.b = pidNew;

    selectedPointIds = [pidNew];
    selectedPointId = pidNew;
    selectedLines = [{ lineId: ln.id, grip: (t < 0 ? "a" : "b"), t: 0.5 }];
    lastSelectedLineId = ln.id;
    updatePointEditorFromSelection();
    clearPointNumberField();

    setStatus(
      `Extended active line to intersection WITHOUT moving the original endpoint.\n` +
      `Created point ${points.get(pidNew).num} at (${fmt(hit.x)}, ${fmt(hit.y)}).`,
      "ok"
    );
  });

  $("#trimToIntersect").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) {
      startLineIntersectionCommand("trim");
      return;
    }
    stopLineIntersectionCommand();
    const hit = lineLineIntersection(s.a1, s.a2, s.b1, s.b2);
    if (!hit) { setStatus("Lines are parallel/colinear; no unique intersection.", "warn"); return; }

    history.push("trim to intersect");

    const active = s.bSel;
    const ln = lines.get(active.lineId);
    const A = points.get(ln.a), B = points.get(ln.b);
    if (!A || !B) return;
    const hitT = pointOnLineParam({x:hit.x, y:hit.y}, A, B);
    const trimGrip = trimGripFromClickSide(active, hitT);
    const gripPid = (trimGrip === "a") ? ln.a : ln.b;
    const gp = points.get(gripPid);
    gp.x = hit.x; gp.y = hit.y;
    active.grip = trimGrip;

    schedulePointsTableRender();
    setStatus(`Trimmed active line (grip ${trimGrip.toUpperCase()}) to intersection at (${fmt(hit.x)}, ${fmt(hit.y)}).`, "ok");
  });

  $("#pointAtIntersection").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) { setStatus("Select two lines (Shift-click) to create an intersection point.", "warn"); return; }
    const hit = lineLineIntersection(s.a1, s.a2, s.b1, s.b2);
    if (!hit) { setStatus("Lines are parallel/colinear; no unique intersection.", "warn"); return; }

    history.push("create point at intersection");

    const num = resolveDesiredPointNumber($("#ptNum").value);
    const z = parseNum($("#ptZ").value, 0);
    const code = String($("#ptCode").value || "");
    const notes = String($("#ptNotes").value || "");
    const pid = addPoint({ num, x: hit.x, y: hit.y, z, code, notes, movable:false });

    selectedPointIds = [pid];
    selectedPointId = pid;
    selectedLines = [];
    lastSelectedLineId = null;
    updatePointEditorFromSelection();
    clearPointNumberField();

    setStatus(`Created point ${points.get(pid).num} at intersection (${fmt(hit.x)}, ${fmt(hit.y)}).`, "ok");
  });

  $("#trimOverlap").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) { setStatus("Select two colinear overlapping lines (Shift-click).", "warn"); return; }

    const ov = isColinearOverlap(s.a1,s.a2,s.b1,s.b2);
    if (!ov) { setStatus("No colinear overlap detected (or lines not colinear).", "warn"); return; }

    history.push("trim overlap");

    const active = s.bSel;
    const ln = lines.get(active.lineId);
    const pA = points.get(ln.a), pB = points.get(ln.b);
    if (!pA || !pB) return;

    const proj = (p)=> ov.useX ? p.x : p.y;

    const grip = active.grip;
    const gPid = (grip === "a") ? ln.a : ln.b;
    const oPid = (grip === "a") ? ln.b : ln.a;
    const gp = points.get(gPid);
    const op = points.get(oPid);

    const gVal = proj(gp);
    const candidates = [ov.oMin, ov.oMax];

    let best = candidates[0];
    let bestD = Math.abs(gVal - best);
    for (const c of candidates.slice(1)) {
      const d = Math.abs(gVal - c);
      if (d < bestD) { bestD = d; best = c; }
    }

    const denom = (ov.useX ? (op.x - gp.x) : (op.y - gp.y));
    if (Math.abs(denom) < EPS) {
      setStatus("Cannot trim overlap (degenerate line).", "warn");
      return;
    }
    const t = (best - (ov.useX ? gp.x : gp.y)) / denom;
    gp.x = gp.x + t*(op.x - gp.x);
    gp.y = gp.y + t*(op.y - gp.y);

    schedulePointsTableRender();
    setStatus("Trimmed overlap on active line at overlap boundary.", "ok");
  });

  // -------------------------
  // Point on line
  // -------------------------
  $("#makePointOnLine").addEventListener("click", () => {
    if (!lastSelectedLineId || !lines.has(lastSelectedLineId)) {
      setStatus("Select a line first.", "warn");
      return;
    }
    const ln = lines.get(lastSelectedLineId);
    const pa = points.get(ln.a), pb = points.get(ln.b);
    if (!pa || !pb) return;

    const station = parseNum($("#station").value, NaN);
    const offset = parseNum($("#offset").value, 0);
    if (!Number.isFinite(station)) { setStatus("Station must be a number.", "warn"); return; }

    const from = $("#stationFrom").value;
    const A = (from === "a") ? pa : pb;
    const B = (from === "a") ? pb : pa;

    const vx = B.x - A.x, vy = B.y - A.y;
    const L = Math.hypot(vx,vy);
    if (L < EPS) { setStatus("Line is too short.", "warn"); return; }

    history.push("point on line");

    const t = station / L;
    const x = A.x + vx * t;
    const y = A.y + vy * t;

    const nx = -vy / L;
    const ny =  vx / L;

    const x2 = x + nx * offset;
    const y2 = y + ny * offset;

    const num = resolveDesiredPointNumber($("#ptNum").value);
    const z = parseNum($("#ptZ").value, 0);
    const code = String($("#ptCode").value || "");
    const notes = String($("#ptNotes").value || "");
    const pid = addPoint({ num, x:x2, y:y2, z, code, notes, movable:false });

    selectedPointIds = [pid];
    selectedPointId = pid;
    selectedLines = [];
    lastSelectedLineId = null;
    updatePointEditorFromSelection();
    clearPointNumberField();

    setStatus(`Created point ${points.get(pid).num} on line at station ${station} offset ${offset}.`, "ok");
    syncToolWorkflowToast();
  });

  $("#swapLineEnds").addEventListener("click", () => {
    if (!lastSelectedLineId || !lines.has(lastSelectedLineId)) {
      setStatus("Select a line first.", "warn");
      return;
    }
    history.push("swap line ends");
    const ln = lines.get(lastSelectedLineId);
    const tmp = ln.a; ln.a = ln.b; ln.b = tmp;
    setStatus("Swapped line ends A ↔ B.", "ok");
  });

  // -------------------------
  // Canvas interaction
  // -------------------------
  function updateMouseFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
    const w = screenToWorld(mouse.x, mouse.y);
    mouse.wx = w.x;
    mouse.wy = w.y;
  }

  function beginDrag(obj) {
    mouse.drag = true;
    mouse.dragObj = obj;
    mouse.dragStartX = mouse.x;
    mouse.dragStartY = mouse.y;
    mouse.dragStartPanX = view.panX;
    mouse.dragStartPanY = view.panY;
    mouse.dragStartWorldX = mouse.wx;
    mouse.dragStartWorldY = mouse.wy;
  }
  function endDrag() {
    mouse.drag = false;
    mouse.dragObj = null;
  }

  const keys = { space:false, shift:false };

  function toolIsPan() {
    return tool === "pan" || keys.space || mouse.button === 1;
  }

  function clearLongPressTimer() {
    if (mobileInteraction.longPressTimer) {
      window.clearTimeout(mobileInteraction.longPressTimer);
      mobileInteraction.longPressTimer = null;
    }
  }

  function setDrawerOpen(open) {
    if (!appShell) return;
    appShell.classList.toggle("drawerOpen", !!open);
    if (drawerToggle) drawerToggle.textContent = open ? "Close" : "Tools";
  }

  function setPanelCollapsed(collapsed) {
    if (!appShell) return;
    const shouldCollapse = !isMobileViewport() && !!collapsed;
    appShell.classList.toggle("panelCollapsed", shouldCollapse);
    window.requestAnimationFrame(() => {
      resize();
      if (mapLayerState.enabled) syncMapToView(true);
    });
  }

  function isMobileViewport() {
    return window.matchMedia("(max-width: 960px)").matches;
  }

  function updateTouchPoint(e) {
    const rect = canvas.getBoundingClientRect();
    touchGesture.points.set(e.pointerId, {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    });
  }

  function removeTouchPoint(pointerId) {
    touchGesture.points.delete(pointerId);
  }

  function getTouchCenter() {
    const pts = [...touchGesture.points.values()];
    if (!pts.length) return null;
    const sum = pts.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
    return { x: sum.x / pts.length, y: sum.y / pts.length };
  }

  function getTouchDistance() {
    const pts = [...touchGesture.points.values()];
    if (pts.length < 2) return 0;
    return dist(pts[0].x, pts[0].y, pts[1].x, pts[1].y);
  }

  // ADDED: hard-reset keys/drag on blur so Space-pan can't get "stuck"
  window.addEventListener("blur", () => {
    keys.space = false;
    keys.shift = false;
    mouse.down = false;
    endDrag();
  });

  window.addEventListener("keydown", (e) => {
    const typing = isEditableTarget(e.target);

    if (e.code === "Space") {
      keys.space = true;
      if (!typing) e.preventDefault();
    }
    if (e.key === "Shift") keys.shift = true;

    if (!typing && (e.key === "Delete")) {
      e.preventDefault();
      doDeleteSelected();
    }

    if (!typing && e.key === "Escape") {
      e.preventDefault();
      runCanvasCancelOrClearAction({ trigger: "escape" });
    }

    if (!typing && (e.ctrlKey || e.metaKey) && !e.altKey) {
      const key = e.key.toLowerCase();
      if (key === "z") {
        e.preventDefault();
        if (e.shiftKey) history.redoAction();
        else history.undoAction();
      } else if (key === "y") {
        e.preventDefault();
        history.redoAction();
      }
    }
  });

  window.addEventListener("keyup", (e) => {
    if (e.code === "Space") keys.space = false;
    if (e.key === "Shift") keys.shift = false;
  });

  canvas.addEventListener("dblclick", (e) => {
    updateMouseFromEvent(e);
    const pid = pickPoint(mouse.x, mouse.y, 10);
    const lpick = pid ? null : pickLine(mouse.x, mouse.y, 8);

    if (pid) {
      history.push("toggle point movable");
      const p = points.get(pid);
      p.movable = !isMovable(p.movable);
      rememberLastUnlockedEntity("point", pid, isMovable(p.movable));
      setStatus(`Point ${p.num} is now ${isMovable(p.movable) ? "MOVABLE (drag enabled)" : "LOCKED (drag disabled)"}.`, "ok");
      schedulePointsTableRender();
      return;
    }
    if (lpick) {
      history.push("toggle line movable");
      const ln = lines.get(lpick.lineId);
      ln.movable = !isMovable(ln.movable);
      rememberLastUnlockedEntity("line", lpick.lineId, isMovable(ln.movable));
      setStatus(`Line ${ln.id} is now ${isMovable(ln.movable) ? "MOVABLE (drag enabled)" : "LOCKED (drag disabled)"}.`, "ok");
      schedulePointsTableRender();
      return;
    }
  });

  canvas.addEventListener("mousedown", (e) => {
    if (modalIsOpen()) return;
    updateMouseFromEvent(e);
    mouse.down = true;
    mouse.button = e.button;

    const additive = e.shiftKey;

    if (toolIsPan()) {
      beginDrag({type:"pan"});
      return;
    }

    if (e.button !== 0) return;

    const pid = pickPoint(mouse.x, mouse.y, 10);
    const lpick = pid ? null : pickLine(mouse.x, mouse.y, 8);

    if (rotateSelectionSession.active && !rotateSelectionSession.awaitingSelection) {
      if (e.button === 0) handleRotateSelectionCanvasPick(mouse.x, mouse.y);
      return;
    }

    if (tool === "select") {
      if (pid) {
        if (!additive) { selectedLines = []; lastSelectedLineId = null; }
        const idx = selectedPointIds.indexOf(pid);
        if (!additive) selectedPointIds = [pid];
        else {
          if (idx >= 0) selectedPointIds.splice(idx,1);
          else selectedPointIds.push(pid);
        }
        selectedPointId = selectedPointIds.length ? selectedPointIds[selectedPointIds.length-1] : null;
        updatePointEditorFromSelection();
        schedulePointsTableRender();
        if (rotateSelectionSession.active) {
          if (rotateSelectionSession.awaitingSelection && getRotatablePointIdsFromSelection().length) {
            rotateSelectionSession.awaitingSelection = false;
            rotateSelectionSession.step = 0;
            setStatus("Selection captured. Click base point.", "ok");
          }
          syncRotateWorkflowToast();
        }

        const p = points.get(pid);
        if (selectedPointId === pid && isMovable(p?.movable)) {
          history.push("move point");
          beginDrag({type:"point", id: pid, _moved:false});
        }
        return;
      }

      if (lpick) {
        const guidedLineSelection = lineIntersectionCommandSession.active;
        if (!additive) { selectedPointIds = []; selectedPointId = null; }
        const idx = selectedLines.findIndex(s => s.lineId === lpick.lineId);
        if (guidedLineSelection) {
          if (idx >= 0) selectedLines[idx] = { lineId: lpick.lineId, grip: lpick.grip, t: lpick.t };
          else selectedLines.push({ lineId: lpick.lineId, grip: lpick.grip, t: lpick.t });
        } else if (!additive) {
          selectedLines = [{ lineId: lpick.lineId, grip: lpick.grip, t: lpick.t }];
        } else {
          if (idx >= 0) selectedLines.splice(idx,1);
          else selectedLines.push({ lineId: lpick.lineId, grip: lpick.grip, t: lpick.t });
        }
        lastSelectedLineId = selectedLines.length ? selectedLines[selectedLines.length-1].lineId : null;
        updatePointEditorFromSelection();
        schedulePointsTableRender();
        if (lineIntersectionCommandSession.active) {
          syncLineIntersectionCommandToast();
          if (selectedLines.length >= 2) {
            const commandButtonId = lineIntersectionCommandSession.mode === "extend" ? "#extendToIntersect" : "#trimToIntersect";
            window.setTimeout(() => $(commandButtonId)?.click(), 0);
          }
        }
        if (rotateSelectionSession.active) {
          if (rotateSelectionSession.awaitingSelection && getRotatablePointIdsFromSelection().length) {
            rotateSelectionSession.awaitingSelection = false;
            rotateSelectionSession.step = 0;
            setStatus("Selection captured. Click base point.", "ok");
          }
          syncRotateWorkflowToast();
        }

        const ln = lines.get(lpick.lineId);
        if (isMovable(ln?.movable)) {
          history.push("move line");
          beginDrag({type:"line", id: lpick.lineId, _moved:false});
        }
        return;
      }

      if (e.button === 0) {
        beginDrag({type:"marquee", x0: mouse.x, y0: mouse.y, x1: mouse.x, y1: mouse.y, additive});
        return;
      }

      return;
    }

    if (tool === "addPoint") {
      history.push("add point");
      const num = resolveDesiredPointNumber($("#ptNum").value);
      const z = parseNum($("#ptZ").value, 0);
      const code = String($("#ptCode").value || "");
      const notes = String($("#ptNotes").value || "");
      const pidNew = addPoint({ num, x: mouse.wx, y: mouse.wy, z, code, notes, movable:false });

      selectedPointIds = [pidNew];
      selectedPointId = pidNew;
      selectedLines = [];
      lastSelectedLineId = null;
      updatePointEditorFromSelection();
      clearPointNumberField();

      setStatus(`Added point ${points.get(pidNew).num} at (${fmt(mouse.wx)}, ${fmt(mouse.wy)}).`, "ok");
      schedulePointsTableRender();
      return;
    }

    if (tool === "line2pt") {
      if (!construction.startPointId) {
        history.push("line 2pt start");
        if (pid) {
          construction.startPointId = pid;
          setStatus(`Line start set: point ${points.get(pid).num}. Click endpoint (point or empty space).`, "ok");
          syncToolWorkflowToast();
          return;
        } else {
          const num = nextOpenPointNumber();
          const pidNew = addPoint({ num, x: mouse.wx, y: mouse.wy, z:0, code:"", notes:"", movable:false });
          construction.startPointId = pidNew;
          selectedPointIds = [pidNew];
          selectedPointId = pidNew;
          updatePointEditorFromSelection();
          setStatus(`Created start point ${points.get(pidNew).num}. Click endpoint.`, "ok");
          syncToolWorkflowToast();
          return;
        }
      } else {
        history.push("line 2pt end");
        let endId = pid;
        if (!endId) {
          const num = nextOpenPointNumber();
          endId = addPoint({ num, x: mouse.wx, y: mouse.wy, z:0, code:"", notes:"", movable:false });
        }
        if (endId === construction.startPointId) {
          setStatus("Endpoint cannot be the same as start point.", "warn");
          return;
        }
        const lid = addLine(construction.startPointId, endId, false);
        selectedLines = [{ lineId: lid, grip:"b", t: 1 }];
        lastSelectedLineId = lid;
        selectedPointIds = [endId];
        selectedPointId = endId;
        construction.startPointId = null;
        updatePointEditorFromSelection();
        setStatus(`Created line to point ${points.get(endId).num}.`, "ok");
        schedulePointsTableRender();
        syncToolWorkflowToast();
        return;
      }
    }

    if (tool === "lineDB") {
      if (pid) {
        construction.startPointId = pid;
        selectedPointIds = [pid];
        selectedPointId = pid;
        updatePointEditorFromSelection();
        schedulePointsTableRender();
        setStatus(`Start point set: ${points.get(pid).num}. Enter dist/bearing then click "Create Point + Line".`, "ok");
        syncToolWorkflowToast();
        return;
      }
      setStatus("Select a start point first (click a point).", "warn");
      return;
    }

    if (tool === "pointOnLine") {
      if (lpick) {
        if (!additive) { selectedPointIds = []; selectedPointId = null; selectedLines = []; }
        selectedLines = [{ lineId: lpick.lineId, grip: lpick.grip, t: lpick.t }];
        lastSelectedLineId = lpick.lineId;
        setStatus("Line selected for station/offset. Enter station/offset and click 'Create Point'.", "ok");
        schedulePointsTableRender();
        syncToolWorkflowToast();
        return;
      }
      setStatus("Select a line (click near it).", "warn");
      return;
    }
  });

  canvas.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    updateMouseFromEvent(e);
    runCanvasCancelOrClearAction();
  });

  canvas.addEventListener("pointerdown", (e) => {
    if (e.pointerType !== "touch" || modalIsOpen()) return;
    e.preventDefault();
    mobileInteraction.pointerDown = true;
    mobileInteraction.moved = false;
    mobileInteraction.activePointerId = e.pointerId;
    updateMouseFromEvent(e);
    mobileInteraction.downX = mouse.x;
    mobileInteraction.downY = mouse.y;
    updateTouchPoint(e);
    canvas.setPointerCapture?.(e.pointerId);

    if (touchGesture.points.size === 2) {
      clearLongPressTimer();
      touchGesture.mode = "pinch";
      touchGesture.boxSelectActive = false;
      touchGesture.startDistance = Math.max(1, getTouchDistance());
      touchGesture.startScale = view.scale;
      touchGesture.startPanX = view.panX;
      touchGesture.startPanY = view.panY;
      touchGesture.startCenter = getTouchCenter();
      return;
    }

    if (touchGesture.points.size === 1) {
      touchGesture.mode = "pending";
      clearLongPressTimer();
      mobileInteraction.longPressTimer = window.setTimeout(() => {
        if (!mobileInteraction.pointerDown || mobileInteraction.moved) return;
        updateMouseFromEvent(e);
        if (tool === "addPoint") {
          history.push("add point");
          const num = resolveDesiredPointNumber($("#ptNum").value);
          const z = parseNum($("#ptZ").value, 0);
          const code = String($("#ptCode").value || "");
          const notes = String($("#ptNotes").value || "");
          const pidNew = addPoint({ num, x: mouse.wx, y: mouse.wy, z, code, notes, movable:false });

          selectedPointIds = [pidNew];
          selectedPointId = pidNew;
          selectedLines = [];
          lastSelectedLineId = null;
          updatePointEditorFromSelection();
          clearPointNumberField();

          setStatus(`Added point ${points.get(pidNew).num} at (${fmt(mouse.wx)}, ${fmt(mouse.wy)}).`, "ok");
          schedulePointsTableRender();
          touchGesture.mode = "long-press-add";
          return;
        }
        const pid = pickPoint(mouse.x, mouse.y, 14);
        const lpick = pid ? null : pickLine(mouse.x, mouse.y, 12);
        if (pid) {
          selectedPointIds = [pid];
          selectedPointId = pid;
          selectedLines = [];
          lastSelectedLineId = null;
          updatePointEditorFromSelection();
          schedulePointsTableRender();
          const p = points.get(pid);
          if (isMovable(p?.movable)) {
            history.push("move point");
            beginDrag({type:"point", id: pid, _moved:false});
            touchGesture.mode = "drag-selection";
          }
        } else if (lpick) {
          selectedPointIds = [];
          selectedPointId = null;
          selectedLines = [{ lineId: lpick.lineId, grip: lpick.grip, t: lpick.t }];
          lastSelectedLineId = lpick.lineId;
          updatePointEditorFromSelection();
          schedulePointsTableRender();
          const ln = lines.get(lpick.lineId);
          if (isMovable(ln?.movable)) {
            history.push("move line");
            beginDrag({type:"line", id: lpick.lineId, _moved:false});
            touchGesture.mode = "drag-selection";
          }
        } else {
          touchGesture.boxSelectActive = true;
          beginDrag({type:"marquee", x0: mouse.x, y0: mouse.y, x1: mouse.x, y1: mouse.y, additive:false});
          touchGesture.mode = "box-select";
        }
      }, mobileInteraction.longPressMs);
    }
  });

  canvas.addEventListener("pointermove", (e) => {
    if (e.pointerType !== "touch" || modalIsOpen()) return;
    e.preventDefault();
    updateTouchPoint(e);
    updateMouseFromEvent(e);

    const moveDist = dist(mobileInteraction.downX, mobileInteraction.downY, mouse.x, mouse.y);
    if (moveDist > mobileInteraction.moveTolerance) {
      mobileInteraction.moved = true;
      clearLongPressTimer();
    }

    if (touchGesture.points.size === 2 && touchGesture.mode === "pinch") {
      const center = getTouchCenter();
      const distance = Math.max(1, getTouchDistance());
      if (!center || !touchGesture.startCenter) return;
      const factor = distance / Math.max(1, touchGesture.startDistance);
      const newScale = clamp(touchGesture.startScale * factor, MIN_SCALE, MAX_SCALE);
      view.scale = newScale;
      view.panX = touchGesture.startPanX + (center.x - touchGesture.startCenter.x);
      view.panY = touchGesture.startPanY + (center.y - touchGesture.startCenter.y);
      return;
    }

    if (touchGesture.points.size === 1 && touchGesture.mode === "pending" && moveDist > mobileInteraction.moveTolerance) {
      touchGesture.mode = "pan";
      beginDrag({type:"pan"});
    }
  });

  function handlePointerUp(e) {
    if (e.pointerType !== "touch") return;
    removeTouchPoint(e.pointerId);
    clearLongPressTimer();
    mobileInteraction.pointerDown = false;
    if (mouse.drag) handleMouseUpCommon();
    touchGesture.mode = null;
    touchGesture.boxSelectActive = false;
  }

  canvas.addEventListener("pointerup", handlePointerUp);
  canvas.addEventListener("pointercancel", handlePointerUp);

  canvas.addEventListener("mousemove", (e) => {
    if (modalIsOpen()) return;
    updateMouseFromEvent(e);
    broadcastCursor();
    if (!mouse.drag) return;

    if (mouse.dragObj?.type === "pan") {
      const dx = mouse.x - mouse.dragStartX;
      const dy = mouse.y - mouse.dragStartY;
      view.panX = mouse.dragStartPanX + dx;
      view.panY = mouse.dragStartPanY + dy;
      return;
    }

    if (mouse.dragObj?.type === "marquee") {
      mouse.dragObj.x1 = mouse.x;
      mouse.dragObj.y1 = mouse.y;
      return;
    }

    if (mouse.dragObj?.type === "point") {
      const pid = mouse.dragObj.id;
      const p = points.get(pid);
      if (!p) return;

      if (!mouse.dragObj._orig) mouse.dragObj._orig = { x:p.x, y:p.y };
      p.x = mouse.wx;
      p.y = mouse.wy;

      if (Math.abs(p.x - mouse.dragObj._orig.x) > 1e-12 || Math.abs(p.y - mouse.dragObj._orig.y) > 1e-12) {
        mouse.dragObj._moved = true;
      }

      if (selectedPointId === pid) {
        $("#ptX").value = p.x;
        $("#ptY").value = p.y;
      }
      schedulePointsTableRender();
      return;
    }

    if (mouse.dragObj?.type === "line") {
      const lid = mouse.dragObj.id;
      const ln = lines.get(lid);
      if (!ln) return;
      const a = points.get(ln.a), b = points.get(ln.b);
      if (!a || !b) return;

      const dx = mouse.wx - mouse.dragStartWorldX;
      const dy = mouse.wy - mouse.dragStartWorldY;

      if (!mouse.dragObj._orig) {
        mouse.dragObj._orig = { ax:a.x, ay:a.y, bx:b.x, by:b.y };
      }
      a.x = mouse.dragObj._orig.ax + dx;
      a.y = mouse.dragObj._orig.ay + dy;
      b.x = mouse.dragObj._orig.bx + dx;
      b.y = mouse.dragObj._orig.by + dy;

      if (Math.abs(dx) > 1e-12 || Math.abs(dy) > 1e-12) mouse.dragObj._moved = true;

      schedulePointsTableRender();
      return;
    }
  });

  function applyMarqueeSelection(obj) {
    const r = rectNorm(obj.x0, obj.y0, obj.x1, obj.y1);

    if (r.w < 3 && r.h < 3) {
      if (!obj.additive) clearSelection();
      return;
    }

    const ptsIn = [];
    for (const p of points.values()) {
      const sp = worldToScreen(p.x,p.y);
      if (sp.x >= r.minX && sp.x <= r.maxX && sp.y >= r.minY && sp.y <= r.maxY) ptsIn.push(p.id);
    }

    const lnsIn = [];
    const rectCenter = {x:r.cx, y:r.cy};
    for (const ln of lines.values()) {
      const a = points.get(ln.a), b = points.get(ln.b);
      if (!a || !b) continue;
      const sa = worldToScreen(a.x,a.y);
      const sb = worldToScreen(b.x,b.y);

      if (segIntersectsRect(sa, sb, r)) {
        const grip = (dist2(rectCenter.x,rectCenter.y, sa.x,sa.y) <= dist2(rectCenter.x,rectCenter.y, sb.x,sb.y)) ? "a" : "b";
        lnsIn.push({ lineId: ln.id, grip, t: 0.5 });
      }
    }

    if (!obj.additive) {
      selectedPointIds = ptsIn;
      selectedPointId = selectedPointIds.length ? selectedPointIds[selectedPointIds.length-1] : null;
      selectedLines = lnsIn;
      lastSelectedLineId = selectedLines.length ? selectedLines[selectedLines.length-1].lineId : null;
    } else {
      const setPts = new Set(selectedPointIds);
      for (const id of ptsIn) if (!setPts.has(id)) selectedPointIds.push(id);
      selectedPointId = selectedPointIds.length ? selectedPointIds[selectedPointIds.length-1] : selectedPointId;

      const setLns = new Set(selectedLines.map(s=>s.lineId));
      for (const s of lnsIn) if (!setLns.has(s.lineId)) selectedLines.push(s);
      lastSelectedLineId = selectedLines.length ? selectedLines[selectedLines.length-1].lineId : lastSelectedLineId;
    }

    updatePointEditorFromSelection();
    schedulePointsTableRender();
    setStatus(`Window selected: ${ptsIn.length} point(s), ${lnsIn.length} line(s).`, "ok");
    if (rotateSelectionSession.active) {
      const rotateIds = getRotatablePointIdsFromSelection();
      if (rotateSelectionSession.awaitingSelection && rotateIds.length) {
        rotateSelectionSession.awaitingSelection = false;
        rotateSelectionSession.step = 0;
        setStatus(`Window selected: ${ptsIn.length} point(s), ${lnsIn.length} line(s). Click base point.`, "ok");
      }
      syncRotateWorkflowToast();
    }
  }

  // ADDED: common mouseup handler + window-level mouseup to prevent stuck pan/drags
  function handleMouseUpCommon() {
    mouse.down = false;
    if (!mouse.drag) return;

    if (mouse.dragObj?.type === "marquee") {
      applyMarqueeSelection(mouse.dragObj);
      endDrag();
      return;
    }

    if (mouse.dragObj && mouse.dragObj.type !== "pan") {
      if (!mouse.dragObj._moved) {
        history.undo.pop();
        updateUndoRedoHUD();
      } else {
        setStatus("Move committed. (Undo available)", "ok");
      }
      schedulePointsTableRender();
    }

    endDrag();
    updatePointEditorFromSelection();
  }

  canvas.addEventListener("mouseup", (e) => {
    if (modalIsOpen()) return;
    handleMouseUpCommon();
  });

  window.addEventListener("mouseup", (e) => {
    // Only run if the mouseup didn't occur on the canvas itself (prevents double-fire)
    if (e.target === canvas) return;
    handleMouseUpCommon();
  });

  canvas.addEventListener("mouseleave", () => {
    mouse.down = false;
    endDrag();
  });

  canvas.addEventListener("wheel", (e) => {
    if (modalIsOpen()) return;
    e.preventDefault();
    updateMouseFromEvent(e);

    const before = screenToWorld(mouse.x, mouse.y);
    const zoomFactor = Math.exp(-e.deltaY * 0.0015);
    const newScale = clamp(view.scale * zoomFactor, MIN_SCALE, MAX_SCALE);
    view.scale = newScale;

    view.panX = mouse.x - before.x * view.scale;
    view.panY = mouse.y + before.y * view.scale;
  }, {passive:false});

  // -------------------------
  // Counts / tool hint enrichment
  // -------------------------
  function updateCounts() {
    pointsCount.textContent = `${points.size} point${points.size===1?"":"s"} / ${lines.size} line${lines.size===1?"":"s"}`;
    modalPointsCount.textContent = String(points.size);
  }

  function updateDerivedSelectionInfo() {
    if (lastSelectedLineId && lines.has(lastSelectedLineId)) {
      const ln = lines.get(lastSelectedLineId);
      const measure = lineMeasurement(points.get(ln.a), points.get(ln.b));
      if (measure) {
        const baseName = ({
          select:"Select/Move",
          addPoint:"Add Point",
          line2pt:"Line: 2 Points",
          lineDB:"Line: Dist/Bearing",
          pointOnLine:"Point on Line",
          pan:"Pan"
        })[tool] ?? tool;
        toolHint.textContent = `${baseName} — L=${measure.distance.toFixed(3)}  ${measure.bearing}`;
        return;
      }
    }
    const names = {
      select:"Select/Move",
      addPoint:"Add Point",
      line2pt:"Line: 2 Points",
      lineDB:"Line: Dist/Bearing",
      pointOnLine:"Point on Line",
      pan:"Pan"
    };
    toolHint.textContent = names[tool] ?? tool;
  }

  function updateLineInspector() {
    let source = "";
    let measure = null;
    if (lastSelectedLineId && lines.has(lastSelectedLineId)) {
      const ln = lines.get(lastSelectedLineId);
      measure = lineMeasurement(points.get(ln.a), points.get(ln.b));
      source = "Selected line";
    } else if (selectedPointIds.length === 2) {
      const a = points.get(selectedPointIds[0]);
      const b = points.get(selectedPointIds[1]);
      measure = lineMeasurement(a, b);
      source = "Selected points";
    }

    if (!measure) {
      lineInspector.textContent = "Select one line or two points to inspect bearing + distance.";
      return;
    }
    lineInspector.innerHTML =
      `<div class="inspectorRow"><span>Source</span><b>${source}</b></div>` +
      `<div class="inspectorRow"><span>Distance</span><b>${measure.distance.toFixed(3)}</b></div>` +
      `<div class="inspectorRow"><span>Bearing</span><b>${measure.bearing}</b></div>`;
  }
  setInterval(updateDerivedSelectionInfo, 250);
  setInterval(updateLineInspector, 250);

  window.addEventListener("message", (event) => {
    if (event.origin !== window.location.origin) return;
    if (event.source !== window.parent) return;
    const message = event.data;
    if (!message || typeof message.type !== "string") return;

    if (message.type === "survey-cad:request-unsaved-state") {
      window.parent.postMessage({
        type: "survey-cad:request-unsaved-state:response",
        requestId: message.requestId,
        hasUnsavedChanges: hasUnsavedDrawingChanges(),
        canSave: Boolean(activeProjectId),
      }, window.location.origin);
      return;
    }

    if (message.type === "survey-cad:request-save-before-navigate") {
      const hadUnsavedChanges = hasUnsavedDrawingChanges();
      let saved = !hadUnsavedChanges;
      if (hadUnsavedChanges) {
        saved = saveDrawingToProject();
      }
      window.parent.postMessage({
        type: "survey-cad:request-save-before-navigate:response",
        requestId: message.requestId,
        saved: Boolean(saved),
      }, window.location.origin);
    }
  });

  // -------------------------
  // Boot
  // -------------------------
  function boot() {
    resize();
    window.addEventListener("resize", resize);
    mapEnabledInput.checked = false;
    mapTileTypeInput.value = "satellite";
    mapOpacityInput.value = "66";
    mapLayerState.opacity = 0.66;
    applyMapOpacity();
    setMapLayerEnabled(false);
    setTool("select");
    updatePointEditorFromSelection();
    updateUndoRedoHUD();
    updateCounts();
    requestAnimationFrame(draw);
    markDrawingAsSaved();

    const drawingHint = $("#drawingSaveHint");
    if (drawingHint) {
      drawingHint.textContent = activeProjectId
        ? `Project-linked saves enabled for ${activeProjectName || activeProjectId}.`
        : "Open LineSmith from an active SurveyFoundry project to enable project-linked drawing saves.";
    }

    const openedFromProjectBrowser = tryImportProjectBrowserDrawingPayload();
    connectCollaboration();
    if (openedFromProjectBrowser) return;

    const importedFromPointforge = tryImportPointforgePayload();
    if (importedFromPointforge) return;

    const restoredLastDrawing = tryRestoreLastOpenedProjectDrawing();
    if (restoredLastDrawing) return;

    setStatus(
      "Ready.\n" +
      "This build preserves your baseline interaction.\n" +
      "Fixes added:\n" +
      "• CSV headerless N,E vs E,N import control (prevents X/Y swapped point data).\n" +
      "• Swap X↔Y for ALL points (Undoable) for already-imported transposed datasets.\n" +
      "• Pan/drag release robustness (window mouseup + blur reset).",
      "ok"
    );
  }

  boot();

})();
</script>
</body>
</html>
