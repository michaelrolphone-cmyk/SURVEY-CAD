<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LineSmith — Points & Bearings</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
  />
  <style>
    :root{
      --bg:#0b0b0b;
      --panel:#111;
      --panel2:#151515;
      --text:#e8e8e8;
      --muted:#9aa0a6;
      --accent:#ffd54a;
      --line:#ffffff;
      --pt:#ff2b2b;
      --num:#ffffff;
      --code:#39ff79;
      --notes:#3aa3ff;
      --warn:#ff6b6b;
      --ok:#46d36b;
      --border:#2a2a2a;
      --bad:#ff4d4d;
      --overlay: rgba(0,0,0,0.55);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:13px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }
    .app{
      height:100vh;
      display:grid;
      grid-template-columns: 1fr minmax(320px, 440px);
      grid-template-areas:"canvas panel";
    }
    .panel{
      grid-area:panel;
      position:relative;
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border-left:1px solid var(--border);
      padding:12px 12px 10px;
      overflow-y:auto;
      overflow-x:visible;
      z-index:5;
    }
    .app.panelCollapsed{
      grid-template-columns: 1fr 0;
    }
    .app.panelCollapsed .panel{
      border-left:none;
      padding:0;
      overflow:hidden;
      pointer-events:auto;
    }
    .panelCollapseHandle{
      position:absolute;
      top:50%;
      left:-14px;
      transform:translateY(-50%);
      width:28px;
      height:64px;
      border:1px solid var(--border);
      border-right:none;
      border-radius:12px 0 0 12px;
      background:#101010;
      color:var(--text);
      font-size:18px;
      line-height:1;
      z-index:8;
      padding:0;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .drawerEdgeExpand{
      position:absolute;
      top:50%;
      right:0;
      transform:translateY(-50%);
      width:30px;
      height:72px;
      border:1px solid var(--border);
      border-right:none;
      border-radius:12px 0 0 12px;
      background:#101010;
      color:var(--text);
      font-size:18px;
      line-height:1;
      z-index:7;
      padding:0;
      display:none;
      align-items:center;
      justify-content:center;
    }
    .app.panelCollapsed .drawerEdgeExpand{ display:flex; }
    .panel h1{
      font-size:14px;
      margin:0 0 10px;
      letter-spacing:.4px;
    }
    .row{ display:flex; gap:8px; align-items:center; }
    .col{ display:flex; flex-direction:column; gap:8px; }
    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .grid3{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; }
    .section{
      border:1px solid var(--border);
      border-radius:10px;
      padding:10px;
      background:#0f0f0f;
      margin-bottom:10px;
    }
    .section .title{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      margin-bottom:8px;
      gap:10px;
    }
    .section .title b{ font-size:12px; }
    .section .title span{ color:var(--muted); font-size:11px; }
    .panelToolsCollapse{
      margin-bottom:10px;
      border:1px solid var(--border);
      border-radius:10px;
      background:#0f0f0f;
      overflow:hidden;
    }
    .panelToolsCollapse summary{
      list-style:none;
      cursor:pointer;
      padding:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      user-select:none;
      font-weight:600;
      font-size:12px;
    }
    .panelToolsCollapse summary::-webkit-details-marker{ display:none; }
    .panelToolsCollapse summary::after{
      content:"▾";
      color:var(--muted);
      font-size:12px;
      transition:transform .15s ease;
    }
    .panelToolsCollapse:not([open]) summary::after{ transform:rotate(-90deg); }
    .panelToolsCollapseBody{ padding:0 10px 10px; }
    .panelToolsCollapseBody .section:last-child{ margin-bottom:0; }
    label{
      display:flex;
      flex-direction:column;
      gap:4px;
      color:var(--muted);
      font-size:11px;
    }
    input, select, textarea, button{
      font:inherit;
      color:var(--text);
      background:#0b0b0b;
      border:1px solid var(--border);
      border-radius:8px;
      padding:8px 9px;
      outline:none;
    }
    textarea{ min-height:64px; resize:vertical; }
    input[type="file"]{ padding:6px; }
    button{
      cursor:pointer;
      background:#141414;
      transition:.15s transform ease, .15s background ease, .15s border-color ease;
      user-select:none;
    }
    button:hover{ background:#1a1a1a; border-color:#3a3a3a; }
    button:active{ transform:translateY(1px); }
    button.primary{
      border-color:#5c4b14;
      background:#201a09;
    }
    button.primary:hover{ background:#2a210b; }
    button.danger{
      border-color:#5c1b1b;
      background:#210b0b;
      color:#ffd9d9;
    }
    button.danger:hover{ background:#2b0f0f; }
    button.ok{
      border-color:#1f5c2d;
      background:#0c1f10;
      color:#dbffe5;
    }
    button.ok:hover{ background:#0f2a15; }
    .pill{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding:5px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      color:var(--muted);
      font-size:11px;
      background:#0c0c0c;
      max-width:100%;
    }
    .pill b{ color:var(--text); font-weight:600; }
    .pill .clip{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:260px;
      display:inline-block;
      vertical-align:bottom;
    }
    .hint{
      color:var(--muted);
      font-size:11px;
      margin-top:6px;
    }
    .status{
      border-left:3px solid var(--border);
      padding:8px 10px;
      border-radius:8px;
      background:#0c0c0c;
      color:var(--muted);
      font-size:11px;
      margin-top:8px;
      white-space:pre-wrap;
    }
    .status.warn{ border-left-color:var(--warn); }
    .sr-only{
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }
    .status.ok{ border-left-color:var(--ok); }
    .inspectorCard{
      margin-top:8px;
      border:1px solid var(--border);
      border-radius:8px;
      padding:8px;
      background:#0c0c0c;
      font-size:11px;
    }
    .inspectorRow{ display:flex; justify-content:space-between; gap:8px; margin-bottom:4px; }
    .inspectorRow:last-child{ margin-bottom:0; }
    .inspectorRow b{ color:var(--text); }
    .inspectorValueWrap{ display:flex; align-items:center; justify-content:flex-end; gap:6px; flex-wrap:wrap; width:58%; min-width:130px; }
    .inspectorSelect{
      width:58%;
      min-width:130px;
      background:#0f1726;
      color:var(--text);
      border:1px solid #2a3550;
      border-radius:6px;
      padding:4px 6px;
      font-size:11px;
    }
    .inspectorVariedPill{
      border:1px solid #7f1d1d;
      background:#b91c1c;
      color:#fff;
      border-radius:999px;
      padding:2px 8px;
      font-size:10px;
      font-weight:700;
      cursor:pointer;
    }
    .inspectorVariedPill:hover{ background:#dc2626; }
    .inspectorLinks{ display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
    .inspectorLinks a{ color:var(--accent); text-decoration:none; border:1px solid #2a3550; border-radius:999px; padding:3px 8px; font-size:11px; }
    .inspectorLinks a:hover{ background:#182238; }
    .pointSymbolBadge{
      width:20px;
      height:20px;
      object-fit:contain;
      border-radius:6px;
      border:1px solid #cbd5e1;
      background:#ffffff;
      padding:2px;
      flex:0 0 auto;
    }
    .pointSymbolBadge.large{
      width:46px;
      height:46px;
      border-radius:12px;
      padding:5px;
    }
    .inspectorPointHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom:8px;
      padding-bottom:8px;
      border-bottom:1px solid #263246;
    }
    .inspectorPointHeaderTitle{ font-size:12px; font-weight:700; }
    .pointEditorSymbolRow{
      display:flex;
      align-items:center;
      gap:8px;
      margin-top:8px;
      min-height:26px;
      color:var(--muted);
      font-size:11px;
    }
    .pointNumberCell{
      display:flex;
      align-items:center;
      gap:6px;
    }
    .pointNumberCell .cellInput{
      flex:1 1 auto;
      min-width:0;
    }
    .quickSearchResultWithSymbol{
      display:flex;
      align-items:flex-start;
      gap:8px;
      width:100%;
    }
    .quickSearchResultContent{
      min-width:0;
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
      gap:2px;
    }

    .canvasWrap{
      grid-area:canvas;
      position:relative;
      overflow:hidden;
      background:
        radial-gradient(900px 500px at 20% 30%, rgba(124,247,255,.08), transparent 60%),
        linear-gradient(180deg, rgba(6,8,12,.55), rgba(6,8,12,.85));
    }
    .drawerToggle,
    .mobileToolbarToggle{
      display:none;
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 10px;
      background:#101010;
      color:var(--text);
      font-size:12px;
      line-height:1.1;
    }
    .quickToolsMobileRow{
      display:none;
      justify-content:space-between;
      gap:8px;
    }
    .quickTools{
      position:absolute;
      top:10px;
      left:10px;
      z-index:6;
      right:10px;
      display:flex;
      flex-direction:column;
      gap:6px;
      width:calc(100% - 20px);
      padding:8px;
      border:1px solid var(--border);
      border-radius:12px;
      background:rgba(8,8,8,0.92);
      backdrop-filter:blur(4px);
    }
    .quickToolsRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      min-width:0;
    }
    .quickToolsRowSecondary{
      padding-top:2px;
      border-top:1px solid rgba(255,255,255,0.08);
    }
    .quickToolBtn{
      width:34px;
      height:34px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius:8px;
      padding:0;
      font-size:14px;
    }
    .quickToolBtn.primary{
      border-color:#5c4b14;
      background:#201a09;
      color:#ffe7a0;
    }
    .quickToolBtn i{ pointer-events:none; }
    .quickToolBtn.saveSuccessPulse{
      animation:quickSaveSuccessPulse 420ms ease-out;
    }
    .quickToolBtn.printCaptureArmed{
      border-color:#5c4b14;
      background:#201a09;
      color:#ffe7a0;
      box-shadow:0 0 0 1px rgba(255,231,160,0.3), 0 0 12px rgba(255,213,74,0.25);
      animation:printCaptureReadyPulse 1s ease-in-out infinite;
    }
    @keyframes quickSaveSuccessPulse{
      0%{ transform:scale(1); box-shadow:0 0 0 0 rgba(110,231,183,0.45); }
      45%{ transform:scale(1.14); box-shadow:0 0 0 8px rgba(110,231,183,0.18); }
      100%{ transform:scale(1); box-shadow:0 0 0 0 rgba(110,231,183,0); }
    }
    @keyframes printCaptureReadyPulse{
      0%, 100%{ transform:scale(1); box-shadow:0 0 0 1px rgba(255,231,160,0.3), 0 0 8px rgba(255,213,74,0.18); }
      50%{ transform:scale(1.05); box-shadow:0 0 0 1px rgba(255,231,160,0.45), 0 0 14px rgba(255,213,74,0.35); }
    }
    .quickToolDivider{
      width:1px;
      margin:2px 1px;
      background:var(--border);
    }
    .workflowToast{
      position:absolute;
      top:58px;
      right:10px;
      z-index:6;
      width:min(340px, calc(100% - 20px));
      border:1px solid var(--border);
      border-radius:10px;
      background:rgba(15,15,15,0.94);
      padding:10px;
      box-shadow:0 8px 20px rgba(0,0,0,0.35);
      backdrop-filter:blur(3px);
    }
    .workflowToast.hidden{ display:none; }
    .workflowToastTitle{ font-weight:700; margin-bottom:4px; }
    .workflowToastMessage{ color:var(--muted); font-size:11px; margin-bottom:8px; }
    .workflowToastSteps{ list-style:none; margin:0; padding:0; display:grid; gap:5px; }
    .workflowToastSteps li{
      font-size:11px;
      color:var(--muted);
      border:1px solid #2b2b2b;
      border-radius:7px;
      padding:5px 7px;
    }
    .workflowToastSteps li.active{
      color:#ffe7a0;
      border-color:#5c4b14;
      background:#201a09;
    }
    .workflowToastSteps li.done{
      color:#9fd9ac;
      border-color:#285836;
      background:#102116;
    }
    .clusterTooltip{
      position:absolute;
      z-index:8;
      min-width:180px;
      max-width:280px;
      border:1px solid #3a3a3a;
      border-radius:8px;
      background:rgba(14,14,14,0.96);
      box-shadow:0 8px 20px rgba(0,0,0,0.4);
      color:var(--text);
      font-size:11px;
      line-height:1.4;
      pointer-events:auto;
      padding:8px;
      white-space:normal;
    }
    .clusterTooltip.hidden{ display:none; }
    .clusterTooltip b{ color:#ffd54a; }
    .clusterTooltip .clusterTooltipLayerName,
    .clusterTooltip .clusterTooltipPointName{ font-weight:700; }
    .clusterTooltipPointRow{ display:inline-flex; align-items:center; gap:6px; }
    .clusterTooltip ul{ margin:6px 0 0 16px; padding:0; }
    .clusterTooltip li{ margin:2px 0; }
    .clusterTooltip li.active{
      background:rgba(255,213,74,0.16);
      border-radius:4px;
      padding:1px 4px;
      margin-left:-4px;
      margin-right:-4px;
    }
    .clusterTooltip .clusterTooltipAction{
      width:100%;
      text-align:left;
      background:transparent;
      border:0;
      color:inherit;
      padding:0;
      margin:0;
      cursor:pointer;
      font:inherit;
    }
    .pointHoverTooltipRow{ margin:2px 0; }
    .pointHoverTooltipLabel{
      color:var(--muted);
      margin-right:4px;
    }
    .pointHoverTooltipDelta{
      margin:0 0 7px;
      padding:6px 8px;
      border:1px solid #2f2f2f;
      border-radius:7px;
      background:rgba(4,4,4,0.72);
      box-shadow:inset 0 1px 2px rgba(0,0,0,0.6);
    }
    .pointHoverTooltipDelta .pointHoverTooltipRow{ margin:0; }
    .pointHoverTooltipFromPill{
      display:inline-flex;
      align-items:center;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.28);
      color:#121212;
      padding:0 6px;
      line-height:1.45;
      font-weight:700;
      margin:0 1px;
    }
    .quickToolField{
      display:inline-flex;
      flex-direction:row;
      align-items:center;
      gap:6px;
      color:var(--muted);
      font-size:11px;
      border:1px solid var(--border);
      border-radius:8px;
      background:#121212;
      padding:0 8px;
      min-height:34px;
    }
    .quickToolField input[type="checkbox"]{
      margin:0;
      width:14px;
      height:14px;
      padding:0;
      border-radius:4px;
      flex:0 0 auto;
    }
    .quickToolField select{
      border:0;
      background:transparent;
      color:var(--text);
      padding:0;
      min-height:22px;
      min-width:140px;
    }
    .quickToolLayer{
      min-width:0;
      justify-content:flex-start;
      gap:8px;
      padding-right:6px;
      width:max-content;
      max-width:100%;
    }
    .quickToolLayerSwatch{
      width:12px;
      height:12px;
      border-radius:2px;
      border:1px solid rgba(255,255,255,0.3);
      flex:0 0 auto;
    }
    .quickLayerDropdown{
      position:relative;
      flex:0 0 auto;
      min-width:0;
      width:max-content;
      max-width:100%;
    }
    .quickLayerDropdownBtn{
      width:auto;
      min-height:24px;
      border:1px solid #2c2c2c;
      border-radius:6px;
      background:#0d0d0d;
      color:var(--text);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:2px 8px;
      font-size:12px;
    }
    .quickLayerDropdownBtnText{
      overflow:visible;
      text-overflow:clip;
      white-space:nowrap;
      max-width:none;
    }
    .quickLayerDropdownMenu{
      position:absolute;
      top:calc(100% + 4px);
      left:0;
      min-width:100%;
      width:max-content;
      max-width:min(80vw, 560px);
      border:1px solid #2f2f2f;
      border-radius:8px;
      background:#121212;
      box-shadow:0 8px 24px rgba(0,0,0,0.4);
      max-height:320px;
      overflow-y:auto;
      z-index:20;
      padding:4px;
    }
    .quickLayerDropdownMenu.hidden{
      display:none;
    }
    .quickLayerDropdownItem{
      width:100%;
      min-height:30px;
      border:0;
      background:transparent;
      color:var(--text);
      border-radius:6px;
      padding:6px;
      display:flex;
      align-items:center;
      gap:8px;
      text-align:left;
    }
    .quickLayerDropdownItem.active{
      background:#1b2534;
    }
    .quickLayerDropdownItem:hover{
      background:#1a1a1a;
    }
    .quickLayerItemName{
      min-width:0;
      flex:1 1 auto;
      overflow:visible;
      text-overflow:clip;
      white-space:nowrap;
      font-size:12px;
    }
    .quickLayerItemFlags{
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    .quickToolIconBtn{
      width:24px;
      height:24px;
      border-radius:6px;
      border:1px solid #2c2c2c;
      background:#111;
      color:var(--muted);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:0;
      font-size:11px;
    }
    .quickToolIconBtn.active{
      color:#ffe7a0;
      border-color:#5c4b14;
      background:#201a09;
    }
    .layerNameCell{ font-weight:600; }
    .layerRowLocked{ opacity:0.7; }
    .quickToolField select:focus{ outline:none; }
    .quickToolToggleGroup{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:4px;
    }
    .quickToggleBtn{
      min-width:32px;
      height:26px;
      border-radius:6px;
      border:1px solid #2c2c2c;
      background:#111;
      color:var(--muted);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:4px;
      padding:0 7px;
      font-size:11px;
      line-height:1;
    }
    .quickToggleBtn i{ font-size:11px; }
    .quickToggleBtn.active{
      border-color:#5c4b14;
      background:#201a09;
      color:#ffe7a0;
    }
    #quickMapLayerEnabled{
      width:34px;
      min-width:34px;
      height:34px;
      border-radius:8px;
      padding:0;
      font-size:14px;
    }
    #quickMapLayerEnabled i{ font-size:14px; }
    .mapBackdrop{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      opacity:0;
      transition:opacity .28s ease;
    }
    .mapBackdrop.on{ opacity:1; }
    .mapBackdrop .leaflet-container{
      width:100%;
      height:100%;
      background:#000;
    }
    canvas{
      position:relative;
      z-index:1;
      width:100%;
      height:100%;
      display:block;
      cursor:crosshair;
      touch-action:none;
    }
    .hud{
      position:absolute;
      left:10px;
      bottom:10px;
      z-index:2;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      pointer-events:none;
    }
    .hud .pill{ pointer-events:none; }
    .quickToolSearch{
      position:relative;
      flex:0 1 170px;
      min-width:140px;
      padding:4px;
      gap:6px;
    }
    .quickToolSearch input{
      border:0;
      background:transparent;
      min-height:24px;
      padding:0 2px;
      flex:1 1 auto;
    }
    .quickToolSearch input::placeholder{ color:#7d8389; }
    .quickSearchResults{
      position:absolute;
      top:calc(100% + 6px);
      left:0;
      right:auto;
      width:max(100%, 420px);
      max-width:min(70vw, 680px);
      border:1px solid #2f2f2f;
      border-radius:8px;
      background:#121212;
      box-shadow:0 8px 24px rgba(0,0,0,0.4);
      max-height:240px;
      overflow-y:auto;
      z-index:30;
      padding:4px;
      display:grid;
      gap:4px;
    }
    .quickSearchResults.hidden{ display:none; }
    .quickSearchResultBtn{
      width:100%;
      border:0;
      border-radius:6px;
      background:#0f0f0f;
      color:var(--text);
      padding:6px 8px;
      text-align:left;
      border-left:3px solid #2f2f2f;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .quickSearchResultBtn:hover{ background:#1a1a1a; }
    .quickSearchResultLine{ display:flex; justify-content:space-between; gap:8px; }
    .quickSearchResultTitle{ font-size:12px; font-weight:600; }
    .quickSearchResultMeta{ color:var(--muted); font-size:11px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .quickSearchResultDescription{ color:var(--muted); font-size:11px; white-space:normal; overflow-wrap:anywhere; }

    .kbd{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
      color:var(--muted);
      font-size:11px;
      margin-top:8px;
    }
    .kbd div{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 8px;
      border:1px dashed #2a2a2a;
      border-radius:8px;
      background:#0c0c0c;
    }
    .kbd code{
      color:var(--text);
      background:#111;
      padding:1px 6px;
      border-radius:6px;
      border:1px solid #2a2a2a;
    }
    .mini{ font-size:10px; color:var(--muted); }
    .sep{ height:1px; background:var(--border); margin:8px 0; }
    .inline{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .inline label{
      flex-direction:row;
      align-items:center;
      gap:8px;
      font-size:11px;
      margin:0;
    }
    .inline input[type="checkbox"]{
      width:16px; height:16px; padding:0;
    }

    /* Modal (Points Manager) */
    .modalOverlay{
      position:fixed;
      inset:0;
      background:var(--overlay);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:9999;
      padding:18px;
    }
    .hidden{ display:none !important; }
    .modalWindow{
      position:absolute;
      width:min(1100px, calc(100vw - 36px));
      height:min(640px, calc(100vh - 36px));
      min-width: 720px;
      min-height: 360px;
      background:linear-gradient(180deg,#0f0f0f,#0b0b0b);
      border:1px solid var(--border);
      border-radius:14px;
      box-shadow: 0 20px 80px rgba(0,0,0,0.6);
      overflow:hidden;
      resize:both;
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:#0c0c0c;
      cursor:move;
      user-select:none;
      gap:10px;
    }
    .modalHeader b{ font-size:12px; letter-spacing:.3px; }
    .modalHeader .right{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .modalHeader .right .pill{ pointer-events:none; }
    .modalHeader button{
      cursor:pointer;
      padding:6px 10px;
      border-radius:10px;
      background:#141414;
      border:1px solid #2a2a2a;
    }
    .modalHeader button:hover{ background:#1a1a1a; border-color:#3a3a3a; }
    .modalBody{
      padding:10px;
      height:calc(100% - 44px);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .connectLinesModalWindow{
      position:relative;
      width:min(360px, calc(100vw - 36px));
      height:auto;
      min-width:0;
      min-height:0;
      resize:none;
    }
    .connectLinesModalWindow .modalHeader{ cursor:default; }
    .connectLinesModalBody{
      height:auto;
      overflow:visible;
      flex-direction:row;
      justify-content:flex-end;
    }
    .tableWrap{
      border:1px solid var(--border);
      border-radius:12px;
      overflow:hidden;
      background:#0b0b0b;
      height:100%;
      display:flex;
      flex-direction:column;
      min-height: 0;
    }
    .tableTools{
      display:flex;
      gap:8px;
      padding:8px;
      border-bottom:1px solid var(--border);
      background:#0c0c0c;
      align-items:center;
      flex-wrap:wrap;
    }
    .tableTools input{ flex:1; min-width:220px; }
    .fldTypeConfigCell{
      min-width:320px;
    }
    .fldTypeConfigStack{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:6px;
    }
    .fldTypeConfigStack .cellInput,
    .fldTypeConfigStack select{
      width:100%;
      min-width:0;
    }
    .fldSymbolPicker{
      border:1px solid #2a2a2a;
      border-radius:8px;
      padding:0;
      background:#0e0e0e;
      position:relative;
      overflow:visible;
    }
    .fldSymbolPickerButton{
      width:100%;
      border:0;
      background:transparent;
      color:var(--fg);
      border-radius:8px;
      padding:6px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      cursor:pointer;
    }
    .fldSymbolPickerCurrent{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .fldSymbolPickerCurrent img,
    .fldSymbolChoiceBtn img{
      width:26px;
      height:26px;
      object-fit:contain;
      filter:invert(1);
      flex-shrink:0;
    }
    .fldSymbolPickerCurrentLabel{
      min-width:0;
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      gap:2px;
      text-align:left;
      font-size:11px;
    }
    .fldSymbolPickerMenu{
      position:absolute;
      top:calc(100% + 4px);
      left:0;
      right:0;
      z-index:50;
      border:1px solid #2a2a2a;
      border-radius:8px;
      background:#0e0e0e;
      padding:4px;
      box-shadow:0 8px 16px rgba(0,0,0,.4);
      max-height:220px;
      overflow:auto;
      width: 300px;
    }
    .fldSymbolPickerMenu.hidden{ display:none; }
    .fldSymbolChoiceBtn{
      width:100%;
      border:1px solid #2d2d2d;
      background:#141414;
      color:var(--fg);
      border-radius:8px;
      padding:5px 6px;
      display:flex;
      align-items:center;
      gap:8px;
      font-size:11px;
      text-align:left;
      cursor:pointer;
      margin-bottom:4px;
    }
    .fldSymbolChoiceBtn:last-child{ margin-bottom:0; }
    .fldSymbolChoiceLabel{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .fldSymbolChoiceBtn.active{
      border-color:#5ea2ff;
      background:#192739;
    }
    table{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    thead th{
      position:sticky;
      top:0;
      background:#0f0f0f;
      border-bottom:1px solid var(--border);
      padding:8px 8px;
      text-align:left;
      color:var(--muted);
      font-weight:600;
      z-index:1;
      white-space:nowrap;
    }
    tbody td{
      border-bottom:1px solid #1a1a1a;
      padding:7px 8px;
      vertical-align:middle;
    }
    tbody tr.groupRow td{
      background:#101010;
      color:var(--muted);
      font-weight:700;
      letter-spacing:.2px;
      text-transform:none;
      border-top:1px solid #242424;
      border-bottom:1px solid #242424;
      padding:8px;
    }
    tbody tr:hover{ background:#0f0f0f; }
    tbody tr.sel{ outline:1px solid #5c4b14; background:#151006; }
    .cellInput{
      width:100%;
      padding:7px 8px;
      border-radius:10px;
      border:1px solid #2a2a2a;
      background:#0b0b0b;
      color:var(--text);
      font-size:12px;
    }
    .cellInput.bad{
      border-color: var(--bad);
      box-shadow: 0 0 0 1px rgba(255,77,77,0.25) inset;
    }
    .cellBtn{
      padding:7px 10px;
      border-radius:10px;
      border:1px solid #2a2a2a;
      background:#121212;
      color:var(--text);
      font-size:12px;
      cursor:pointer;
      white-space:nowrap;
    }
    .cellBtn:hover{ border-color:#3a3a3a; background:#171717; }
    .cellBtn.danger{
      border-color:#5c1b1b;
      background:#210b0b;
      color:#ffd9d9;
    }
    .cellBtn.danger:hover{ background:#2b0f0f; border-color:#743030; }
    .scrollBody{
      overflow:auto;
      flex:1;
      min-height: 0;
    }

    .linesmith-loading-overlay{
      position:fixed;
      inset:0;
      z-index:1200;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:20px;
      background:transparent;
      pointer-events:none;
      transition:opacity .35s ease, visibility .35s ease;
      opacity:1;
      visibility:visible;
    }
    .linesmith-loading-overlay.hidden{
      opacity:0;
      visibility:hidden;
      pointer-events:none;
    }
    .linesmith-loading-card{
      width:min(520px, calc(100vw - 30px));
      border:1px solid rgba(121, 160, 255, 0.45);
      border-radius:20px;
      background:rgba(7,10,20,0.58);
      box-shadow:0 18px 42px rgba(0,0,0,0.38), inset 0 0 0 1px rgba(255,255,255,0.05);
      padding:18px 22px 14px;
      backdrop-filter: blur(6px);
      pointer-events:auto;
      transition:opacity .3s ease, transform .3s ease;
      transform:translateY(0);
      opacity:1;
    }
    .linesmith-loading-overlay.hidden .linesmith-loading-card{
      opacity:0;
      transform:translateY(8px) scale(0.985);
    }
    .linesmith-loading-title{
      margin:0;
      font-size:17px;
      font-weight:700;
      letter-spacing:.3px;
      color:#edf3ff;
    }
    .linesmith-loading-subtitle{
      margin:6px 0 14px;
      font-size:13px;
      color:#9fb2dd;
    }
    .linesmith-loading-stage{
      font-size:12px;
      color:#c8d7ff;
      font-weight:600;
      letter-spacing:.25px;
      min-height:18px;
      display:block;
    }
    .linesmith-loading-network{
      width:100%;
      height:auto;
      display:block;
      margin-bottom:10px;
      overflow:visible;
    }
    .linesmith-loading-network-graph{
      mask:url(#linesmithLoadingEdgeFade);
    }
    .linesmith-loading-link,
    .linesmith-loading-route-outline,
    .linesmith-loading-segment{
      fill:none;
      stroke-linecap:round;
      stroke-linejoin:round;
    }
    .linesmith-loading-route-outline{
      stroke:rgba(114, 144, 220, 0.28);
      stroke-width:8;
    }
    .linesmith-loading-link{
      stroke:url(#linesmithLoadingLinkFade);
      stroke-width:3;
      stroke-dasharray:7 9;
      animation:linesmithLinkFlow 1.9s linear infinite;
      opacity:.95;
    }
    .linesmith-loading-segment{
      stroke:url(#linesmithLoadingAssemblyStroke);
      stroke-width:4;
      stroke-dasharray:var(--segment-length);
      stroke-dashoffset:var(--segment-length);
      opacity:0;
    }
    .linesmith-loading-segment.segment-1{ animation:linesmithAssembleSegment1 30s linear infinite; }
    .linesmith-loading-segment.segment-2{ animation:linesmithAssembleSegment2 30s linear infinite; }
    .linesmith-loading-segment.segment-3{ animation:linesmithAssembleSegment3 30s linear infinite; }
    .linesmith-loading-segment.segment-4{ animation:linesmithAssembleSegment4 30s linear infinite; }
    .linesmith-loading-segment.segment-5{ animation:linesmithAssembleSegment5 30s linear infinite; }
    .linesmith-loading-node{
      fill:#78e4ff;
      filter:drop-shadow(0 0 8px rgba(120, 228, 255, 0.75));
      animation:linesmithNodeIdle 30s linear infinite;
      transform-origin:center;
      opacity:0;
    }
    .linesmith-loading-node.is-origin{
      fill:#ffe48b;
      filter:drop-shadow(0 0 10px rgba(255, 228, 139, 0.8));
      animation-name:linesmithNodeAssemble1;
    }
    .linesmith-loading-node.node-2{ animation-name:linesmithNodeAssemble2; }
    .linesmith-loading-node.node-3{ animation-name:linesmithNodeAssemble3; }
    .linesmith-loading-node.node-4{ animation-name:linesmithNodeAssemble4; }
    .linesmith-loading-node.is-target{
      fill:#8ff2b1;
      filter:drop-shadow(0 0 10px rgba(143, 242, 177, 0.82));
      animation-name:linesmithNodeAssemble5;
    }
    .linesmith-loading-node-ping{
      fill:none;
      stroke:rgba(120, 228, 255, 0.5);
      stroke-width:2;
      opacity:0;
      transform-origin:center;
      animation:linesmithNodePing 2.6s ease-out infinite;
    }
    .linesmith-loading-node-ping.origin{ animation-delay:.25s; }
    .linesmith-loading-node-ping.target{ animation-delay:1.5s; }
    .linesmith-loading-traverse-dot{
      fill:#ffffff;
      stroke:#8bd6ff;
      stroke-width:1.5;
      filter:drop-shadow(0 0 12px rgba(139, 214, 255, 0.9));
    }
    .linesmith-loading-builder-dot{
      fill:#fef6d8;
      stroke:#ffd261;
      stroke-width:1;
      opacity:0;
      filter:drop-shadow(0 0 8px rgba(255, 210, 97, 0.7));
      animation:linesmithBuilderPulse 30s linear infinite;
    }
    @keyframes linesmithNodeIdle{
      0%, 100% { transform:scale(0.92); }
      50% { transform:scale(1.05); }
    }
    @keyframes linesmithNodePing{
      0% { transform:scale(0.65); opacity:0; }
      15% { opacity:.75; }
      100% { transform:scale(2.15); opacity:0; }
    }
    @keyframes linesmithLinkFlow{
      from { stroke-dashoffset:0; }
      to { stroke-dashoffset:-48; }
    }
    @keyframes linesmithAssembleSegment1{
      0%, 2% { opacity:0; stroke-dashoffset:var(--segment-length); }
      10%, 82% { opacity:1; stroke-dashoffset:0; }
      100% { opacity:0; stroke-dashoffset:0; }
    }
    @keyframes linesmithAssembleSegment2{
      0%, 10% { opacity:0; stroke-dashoffset:var(--segment-length); }
      20%, 84% { opacity:1; stroke-dashoffset:0; }
      100% { opacity:0; stroke-dashoffset:0; }
    }
    @keyframes linesmithAssembleSegment3{
      0%, 20% { opacity:0; stroke-dashoffset:var(--segment-length); }
      32%, 86% { opacity:1; stroke-dashoffset:0; }
      100% { opacity:0; stroke-dashoffset:0; }
    }
    @keyframes linesmithAssembleSegment4{
      0%, 32% { opacity:0; stroke-dashoffset:var(--segment-length); }
      44%, 88% { opacity:1; stroke-dashoffset:0; }
      100% { opacity:0; stroke-dashoffset:0; }
    }
    @keyframes linesmithAssembleSegment5{
      0%, 44% { opacity:0; stroke-dashoffset:var(--segment-length); }
      56%, 90% { opacity:1; stroke-dashoffset:0; }
      100% { opacity:0; stroke-dashoffset:0; }
    }
    @keyframes linesmithNodeAssemble1{
      0%, 3% { opacity:0; transform:scale(0.7); }
      10%, 90% { opacity:1; transform:scale(1); }
      100% { opacity:0; transform:scale(0.9); }
    }
    @keyframes linesmithNodeAssemble2{
      0%, 14% { opacity:0; transform:scale(0.7); }
      21%, 90% { opacity:1; transform:scale(1); }
      100% { opacity:0; transform:scale(0.9); }
    }
    @keyframes linesmithNodeAssemble3{
      0%, 25% { opacity:0; transform:scale(0.7); }
      32%, 90% { opacity:1; transform:scale(1); }
      100% { opacity:0; transform:scale(0.9); }
    }
    @keyframes linesmithNodeAssemble4{
      0%, 37% { opacity:0; transform:scale(0.7); }
      44%, 90% { opacity:1; transform:scale(1); }
      100% { opacity:0; transform:scale(0.9); }
    }
    @keyframes linesmithNodeAssemble5{
      0%, 50% { opacity:0; transform:scale(0.7); }
      57%, 90% { opacity:1; transform:scale(1); }
      100% { opacity:0; transform:scale(0.9); }
    }
    @keyframes linesmithBuilderPulse{
      0%, 4% { opacity:0; }
      8%, 88% { opacity:1; }
      100% { opacity:0; }
    }

    @media (max-width: 960px) {
      .app{ grid-template-columns:1fr; grid-template-areas:"canvas"; }
      .panel{
        position:fixed;
        top:0;
        right:0;
        height:100vh;
        width:min(88vw, 420px);
        transform:translateX(100%);
        transition:transform .2s ease;
        box-shadow:-18px 0 50px rgba(0,0,0,.45);
      }
      .app.panelCollapsed{
        grid-template-columns:1fr;
      }
      .app.panelCollapsed .panel{
        padding:12px 12px 10px;
      }
      .panelCollapseHandle,
      .drawerEdgeExpand{ display:none !important; }
      .app.drawerOpen .panel{ transform:translateX(0); }
      .quickTools{ max-width:calc(100% - 20px); }
      .quickToolsMobileRow{ display:flex; }
      .drawerToggle,
      .mobileToolbarToggle{ display:inline-flex; align-items:center; justify-content:center; }
      .app.mobileToolbarsHidden .quickTools .quickToolsRowPrimary,
      .app.mobileToolbarsHidden .quickTools .quickToolsRowSecondary{ display:none; }
      .linesmith-loading-overlay{ padding:10px; }
      .workflowToast{
        top:auto;
        right:8px;
        bottom:8px;
        left:8px;
        width:auto;
      }
    }

    @keyframes lockDeniedFlash {
      0%, 100% { box-shadow: inset 0 0 0 0 rgba(0,0,0,0); }
      25%, 75% { box-shadow: inset 0 0 0 9999px rgba(239, 68, 68, 0.18); }
      50% { box-shadow: inset 0 0 0 9999px rgba(59, 130, 246, 0.2); }
    }

    body.lock-denied-flash {
      animation: lockDeniedFlash 0.8s linear 1;
    }

  </style>
  <script type="module" src="/src/browser-localstorage-sync.js"></script>
</head>
<body>
<div id="lineSmithLoadingOverlay" class="linesmith-loading-overlay" role="status" aria-live="polite" aria-label="LineSmith loading animation">
  <div class="linesmith-loading-card">
    <h2 class="linesmith-loading-title">Building your LineSmith workspace</h2>
    <p class="linesmith-loading-subtitle">Connecting survey points and restoring drawing context…</p>
    <svg class="linesmith-loading-network" viewBox="0 0 520 160" aria-hidden="true" focusable="false">
      <defs>
        <linearGradient id="linesmithLoadingLinkFade" x1="0" y1="0" x2="1" y2="0">
          <stop offset="0" stop-color="#7ba2ff" stop-opacity="0" />
          <stop offset="0.12" stop-color="#7ba2ff" stop-opacity="1" />
          <stop offset="0.88" stop-color="#7ba2ff" stop-opacity="1" />
          <stop offset="1" stop-color="#7ba2ff" stop-opacity="0" />
        </linearGradient>
        <linearGradient id="linesmithLoadingMaskFade" x1="0" y1="0" x2="1" y2="0">
          <stop offset="0" stop-color="black" stop-opacity="0" />
          <stop offset="0.1" stop-color="white" stop-opacity="1" />
          <stop offset="0.9" stop-color="white" stop-opacity="1" />
          <stop offset="1" stop-color="black" stop-opacity="0" />
        </linearGradient>
        <linearGradient id="linesmithLoadingAssemblyStroke" x1="48" y1="96" x2="452" y2="90" gradientUnits="userSpaceOnUse">
          <stop offset="0" stop-color="#ffe58d" />
          <stop offset="0.45" stop-color="#8fdfff" />
          <stop offset="1" stop-color="#8ff2b1" />
        </linearGradient>
        <mask id="linesmithLoadingEdgeFade">
          <rect x="0" y="0" width="520" height="160" fill="url(#linesmithLoadingMaskFade)" />
        </mask>
      </defs>
      <g class="linesmith-loading-network-graph">
        <path id="linesmithLoadingTraversePath" class="linesmith-loading-route-outline" d="M48 96 L140 62 L248 104 L344 48 L452 90" />
        <path class="linesmith-loading-link" d="M48 96 L140 62 L248 104 L344 48 L452 90" />
        <path class="linesmith-loading-link" d="M140 62 L250 24 L344 48" style="animation-delay:.4s" />
        <path class="linesmith-loading-segment segment-1" style="--segment-length:104" d="M48 96 L140 62" />
        <path class="linesmith-loading-segment segment-2" style="--segment-length:124" d="M140 62 L248 104" />
        <path class="linesmith-loading-segment segment-3" style="--segment-length:112" d="M248 104 L344 48" />
        <path class="linesmith-loading-segment segment-4" style="--segment-length:118" d="M344 48 L452 90" />
        <path class="linesmith-loading-segment segment-5" style="--segment-length:158" d="M140 62 L250 24 L344 48" />
        <circle class="linesmith-loading-node-ping origin" cx="48" cy="96" r="8" />
        <circle class="linesmith-loading-node-ping target" cx="452" cy="90" r="8" />
        <circle class="linesmith-loading-node is-origin" cx="48" cy="96" r="7" />
        <circle class="linesmith-loading-node node-2" cx="140" cy="62" r="7" />
        <circle class="linesmith-loading-node node-3" cx="248" cy="104" r="7" />
        <circle class="linesmith-loading-node node-4" cx="344" cy="48" r="7" />
        <circle class="linesmith-loading-node is-target" cx="452" cy="90" r="7" />
        <circle class="linesmith-loading-builder-dot" cx="48" cy="96" r="3.2">
          <animateMotion dur="30s" repeatCount="indefinite" rotate="auto">
            <mpath href="#linesmithLoadingTraversePath" />
          </animateMotion>
        </circle>
        <circle class="linesmith-loading-traverse-dot" cx="48" cy="96" r="4.5">
          <animateMotion dur="30s" repeatCount="indefinite" keyTimes="0;0.18;0.4;0.62;0.86;1" keyPoints="0;0.25;0.5;0.75;1;1" calcMode="linear" rotate="auto">
            <mpath href="#linesmithLoadingTraversePath" />
          </animateMotion>
        </circle>
      </g>
    </svg>
    <span id="lineSmithLoadingStage" class="linesmith-loading-stage">Preparing drawing canvas…</span>
  </div>
</div>
<div class="app panelCollapsed" id="appShell">
  <div class="panel">
    <button id="panelCollapseHandle" class="panelCollapseHandle" aria-label="Collapse controls drawer" title="Collapse controls drawer">→</button>
    <h1>LineSmith — Points & Bearings</h1>

    <div class="section">
      <div class="title">
        <b>Inspector + Map Opacity</b>
        <span>always visible</span>
      </div>
      <label>Map opacity
        <input id="mapOpacity" type="range" min="0" max="100" step="1" value="66" />
        <span class="mini" id="mapOpacityValue">66%</span>
      </label>
      <div id="lineInspector" class="inspectorCard">Select one line or two points to inspect bearing + distance.</div>
      <div id="pointInspector" class="inspectorCard">Select one point to inspect point details.</div>
    </div>

    <details id="panelToolsCollapse" class="panelToolsCollapse">
      <summary>Tool drawer sections</summary>
      <div class="panelToolsCollapseBody">

    <div class="section">
      <div class="title">
        <b>Tool</b>
        <span id="toolHint">Select/Move</span>
      </div>
      <div class="grid2">
        <button id="toolSelect" class="primary">Select / Move</button>
        <button id="toolAddPoint">Add Point</button>
        <button id="toolLine2pt">Line: 2 Points</button>
        <button id="toolLineDB">Line: Dist/Bearing</button>
        <button id="toolPointOnLine">Point on Line</button>
        <button id="toolPan">Pan</button>
      </div>

      <div class="grid2" style="margin-top:8px;">
        <button id="undoBtn">Undo</button>
        <button id="redoBtn">Redo</button>
      </div>

      <div class="grid2" style="margin-top:8px;">
        <button id="zoomExtents" class="ok">Zoom Extents</button>
      </div>

      <div class="hint">
        <b>Locked by default:</b> points/lines won’t drag-move unless you <b>double-click</b> them to toggle “movable”.
        <br><b>Multi-select:</b> hold <b>Shift</b> while clicking.
        <br><b>Window select:</b> Shift+drag in empty space (desktop) or long-press blank space then drag (mobile).
      </div>
      <div class="kbd">
        <div><span>Toggle movable</span><code>DblClick</code></div>
        <div><span>Marquee select</span><code>Drag</code></div>
        <div><span>Add to selection</span><code>Shift</code></div>
        <div><span>Pan while holding</span><code>Space</code></div>
        <div><span>Undo</span><code>Ctrl+Z</code></div>
        <div><span>Redo</span><code>Ctrl+Y</code></div>
        <div><span>Delete selected</span><code>Del</code></div>
        <div><span>Zoom</span><code>Wheel</code></div>
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Project Drawing Saves</b>
        <span>named differential history</span>
      </div>
      <div class="grid2">
        <label style="grid-column:1/-1;">Drawing name
          <input id="drawingName" placeholder="Boundary Base Map" />
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="saveDrawingToProject" class="ok">Save Drawing to Project</button>
        <button id="restoreDrawingVersion">Restore Saved Version…</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="openArrowHead" class="ok" style="flex:1;">Open ArrowHead AR</button>
      </div>
      <div class="hint mini" id="drawingSaveHint">Open LineSmith from an active SurveyFoundry project to enable project-linked drawing saves.</div>
      <div class="hint mini" id="collabStatus">Collaboration: offline</div>
    </div>

    <div class="section">
      <div class="title">
        <b>CSV</b>
        <span>number,x,y,z,code,notes</span>
      </div>
      <label>
        Import points CSV
        <input id="csvIn" type="file" accept=".csv,.txt" />
      </label>
      <div class="row" style="margin-top:8px;">
        <label style="flex:1;">
          On import
          <select id="importMode">
            <option value="merge">Merge by point number (update existing)</option>
            <option value="skip">Skip duplicates</option>
            <option value="rename">Auto-rename duplicates (next open number)</option>
          </select>
        </label>
      </div>

      <!-- ADDED: coordinate order selector (fixes X/Y swap root cause for headerless N,E CSVs) -->
      <div class="row" style="margin-top:8px;">
        <label style="flex:1;">
          Coordinate columns (headerless CSV only)
          <select id="csvCoordOrder">
            <option value="xy">Assume X,Y (Easting,Northing)</option>
            <option value="yx">Assume Y,X (Northing,Easting) — swap on import</option>
          </select>
        </label>
      </div>

      <div class="inline" style="margin-top:8px;">
        <label><input id="autoZoomAfterImport" type="checkbox" checked /> Auto-zoom after import</label>
      </div>

      <!-- ADDED: one-click repair for already imported swapped datasets -->
      <div class="row" style="margin-top:8px;">
        <button id="swapXYAll" class="danger" style="flex:1;">Swap X↔Y for ALL Points</button>
      </div>
      <div class="hint mini">
        If your drawing came in “transposed”, that’s X/Y swapped in the point data (common when a headerless CSV is N,E instead of E,N).
        This button fixes existing points (Undo works). For future imports, set “Coordinate columns” to Y,X.
      </div>

      <div class="row" style="margin-top:8px;">
        <button id="exportCsv" class="ok" style="flex:1;">Export Points CSV</button>
      </div>
      <div class="hint">Header row optional. Extra columns ignored.</div>
    </div>

    <div class="section">
      <div class="title">
        <b>Print View</b>
        <span>record of survey template (landscape)</span>
      </div>
      <div class="grid2">
        <label>Paper size
          <select id="printPaperSize">
            <option value="A0">A0</option>
            <option value="A1">A1</option>
            <option value="A2">A2</option>
            <option value="A3">A3</option>
            <option value="A4" selected>A4</option>
            <option value="custom">Custom</option>
          </select>
        </label>
        <label>Scale (auto)
          <input id="printScalePreview" value="Auto" readonly />
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <label>Custom width (mm)
          <input id="printCustomWidthMm" type="number" min="100" step="1" value="420" />
        </label>
        <label>Custom height (mm)
          <input id="printCustomHeightMm" type="number" min="100" step="1" value="297" />
        </label>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="generatePrintView" class="ok" style="flex:1;">Draw Print Window</button>
      </div>
      <div class="hint mini">Click <b>Draw Print Window</b>, drag a selection window around the area to print, then release to generate a black-on-white print-ready excerpt. Scale snaps to nearest supported ratio: 1:1, 1:5, 1:10, 1:20, 1:30, 1:40, 1:50, 1:100, 1:200, 1:500, 1:1000.</div>
    </div>

    <div class="section">
      <div class="title">
        <b>Add / Edit Point</b>
        <span>click canvas in Add Point</span>
      </div>
      <div class="grid2">
        <label>Number (blank = auto)
          <input id="ptNum" placeholder="auto" />
        </label>
        <label>Z
          <input id="ptZ" placeholder="0" />
        </label>
      </div>
      <div class="grid2">
        <label>Code
          <input id="ptCode" placeholder="CODE" />
        </label>
        <label class="mini">Notes/Desc
          <input id="ptNotes" placeholder="notes" />
        </label>
      </div>
      <div class="grid2">
        <label>X
          <input id="ptX" placeholder="(selected)" />
        </label>
        <label>Y
          <input id="ptY" placeholder="(selected)" />
        </label>
      </div>
      <div id="pointEditorSymbolRow" class="pointEditorSymbolRow" aria-live="polite"></div>
      <div class="grid2" style="margin-top:8px;">
        <button id="applyPoint" class="ok">Apply to Selected Point</button>
        <button id="focusSelected">Center on Selection</button>
      </div>
      <div class="hint">
        Marker: <span style="color:var(--pt)">red X</span> · Number: <span style="color:var(--num)">white</span> · Code: <span style="color:var(--code)">green</span> · Notes: <span style="color:var(--notes)">blue</span>
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Display</b>
        <span>display visibility</span>
      </div>
      <div class="inline">
        <label><input id="showLines" type="checkbox" checked /> Draw lines</label>
        <label><input id="showBearings" type="checkbox" checked /> Draw bearings</label>
        <label><input id="showPoints" type="checkbox" checked /> Draw point markers</label>
        <label><input id="showPointNames" type="checkbox" checked /> Draw point names</label>
      </div>
      <div class="inline">
        <label><input id="showPointCodes" type="checkbox" checked /> Draw point codes</label>
        <label><input id="showPointNotes" type="checkbox" /> Draw point notes</label>
        <label><input id="enablePointClustering" type="checkbox" checked /> Cluster overlapping points</label>
      </div>
      <div class="sep"></div>
      <div class="inline">
        <label><input id="mapLayerEnabled" type="checkbox" /> Show map layer behind canvas</label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <label>Map tiles
          <select id="mapTileType">
            <option value="satellite" selected>Satellite</option>
            <option value="osmStandard">OpenStreetMap Standard</option>
            <option value="osmHumanitarian">OpenStreetMap Humanitarian</option>
            <option value="osmCycle">OpenStreetMap Cycle</option>
          </select>
        </label>
      </div>
      <div class="hint mini">Toggle markers, names, codes, notes, and clustering anytime while sketching. Disable point markers to view only linework. Map layer defaults to 66% opacity when enabled.</div>
    </div>

    <div class="section">
      <div class="title">
        <b>Line: Distance / Bearing</b>
        <span>select start point</span>
      </div>
      <div class="grid2">
        <label>Distance
          <input id="dist" placeholder="100.00" />
        </label>
        <label>Bearing / Azimuth
          <input id="bearing" placeholder='N15-15-15W  or  N15.1515W  or  123.45' />
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="setStartFromSel" class="primary">Use Selected Point as Start</button>
        <button id="makeLineDB" class="ok">Create Point + Line</button>
      </div>
      <div class="hint">
        Bearing formats accepted:
        <br>• Quadrant: <b>N15-15-15W</b>, <b>N15.1515W</b>, <b>S12-30E</b>
        <br>• Azimuth degrees from North (clockwise): <b>123.45</b>
      </div>
      <div class="sep"></div>
      <div class="grid2">
        <button id="lineBetweenSelected" class="ok">Line Between Selected Points</button>
        <button id="clearConstruction">Clear Construction</button>
      </div>
      <div class="hint">
        If you have <b>2</b> points selected → one line.
        If you have <b>3+</b> points selected → chain lines in selection order (P1–P2, P2–P3, ...).
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Basis of Bearing</b>
        <span>define two existing points</span>
      </div>
      <div class="grid2">
        <label>Start point #/name
          <input id="basisBearingStartPoint" placeholder="101" />
        </label>
        <label>End point #/name
          <input id="basisBearingEndPoint" placeholder="102" />
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <label>Record basis bearing
          <input id="basisBearingRecordBearing" placeholder='N89°59\'59"E' />
        </label>
        <label>Record basis distance
          <input id="basisBearingRecordDistance" placeholder="123.456" />
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="setBasisOfBearing" class="ok">Set Basis of Bearing</button>
        <button id="clearBasisOfBearing">Clear Basis of Bearing</button>
      </div>
      <div class="hint mini">Draws an on-canvas reference line clearly labeled <b>BASIS OF BEARING</b>.</div>
    </div>

    <div class="section">
      <div class="title">
        <b>Line Ops</b>
        <span>select lines (Shift for multi)</span>
      </div>
      <div class="grid2">
        <button id="extendToIntersect" class="primary">Extend → Intersect (new point)</button>
        <button id="trimToIntersect">Trim (grip) → Intersect</button>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="pointAtIntersection" class="ok">Create Point @ Intersection</button>
        <button id="trimOverlap">Trim Overlap (colinear)</button>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <label>Offset distance
          <input id="lineOffsetDistance" placeholder="10.00" />
        </label>
        <button id="offsetSelectedLine" class="ok">Offset Selected Line</button>
      </div>
      <div class="hint">
        • <b>Extend → Intersect</b> creates a <b>new point</b> at the intersection and re-ends the active line there (original endpoint point does not move).
        <br>• <b>Trim</b> uses the selected line’s grip (nearest endpoint where you clicked) and shortens by moving that endpoint.
        <br>• <b>Offset Selected Line</b> creates a parallel line by the entered distance (+left, −right from A→B).
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Point on Line</b>
        <span>select a line</span>
      </div>
      <div class="grid3">
        <label>Station
          <input id="station" placeholder="25.00" />
        </label>
        <label>Offset (+left)
          <input id="offset" placeholder="0.00" />
        </label>
        <label>From
          <select id="stationFrom">
            <option value="a">Line A-end</option>
            <option value="b">Line B-end</option>
          </select>
        </label>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="makePointOnLine" class="ok">Create Point</button>
        <button id="swapLineEnds">Swap Line Ends</button>
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Selection</b>
        <span id="selSummary">none</span>
      </div>
      <div class="grid2">
        <button id="deleteSelected" class="danger">Delete Selected</button>
        <button id="clearSelection">Clear Selection</button>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <button id="rotateSelectionReference" class="primary">Rotate Selection (Reference)</button>
      </div>
      <div class="hint mini">Pick base point → reference angle point → target angle point.</div>
      <div id="status" class="status">Ready.</div>
    </div>

    <div class="section">
      <div class="title">
        <b>Points Manager</b>
        <span id="pointsCount">0 points</span>
      </div>
      <div class="grid2">
        <button id="openPointsManager" class="primary">Open Points List / Editor</button>
        <button id="closePointsManager" disabled>Close</button>
      </div>
      <div class="hint">
        Opens a resizable modal for wide columns (number, X, Y, Z, code, notes) without squeezing the sidebar.
      </div>
    </div>

    <div class="section">
      <div class="title">
        <b>Field-to-Finish</b>
        <span>FLD rules</span>
      </div>
      <div class="grid2">
        <button id="openFldEditor" class="primary">Open FLD Editor</button>
        <button id="downloadFldLocal" title="Download locally-overridden FLD config">Download Local FLD</button>
      </div>
      <div class="hint">Edit/add/remove FLD codes, keep a local override copy, or reset back to the server file.</div>
    </div>

      </div>
    </details>

  </div>

  <div class="canvasWrap">
    <button id="drawerEdgeExpand" class="drawerEdgeExpand" aria-label="Expand controls drawer" title="Expand controls drawer">←</button>
    <div id="quickTools" class="quickTools" aria-label="LineSmith quick tools">
      <div class="quickToolsRow quickToolsMobileRow">
        <button id="mobileToolbarToggle" class="mobileToolbarToggle" aria-pressed="false" aria-label="Hide quick toolbars">Hide Bars</button>
        <button id="drawerToggle" class="drawerToggle">Tools</button>
      </div>
      <div class="quickToolsRow quickToolsRowPrimary">
        <button id="quickSave" class="quickToolBtn" title="Save Drawing to Project" aria-label="Save Drawing to Project"><i class="fa-solid fa-floppy-disk"></i></button>
        <button id="quickPrintView" class="quickToolBtn" title="Draw Print Window" aria-label="Draw Print Window"><i class="fa-solid fa-print"></i></button>
        <button id="quickOpenArrowHead" class="quickToolBtn" title="Open ArrowHead AR" aria-label="Open ArrowHead AR"><i class="fa-solid fa-vr-cardboard"></i></button>
        <button id="quickLayerManager" class="quickToolBtn" title="Layer Manager" aria-label="Layer Manager"><i class="fa-solid fa-layer-group"></i></button>
        <div class="quickToolField quickToolLayer" title="Active layer">
          <span id="quickLayerColor" class="quickToolLayerSwatch" aria-hidden="true"></span>
          <div id="quickLayerDropdown" class="quickLayerDropdown">
            <button id="quickLayerDropdownButton" class="quickLayerDropdownBtn" aria-label="Active Layer" aria-haspopup="listbox" aria-expanded="false">
              <span id="quickLayerDropdownLabel" class="quickLayerDropdownBtnText">Layer</span>
              <i class="fa-solid fa-chevron-down" aria-hidden="true"></i>
            </button>
            <div id="quickLayerDropdownMenu" class="quickLayerDropdownMenu hidden" role="listbox" aria-label="Layer options"></div>
          </div>
        </div>
        <div class="quickToolField quickToolToggleGroup" title="Display toggles" aria-label="Display toggles">
          <button id="quickShowLines" class="quickToggleBtn active" title="Toggle lines" aria-label="Toggle lines"><i class="fa-solid fa-slash"></i><span class="sr-only">Lines</span></button>
          <button id="quickShowBearings" class="quickToggleBtn active" title="Toggle bearings" aria-label="Toggle bearings"><i class="fa-solid fa-compass"></i><span class="sr-only">Bearings</span></button>
          <button id="quickShowPoints" class="quickToggleBtn active" title="Toggle point markers" aria-label="Toggle point markers"><i class="fa-solid fa-location-crosshairs"></i><span class="sr-only">Points</span></button>
          <button id="quickShowPointNames" class="quickToggleBtn active" title="Toggle point names" aria-label="Toggle point names"><i class="fa-solid fa-tag"></i><span class="sr-only">Names</span></button>
          <button id="quickShowPointCodes" class="quickToggleBtn active" title="Toggle point codes" aria-label="Toggle point codes"><i class="fa-solid fa-hashtag"></i><span class="sr-only">Codes</span></button>
          <button id="quickShowPointNotes" class="quickToggleBtn" title="Toggle point notes" aria-label="Toggle point notes"><i class="fa-solid fa-note-sticky"></i><span class="sr-only">Notes</span></button>
          <button id="quickTogglePointClustering" class="quickToggleBtn active" title="Toggle point clustering" aria-label="Toggle point clustering"><i class="fa-solid fa-circle-nodes"></i><span class="sr-only">Clustering</span></button>
        </div>
        <div id="quickCommandSearch" class="quickToolField quickToolSearch" title="Search points or enter command">
          <input id="quickCommandSearchInput" type="text" placeholder="Search points or type command" aria-label="Search points or type command" autocomplete="off" />
                    <div id="quickCommandSearchResults" class="quickSearchResults hidden" role="listbox" aria-label="Search and command suggestions"></div>
        </div>
        <button id="quickMapLayerEnabled" class="quickToggleBtn" title="Toggle map layer" aria-label="Toggle map layer" aria-pressed="false"><i class="fa-solid fa-map"></i><span class="sr-only">Map</span></button>
        <div class="quickToolField" title="Map tiles">
          <select id="quickMapTileType" aria-label="Quick Map Tile Type">
            <option value="satellite" selected>Satellite</option>
            <option value="osmStandard">OSM Standard</option>
            <option value="osmHumanitarian">OSM Humanitarian</option>
            <option value="osmCycle">OSM Cycle</option>
          </select>
        </div>
      </div>
      <div class="quickToolsRow quickToolsRowSecondary">
        <button id="quickSelect" class="quickToolBtn primary" title="Select / Move" aria-label="Select / Move"><i class="fa-solid fa-arrow-pointer"></i></button>
        <button id="quickAddPoint" class="quickToolBtn" title="Add Point" aria-label="Add Point"><i class="fa-solid fa-circle-plus"></i></button>
        <button id="quickLineByPoints" class="quickToolBtn" title="Line by Points" aria-label="Line by Points"><i class="fa-solid fa-share-nodes"></i></button>
        <span class="quickToolDivider" aria-hidden="true"></span>
        <button id="quickUndo" class="quickToolBtn" title="Undo" aria-label="Undo"><i class="fa-solid fa-rotate-left"></i></button>
        <button id="quickRedo" class="quickToolBtn" title="Redo" aria-label="Redo"><i class="fa-solid fa-rotate-right"></i></button>
        <button id="quickZoomExtents" class="quickToolBtn" title="Zoom Extents" aria-label="Zoom Extents"><i class="fa-solid fa-expand"></i></button>
        <button id="quickCenterOnLocation" class="quickToolBtn" title="Center on My Location (25′ radius)" aria-label="Center on My Location"><i class="fa-solid fa-location-dot"></i></button>
        <span class="quickToolDivider" aria-hidden="true"></span>
        <button id="quickExtend" class="quickToolBtn" title="Extend to Intersect" aria-label="Extend"><i class="fa-solid fa-up-right-and-down-left-from-center"></i></button>
        <button id="quickTrimIntersect" class="quickToolBtn" title="Trim to Intersect" aria-label="Trim / Intersect"><i class="fa-solid fa-scissors"></i></button>
        <button id="quickOffsetLine" class="quickToolBtn" title="Offset Selected Line" aria-label="Offset Selected Line"><i class="fa-solid fa-arrows-left-right"></i></button>
        <button id="quickRotateSelection" class="quickToolBtn" title="Rotate Selection (Reference)" aria-label="Rotate Selection"><i class="fa-solid fa-rotate"></i></button>
        <button id="quickPointManager" class="quickToolBtn" title="Open Points Manager" aria-label="Point Manager"><i class="fa-solid fa-list"></i></button>
        <button id="quickFtfManager" class="quickToolBtn" title="Open FLD Editor" aria-label="Field-to-Finish Manager"><i class="fa-solid fa-diagram-project"></i></button>
      </div>
    </div>
    <div id="mapBackdrop" class="mapBackdrop"><div id="mapLayer"></div></div>
    <canvas id="c"></canvas>
    <div id="clusterTooltip" class="clusterTooltip hidden" role="status" aria-live="polite"></div>
    <div id="pointHoverTooltip" class="clusterTooltip hidden" role="status" aria-live="polite"></div>
    <div id="workflowToast" class="workflowToast hidden" role="status" aria-live="polite" aria-atomic="true">
      <div id="workflowToastTitle" class="workflowToastTitle"></div>
      <div id="workflowToastMessage" class="workflowToastMessage"></div>
      <ol id="workflowToastSteps" class="workflowToastSteps"></ol>
    </div>
    <div class="hud">
      <span class="pill"><b>Tool</b> <span id="hudTool">Select/Move</span></span>
      <span class="pill"><b>Mouse (State Plane)</b> <span id="hudMouse">x: 0.000, y: 0.000</span></span>
      <span class="pill"><b>Scale</b> <span id="hudZoom">1.00</span></span>
      <span class="pill"><b>Sel</b> <span id="hudSel" class="clip">none</span></span>
      <span class="pill"><b>Undo</b> <span id="hudUndo">0</span></span>
      <span class="pill"><b>Redo</b> <span id="hudRedo">0</span></span>
    </div>
  </div>
</div>

<!-- Points Manager Modal -->
<div id="pointsModal" class="modalOverlay hidden" aria-hidden="true">
  <div id="pointsModalWindow" class="modalWindow">
    <div id="pointsModalHeader" class="modalHeader">
      <b>Points Manager</b>
      <div class="right">
        <span class="pill"><b>Total</b> <span id="modalPointsCount">0</span></span>
        <button id="pointsModalClose" class="cellBtn">Close</button>
      </div>
    </div>

    <div class="modalBody">
      <div class="tableWrap">
        <div class="tableTools">
          <input id="ptFilter" placeholder="Filter: number / code / notes" />
          <select id="ptGroupBy" aria-label="Group points by">
            <option value="none" selected>Group: None</option>
            <option value="layer">Group: Layer</option>
            <option value="code">Group: Code</option>
          </select>
          <button id="refreshPoints" class="cellBtn">Refresh</button>
          <button id="sortPoints" class="cellBtn">Sort: Num</button>
          <span class="pill"><b>Tip</b> <span class="clip">Shift-click + drag window to multi-select</span></span>
        </div>

        <div class="scrollBody">
          <table>
            <thead>
              <tr>
                <th style="width:90px;">#</th>
                <th style="width:140px;">X</th>
                <th style="width:140px;">Y</th>
                <th style="width:110px;">Z</th>
                <th style="width:140px;">Code</th>
                <th>Notes</th>
                <th style="width:240px;">Actions</th>
              </tr>
            </thead>
            <tbody id="pointsTbody"></tbody>
          </table>
        </div>
      </div>

      <div class="hint">
        Edits validate point number uniqueness. Press <b>Esc</b> to close the modal.
      </div>
    </div>
  </div>
</div>

<div id="connectLinesModal" class="modalOverlay hidden" aria-hidden="true">
  <div class="modalWindow connectLinesModalWindow">
    <div class="modalHeader">
      <b>Connect Lines</b>
    </div>
    <div class="modalBody connectLinesModalBody">
      <button id="connectLinesSequential" class="primary">Sequentially</button>
      <button id="connectLinesByDistance">By Distance</button>
    </div>
  </div>
</div>

<div id="layersModal" class="modalOverlay hidden" aria-hidden="true">
  <div id="layersModalWindow" class="modalWindow">
    <div id="layersModalHeader" class="modalHeader">
      <b>Layer Manager</b>
      <div class="right">
        <button id="layersAdd" class="cellBtn">Add Layer</button>
        <button id="layersModalClose" class="cellBtn">Close</button>
      </div>
    </div>
    <div class="modalBody">
      <div class="tableWrap">
        <div class="scrollBody">
          <table>
            <thead>
              <tr>
                <th>Name</th>
                <th>Color</th>
                <th>Line Weight</th>
                <th>Lock</th>
                <th>Visible</th>
                <th>Fill</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="layersTbody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="fldModal" class="modalOverlay hidden" aria-hidden="true">
  <div id="fldModalWindow" class="modalWindow" style="width:min(1200px,95vw);height:min(680px,84vh);">
    <div id="fldModalHeader" class="modalHeader">
      <b>Field-to-Finish (FLD) Editor</b>
      <div class="right">
        <span class="pill"><b>Source</b> <span id="fldSourceLabel">Server</span></span>
        <button id="fldAddRule" class="cellBtn">Add Code</button>
        <button id="fldDownloadLocal" class="cellBtn">Download Local FLD</button>
        <button id="fldDownloadCurrent" class="cellBtn">Download Current FLD</button>
        <button id="fldResetServer" class="cellBtn">Reset to Server</button>
        <button id="fldSaveLocal" class="cellBtn">Save Local</button>
        <button id="fldModalClose" class="cellBtn">Close</button>
      </div>
    </div>
    <div class="modalBody">
      <div class="tableWrap">
        <div class="tableTools">
          <input id="fldFilter" placeholder="Filter codes" />
          <span class="pill"><b>Tip</b> <span class="clip">Edits are stored in browser localStorage until reset.</span></span>
        </div>
        <div class="scrollBody">
          <table>
            <thead>
              <tr>
                <th style="width:120px;">Code</th>
                <th style="width:110px;">Entity</th>
                <th style="width:110px;">Process</th>
                <th style="width:180px;">Layer</th>
                <th style="width:220px;">Description</th>
                <th style="width:340px;">Type Config (line type / symbol + scale)</th>
                <th style="width:220px;">Companion Codes</th>
                <th style="width:100px;">Actions</th>
              </tr>
            </thead>
            <tbody id="fldTbody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>
<script>
(() => {
  // -------------------------
  // Utilities
  // -------------------------
  const EPS = 1e-9;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist2 = (ax,ay,bx,by)=>{ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };
  const dist = (ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
  const fmt = (n)=> (Number.isFinite(n) ? (Math.abs(n) < 1e6 ? n.toFixed(3) : n.toExponential(6)) : "NaN");
  const fmtPlainCoordinate = (n)=> (Number.isFinite(n)
    ? n.toLocaleString("en-US", { useGrouping:false, minimumFractionDigits:3, maximumFractionDigits:3 })
    : "NaN");
  const POINTFORGE_IMPORT_STORAGE_KEY = "lineSmithPointforgeImport";
  const PROJECT_FILE_STORAGE_PREFIX = "surveyfoundryProjectFile";
  const PROJECT_DRAWING_STORAGE_PREFIX = "surveyfoundryLineSmithDrawing";
  const PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY = "lineSmithProjectBrowserDrawingImport";
  const PROJECT_LAST_DRAWING_STORAGE_PREFIX = "surveyfoundryLastLineSmithDrawing";
  const ARROWHEAD_IMPORT_STORAGE_KEY = "lineSmithArrowHeadImport";
  const FLD_CONFIG_LOCAL_STORAGE_KEY = "lineSmithFldConfigLocal";
  const FLD_SYMBOL_MAP_OVERRIDES_LOCAL_STORAGE_KEY = "lineSmithFldSymbolSvgOverrides";
  const ARROWHEAD_SYNC_INTERVAL_MS = 1000;
  let lastArrowHeadPayloadJson = "";
  let lastArrowHeadPayloadSyncAt = 0;

  const parseNum = (s, def=0) => {
    const n = Number(String(s).trim());
    return Number.isFinite(n) ? n : def;
  };
  const isEditableTarget = (t) => {
    if (!t) return false;
    const tag = (t.tagName || "").toUpperCase();
    return tag === "INPUT" || tag === "TEXTAREA" || t.isContentEditable || tag === "SELECT";
  };
  const $ = (q)=>document.querySelector(q);

  const queryParams = new URLSearchParams(window.location.search);
  const launchSource = queryParams.get("source") || "";
  const activeProjectId = queryParams.get("activeProjectId") || "";
  const activeProjectName = queryParams.get("activeProjectName") || "";
  const collabRoomParam = queryParams.get("drawingId") || queryParams.get("collabRoom") || "";
  let activeDrawingStorageKey = "";
  let lastSavedDrawingSnapshot = "";

  const collab = {
    socket: null,
    roomId: "",
    wsUrl: "",
    clientId: "",
    color: "#ffffff",
    peers: new Map(),
    remoteCursors: new Map(),
    remoteArPresence: new Map(),
    stateDebounce: null,
    applyingRemoteState: false,
    enabled: false,
    reconnectDelayMs: 3000,
    maxReconnectDelayMs: 60000,
    reconnectTimer: null,
    connectToken: 0,
    stateInFlight: null,
    pendingState: "",
    lastKnownRevision: 0,
    latestServerState: "",
    lastQueuedState: "",
    objectLocks: new Map(),
    pendingLockRequests: new Map(),
    activeDragLock: null,
    pendingDragLockRelease: null
  };

  function nextCollabReconnectDelay(previousDelayMs, maxDelayMs) {
    const baseDelayMs = 3000;
    const normalizedPrevious = Number.isFinite(previousDelayMs)
      ? Math.max(baseDelayMs, Math.trunc(previousDelayMs))
      : baseDelayMs;
    const normalizedMax = Number.isFinite(maxDelayMs)
      ? Math.max(baseDelayMs, Math.trunc(maxDelayMs))
      : 60000;
    return Math.min(normalizedPrevious * 2, normalizedMax);
  }

  function setStatus(msg, kind="") {
    const el = $("#status");
    el.textContent = msg;
    el.className = "status" + (kind ? " " + kind : "");
  }

  function setLineSmithLoadingStage(stage = "") {
    const stageEl = $("#lineSmithLoadingStage");
    if (!stageEl) return;
    stageEl.textContent = String(stage || "").trim() || "Preparing drawing canvas…";
  }

  function showLineSmithLoadingOverlay(stage = "") {
    const overlay = $("#lineSmithLoadingOverlay");
    if (!overlay) return;
    setLineSmithLoadingStage(stage);
    overlay.classList.remove("hidden");
  }

  function hideLineSmithLoadingOverlay() {
    const overlay = $("#lineSmithLoadingOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
  }

  const workflowToastState = {
    active: false,
    title: "",
    message: "",
    steps: [],
    currentStepIndex: -1
  };

  const lineIntersectionCommandSession = {
    active: false,
    mode: ""
  };

  function renderWorkflowToast() {
    const root = $("#workflowToast");
    const titleEl = $("#workflowToastTitle");
    const messageEl = $("#workflowToastMessage");
    const stepsEl = $("#workflowToastSteps");
    if (!root || !titleEl || !messageEl || !stepsEl) return;

    if (!workflowToastState.active || !workflowToastState.steps.length) {
      root.classList.add("hidden");
      titleEl.textContent = "";
      messageEl.textContent = "";
      stepsEl.innerHTML = "";
      return;
    }

    root.classList.remove("hidden");
    titleEl.textContent = workflowToastState.title;
    messageEl.textContent = workflowToastState.message;
    stepsEl.innerHTML = "";

    workflowToastState.steps.forEach((step, idx) => {
      const li = document.createElement("li");
      li.textContent = step;
      if (idx < workflowToastState.currentStepIndex) li.classList.add("done");
      else if (idx === workflowToastState.currentStepIndex) li.classList.add("active");
      stepsEl.appendChild(li);
    });
  }

  function hideWorkflowToast() {
    workflowToastState.active = false;
    workflowToastState.title = "";
    workflowToastState.message = "";
    workflowToastState.steps = [];
    workflowToastState.currentStepIndex = -1;
    renderWorkflowToast();
  }

  function showWorkflowToast({ title, message, steps, currentStepIndex }) {
    workflowToastState.active = true;
    workflowToastState.title = String(title || "");
    workflowToastState.message = String(message || "");
    workflowToastState.steps = Array.isArray(steps) ? steps.map((item) => String(item)) : [];
    workflowToastState.currentStepIndex = clamp(Number(currentStepIndex) || 0, 0, Math.max(0, workflowToastState.steps.length - 1));
    renderWorkflowToast();
  }

  function syncLineIntersectionCommandToast() {
    if (!lineIntersectionCommandSession.active) return;
    const selectedCount = Math.min(2, selectedLines.length);
    const isExtend = lineIntersectionCommandSession.mode === "extend";
    const isTrim = lineIntersectionCommandSession.mode === "trim";
    const firstStep = isTrim ? "Select trim boundary line" : "Select first line";
    const secondStep = isTrim ? "Select line to trim (click desired side)" : "Select second line";
    showWorkflowToast({
      title: isExtend ? "Extend to Intersect Workflow" : "Trim to Intersect Workflow",
      message: selectedCount < 2
        ? `${selectedCount === 0 ? firstStep : secondStep} (${selectedCount === 0 ? "click line" : "click next line"}; Shift-click still supports normal multi-select).`
        : "Two lines selected. Running command...",
      steps: [
        firstStep,
        secondStep,
        isExtend ? "Extend active line to intersection" : "Trim active line to intersection"
      ],
      currentStepIndex: selectedCount
    });
  }

  function startLineIntersectionCommand(mode) {
    lineIntersectionCommandSession.active = true;
    lineIntersectionCommandSession.mode = mode;
    setTool("select");
    syncLineIntersectionCommandToast();
    setStatus(`Line ${mode}: select two lines to continue.`, "warn");
  }

  function stopLineIntersectionCommand() {
    lineIntersectionCommandSession.active = false;
    lineIntersectionCommandSession.mode = "";
    syncToolWorkflowToast();
  }

  function deepClone(value) {
    return JSON.parse(JSON.stringify(value));
  }

  function isPlainObject(value) {
    return !!value && typeof value === "object" && !Array.isArray(value);
  }

  function diffState(previous, next) {
    if (Object.is(previous, next)) return undefined;
    if (Array.isArray(previous) && Array.isArray(next)) {
      if (previous.length !== next.length) return deepClone(next);
      const out = [];
      let changed = false;
      for (let i = 0; i < next.length; i += 1) {
        const child = diffState(previous[i], next[i]);
        if (child === undefined) {
          out[i] = { __unchanged: true };
          continue;
        }
        out[i] = child;
        changed = true;
      }
      return changed ? out : undefined;
    }
    if (isPlainObject(previous) && isPlainObject(next)) {
      const keys = new Set([...Object.keys(previous), ...Object.keys(next)]);
      const out = {};
      let changed = false;
      for (const key of keys) {
        if (!(key in next)) {
          out[key] = { __deleted: true };
          changed = true;
          continue;
        }
        const child = diffState(previous[key], next[key]);
        if (child !== undefined) {
          out[key] = child;
          changed = true;
        }
      }
      return changed ? out : undefined;
    }
    return deepClone(next);
  }

  function applyStateDiff(base, diff) {
    if (diff === undefined) return deepClone(base);
    if (Array.isArray(diff)) {
      const source = Array.isArray(base) ? base : [];
      return diff.map((part, index) => applyStateDiff(source[index], part));
    }
    if (isPlainObject(diff)) {
      if (diff.__unchanged) return deepClone(base);
      if (diff.__deleted) return undefined;
      const source = isPlainObject(base) ? base : {};
      const out = {};
      const keys = new Set([...Object.keys(source), ...Object.keys(diff)]);
      for (const key of keys) {
        if (!(key in diff)) {
          out[key] = deepClone(source[key]);
          continue;
        }
        const merged = applyStateDiff(source[key], diff[key]);
        if (merged !== undefined) out[key] = merged;
      }
      return out;
    }
    return deepClone(diff);
  }

  // -------------------------
  // Bearing parsing
  // -------------------------
  function parseQuadrantAngleDegrees(midRaw) {
    let mid = String(midRaw ?? "").trim();
    if (!mid) return null;

    mid = mid
      .replace(/\s+/g, "-")
      .replace(/DEG|°/gi, "-")
      .replace(/MIN|'/gi, "-")
      .replace(/SEC|"/gi, "-")
      .replace(/:+/g, "-")
      .replace(/[^0-9.+-]+/g, "-")
      .replace(/-+/g, "-")
      .replace(/^-|-$/g, "");

    if (!mid) return null;

    if (!mid.includes("-")) {
      const a = Number(mid);
      if (!Number.isFinite(a)) return null;
      return Math.abs(a);
    }

    const parts = mid.split("-").filter(Boolean);
    if (!parts.length) return null;

    const d = Number(parts[0]);
    const m = parts.length > 1 ? Number(parts[1]) : 0;
    const s = parts.length > 2 ? Number(parts[2]) : 0;
    if (![d,m,s].every(Number.isFinite)) return null;

    const deg = Math.abs(d) + (Math.abs(m)/60) + (Math.abs(s)/3600);
    return deg;
  }

  function bearingToAzimuthRad(input) {
    const raw = String(input ?? "").trim();
    if (!raw) return null;

    // numeric azimuth
    if (/^[+-]?\d+(\.\d+)?$/.test(raw)) {
      const deg = parseFloat(raw);
      return (deg * Math.PI) / 180;
    }

    // quadrant
    const m = raw.trim().toUpperCase().match(/^([NS])\s*(.+?)\s*([EW])$/);
    if (!m) return null;

    const q1 = m[1];
    const q2 = m[3];
    const mid = m[2];

    const angle = parseQuadrantAngleDegrees(mid);
    if (angle == null) return null;

    let azDeg;
    if (q1==="N" && q2==="E") azDeg = angle;
    else if (q1==="S" && q2==="E") azDeg = 180 - angle;
    else if (q1==="S" && q2==="W") azDeg = 180 + angle;
    else if (q1==="N" && q2==="W") azDeg = 360 - angle;
    else return null;

    return (azDeg * Math.PI) / 180;
  }

  function azimuthRadToQuadrantString(az) {
    let deg = (az * 180/Math.PI) % 360;
    if (deg < 0) deg += 360;

    let q1="N", q2="E", ang=deg;
    if (deg >= 0 && deg <= 90) { q1="N"; q2="E"; ang=deg; }
    else if (deg > 90 && deg < 180) { q1="S"; q2="E"; ang=180-deg; }
    else if (deg >= 180 && deg < 270) { q1="S"; q2="W"; ang=deg-180; }
    else { q1="N"; q2="W"; ang=360-deg; }

    let d = Math.floor(ang + 1e-10);
    const mFloat = (ang - d) * 60;
    let m = Math.floor(mFloat + 1e-10);
    const s = (mFloat - m) * 60;
    let sRound = Math.round(s);

    if (sRound >= 60) {
      sRound = 0;
      m += 1;
    }
    if (m >= 60) {
      m = 0;
      d += 1;
    }
    if (d > 90) {
      d = 90;
      m = 0;
      sRound = 0;
    }

    return `${q1}${d}°${String(m).padStart(2,"0")}'${String(sRound).padStart(2,"0")}"${q2}`;
  }

  function normalizeAzimuthRad(az) {
    const twoPi = Math.PI * 2;
    let value = az % twoPi;
    if (value < 0) value += twoPi;
    return value;
  }

  function resolvePointByNumberOrName(reference) {
    const raw = String(reference ?? "").trim();
    if (!raw) return null;
    const normalized = raw.toUpperCase();

    const byNumber = [...points.values()].find((point) => String(point?.num ?? "").trim().toUpperCase() === normalized);
    if (byNumber) return byNumber;

    if (/^\d+$/.test(raw)) {
      const pointById = points.get(Number(raw));
      if (pointById) return pointById;
    }

    const withoutPrefix = normalized.replace(/^P\s*-?\s*/i, "");
    if (withoutPrefix && withoutPrefix !== normalized) {
      const byPrefixedNumber = [...points.values()].find((point) => String(point?.num ?? "").trim().toUpperCase() === withoutPrefix);
      if (byPrefixedNumber) return byPrefixedNumber;
    }

    return null;
  }

  function resolveBasisOfBearingEndpoints(value = basisOfBearing) {
    if (!value) return null;

    if (value.startPointId != null && value.endPointId != null) {
      const startPoint = points.get(value.startPointId);
      const endPoint = points.get(value.endPointId);
      if (!startPoint || !endPoint) return null;
      if (startPoint.id === endPoint.id) return null;
      return {
        start: { x: Number(startPoint.x), y: Number(startPoint.y) },
        end: { x: Number(endPoint.x), y: Number(endPoint.y) },
        startPoint,
        endPoint
      };
    }

    const startX = Number(value?.start?.x);
    const startY = Number(value?.start?.y);
    const endX = Number(value?.end?.x);
    const endY = Number(value?.end?.y);
    if (![startX, startY, endX, endY].every(Number.isFinite)) return null;
    if (Math.hypot(endX - startX, endY - startY) <= EPS) return null;
    return {
      start: { x: startX, y: startY },
      end: { x: endX, y: endY },
      startPoint: null,
      endPoint: null
    };
  }

  function basisAzimuthRad() {
    const endpoints = resolveBasisOfBearingEndpoints();
    if (!endpoints) return null;
    const dx = endpoints.end.x - endpoints.start.x;
    const dy = endpoints.end.y - endpoints.start.y;
    if (Math.hypot(dx, dy) <= EPS) return null;
    return normalizeAzimuthRad(Math.atan2(dx, dy));
  }

  function basisStartPointForRotation() {
    const endpoints = resolveBasisOfBearingEndpoints();
    if (!endpoints) return null;
    return endpoints.start;
  }

  function normalizedSignedAngleDelta(targetAz, sourceAz) {
    const diff = targetAz - sourceAz;
    return Math.atan2(Math.sin(diff), Math.cos(diff));
  }

  function drawingRotationRad() {
    const basisAz = basisAzimuthRad();
    const recordAz = bearingToAzimuthRad(recordBasisBearing);
    if (basisAz == null || recordAz == null) return 0;
    return normalizedSignedAngleDelta(recordAz, basisAz);
  }

  function geometryAzimuthToDrawingAzimuth(az) {
    return normalizeAzimuthRad(az + drawingRotationRad());
  }

  function drawingAzimuthToGeometryAzimuth(az) {
    return normalizeAzimuthRad(az - drawingRotationRad());
  }

  function rotateWorldPointAroundBasis(x, y, rotationRad = drawingRotationRad()) {
    const basisStart = basisStartPointForRotation();
    if (!basisStart || Math.abs(rotationRad) <= 1e-12) return { x, y };
    const ox = x - basisStart.x;
    const oy = y - basisStart.y;
    const c = Math.cos(rotationRad);
    const ss = Math.sin(rotationRad);
    return {
      x: basisStart.x + (ox * c - oy * ss),
      y: basisStart.y + (ox * ss + oy * c)
    };
  }

  function rotateDrawingPointToWorld(x, y, rotationRad = drawingRotationRad()) {
    return rotateWorldPointAroundBasis(x, y, -rotationRad);
  }

  function orientAzimuthClockwiseFromBasis(az) {
    const basisAzRaw = basisAzimuthRad();
    const basisAz = basisAzRaw == null ? null : geometryAzimuthToDrawingAzimuth(basisAzRaw);
    const forward = geometryAzimuthToDrawingAzimuth(az);
    if (basisAz == null) return forward;
    const reverse = normalizeAzimuthRad(forward + Math.PI);
    const fDelta = (forward - basisAz + Math.PI * 2) % (Math.PI * 2);
    const rDelta = (reverse - basisAz + Math.PI * 2) % (Math.PI * 2);
    return fDelta <= rDelta ? forward : reverse;
  }

  function lineMeasurement(a, b) {
    if (!a || !b) return null;
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const distance = Math.hypot(dx, dy);
    if (!(distance > EPS)) return null;
    const az = orientAzimuthClockwiseFromBasis(Math.atan2(dx, dy));
    return {
      distance,
      bearing: azimuthRadToQuadrantString(az),
      angle: Math.atan2(-Math.cos(az), Math.sin(az)),
      azimuth: az
    };
  }

  function normalizeReadableBearingTextAngle(angle) {
    const twoPi = Math.PI * 2;
    let normalized = angle;
    while (normalized <= -Math.PI) normalized += twoPi;
    while (normalized > Math.PI) normalized -= twoPi;

    const candidates = [normalized, normalized + Math.PI, normalized - Math.PI];
    let best = candidates[0];
    let bestScore = -Infinity;
    for (const candidate of candidates) {
      const right = Math.cos(candidate);
      const up = -Math.sin(candidate);
      const score = (right * 2) + (up * 2) + ((right > 0 && up > 0) ? 1 : 0);
      if (score > bestScore) {
        best = candidate;
        bestScore = score;
      }
    }

    while (best <= -Math.PI) best += twoPi;
    while (best > Math.PI) best -= twoPi;
    return best;
  }

  function rectsOverlap(a, b, padding = 4) {
    return !(a.x + a.w + padding <= b.x || b.x + b.w + padding <= a.x || a.y + a.h + padding <= b.y || b.y + b.h + padding <= a.y);
  }

  function rotatedRectAabb(cx, cy, width, height, angle) {
    const hw = width / 2;
    const hh = height / 2;
    const c = Math.cos(angle);
    const ss = Math.sin(angle);
    const pts = [
      { x: -hw, y: -hh },
      { x: hw, y: -hh },
      { x: hw, y: hh },
      { x: -hw, y: hh }
    ].map((p) => ({ x: cx + (p.x * c - p.y * ss), y: cy + (p.x * ss + p.y * c) }));
    const xs = pts.map((p) => p.x);
    const ys = pts.map((p) => p.y);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }

  const BEARING_LABEL_ALLOWED_LINE_CODES = new Set(["BDY", "BDRY", "BOUNDARY", "SEC", "SECTION", "COR", "SUB", "CL", "ROW", "BEAR"]);

  function lineIsEligibleForBearingLabels(line, startPoint, endPoint) {
    if (!line) return false;

    const lineCode = String(line.fieldToFinishBaseCode || "").trim().toUpperCase();
    if (lineCode && BEARING_LABEL_ALLOWED_LINE_CODES.has(lineCode)) return true;

    const startTokens = splitCodeTokens(startPoint?.code).map((token) => token.toUpperCase());
    const endTokens = splitCodeTokens(endPoint?.code).map((token) => token.toUpperCase());
    if (startTokens.some((token) => BEARING_LABEL_ALLOWED_LINE_CODES.has(token))) return true;
    if (endTokens.some((token) => BEARING_LABEL_ALLOWED_LINE_CODES.has(token))) return true;
    return startTokens.includes("BEAR") || endTokens.includes("BEAR");
  }

  function buildBearingLabelGroups(lineCandidates) {
    const withMeasure = lineCandidates
      .map((candidate, index) => {
        const measure = lineMeasurement(candidate.a, candidate.b);
        if (!measure) return null;
        return { ...candidate, index, measure };
      })
      .filter(Boolean);

    const idForPoint = (point) => `${point?.id ?? "xy"}:${point?.x ?? 0},${point?.y ?? 0}`;
    const pointDegree = new Map();
    for (const candidate of lineCandidates) {
      const aid = idForPoint(candidate.a);
      const bid = idForPoint(candidate.b);
      pointDegree.set(aid, (pointDegree.get(aid) || 0) + 1);
      pointDegree.set(bid, (pointDegree.get(bid) || 0) + 1);
    }

    const signatureMap = new Map();
    for (const item of withMeasure) {
      const sig = item.measure.bearing;
      if (!signatureMap.has(sig)) signatureMap.set(sig, []);
      signatureMap.get(sig).push(item);
    }

    const groups = [];
    for (const [bearing, items] of signatureMap.entries()) {
      const pointToSegmentIndices = new Map();
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const aid = idForPoint(item.a);
        const bid = idForPoint(item.b);
        if (!pointToSegmentIndices.has(aid)) pointToSegmentIndices.set(aid, []);
        if (!pointToSegmentIndices.has(bid)) pointToSegmentIndices.set(bid, []);
        pointToSegmentIndices.get(aid).push(i);
        pointToSegmentIndices.get(bid).push(i);
      }

      const sharedEndpointCanChain = (endpointId) => {
        const totalDegree = pointDegree.get(endpointId) || 0;
        const sameBearingDegree = (pointToSegmentIndices.get(endpointId) || []).length;
        return totalDegree === 2 && sameBearingDegree === 2;
      };

      const visited = new Set();
      for (let i = 0; i < items.length; i++) {
        if (visited.has(i)) continue;
        const queue = [i];
        visited.add(i);
        const component = [];
        while (queue.length) {
          const current = queue.shift();
          component.push(items[current]);
          const endpoints = [idForPoint(items[current].a), idForPoint(items[current].b)];
          for (const endpoint of endpoints) {
            if (!sharedEndpointCanChain(endpoint)) continue;
            for (const next of pointToSegmentIndices.get(endpoint) || []) {
              if (!visited.has(next)) {
                visited.add(next);
                queue.push(next);
              }
            }
          }
        }
        groups.push({ bearing, segments: component });
      }
    }

    return groups;
  }

  // -------------------------
  // Geometry helpers
  // -------------------------
  function lineLineIntersection(p1, p2, p3, p4) {
    const x1=p1.x, y1=p1.y, x2=p2.x, y2=p2.y;
    const x3=p3.x, y3=p3.y, x4=p4.x, y4=p4.y;
    const dx12 = x2-x1, dy12=y2-y1;
    const dx34 = x4-x3, dy34=y4-y3;
    const denom = dx12*dy34 - dy12*dx34;
    if (Math.abs(denom) < EPS) return null;
    const dx13 = x3-x1, dy13 = y3-y1;
    const t = (dx13*dy34 - dy13*dx34) / denom;
    const u = (dx13*dy12 - dy13*dx12) / denom;
    return { x: x1 + t*dx12, y: y1 + t*dy12, t, u };
  }

  function pointOnLineParam(p, a, b) {
    const dx = b.x-a.x, dy=b.y-a.y;
    const len2 = dx*dx + dy*dy;
    if (len2 < EPS) return 0;
    return ((p.x-a.x)*dx + (p.y-a.y)*dy) / len2;
  }

  function segmentClosestPoint(p, a, b) {
    const abx = b.x-a.x, aby=b.y-a.y;
    const apx = p.x-a.x, apy=p.y-a.y;
    const ab2 = abx*abx + aby*aby;
    let t = ab2 > EPS ? (apx*abx + apy*aby) / ab2 : 0;
    t = clamp(t, 0, 1);
    return { x: a.x + t*abx, y: a.y + t*aby, t };
  }

  function isColinearOverlap(a1,a2,b1,b2) {
    const ax=a2.x-a1.x, ay=a2.y-a1.y;
    const cross1 = ax*(b1.y-a1.y) - ay*(b1.x-a1.x);
    const cross2 = ax*(b2.y-a1.y) - ay*(b2.x-a1.x);
    if (Math.abs(cross1) > 1e-7 || Math.abs(cross2) > 1e-7) return null;

    const useX = Math.abs(ax) >= Math.abs(ay);
    const proj = (p)=> useX ? p.x : p.y;

    const A0 = proj(a1), A1 = proj(a2);
    const B0 = proj(b1), B1 = proj(b2);

    const aMin = Math.min(A0,A1), aMax=Math.max(A0,A1);
    const bMin = Math.min(B0,B1), bMax=Math.max(B0,B1);
    const oMin = Math.max(aMin,bMin);
    const oMax = Math.min(aMax,bMax);
    if (oMax <= oMin + 1e-9) return null;

    return { useX, oMin, oMax };
  }

  function rectNorm(x0,y0,x1,y1){
    return {
      minX: Math.min(x0,x1),
      maxX: Math.max(x0,x1),
      minY: Math.min(y0,y1),
      maxY: Math.max(y0,y1),
      w: Math.abs(x1-x0),
      h: Math.abs(y1-y0),
      cx: (x0+x1)/2,
      cy: (y0+y1)/2
    };
  }
  function pointInRect(p, r){
    return p.x >= r.minX && p.x <= r.maxX && p.y >= r.minY && p.y <= r.maxY;
  }
  function orient(a,b,c){
    return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
  }
  function onSeg(a,b,c){
    return Math.min(a.x,b.x)-EPS <= c.x && c.x <= Math.max(a.x,b.x)+EPS &&
           Math.min(a.y,b.y)-EPS <= c.y && c.y <= Math.max(a.y,b.y)+EPS;
  }
  function segIntersect(a,b,c,d){
    const o1 = orient(a,b,c);
    const o2 = orient(a,b,d);
    const o3 = orient(c,d,a);
    const o4 = orient(c,d,b);

    if ((o1>0 && o2<0 || o1<0 && o2>0) && (o3>0 && o4<0 || o3<0 && o4>0)) return true;
    if (Math.abs(o1) < EPS && onSeg(a,b,c)) return true;
    if (Math.abs(o2) < EPS && onSeg(a,b,d)) return true;
    if (Math.abs(o3) < EPS && onSeg(c,d,a)) return true;
    if (Math.abs(o4) < EPS && onSeg(c,d,b)) return true;
    return false;
  }
  function segIntersectsRect(p1,p2,r){
    if (pointInRect(p1,r) || pointInRect(p2,r)) return true;
    const topL = {x:r.minX,y:r.minY}, topR = {x:r.maxX,y:r.minY};
    const botL = {x:r.minX,y:r.maxY}, botR = {x:r.maxX,y:r.maxY};
    // Edges (note: in screen coords, y grows down, but intersection math is unaffected)
    if (segIntersect(p1,p2, topL, topR)) return true;
    if (segIntersect(p1,p2, topR, botR)) return true;
    if (segIntersect(p1,p2, botR, botL)) return true;
    if (segIntersect(p1,p2, botL, topL)) return true;
    return false;
  }

  // -------------------------
  // DOM
  // -------------------------
  const canvas = $("#c");
  const ctx = canvas.getContext("2d");
  const appShell = $("#appShell");
  const drawerToggle = $("#drawerToggle");
  const mobileToolbarToggle = $("#mobileToolbarToggle");
  const panelCollapseHandle = $("#panelCollapseHandle");
  const drawerEdgeExpand = $("#drawerEdgeExpand");
  const mapBackdrop = $("#mapBackdrop");
  const mapEnabledInput = $("#mapLayerEnabled");
  const mapTileTypeInput = $("#mapTileType");
  const mapOpacityInput = $("#mapOpacity");
  const mapOpacityValue = $("#mapOpacityValue");
  const quickMapEnabledBtn = $("#quickMapLayerEnabled");
  const quickMapTileTypeInput = $("#quickMapTileType");
  const showLinesInput = $("#showLines");
  const showBearingsInput = $("#showBearings");
  const showPointsInput = $("#showPoints");
  const showPointNamesInput = $("#showPointNames");
  const showPointCodesInput = $("#showPointCodes");
  const showPointNotesInput = $("#showPointNotes");
  const basisBearingStartPointInput = $("#basisBearingStartPoint");
  const basisBearingEndPointInput = $("#basisBearingEndPoint");
  const basisBearingRecordBearingInput = $("#basisBearingRecordBearing");
  const basisBearingRecordDistanceInput = $("#basisBearingRecordDistance");
  const setBasisOfBearingBtn = $("#setBasisOfBearing");
  const clearBasisOfBearingBtn = $("#clearBasisOfBearing");
  
  const enablePointClusteringInput = $("#enablePointClustering");
  const quickShowLinesBtn = $("#quickShowLines");
  const quickShowBearingsBtn = $("#quickShowBearings");
  const quickShowPointsBtn = $("#quickShowPoints");
  const quickShowPointNamesBtn = $("#quickShowPointNames");
  const quickShowPointCodesBtn = $("#quickShowPointCodes");
  const quickShowPointNotesBtn = $("#quickShowPointNotes");
  const quickTogglePointClusteringBtn = $("#quickTogglePointClustering");

  const quickLayerDropdown = $("#quickLayerDropdown");
  const quickLayerDropdownButton = $("#quickLayerDropdownButton");
  const quickLayerDropdownLabel = $("#quickLayerDropdownLabel");
  const quickLayerDropdownMenu = $("#quickLayerDropdownMenu");

  const quickLayerColor = $("#quickLayerColor");
  const quickLayerManagerBtn = $("#quickLayerManager");
  const clusterTooltip = $("#clusterTooltip");
  const pointHoverTooltip = $("#pointHoverTooltip");

  const hudTool = $("#hudTool");
  const hudMouse = $("#hudMouse");
  const hudZoom = $("#hudZoom");
  const hudSel = $("#hudSel");
  const hudUndo = $("#hudUndo");
  const hudRedo = $("#hudRedo");
  const selSummary = $("#selSummary");
  const lineInspector = $("#lineInspector");
  const pointInspector = $("#pointInspector");
  const toolHint = $("#toolHint");
  const quickCommandSearchInput = $("#quickCommandSearchInput");
  const quickCommandSearchResults = $("#quickCommandSearchResults");
  const pointEditorSymbolRow = $("#pointEditorSymbolRow");
  const printPaperSizeInput = $("#printPaperSize");
  const printScalePreviewInput = $("#printScalePreview");
  const printCustomWidthMmInput = $("#printCustomWidthMm");
  const printCustomHeightMmInput = $("#printCustomHeightMm");
  const generatePrintViewBtn = $("#generatePrintView");

  const pointsCount = $("#pointsCount");
  const modal = $("#pointsModal");
  const modalWindow = $("#pointsModalWindow");
  const modalHeader = $("#pointsModalHeader");
  const modalClose = $("#pointsModalClose");
  const modalPointsCount = $("#modalPointsCount");
  const openPointsManagerBtn = $("#openPointsManager");
  const closePointsManagerBtn = $("#closePointsManager");
  const connectLinesModal = $("#connectLinesModal");
  const connectLinesSequentialBtn = $("#connectLinesSequential");
  const connectLinesByDistanceBtn = $("#connectLinesByDistance");
  const layersModal = $("#layersModal");
  const layersModalWindow = $("#layersModalWindow");
  const layersModalHeader = $("#layersModalHeader");
  const layersModalClose = $("#layersModalClose");
  const layersAddBtn = $("#layersAdd");
  const layersTbody = $("#layersTbody");
  const openFldEditorBtn = $("#openFldEditor");
  const downloadFldLocalBtn = $("#downloadFldLocal");
  const fldModal = $("#fldModal");
  const fldModalWindow = $("#fldModalWindow");
  const fldModalHeader = $("#fldModalHeader");
  const fldModalClose = $("#fldModalClose");
  const fldFilterInput = $("#fldFilter");
  const fldTbody = $("#fldTbody");
  const fldSourceLabel = $("#fldSourceLabel");
  const fldAddRuleBtn = $("#fldAddRule");
  const fldSaveLocalBtn = $("#fldSaveLocal");
  const fldResetServerBtn = $("#fldResetServer");
  const fldDownloadLocalInlineBtn = $("#fldDownloadLocal");
  const fldDownloadCurrentBtn = $("#fldDownloadCurrent");

  // -------------------------
  // Model
  // -------------------------
  let nextId = 1;
  const DEFAULT_LAYER_ID = "layer-1";
  const layers = new Map(); // id -> {id,name,color,locked,visible,lineWeight,fill}
  let selectedLayerId = DEFAULT_LAYER_ID;
  var layersTableDirty = true;
  const points = new Map(); // id -> {id,num,x,y,z,code,notes,movable,layerId}
  const lines = new Map();  // id -> {id,a,b,movable,layerId}
  let basisOfBearing = null; // {startPointId, endPointId}
  let recordBasisBearing = "";
  let recordBasisDistance = "";
  let quickLayerDropdownOpen = false;
  let mobileToolbarsHidden = false;

  // Selection
  let selectedPointId = null;   // primary point
  let selectedPointIds = [];    // multi points (ordered)
  let selectedLines = [];       // [{ lineId, grip, t }]
  let lastSelectedLineId = null;
  let lastLayerDisplaySignature = "";
  const rotateSelectionSession = {
    active: false,
    step: 0,
    basePoint: null,
    fromPoint: null,
    awaitingSelection: false
  };
  let lastUnlockedEntity = null; // { type: "point"|"line", id }
  let pendingEscapeLockEntity = null;

  // Construction
  let tool = "select";
  let construction = { startPointId: null };

  // View transform
  const MIN_SCALE = 0.0005;
  const MAX_SCALE = 5000;
  const view = { scale: 20, panX: 0, panY: 0 };
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  // Mouse
  const mouse = {
    x: 0, y: 0,
    wx: 0, wy: 0,
    down: false,
    button: 0,
    drag: false,
    dragStartX: 0, dragStartY: 0,
    dragStartPanX: 0, dragStartPanY: 0,
    dragStartWorldX: 0, dragStartWorldY: 0,
    dragObj: null
  };
  let pendingMarqueeZoomRect = null;
  let pendingMarqueeSelectionSnapshot = null;
  let pendingPrintWindowCapture = false;
  const DOUBLE_RIGHT_CLICK_ZOOM_OUT_MS = 325;
  let lastRightClickAtMs = 0;

  const mobileInteraction = {
    longPressMs: 450,
    moveTolerance: 10,
    pointerDown: false,
    moved: false,
    activePointerId: null,
    downX: 0,
    downY: 0,
    longPressTimer: null,
    suppressClick: false
  };

  const touchGesture = {
    mode: null,
    points: new Map(),
    startDistance: 0,
    startScale: 0,
    startPanX: 0,
    startPanY: 0,
    startCenter: null,
    startWorldAtCenter: null,
    boxSelectActive: false
  };

  const pointDisplayVisibility = {
    lines: true,
    bearings: true,
    points: true,
    names: true,
    codes: true,
    notes: false,
    clustering: true
  };
  const POINT_CLUSTER_DISTANCE_PX = 18;
  const POINT_CLUSTER_PICK_PADDING_PX = 8;
  const POINT_LABEL_SPREAD_RADIUS_PX = 24;
  const POINT_CLUSTER_LABEL_BREAKOUT_LIMIT = 5;
  const POINT_CLUSTER_TOOLTIP_GROUP_BY_LAYER_LIMIT = 10;
  const POINT_CLUSTER_MIN_STROKE_ALPHA = 0.25;
  const POINT_CLUSTER_MAX_STROKE_ALPHA = 0.7;
  const POINT_CLUSTER_COUNT_TEXT_FILL_ALPHA = 0.98;
  const POINT_CLUSTER_COUNT_TEXT_STROKE_ALPHA = 0.9;
  const POINT_CLUSTER_POLYGON_AREA_RATIO_TARGET = 0.5;
  const POINT_CLUSTER_POLYGON_AREA_RATIO_TOLERANCE = 0.15;
  const POINT_CLUSTER_POLYGON_MIN_WIDTH_TO_HEIGHT_RATIO = 1 / 3;
  const POINT_CLUSTER_TOOLTIP_HIDE_DELAY_MS = 180;
  let cachedPointClusters = [];
  let hoveredClusterPointId = null;
  let activeClusterTooltip = {
    cluster: null,
    expandedLayerId: null
  };
  let clusterTooltipHovering = false;
  let clusterTooltipHideTimer = null;

  const mapLayerState = {
    enabled: false,
    tileType: "satellite",
    opacity: 0.66
  };
  let mapViewportSignature = "";

  const FEET_TO_METERS = 0.3048006096012192;
  const MAP_LAYER_MIN_RENDER_ZOOM = 1;
  const MAP_LAYER_MAX_RENDER_ZOOM = 40;
  let mapGeoreference = null;
  const ADA_CPF_PDF_BASE = "https://gisprod.adacounty.id.gov/apps/acdscpf/CpfPdfs/";

  const MAP_TILESETS = {
    satellite: {
      url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
      options: {
        maxNativeZoom: 19,
        maxZoom: MAP_LAYER_MAX_RENDER_ZOOM,
        attribution: "Tiles &copy; Esri"
      }
    },
    osmStandard: {
      url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      options: {
        maxNativeZoom: 19,
        maxZoom: MAP_LAYER_MAX_RENDER_ZOOM,
        attribution: "&copy; OpenStreetMap contributors"
      }
    },
    osmHumanitarian: {
      url: "https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png",
      options: {
        maxNativeZoom: 19,
        maxZoom: MAP_LAYER_MAX_RENDER_ZOOM,
        attribution: "&copy; OpenStreetMap contributors, Tiles style by HOT"
      }
    },
    osmCycle: {
      url: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
      options: {
        maxNativeZoom: 17,
        maxZoom: MAP_LAYER_MAX_RENDER_ZOOM,
        attribution: "&copy; OpenStreetMap contributors, Map style: OpenTopoMap"
      }
    }
  };

  let mapInstance = null;
  let mapTileLayer = null;
  let mapArPresenceLayer = null;
  const mapArPresenceGraphics = new Map();

  function isMovable(value) {
    return value === true;
  }

  function defaultLayerList() {
    return [
      { id: DEFAULT_LAYER_ID, name: "Default", color: "#ffffff", locked: false, visible: true, lineWeight: 1.5, fill: false }
    ];
  }

  function clampLayerLineWeight(value) {
    const n = Number(value);
    return clamp(Number.isFinite(n) ? n : 1.5, 0.5, 12);
  }

  function sanitizeLayer(raw, fallbackId) {
    const id = String(raw?.id || fallbackId || `layer-${Date.now()}`);
    return {
      id,
      name: String(raw?.name || id),
      color: String(raw?.color || "#ffffff"),
      locked: raw?.locked === true,
      visible: raw?.visible !== false,
      lineWeight: clampLayerLineWeight(raw?.lineWeight),
      fill: raw?.fill === true
    };
  }

  function resetLayers(rawLayers = defaultLayerList()) {
    layers.clear();
    for (const [index, layer] of rawLayers.entries()) {
      const sanitized = sanitizeLayer(layer, `layer-${index + 1}`);
      if (!layers.has(sanitized.id)) layers.set(sanitized.id, sanitized);
    }
    if (!layers.size) {
      const fallback = sanitizeLayer(defaultLayerList()[0], DEFAULT_LAYER_ID);
      layers.set(fallback.id, fallback);
    }
    if (!layers.has(selectedLayerId)) selectedLayerId = layers.keys().next().value;
    for (const p of points.values()) {
      if (!layers.has(p.layerId)) p.layerId = selectedLayerId;
    }
    for (const ln of lines.values()) {
      if (!layers.has(ln.layerId)) ln.layerId = selectedLayerId;
    }
    renderLayerControls();
    scheduleLayersTableRender();
  }

  function getLayerById(layerId) {
    return layers.get(layerId) || layers.get(DEFAULT_LAYER_ID) || layers.values().next().value || null;
  }

  function isLayerLocked(layerId) {
    return getLayerById(layerId)?.locked === true;
  }

  function isLayerVisible(layerId) {
    return getLayerById(layerId)?.visible !== false;
  }

  function isPointLockedByLayer(pointId) {
    const p = points.get(pointId);
    return p ? isLayerLocked(p.layerId) : false;
  }

  function isLineLockedByLayer(lineId) {
    const ln = lines.get(lineId);
    return ln ? isLayerLocked(ln.layerId) : false;
  }

  function activeLayer() {
    return getLayerById(selectedLayerId);
  }

  function getSelectionLayerDisplayState() {
    const layerIds = new Set();
    for (const pointId of selectedPointIds) {
      const point = points.get(pointId);
      if (point && layers.has(point.layerId)) layerIds.add(point.layerId);
    }
    for (const selectedLine of selectedLines) {
      const line = lines.get(selectedLine?.lineId);
      if (line && layers.has(line.layerId)) layerIds.add(line.layerId);
    }

    if (!layerIds.size) {
      const layer = activeLayer();
      return {
        mode: "none",
        layerId: selectedLayerId,
        label: layer?.name || "Layer",
        color: layer?.color || "#ffffff"
      };
    }

    if (layerIds.size > 1) {
      return {
        mode: "multiple",
        layerId: null,
        label: "Multiple Layers",
        color: "#6f7785"
      };
    }

    const [layerId] = [...layerIds];
    const layer = getLayerById(layerId);
    return {
      mode: "single",
      layerId,
      label: layer?.name || "Layer",
      color: layer?.color || "#ffffff"
    };
  }

  function scaleToLeafletZoom(scale) {
    if (!Number.isFinite(scale) || scale <= 0) return 2;
    const zoom = Math.log2((scale * 360) / 256);
    return clamp(zoom, MAP_LAYER_MIN_RENDER_ZOOM, MAP_LAYER_MAX_RENDER_ZOOM);
  }

  function clampLatLng(lat, lng) {
    return {
      lat: clamp(lat, -85, 85),
      lng: clamp(lng, -180, 180)
    };
  }

  function worldToApproxLatLng(x, y) {
    return clampLatLng(y, x);
  }

  function solveLinear3x3(matrix, vector) {
    const m = matrix.map((row, rowIdx) => [...row, vector[rowIdx]]);
    const n = 3;
    for (let col = 0; col < n; col++) {
      let pivot = col;
      for (let row = col + 1; row < n; row++) {
        if (Math.abs(m[row][col]) > Math.abs(m[pivot][col])) pivot = row;
      }
      if (Math.abs(m[pivot][col]) < 1e-12) return null;
      if (pivot !== col) {
        const tmp = m[col];
        m[col] = m[pivot];
        m[pivot] = tmp;
      }
      const div = m[col][col];
      for (let k = col; k <= n; k++) m[col][k] /= div;
      for (let row = 0; row < n; row++) {
        if (row === col) continue;
        const factor = m[row][col];
        for (let k = col; k <= n; k++) m[row][k] -= factor * m[col][k];
      }
    }
    return [m[0][n], m[1][n], m[2][n]];
  }

  function buildGeoreferenceTransform(pointsList) {
    if (!Array.isArray(pointsList) || pointsList.length < 3) return null;
    let sumX = 0, sumY = 0, sumXX = 0, sumXY = 0, sumYY = 0;
    let sumLat = 0, sumLng = 0, sumXLat = 0, sumYLat = 0, sumXLng = 0, sumYLng = 0;

    for (const pt of pointsList) {
      const x = Number(pt.x);
      const y = Number(pt.y);
      const lat = Number(pt.lat);
      const lng = Number(pt.lng);
      if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(lat) || !Number.isFinite(lng)) {
        continue;
      }
      sumX += x;
      sumY += y;
      sumXX += x * x;
      sumXY += x * y;
      sumYY += y * y;
      sumLat += lat;
      sumLng += lng;
      sumXLat += x * lat;
      sumYLat += y * lat;
      sumXLng += x * lng;
      sumYLng += y * lng;
    }

    const n = pointsList.length;
    const normal = [
      [sumXX, sumXY, sumX],
      [sumXY, sumYY, sumY],
      [sumX,  sumY,  n]
    ];

    const latCoeffs = solveLinear3x3(normal, [sumXLat, sumYLat, sumLat]);
    const lngCoeffs = solveLinear3x3(normal, [sumXLng, sumYLng, sumLng]);
    if (!latCoeffs || !lngCoeffs) return null;

    return {
      lat: { ax: latCoeffs[0], by: latCoeffs[1], c: latCoeffs[2] },
      lng: { ax: lngCoeffs[0], by: lngCoeffs[1], c: lngCoeffs[2] }
    };
  }

  function worldToLatLng(x, y) {
    if (mapGeoreference) {
      const lat = mapGeoreference.lat.ax * x + mapGeoreference.lat.by * y + mapGeoreference.lat.c;
      const lng = mapGeoreference.lng.ax * x + mapGeoreference.lng.by * y + mapGeoreference.lng.c;
      if (Number.isFinite(lat) && Number.isFinite(lng)) {
        return clampLatLng(lat, lng);
      }
    }
    return worldToApproxLatLng(x, y);
  }

  function latLngToWorld(lat, lng) {
    if (mapGeoreference) {
      const g = mapGeoreference;
      const det = g.lat.ax * g.lng.by - g.lat.by * g.lng.ax;
      if (Math.abs(det) > 1e-20) {
        const dLat = lat - g.lat.c;
        const dLng = lng - g.lng.c;
        const x = (g.lng.by * dLat - g.lat.by * dLng) / det;
        const y = (g.lat.ax * dLng - g.lng.ax * dLat) / det;
        if (Number.isFinite(x) && Number.isFinite(y)) return { x, y };
      }
    }
    return { x: lng, y: lat };
  }

  function sanitizeMapGeoreference(candidate) {
    if (!candidate) return null;
    const latAx = Number(candidate?.lat?.ax);
    const latBy = Number(candidate?.lat?.by);
    const latC = Number(candidate?.lat?.c);
    const lngAx = Number(candidate?.lng?.ax);
    const lngBy = Number(candidate?.lng?.by);
    const lngC = Number(candidate?.lng?.c);
    if (
      !Number.isFinite(latAx) ||
      !Number.isFinite(latBy) ||
      !Number.isFinite(latC) ||
      !Number.isFinite(lngAx) ||
      !Number.isFinite(lngBy) ||
      !Number.isFinite(lngC)
    ) {
      return null;
    }
    return {
      lat: { ax: latAx, by: latBy, c: latC },
      lng: { ax: lngAx, by: lngBy, c: lngC }
    };
  }

  function scaleToLeafletZoomForLat(scale, lat) {
    if (!Number.isFinite(scale) || scale <= 0) return 2;
    if (!mapGeoreference) return scaleToLeafletZoom(scale);
    const feetPerPixel = 1 / scale;
    const metersPerPixel = feetPerPixel * FEET_TO_METERS;
    const cosLat = Math.max(0.01, Math.cos((lat * Math.PI) / 180));
    const zoom = Math.log2((156543.03392 * cosLat) / Math.max(1e-9, metersPerPixel));
    return clamp(zoom, MAP_LAYER_MIN_RENDER_ZOOM, MAP_LAYER_MAX_RENDER_ZOOM);
  }

  function leafletZoomToScaleForLat(zoom, lat) {
    if (!Number.isFinite(zoom)) return view.scale;
    if (!mapGeoreference) {
      return clamp((256 * (2 ** zoom)) / 360, MIN_SCALE, MAX_SCALE);
    }
    const cosLat = Math.max(0.01, Math.cos((lat * Math.PI) / 180));
    const metersPerPixel = (156543.03392 * cosLat) / (2 ** zoom);
    const feetPerPixel = metersPerPixel / FEET_TO_METERS;
    return clamp(1 / Math.max(1e-9, feetPerPixel), MIN_SCALE, MAX_SCALE);
  }

  function nextZoomOutLeafletLevel(currentZoom) {
    if (!Number.isFinite(currentZoom)) return MAP_LAYER_MIN_RENDER_ZOOM;
    const epsilon = 1e-6;
    const nextLevel = Math.abs(currentZoom - Math.round(currentZoom)) <= epsilon
      ? currentZoom - 1
      : Math.floor(currentZoom);
    return clamp(nextLevel, MAP_LAYER_MIN_RENDER_ZOOM, MAP_LAYER_MAX_RENDER_ZOOM);
  }

  function zoomOutToNextMapLevelAtScreenPoint(screenX, screenY) {
    const before = screenToWorld(screenX, screenY);
    const centerLatLng = worldToLatLng(before.x, before.y);
    const currentZoom = scaleToLeafletZoomForLat(view.scale, centerLatLng.lat);
    const targetZoom = nextZoomOutLeafletLevel(currentZoom);
    const targetScale = leafletZoomToScaleForLat(targetZoom, centerLatLng.lat);
    view.scale = targetScale;
    view.panX = screenX - before.x * view.scale;
    view.panY = screenY + before.y * view.scale;
    setStatus(`Zoomed out to map zoom ${targetZoom.toFixed(0)}.`, "ok");
  }

  function syncViewToGeoreference(payload) {
    const geo = payload?.georeference;
    const pointsList = Array.isArray(geo?.points) ? geo.points.filter((pt)=>
      Number.isFinite(Number(pt?.x)) &&
      Number.isFinite(Number(pt?.y)) &&
      Number.isFinite(Number(pt?.lat)) &&
      Number.isFinite(Number(pt?.lng))
    ) : [];
    if (!pointsList.length) return false;
    mapGeoreference = buildGeoreferenceTransform(pointsList);
    return mapGeoreference != null;
  }

  function ensureMapLayer() {
    if (mapInstance || !window.L) return;
    mapInstance = L.map("mapLayer", {
      zoomControl: false,
      attributionControl: true,
      dragging: false,
      scrollWheelZoom: false,
      doubleClickZoom: false,
      boxZoom: false,
      keyboard: false,
      tap: false,
      touchZoom: false,
      zoomSnap: 0,
      zoomDelta: 0.25,
      minZoom: MAP_LAYER_MIN_RENDER_ZOOM,
      maxZoom: MAP_LAYER_MAX_RENDER_ZOOM
    });
    applyMapTileType();
    mapArPresenceLayer = L.layerGroup().addTo(mapInstance);
    applyMapOpacity();
    syncMapToView(true);
  }

  function applyMapTileType() {
    if (mapTileTypeInput) mapTileTypeInput.value = mapLayerState.tileType;
    if (quickMapTileTypeInput) quickMapTileTypeInput.value = mapLayerState.tileType;
    if (!mapInstance) return;
    const tile = MAP_TILESETS[mapLayerState.tileType] || MAP_TILESETS.satellite;
    if (mapTileLayer) mapInstance.removeLayer(mapTileLayer);
    mapTileLayer = L.tileLayer(tile.url, tile.options).addTo(mapInstance);
  }

  function applyMapOpacity() {
    syncMapBackdropVisibility();
    if (mapOpacityValue) {
      mapOpacityValue.textContent = `${Math.round(mapLayerState.opacity * 100)}%`;
    }
  }

  function syncMapBackdropVisibility() {
    if (!mapBackdrop) return;
    const targetOpacity = mapLayerState.enabled ? mapLayerState.opacity : 0;
    mapBackdrop.style.opacity = String(clamp(targetOpacity, 0, 1));
    mapBackdrop.classList.toggle("on", mapLayerState.enabled);
  }

  function syncMapToView(force=false) {
    if (!mapLayerState.enabled || !mapInstance) return;
    const rect = canvas.getBoundingClientRect();
    if (!rect.width || !rect.height) return;
    const viewportSignature = `${Math.round(rect.width)}x${Math.round(rect.height)}`;
    if (force || mapViewportSignature !== viewportSignature) {
      mapViewportSignature = viewportSignature;
      mapInstance.invalidateSize(false);
    }
    const center = screenToWorld(rect.width * 0.5, rect.height * 0.5);
    const ll = worldToLatLng(center.x, center.y);
    const zoom = scaleToLeafletZoomForLat(view.scale, ll.lat);
    mapInstance.setView([ll.lat, ll.lng], zoom, { animate: false });
  }

  function upsertMapArPresence(clientId, presence) {
    if (!mapInstance || !window.L || !Number.isFinite(presence.lat) || !Number.isFinite(presence.lon)) return;
    let entry = mapArPresenceGraphics.get(clientId);
    if (!entry) {
      const marker = L.circleMarker([presence.lat, presence.lon], {
        radius: 6,
        color: presence.color || "#f97316",
        weight: 2,
        fillColor: presence.color || "#f97316",
        fillOpacity: 0.95
      });
      const cone = L.polygon([], {
        color: presence.color || "#f97316",
        fillColor: presence.color || "#f97316",
        fillOpacity: 0.18,
        weight: 1.5
      });
      entry = { marker, cone };
      mapArPresenceGraphics.set(clientId, entry);
      if (mapArPresenceLayer) {
        entry.marker.addTo(mapArPresenceLayer);
        entry.cone.addTo(mapArPresenceLayer);
      }
    }
    const headingRad = Number(presence.headingRad) || 0;
    const coneLengthMeters = 24;
    const halfAngle = 0.33;
    const cosLat = Math.max(0.1, Math.cos((presence.lat * Math.PI) / 180));
    const metersToLat = 1 / 111320;
    const metersToLon = 1 / (111320 * cosLat);
    const leftHeading = headingRad - halfAngle;
    const rightHeading = headingRad + halfAngle;
    const leftLat = presence.lat + (Math.cos(leftHeading) * coneLengthMeters * metersToLat);
    const leftLon = presence.lon + (Math.sin(leftHeading) * coneLengthMeters * metersToLon);
    const rightLat = presence.lat + (Math.cos(rightHeading) * coneLengthMeters * metersToLat);
    const rightLon = presence.lon + (Math.sin(rightHeading) * coneLengthMeters * metersToLon);

    entry.marker.setLatLng([presence.lat, presence.lon]);
    entry.marker.setStyle({ color: presence.color || "#f97316", fillColor: presence.color || "#f97316" });
    entry.cone.setLatLngs([[presence.lat, presence.lon], [leftLat, leftLon], [rightLat, rightLon]]);
    entry.cone.setStyle({ color: presence.color || "#f97316", fillColor: presence.color || "#f97316" });
  }

  function removeMapArPresence(clientId) {
    const entry = mapArPresenceGraphics.get(clientId);
    if (!entry) return;
    if (mapArPresenceLayer) {
      mapArPresenceLayer.removeLayer(entry.marker);
      mapArPresenceLayer.removeLayer(entry.cone);
    }
    mapArPresenceGraphics.delete(clientId);
  }

  function clearMapArPresence() {
    for (const clientId of mapArPresenceGraphics.keys()) {
      removeMapArPresence(clientId);
    }
  }

  function setMapLayerEnabled(enabled) {
    mapLayerState.enabled = enabled === true;
    if (mapEnabledInput) mapEnabledInput.checked = mapLayerState.enabled;
    setQuickToggleButtonState(quickMapEnabledBtn, mapLayerState.enabled);
    if (mapLayerState.enabled) {
      ensureMapLayer();
    }
    syncMapBackdropVisibility();
    if (mapLayerState.enabled) {
      syncMapToView(true);
    }
  }

  // -------------------------
  // Undo/Redo (snapshot-based)
  // -------------------------
  const history = {
    undo: [],
    redo: [],
    max: 200,
    push(label="") {
      this.undo.push({ state: serializeState(), label, ts: Date.now() });
      if (this.undo.length > this.max) this.undo.shift();
      this.redo.length = 0;
      updateUndoRedoHUD();
      scheduleCollabStateSync();
    },
    undoAction() {
      if (!this.undo.length) { setStatus("Nothing to undo.", "warn"); return; }
      const cur = serializeState();
      const prev = this.undo.pop().state;
      this.redo.push({ state: cur, label:"", ts: Date.now() });
      restoreState(prev);
      setStatus("Undo.", "ok");
      updateUndoRedoHUD();
      scheduleCollabStateSync();
    },
    redoAction() {
      if (!this.redo.length) { setStatus("Nothing to redo.", "warn"); return; }
      const cur = serializeState();
      const next = this.redo.pop().state;
      this.undo.push({ state: cur, label:"", ts: Date.now() });
      restoreState(next);
      setStatus("Redo.", "ok");
      updateUndoRedoHUD();
      scheduleCollabStateSync();
    }
  };

  function sanitizeBasisOfBearing(value) {
    const startPointId = Number(value?.startPointId);
    const endPointId = Number(value?.endPointId);
    if (Number.isFinite(startPointId) && Number.isFinite(endPointId)) {
      const startPoint = points.get(startPointId);
      const endPoint = points.get(endPointId);
      if (!startPoint || !endPoint) return null;
      if (startPoint.id === endPoint.id) return null;
      return { startPointId: startPoint.id, endPointId: endPoint.id };
    }

    const startX = Number(value?.start?.x);
    const startY = Number(value?.start?.y);
    const endX = Number(value?.end?.x);
    const endY = Number(value?.end?.y);
    if (![startX, startY, endX, endY].every(Number.isFinite)) return null;
    if (Math.hypot(endX - startX, endY - startY) < EPS) return null;
    return {
      start: { x: startX, y: startY },
      end: { x: endX, y: endY }
    };
  }

  function syncBasisOfBearingInputs() {
    if (basisBearingRecordBearingInput) basisBearingRecordBearingInput.value = recordBasisBearing;
    if (basisBearingRecordDistanceInput) basisBearingRecordDistanceInput.value = recordBasisDistance;

    if (!basisOfBearing) {
      if (basisBearingStartPointInput) basisBearingStartPointInput.value = "";
      if (basisBearingEndPointInput) basisBearingEndPointInput.value = "";
      return;
    }

    if (basisOfBearing.startPointId != null && basisOfBearing.endPointId != null) {
      const startPoint = points.get(basisOfBearing.startPointId);
      const endPoint = points.get(basisOfBearing.endPointId);
      if (basisBearingStartPointInput) basisBearingStartPointInput.value = startPoint ? String(startPoint.num ?? startPoint.id) : "";
      if (basisBearingEndPointInput) basisBearingEndPointInput.value = endPoint ? String(endPoint.num ?? endPoint.id) : "";
      return;
    }

    if (basisBearingStartPointInput) basisBearingStartPointInput.value = basisOfBearing?.start ? `${basisOfBearing.start.x},${basisOfBearing.start.y}` : "";
    if (basisBearingEndPointInput) basisBearingEndPointInput.value = basisOfBearing?.end ? `${basisOfBearing.end.x},${basisOfBearing.end.y}` : "";
  }

  function serializeState(options = {}) {
    const { includeView = true } = options;
    const pts = Array.from(points.values()).map(p => ({...p}));
    const lns = Array.from(lines.values()).map(l => ({...l}));
    const serialized = {
      nextId,
      points: pts,
      lines: lns,
      layers: Array.from(layers.values()).map((layer) => ({ ...layer })),
      selectedLayerId,
      selection: {
        selectedPointId,
        selectedPointIds: [...selectedPointIds],
        selectedLines: selectedLines.map(s => ({...s})),
        lastSelectedLineId
      },
      construction: {...construction},
      basisOfBearing: basisOfBearing ? { ...basisOfBearing } : null,
      recordBasisBearing,
      recordBasisDistance,
      mapGeoreference: mapGeoreference ? {
        lat: { ...mapGeoreference.lat },
        lng: { ...mapGeoreference.lng }
      } : null,
      modal: { open: !modal.classList.contains("hidden"), left: modalWindow.style.left, top: modalWindow.style.top, w: modalWindow.style.width, h: modalWindow.style.height }
    };
    if (includeView) serialized.view = { ...view };
    return JSON.stringify(serialized);
  }

  function restoreState(json, { skipSync = false, applyView = true } = {}) {
    const s = JSON.parse(json);
    nextId = s.nextId ?? 1;

    points.clear();
    for (const p of (s.points || [])) {
      if (!p || typeof p !== "object" || p.id == null) continue;
      points.set(p.id, { ...p, movable: isMovable(p.movable), layerId: String(p.layerId || selectedLayerId || DEFAULT_LAYER_ID) });
    }

    lines.clear();
    for (const l of (s.lines || [])) {
      if (!l || typeof l !== "object" || l.id == null || l.a == null || l.b == null) continue;
      lines.set(l.id, { ...l, movable: isMovable(l.movable), layerId: String(l.layerId || selectedLayerId || DEFAULT_LAYER_ID) });
    }

    resetLayers(Array.isArray(s.layers) ? s.layers : defaultLayerList());
    selectedLayerId = layers.has(s.selectedLayerId) ? s.selectedLayerId : (layers.keys().next().value || DEFAULT_LAYER_ID);

    selectedPointId = s.selection?.selectedPointId ?? null;
    if (selectedPointId != null && !points.has(selectedPointId)) selectedPointId = null;
    selectedPointIds = Array.isArray(s.selection?.selectedPointIds)
      ? s.selection.selectedPointIds.filter((id) => points.has(id))
      : [];
    selectedLines = Array.isArray(s.selection?.selectedLines)
      ? s.selection.selectedLines.filter((entry) => entry?.id != null && lines.has(entry.id))
      : [];
    lastSelectedLineId = s.selection?.lastSelectedLineId ?? null;

    construction = s.construction ?? { startPointId:null };
    basisOfBearing = sanitizeBasisOfBearing(s.basisOfBearing);
    recordBasisBearing = String(s.recordBasisBearing ?? "").trim();
    recordBasisDistance = String(s.recordBasisDistance ?? "").trim();
    syncBasisOfBearingInputs();

    if (applyView && s.view) {
      view.scale = s.view.scale ?? view.scale;
      view.panX = s.view.panX ?? view.panX;
      view.panY = s.view.panY ?? view.panY;
    }

    mapGeoreference = sanitizeMapGeoreference(s.mapGeoreference);

    ensureLegacyAutoFieldToFinishLineMetadata();
    syncFieldToFinishLinework();

    updatePointEditorFromSelection();
    schedulePointsTableRender();
    updateUndoRedoHUD();
    updateCounts();

    // Restore modal geometry (don’t auto-open/close during undo/redo; keep current visibility)
    if (s.modal) {
      if (s.modal.left) modalWindow.style.left = s.modal.left;
      if (s.modal.top) modalWindow.style.top = s.modal.top;
      if (s.modal.w) modalWindow.style.width = s.modal.w;
      if (s.modal.h) modalWindow.style.height = s.modal.h;
    }

    if (mapLayerState.enabled) syncMapToView(true);
    if (!skipSync) scheduleCollabStateSync();
  }

  function resolveCollabRoomId() {
    if (activeDrawingStorageKey) return activeDrawingStorageKey;
    if (activeProjectId) {
      const drawingName = String($("#drawingName")?.value || "").trim() || "default";
      const drawingId = normalizeDrawingId(drawingName);
      return drawingStorageKey(activeProjectId, drawingId);
    }
    return collabRoomParam || "global";
  }

  function setCollabStatus(text) {
    const el = $("#collabStatus");
    if (el) el.textContent = `Collaboration: ${text}`;
  }

  function sendCollabMessage(payload) {
    if (!collab.enabled || !collab.socket || collab.socket.readyState !== WebSocket.OPEN) return;
    collab.socket.send(JSON.stringify(payload));
  }


  function lockEntityKey(entityType, entityId) {
    return `${entityType}:${String(entityId)}`;
  }

  function triggerLockDeniedFlash() {
    document.body.classList.remove('lock-denied-flash');
    void document.body.offsetWidth;
    document.body.classList.add('lock-denied-flash');
    window.setTimeout(() => document.body.classList.remove('lock-denied-flash'), 850);
  }

  function upsertObjectLock(lockPayload = {}) {
    const entityType = lockPayload.entityType === 'point' ? 'point' : lockPayload.entityType === 'line' ? 'line' : null;
    const entityId = String(lockPayload.entityId || '').trim();
    if (!entityType || !entityId) return;
    collab.objectLocks.set(lockEntityKey(entityType, entityId), {
      entityType,
      entityId,
      ownerClientId: String(lockPayload.ownerClientId || ''),
      ownerColor: String(lockPayload.ownerColor || '#ffffff'),
      at: Number(lockPayload.at) || Date.now(),
    });
  }

  function releaseObjectLock(entityType, entityId) {
    collab.objectLocks.delete(lockEntityKey(entityType, entityId));
  }

  function isObjectLockedByOther(entityType, entityId) {
    const lock = collab.objectLocks.get(lockEntityKey(entityType, entityId));
    if (!lock) return false;
    return lock.ownerClientId && lock.ownerClientId !== collab.clientId;
  }

  function sendLockRelease(lockPayload = {}) {
    const entityType = lockPayload.entityType;
    const entityId = lockPayload.entityId;
    if (!entityType || entityId == null) return;
    sendCollabMessage({
      type: 'lock-release',
      entityType,
      entityId: String(entityId),
    });
    releaseObjectLock(entityType, entityId);
  }

  function flushPendingDragLockRelease() {
    const pendingLock = collab.pendingDragLockRelease;
    if (!pendingLock) return;
    if (collab.stateDebounce || collab.pendingState || collab.stateInFlight) return;
    collab.pendingDragLockRelease = null;
    sendLockRelease(pendingLock);
  }

  const LOCK_REQUEST_TIMEOUT_MS = 5000;

  function requestObjectEditLock({ entityType, entityId, onGranted, onDenied } = {}) {
    if (!entityType || entityId == null) return false;
    if (!collab.enabled || !collab.socket || collab.socket.readyState !== WebSocket.OPEN) {
      onGranted?.();
      return true;
    }

    const entityIdString = String(entityId);
    if (isObjectLockedByOther(entityType, entityIdString)) {
      setStatus(`${entityType} ${entityIdString} is locked by another collaborator.`, 'warn');
      triggerLockDeniedFlash();
      onDenied?.();
      return false;
    }

    const requestId = `lock-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const timeoutId = window.setTimeout(() => {
      const pending = collab.pendingLockRequests.get(requestId);
      if (pending) {
        collab.pendingLockRequests.delete(requestId);
        setStatus(`Lock request for ${entityType} ${entityIdString} timed out.`, 'warn');
        pending.onDenied?.();
      }
    }, LOCK_REQUEST_TIMEOUT_MS);

    collab.pendingLockRequests.set(requestId, {
      entityType,
      entityId: entityIdString,
      onGranted,
      onDenied,
      timeoutId,
      at: Date.now(),
    });

    sendCollabMessage({
      type: 'lock-request',
      requestId,
      entityType,
      entityId: entityIdString,
    });

    return true;
  }

  function buildLockVisualState() {
    const flashColor = Math.floor(performance.now() / 260) % 2 === 0 ? '#ef4444' : '#3b82f6';
    const lockedLineIds = new Set();
    const lockedPointIds = new Set();

    for (const lock of collab.objectLocks.values()) {
      if (lock.entityType === 'line') {
        lockedLineIds.add(lock.entityId);
        const line = lines.get(lock.entityId);
        if (line) {
          lockedPointIds.add(line.a);
          lockedPointIds.add(line.b);
        }
      }
      if (lock.entityType === 'point') {
        lockedPointIds.add(lock.entityId);
        for (const line of lines.values()) {
          if (line.a === lock.entityId || line.b === lock.entityId) {
            lockedLineIds.add(line.id);
          }
        }
      }
    }

    return { flashColor, lockedLineIds, lockedPointIds };
  }

  function parseSerializedCollabState(serialized) {
    if (typeof serialized !== "string" || !serialized.trim()) return {};
    try {
      return JSON.parse(serialized);
    } catch {
      return {};
    }
  }

  function shouldSkipQueuedCollabState(statePayload) {
    if (typeof statePayload !== "string" || !statePayload) return true;
    if (statePayload === collab.pendingState) return true;
    if (statePayload === collab.lastQueuedState) return true;
    if (statePayload === collab.latestServerState) return true;
    if (collab.stateInFlight && statePayload === collab.stateInFlight.localState) return true;
    return false;
  }

  function flushCollabStateSync() {
    if (!collab.enabled || collab.applyingRemoteState) {
      flushPendingDragLockRelease();
      return;
    }
    if (collab.stateInFlight || !collab.pendingState) {
      flushPendingDragLockRelease();
      return;
    }

    const statePayload = collab.pendingState;
    collab.pendingState = "";
    if (statePayload === collab.latestServerState) {
      flushPendingDragLockRelease();
      return;
    }

    const requestId = `state-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    collab.stateInFlight = {
      requestId,
      baseRevision: collab.lastKnownRevision,
      baseState: collab.latestServerState || "",
      localState: statePayload,
    };

    sendCollabMessage({
      type: "state",
      requestId,
      baseRevision: collab.lastKnownRevision,
      state: statePayload,
    });
  }

  function scheduleCollabStateSync() {
    if (!collab.enabled || collab.applyingRemoteState) return;
    if (collab.stateDebounce) clearTimeout(collab.stateDebounce);
    collab.stateDebounce = setTimeout(() => {
      collab.stateDebounce = null;
      const serializedState = serializeState({ includeView: false });
      if (shouldSkipQueuedCollabState(serializedState)) return;
      collab.pendingState = serializedState;
      collab.lastQueuedState = serializedState;
      flushCollabStateSync();
    }, 120);
  }

  function connectCollaboration({ skipInitialStateHydration = false, syncLocalStateOnConnect = false } = {}) {
    const roomId = resolveCollabRoomId();
    if (!roomId) return;
    collab.roomId = roomId;
    collab.enabled = true;

    const scheme = window.location.protocol === "https:" ? "wss" : "ws";
    const wsUrl = `${scheme}://${window.location.host}/ws/lineforge?room=${encodeURIComponent(roomId)}`;
    collab.wsUrl = wsUrl;
    if (collab.reconnectTimer) {
      clearTimeout(collab.reconnectTimer);
      collab.reconnectTimer = null;
    }
    const connectToken = ++collab.connectToken;
    setCollabStatus(`connecting (${roomId})…`);
    const socket = new WebSocket(wsUrl);
    collab.socket = socket;

    socket.addEventListener("open", () => {
      if (connectToken !== collab.connectToken) {
        socket.close();
        return;
      }
      collab.reconnectDelayMs = 3000;
      setCollabStatus(`connected (${roomId})`);
      if (syncLocalStateOnConnect) {
        const connectState = serializeState({ includeView: false });
        if (!shouldSkipQueuedCollabState(connectState)) {
          collab.pendingState = connectState;
          collab.lastQueuedState = connectState;
          flushCollabStateSync();
        }
      }
    });

    socket.addEventListener("close", () => {
      if (connectToken !== collab.connectToken) return;
      if (collab.socket === socket) collab.socket = null;
      setCollabStatus(`reconnecting (${roomId})…`);
      collab.remoteCursors.clear();
      collab.remoteArPresence.clear();
      collab.peers.clear();
      collab.stateInFlight = null;
      collab.pendingState = "";
      collab.pendingDragLockRelease = null;
      for (const pending of collab.pendingLockRequests.values()) {
        if (pending.timeoutId) window.clearTimeout(pending.timeoutId);
      }
      collab.pendingLockRequests.clear();
      collab.objectLocks.clear();
      clearMapArPresence();
      if (collab.enabled && collab.roomId && !collab.reconnectTimer) {
        const scheduledDelayMs = collab.reconnectDelayMs;
        collab.reconnectTimer = setTimeout(() => {
          collab.reconnectTimer = null;
          connectCollaboration({ skipInitialStateHydration, syncLocalStateOnConnect });
        }, scheduledDelayMs);
        collab.reconnectDelayMs = nextCollabReconnectDelay(scheduledDelayMs, collab.maxReconnectDelayMs);
      }
    });

    socket.addEventListener("message", (event) => {
      let message;
      try {
        message = JSON.parse(event.data);
      } catch {
        return;
      }

      if (message.type === "welcome") {
        collab.clientId = message.clientId || "";
        collab.color = message.color || "#ffffff";
        collab.lastKnownRevision = Number.isInteger(Number(message.revision)) ? Number(message.revision) : 0;
        collab.latestServerState = typeof message.state === "string" ? message.state : "";
        collab.lastQueuedState = collab.latestServerState || collab.lastQueuedState;
        collab.peers.clear();
        for (const peer of (message.peers || [])) {
          collab.peers.set(peer.clientId, { color: peer.color || "#ffffff" });
        }
        collab.objectLocks.clear();
        for (const lock of (message.locks || [])) {
          upsertObjectLock(lock);
        }
        if (message.state && !skipInitialStateHydration) {
          collab.applyingRemoteState = true;
          restoreState(message.state, { skipSync: true, applyView: false });
          collab.applyingRemoteState = false;
        }
        flushCollabStateSync();
        flushPendingDragLockRelease();
        return;
      }

      if (message.type === "peer-joined") {
        collab.peers.set(message.clientId, { color: message.color || "#ffffff" });
        return;
      }

      if (message.type === "peer-left") {
        collab.peers.delete(message.clientId);
        collab.remoteCursors.delete(message.clientId);
        collab.remoteArPresence.delete(message.clientId);
        removeMapArPresence(message.clientId);
        return;
      }

      if (message.type === "cursor") {
        collab.remoteCursors.set(message.clientId, {
          color: message.color || collab.peers.get(message.clientId)?.color || "#ffffff",
          x: Number(message.cursor?.x) || 0,
          y: Number(message.cursor?.y) || 0,
          crewMemberId: message.crewMemberId || null,
          crewName: message.crewName || null,
          at: Number(message.at) || Date.now()
        });
        return;
      }


      if (message.type === "lock-granted") {
        upsertObjectLock(message);
        const pending = collab.pendingLockRequests.get(message.requestId);
        if (pending) {
          collab.pendingLockRequests.delete(message.requestId);
          if (pending.timeoutId) window.clearTimeout(pending.timeoutId);
          pending.onGranted?.();
        }
        return;
      }

      if (message.type === "lock-denied") {
        const pending = collab.pendingLockRequests.get(message.requestId);
        if (pending) {
          collab.pendingLockRequests.delete(message.requestId);
          if (pending.timeoutId) window.clearTimeout(pending.timeoutId);
          setStatus(`${pending.entityType} ${pending.entityId} is locked by another collaborator.`, "warn");
          triggerLockDeniedFlash();
          pending.onDenied?.();
        }
        return;
      }

      if (message.type === "lock-updated") {
        if (message.action === "released") {
          releaseObjectLock(message.entityType, message.entityId);
        } else {
          upsertObjectLock(message);
        }
        return;
      }

      if (message.type === "state-ack") {
        if (collab.stateInFlight && message.requestId === collab.stateInFlight.requestId) {
          collab.lastKnownRevision = Number.isInteger(Number(message.revision)) ? Number(message.revision) : collab.lastKnownRevision;
          collab.latestServerState = typeof message.state === "string" ? message.state : collab.stateInFlight.localState;
          collab.stateInFlight = null;
        }
        flushCollabStateSync();
        flushPendingDragLockRelease();
        return;
      }

      if (message.type === "state-rejected") {
        const rejectedState = typeof message.state === "string" ? message.state : "";
        if (rejectedState) {
          collab.lastKnownRevision = Number.isInteger(Number(message.revision)) ? Number(message.revision) : collab.lastKnownRevision;
          collab.latestServerState = rejectedState;
          collab.applyingRemoteState = true;
          restoreState(rejectedState, { skipSync: true, applyView: false });
          collab.applyingRemoteState = false;
        }

        if (collab.stateInFlight && message.requestId === collab.stateInFlight.requestId) {
          const baseObj = parseSerializedCollabState(collab.stateInFlight.baseState);
          const localObj = parseSerializedCollabState(collab.stateInFlight.localState);
          const serverObj = parseSerializedCollabState(rejectedState);
          const localDiff = diffState(baseObj, localObj);
          const rebasedState = localDiff === undefined ? serverObj : applyStateDiff(serverObj, localDiff);
          const rebasedSerialized = JSON.stringify(rebasedState);
          if (rebasedSerialized && rebasedSerialized !== rejectedState) {
            collab.pendingState = rebasedSerialized;
            collab.lastQueuedState = rebasedSerialized;
            collab.applyingRemoteState = true;
            restoreState(rebasedSerialized, { skipSync: true, applyView: false });
            collab.applyingRemoteState = false;
          }
          collab.stateInFlight = null;
        }

        flushCollabStateSync();
        return;
      }

      if (message.type === "ar-presence" && message.presence) {
        const presence = {
          color: message.color || collab.peers.get(message.clientId)?.color || "#f97316",
          x: Number(message.presence.x),
          y: Number(message.presence.y),
          lat: Number(message.presence.lat),
          lon: Number(message.presence.lon),
          headingRad: Number(message.presence.headingRad) || 0,
          at: Number(message.at) || Date.now()
        };
        collab.remoteArPresence.set(message.clientId, presence);
        upsertMapArPresence(message.clientId, presence);
        return;
      }
      if (message.type === "state" && message.state) {
        collab.lastKnownRevision = Number.isInteger(Number(message.revision)) ? Number(message.revision) : collab.lastKnownRevision;
        collab.latestServerState = message.state;
        collab.applyingRemoteState = true;
        restoreState(message.state, { skipSync: true, applyView: false });
        collab.applyingRemoteState = false;
        flushCollabStateSync();
      }
    });
  }

  function getLocalCrewInfo() {
    const id = localStorage.getItem('surveyfoundryActiveCrewMemberId') || null;
    if (!id) return { crewMemberId: null, crewName: null };
    try {
      const profiles = JSON.parse(localStorage.getItem('surveyfoundryCrewProfiles') || '[]');
      const member = profiles.find(p => p.id === id);
      return { crewMemberId: id, crewName: member?.firstName || null };
    } catch { return { crewMemberId: id, crewName: null }; }
  }

  function broadcastCursor() {
    const crew = getLocalCrewInfo();
    sendCollabMessage({
      type: "cursor",
      cursor: {
        x: mouse.wx,
        y: mouse.wy
      },
      crewMemberId: crew.crewMemberId,
      crewName: crew.crewName
    });
  }

function paintBackground(ctx, w, h){
  // 1) radial glow
  const rg = ctx.createRadialGradient(
    w*0.20, h*0.30, 0,
    w*0.20, h*0.30, Math.max(w,h)*0.75
  );
  rg.addColorStop(0.0, "rgba(124,247,255,0.08)");
  rg.addColorStop(0.60, "rgba(124,247,255,0.00)");
  ctx.fillStyle = rg;
  ctx.fillRect(0,0,w,h);

  // 2) vertical vignette
  const lg = ctx.createLinearGradient(0,0,0,h);
  lg.addColorStop(0.0, "rgba(6,8,12,0.55)");
  lg.addColorStop(1.0, "rgba(6,8,12,0.85)");
  ctx.fillStyle = lg;
  ctx.fillRect(0,0,w,h);
}


  function drawRemoteCursors() {
    const expiryMs = 8000;
    const now = Date.now();

    for (const [clientId, presence] of collab.remoteArPresence.entries()) {
      if (now - presence.at > expiryMs) {
        collab.remoteArPresence.delete(clientId);
        removeMapArPresence(clientId);
        continue;
      }

      const x = Number(presence.x);
      const y = Number(presence.y);
      if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
      const sp = worldToScreen(x, y);
      const headingRad = Number(presence.headingRad) || 0;
      const coneLength = 28;
      const halfAngle = 0.33;
      const leftHeading = headingRad - halfAngle;
      const rightHeading = headingRad + halfAngle;
      const leftX = sp.x + Math.sin(leftHeading) * coneLength;
      const leftY = sp.y - Math.cos(leftHeading) * coneLength;
      const rightX = sp.x + Math.sin(rightHeading) * coneLength;
      const rightY = sp.y - Math.cos(rightHeading) * coneLength;

      ctx.save();
      ctx.fillStyle = presence.color || "#f97316";
      ctx.strokeStyle = presence.color || "#f97316";
      ctx.globalAlpha = 0.2;
      ctx.beginPath();
      ctx.moveTo(sp.x, sp.y);
      ctx.lineTo(leftX, leftY);
      ctx.lineTo(rightX, rightY);
      ctx.closePath();
      ctx.fill();

      ctx.globalAlpha = 1;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(sp.x, sp.y);
      ctx.lineTo(leftX, leftY);
      ctx.lineTo(rightX, rightY);
      ctx.closePath();
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(sp.x, sp.y, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(clientId.slice(0, 6), sp.x + 8, sp.y - 8);
      ctx.restore();
    }

    if (!collab.remoteCursors.size) return;
    for (const [clientId, cursor] of collab.remoteCursors.entries()) {
      if (now - cursor.at > expiryMs) {
        collab.remoteCursors.delete(clientId);
        continue;
      }
      const sp = worldToScreen(cursor.x, cursor.y);
      ctx.save();
      ctx.strokeStyle = cursor.color;
      ctx.fillStyle = cursor.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(sp.x - 8, sp.y);
      ctx.lineTo(sp.x + 8, sp.y);
      ctx.moveTo(sp.x, sp.y - 8);
      ctx.lineTo(sp.x, sp.y + 8);
      ctx.stroke();
      ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(cursor.crewName || clientId.slice(0, 6), sp.x + 10, sp.y - 10);
      ctx.restore();
    }
  }


  function updateUndoRedoHUD() {
    hudUndo.textContent = String(history.undo.length);
    hudRedo.textContent = String(history.redo.length);
    $("#undoBtn").disabled = history.undo.length === 0;
    $("#redoBtn").disabled = history.redo.length === 0;
  }

  // -------------------------
  // Transform helpers
  // -------------------------
  function worldToScreen(x,y){
    const rotated = rotateWorldPointAroundBasis(x, y);
    return {
      x: (rotated.x * view.scale) + view.panX,
      y: (-rotated.y * view.scale) + view.panY
    };
  }
  function screenToWorld(x,y){
    const rotatedX = (x - view.panX) / view.scale;
    const rotatedY = -((y - view.panY) / view.scale);
    return rotateDrawingPointToWorld(rotatedX, rotatedY);
  }

  // -------------------------
  // Model helpers
  // -------------------------
  function getMaxPointNumber() {
    let m = 0;
    for (const p of points.values()) m = Math.max(m, Number(p.num) || 0);
    return m;
  }
  function nextOpenPointNumber(start=null) {
    const used = new Set();
    for (const p of points.values()) used.add(String(p.num));
    let n = start ?? (getMaxPointNumber() + 1);
    n = Math.max(1, Math.floor(Number(n) || 1));
    while (used.has(String(n))) n++;
    return n;
  }
  function pointNumberExists(numStr, excludeId=null) {
    const ns = String(numStr);
    for (const p of points.values()) {
      if (excludeId != null && p.id === excludeId) continue;
      if (String(p.num) === ns) return true;
    }
    return false;
  }
  function resolveDesiredPointNumber(inputValue) {
    const raw = String(inputValue ?? "").trim();
    if (!raw) return nextOpenPointNumber();
    const requested = Number(raw);
    if (!Number.isFinite(requested)) return nextOpenPointNumber();
    const reqInt = Math.max(1, Math.floor(requested));
    if (!pointNumberExists(String(reqInt))) return reqInt;
    return nextOpenPointNumber(reqInt);
  }

  function findPointIdByNumber(pointNumber) {
    const desired = String(pointNumber ?? "").trim();
    if (!desired) return null;
    for (const p of points.values()) {
      if (String(p.num) === desired) return p.id;
    }
    return null;
  }

  function findDirectConnectionLine(aId, bId) {
    for (const ln of lines.values()) {
      if ((ln.a === aId && ln.b === bId) || (ln.a === bId && ln.b === aId)) return ln;
    }
    return null;
  }

  function arePointsDirectlyConnected(aId, bId) {
    return !!findDirectConnectionLine(aId, bId);
  }

  const defaultFldConfigPath = "config/MLS.fld";
  const fieldToFinishRuleState = {
    lineworkCodes: new Set(),
    symbolCodes: new Set(),
    codeLayers: new Map(),
    codeSymbolMapFiles: new Map(),
    lineworkCompanionCodes: new Map(),
    companionToLineworkCodes: new Map(),
    symbolSvgOverrides: new Map(),
    source: null,
    loaded: false,
    attempted: false,
  };
  const fldEditorState = {
    serverConfig: null,
    activeConfig: null,
    source: "server",
  };
  const fldSymbolLibraryState = {
    symbols: [],
    byFile: new Map(),
    loaded: false,
  };
  const symbolMarkerImageCache = new Map();
  const tintedSymbolMarkerCache = new Map();
  const SYMBOL_MARKER_SIZE_PX = 30;
  const SYMBOL_MARKER_HALF_SIZE_PX = SYMBOL_MARKER_SIZE_PX / 2;
  const SYMBOL_BOLD_OFFSET_PX = 1;

  async function loadSurveySymbolLibrary() {
    try {
      const response = await fetch("/assets/survey-symbols/index.json");
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const manifest = await response.json();
      const symbols = Array.isArray(manifest?.symbols) ? manifest.symbols : [];
      fldSymbolLibraryState.symbols = symbols;
      fldSymbolLibraryState.byFile = new Map(symbols.map((symbol) => [String(symbol?.file || "").trim(), symbol]));
      fldSymbolLibraryState.loaded = true;
      return true;
    } catch (_err) {
      fldSymbolLibraryState.symbols = [];
      fldSymbolLibraryState.byFile = new Map();
      fldSymbolLibraryState.loaded = false;
      return false;
    }
  }

  function buildLineTypeOptions(config) {
    const options = new Set(["BYLAYER"]);
    const rules = Array.isArray(config?.rules) ? config.rules : [];
    for (const rule of rules) {
      const lineType = String(rule?.raw?.linetype || "").trim();
      if (lineType) options.add(lineType);
    }
    return Array.from(options).sort((a, b) => a.localeCompare(b));
  }

  function buildSymbolMapChoices(config) {
    const choices = [];
    const seen = new Set();
    for (const symbol of fldSymbolLibraryState.symbols) {
      const file = String(symbol?.file || "").trim();
      if (!file || seen.has(file)) continue;
      seen.add(file);
      const id = String(symbol?.id || "").trim();
      const code = String(symbol?.code || "").trim();
      choices.push({
        value: file,
        id,
        code,
        file,
        label: [code, id, file].filter(Boolean).join(" • "),
      });
    }
    const rules = Array.isArray(config?.rules) ? config.rules : [];
    for (const rule of rules) {
      const existingFile = getSymbolMapFileForRule(rule);
      if (!existingFile || seen.has(existingFile)) continue;
      seen.add(existingFile);
      choices.push({ value: existingFile, label: existingFile });
    }
    return choices;
  }

  function symbolChoicePreviewUrl(value) {
    const file = String(value || "").trim();
    if (file) return `/assets/survey-symbols/${encodeURIComponent(file)}`;
    return "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='26' height='26' viewBox='0 0 26 26'%3E%3Crect x='2' y='2' width='22' height='22' rx='4' fill='none' stroke='%23bbbbbb' stroke-dasharray='2 2'/%3E%3C/svg%3E";
  }

  function buildFldSymbolPreviewPicker({ symbolMapChoices, currentValue, onPick }) {
    const pickerWrap = document.createElement("div");
    pickerWrap.className = "fldSymbolPicker";

    const selectedChoice = symbolMapChoices.find((choice) => choice.value === currentValue) || null;
    const pickerButton = document.createElement("button");
    pickerButton.type = "button";
    pickerButton.className = "fldSymbolPickerButton";

    const currentWrap = document.createElement("div");
    currentWrap.className = "fldSymbolPickerCurrent";

    const currentPreview = document.createElement("img");
    currentPreview.src = symbolChoicePreviewUrl(selectedChoice?.value);
    currentPreview.alt = "Selected symbol preview";
    if (!selectedChoice?.value) currentPreview.style.opacity = "0.5";

    const currentLabel = document.createElement("div");
    currentLabel.className = "fldSymbolPickerCurrentLabel";

    const currentName = document.createElement("b");
    currentName.textContent = selectedChoice?.code || selectedChoice?.id || selectedChoice?.value || "No SVG mapping";

    const currentFile = document.createElement("span");
    currentFile.className = "muted";
    currentFile.textContent = selectedChoice?.file || selectedChoice?.value || "Click to choose an SVG";

    currentLabel.append(currentName, currentFile);
    currentWrap.append(currentPreview, currentLabel);

    const chevron = document.createElement("span");
    chevron.className = "muted";
    chevron.textContent = "▾";

    pickerButton.append(currentWrap, chevron);

    const menu = document.createElement("div");
    menu.className = "fldSymbolPickerMenu hidden";
    symbolMapChoices.forEach((choice) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "fldSymbolChoiceBtn";
      if (choice.value === currentValue) btn.classList.add("active");

      const img = document.createElement("img");
      img.src = symbolChoicePreviewUrl(choice.value);
      img.alt = `${choice.code || choice.id || choice.value || "No SVG mapping"} preview`;
      img.loading = "lazy";
      if (!choice.value) img.style.opacity = "0.5";

      const labelWrap = document.createElement("div");
      labelWrap.className = "fldSymbolChoiceLabel";

      const name = document.createElement("b");
      name.textContent = choice.code || choice.id || choice.value || "No SVG mapping";

      const file = document.createElement("span");
      file.className = "muted";
      file.textContent = choice.file || choice.value || "Clear SVG mapping";

      labelWrap.append(name, file);
      btn.append(img, labelWrap);
      btn.addEventListener("click", () => {
        menu.classList.add("hidden");
        onPick(choice.value);
      });
      menu.appendChild(btn);
    });

    pickerButton.addEventListener("click", (event) => {
      event.stopPropagation();
      menu.classList.toggle("hidden");
    });
    document.addEventListener("click", () => {
      menu.classList.add("hidden");
    });

    pickerWrap.append(pickerButton, menu);
    return pickerWrap;
  }

  function isLineworkEntityType(entityType) {
    const normalized = String(entityType ?? "").trim();
    return normalized === "2" || normalized === "1";
  }

  function getRuleSymbolMapFile(raw = {}) {
    return String(raw?.symbol_name_2 || raw?.symbol_block_id || raw?.symbol_map_file || "").trim();
  }

  function setRuleSymbolMapFile(raw, value) {
    if (!raw || typeof raw !== "object") return;
    const normalized = String(value || "").trim();
    raw.symbol_name_2 = normalized;
    if (Object.hasOwn(raw, "symbol_block_id")) raw.symbol_block_id = normalized;
    if (Object.hasOwn(raw, "symbol_map_file")) raw.symbol_map_file = normalized;
  }

  function normalizeSymbolOverrideKey(symbolName = "") {
    return String(symbolName || "").trim().toUpperCase();
  }

  function loadFldSymbolMapOverrides() {
    try {
      const raw = localStorage.getItem(FLD_SYMBOL_MAP_OVERRIDES_LOCAL_STORAGE_KEY);
      if (!raw) return new Map();
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return new Map();
      const overrides = new Map();
      for (const [symbol, file] of Object.entries(parsed)) {
        const symbolKey = normalizeSymbolOverrideKey(symbol);
        const mappedFile = String(file || "").trim();
        if (!symbolKey || !mappedFile) continue;
        overrides.set(symbolKey, mappedFile);
      }
      return overrides;
    } catch (_err) {
      return new Map();
    }
  }

  function saveFldSymbolMapOverrides(overrides) {
    const obj = {};
    for (const [symbol, file] of (overrides instanceof Map ? overrides.entries() : [])) {
      const symbolKey = normalizeSymbolOverrideKey(symbol);
      const mappedFile = String(file || "").trim();
      if (!symbolKey || !mappedFile) continue;
      obj[symbolKey] = mappedFile;
    }
    localStorage.setItem(FLD_SYMBOL_MAP_OVERRIDES_LOCAL_STORAGE_KEY, JSON.stringify(obj));
  }

  function getSymbolMapFileForRule(rule) {
    const symbolName = normalizeSymbolOverrideKey(rule?.raw?.symbol);
    if (symbolName) {
      const override = String(fieldToFinishRuleState.symbolSvgOverrides.get(symbolName) || "").trim();
      if (override) return override;
    }
    return getRuleSymbolMapFile(rule?.raw);
  }

  function setSymbolMapFileForRule(rule, value) {
    const symbolName = normalizeSymbolOverrideKey(rule?.raw?.symbol);
    if (!symbolName) {
      setStatus("Enter a Symbol value before assigning an SVG mapping.", "warn");
      return false;
    }
    const mappedFile = String(value || "").trim();
    setRuleSymbolMapFile(rule?.raw, mappedFile);
    if (mappedFile) fieldToFinishRuleState.symbolSvgOverrides.set(symbolName, mappedFile);
    else fieldToFinishRuleState.symbolSvgOverrides.delete(symbolName);
    saveFldSymbolMapOverrides(fieldToFinishRuleState.symbolSvgOverrides);
    return true;
  }

  function normalizeLineworkRuleDefaults(rule) {
    if (!rule?.raw || !isLineworkEntityType(rule.raw.entity_type)) return;
    rule.raw.symbol = "SPT10";
    setRuleSymbolMapFile(rule.raw, "");
  }

  function deriveFieldToFinishCodeSetsFromConfig(config) {
    const lineworkCodes = new Set();
    const symbolCodes = new Set();
    const codeLayers = new Map();
    const codeSymbolMapFiles = new Map();
    const lineworkCompanionCodes = new Map();
    const companionToLineworkCodes = new Map();
    const rules = Array.isArray(config?.rules) ? config.rules : [];
    for (const rule of rules) {
      if (!rule?.processingOn || !rule.code) continue;
      const code = String(rule.code).trim().toUpperCase();
      const entityType = String(rule.entityType ?? "").trim();
      const layerName = String(rule.layer ?? "").trim();
      const symbolMapFile = getSymbolMapFileForRule(rule);
      if (!code) continue;
      if (isLineworkEntityType(entityType)) lineworkCodes.add(code);
      if (entityType === "0") symbolCodes.add(code);
      if (entityType === "0" && symbolMapFile) codeSymbolMapFiles.set(code, symbolMapFile);
      if (layerName) codeLayers.set(code, layerName);

      if (!isLineworkEntityType(entityType)) continue;
      const companionCodes = Array.isArray(rule.companionCodes) ? rule.companionCodes : [];
      const normalizedCompanions = companionCodes
        .map((companionCode) => String(companionCode ?? "").trim().toUpperCase())
        .filter(Boolean);
      if (!normalizedCompanions.length) continue;

      lineworkCompanionCodes.set(code, new Set(normalizedCompanions));
      for (const companionCode of normalizedCompanions) {
        if (!companionToLineworkCodes.has(companionCode)) companionToLineworkCodes.set(companionCode, new Set());
        companionToLineworkCodes.get(companionCode).add(code);
      }
    }
    return { lineworkCodes, symbolCodes, codeLayers, codeSymbolMapFiles, lineworkCompanionCodes, companionToLineworkCodes };
  }

  function cloneFldConfig(config) {
    if (!config || typeof config !== "object") return null;
    return JSON.parse(JSON.stringify(config));
  }

  function loadLocalFldOverride() {
    try {
      const raw = localStorage.getItem(FLD_CONFIG_LOCAL_STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed?.columns) || !Array.isArray(parsed?.rules)) return null;
      return parsed;
    } catch (_err) {
      return null;
    }
  }

  function saveLocalFldOverride(config) {
    localStorage.setItem(FLD_CONFIG_LOCAL_STORAGE_KEY, JSON.stringify(config));
  }

  function clearLocalFldOverride() {
    localStorage.removeItem(FLD_CONFIG_LOCAL_STORAGE_KEY);
  }

  function serializeFieldToFinishConfig(config) {
    const columns = Array.isArray(config?.columns) ? config.columns : [];
    const rules = Array.isArray(config?.rules) ? config.rules : [];
    if (!columns.length) return "";
    const header = `#${String(config?.versionTag || "2010V").trim()}# ${columns.map((col, idx) => String(col?.name || `Column ${idx + 1}`).trim()).join("|")}`;
    const lines = [header];
    for (const rule of rules) {
      const raw = rule?.raw && typeof rule.raw === "object" ? rule.raw : {};
      lines.push(columns.map((col) => String(raw[col.key] ?? "").replace(/[\r\n|]/g, " ").trim()).join("|"));
    }
    return `${lines.join("\n")}\n`;
  }

  function downloadTextFile(filename, content) {
    const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function applyFieldToFinishConfig(config, sourceLabel = defaultFldConfigPath) {
    fieldToFinishRuleState.symbolSvgOverrides = loadFldSymbolMapOverrides();
    const { lineworkCodes, symbolCodes, codeLayers, codeSymbolMapFiles, lineworkCompanionCodes, companionToLineworkCodes } = deriveFieldToFinishCodeSetsFromConfig(config);
    fieldToFinishRuleState.lineworkCodes = lineworkCodes;
    fieldToFinishRuleState.symbolCodes = symbolCodes;
    fieldToFinishRuleState.codeLayers = codeLayers;
    fieldToFinishRuleState.codeSymbolMapFiles = codeSymbolMapFiles;
    fieldToFinishRuleState.lineworkCompanionCodes = lineworkCompanionCodes;
    fieldToFinishRuleState.companionToLineworkCodes = companionToLineworkCodes;
    fieldToFinishRuleState.source = sourceLabel;
    fieldToFinishRuleState.loaded = true;
    preloadMappedPointSymbolMarkers();
  }

  async function loadFieldToFinishRulesFromFld(path = defaultFldConfigPath) {
    fieldToFinishRuleState.attempted = true;
    try {
      const response = await fetch(`/api/fld-config?file=${encodeURIComponent(path)}`);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const serverConfig = await response.json();
      fldEditorState.serverConfig = cloneFldConfig(serverConfig);
      const localOverride = loadLocalFldOverride();
      fldEditorState.activeConfig = cloneFldConfig(localOverride || serverConfig);
      fldEditorState.source = localOverride ? "local" : "server";
      applyFieldToFinishConfig(fldEditorState.activeConfig, localOverride ? "localStorage" : path);
      await loadSurveySymbolLibrary();
      return true;
    } catch (_err) {
      fieldToFinishRuleState.loaded = false;
      fieldToFinishRuleState.lineworkCodes = new Set();
      fieldToFinishRuleState.symbolCodes = new Set();
      fieldToFinishRuleState.codeLayers = new Map();
      fieldToFinishRuleState.codeSymbolMapFiles = new Map();
      fieldToFinishRuleState.lineworkCompanionCodes = new Map();
      fieldToFinishRuleState.companionToLineworkCodes = new Map();
      fieldToFinishRuleState.symbolSvgOverrides = loadFldSymbolMapOverrides();
      return false;
    }
  }

  function getPointSymbolMapFile(pointCode = "") {
    const tokensUpper = tokenizePointCode(pointCode);
    for (const token of tokensUpper) {
      const mappedFile = String(fieldToFinishRuleState.codeSymbolMapFiles.get(token) || "").trim();
      if (mappedFile) return mappedFile;
    }
    return "";
  }

  function getPointSymbolPreviewUrl(pointCode = "") {
    const symbolMapFile = getPointSymbolMapFile(pointCode);
    if (!symbolMapFile) return "";
    return `/assets/survey-symbols/${encodeURIComponent(symbolMapFile)}`;
  }

  function getSymbolMarkerImage(symbolMapFile = "") {
    const file = String(symbolMapFile || "").trim();
    if (!file) return null;
    const cached = symbolMarkerImageCache.get(file);
    if (cached) return cached;
    const image = new Image();
    image.decoding = "async";
    image.src = `/assets/survey-symbols/${encodeURIComponent(file)}`;
    image.addEventListener("load", () => {
      for (const cacheKey of tintedSymbolMarkerCache.keys()) {
        if (cacheKey.startsWith(`${file}::`)) tintedSymbolMarkerCache.delete(cacheKey);
      }
      draw();
    }, { once: true });
    image.addEventListener("error", () => {
      symbolMarkerImageCache.delete(file);
    }, { once: true });
    symbolMarkerImageCache.set(file, image);
    return image;
  }

  function preloadMappedPointSymbolMarkers() {
    const pendingLoads = [];
    const uniqueFiles = new Set(fieldToFinishRuleState.codeSymbolMapFiles.values());
    for (const file of uniqueFiles) {
      const normalizedFile = String(file || "").trim();
      if (!normalizedFile) continue;
      const image = getSymbolMarkerImage(normalizedFile);
      if (!(image instanceof HTMLImageElement)) continue;
      if (image.complete) continue;
      pendingLoads.push(new Promise((resolve) => {
        image.addEventListener("load", resolve, { once: true });
        image.addEventListener("error", resolve, { once: true });
      }));
    }
    if (pendingLoads.length) {
      Promise.allSettled(pendingLoads).then(() => draw());
    }
  }

  function getTintedSymbolMarker(symbolMapFile = "", layerColor = "") {
    const file = String(symbolMapFile || "").trim();
    const tint = String(layerColor || "").trim() || "#ff2b2b";
    if (!file) return null;
    const cacheKey = `${file}::${tint}`;
    if (tintedSymbolMarkerCache.has(cacheKey)) {
      return tintedSymbolMarkerCache.get(cacheKey);
    }
    const image = getSymbolMarkerImage(file);
    if (!(image?.complete && image.naturalWidth > 0 && image.naturalHeight > 0)) return null;

    const markerCanvas = document.createElement("canvas");
    markerCanvas.width = SYMBOL_MARKER_SIZE_PX;
    markerCanvas.height = SYMBOL_MARKER_SIZE_PX;
    const markerCtx = markerCanvas.getContext("2d");
    if (!markerCtx) return null;

    // Draw several 1px-offset passes first so thin symbol strokes stay visibly bold.
    markerCtx.drawImage(image, 0, 0, markerCanvas.width, markerCanvas.height);
    markerCtx.drawImage(image, SYMBOL_BOLD_OFFSET_PX, 0, markerCanvas.width, markerCanvas.height);
    markerCtx.drawImage(image, -SYMBOL_BOLD_OFFSET_PX, 0, markerCanvas.width, markerCanvas.height);
    markerCtx.drawImage(image, 0, SYMBOL_BOLD_OFFSET_PX, markerCanvas.width, markerCanvas.height);
    markerCtx.drawImage(image, 0, -SYMBOL_BOLD_OFFSET_PX, markerCanvas.width, markerCanvas.height);

    // tint only the symbol footprint (avoid flooding the full marker square)
    markerCtx.drawImage(image, 0, 0, markerCanvas.width, markerCanvas.height);
    markerCtx.globalCompositeOperation = "source-in";
    markerCtx.fillStyle = tint;
    markerCtx.fillRect(0, 0, markerCanvas.width, markerCanvas.height);
    markerCtx.globalCompositeOperation = "source-over";

    tintedSymbolMarkerCache.set(cacheKey, markerCanvas);
    return markerCanvas;
  }

  function pointSupportsLineworkSequenceToken(tokenSet, lineCode) {
    if (tokenSet.has(lineCode)) return true;
    const companionCodes = fieldToFinishRuleState.lineworkCompanionCodes.get(lineCode);
    if (!companionCodes?.size) return false;
    for (const companionCode of companionCodes) {
      if (tokenSet.has(companionCode)) return true;
    }
    return false;
  }

  const fieldToFinishCommandParsers = [
    {
      type: "join-point-number",
      parse(raw, tokensUpper) {
        const commands = [];
        const regex = /\bJPN\s*([A-Za-z0-9]+)\b/gi;
        let match = regex.exec(raw);
        const seen = new Set();
        while (match) {
          const target = String(match[1] ?? "").trim();
          if (target && !seen.has(target)) {
            seen.add(target);
            commands.push({ type: "join-point-number", targetPointNumber: target });
          }
          match = regex.exec(raw);
        }
        return commands;
      }
    },
    {
      type: "circle",
      parse(raw, _tokensUpper) {
        const commands = [];
        const regex = /(?:^|[^A-Z0-9])CIR\s*([0-9]*\.?[0-9]+)\s*(?:FT)?\b/gi;
        let match = regex.exec(raw);
        while (match) {
          const radius = Number(match[1]);
          if (Number.isFinite(radius) && radius > 0) {
            commands.push({ type: "circle", radius });
          }
          match = regex.exec(raw);
        }
        return commands;
      }
    },
    {
      type: "sequential-line",
      parse(_raw, tokensUpper) {
        const commands = [];
        const directives = new Set(["BEG", "END", "CLO"]);
        for (let i = 0; i < tokensUpper.length - 1; i++) {
          const baseCode = tokensUpper[i];
          const action = tokensUpper[i + 1];
          if (!baseCode || directives.has(baseCode) || !directives.has(action)) continue;
          commands.push({ type: "sequential-line", baseCode, action });
        }
        return commands;
      }
    }
  ];

  function tokenizePointCode(rawCode = "") {
    const raw = String(rawCode ?? "");
    return raw
      .split(/[^A-Za-z0-9]+/)
      .map(token => token.trim().toUpperCase())
      .filter(Boolean);
  }

  function parseFieldToFinishCommands(code = "") {
    const raw = String(code ?? "");
    const tokensUpper = tokenizePointCode(raw);
    const commands = [];
    for (const parser of fieldToFinishCommandParsers) {
      const parsed = parser.parse(raw, tokensUpper) || [];
      for (const cmd of parsed) commands.push(cmd);
    }
    return { tokensUpper, commands };
  }

  function getRenderedPointCode(rawCode = "") {
    const tokens = String(rawCode ?? "")
      .trim()
      .split(/\s+/)
      .filter(Boolean);
    if (tokens.length <= 1) return tokens.join(" ");

    const directives = new Set(["BEG", "END", "CLO"]);
    const rendered = [];

    for (let i = 0; i < tokens.length; i++) {
      const tokenRaw = tokens[i];
      const tokenUpper = tokenRaw.toUpperCase();

      if (i === 0) {
        rendered.push(tokenRaw);
        continue;
      }

      if (directives.has(tokenUpper)) continue;
      if (/^JPN[A-Z0-9]+$/i.test(tokenRaw)) continue;
      if (tokenUpper === "JPN") {
        const next = String(tokens[i + 1] ?? "");
        if (/^[A-Z0-9]+$/i.test(next)) i++;
        continue;
      }
      if (/^CIR\s*[0-9]*\.?[0-9]+(?:FT)?$/i.test(tokenRaw)) continue;
      if (tokenUpper === "CIR") {
        const next = String(tokens[i + 1] ?? "");
        if (/^[0-9]*\.?[0-9]+(?:FT)?$/i.test(next)) i++;
        continue;
      }

      if (fieldToFinishRuleState.lineworkCodes.has(tokenUpper)) continue;
      if (fieldToFinishRuleState.companionToLineworkCodes.has(tokenUpper)) continue;

      rendered.push(tokenRaw);
    }

    return rendered.join(" ");
  }
  function buildLayerIdFromName(layerName = "") {
    const base = String(layerName ?? "").trim().toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
    return `layer-ftf-${base || Date.now()}`;
  }

  const fieldToFinishStandardLayerColorRules = [
    { pattern: /\bwater\b|\bpotable\b|\birrigation\b/i, color: "#007bff" },
    { pattern: /\bgas\b|\bnatural\s*gas\b/i, color: "#ffd400" },
    { pattern: /\bsewer\b|\bsanitary\b|\bwaste\b/i, color: "#00a651" },
    { pattern: /\bpower\b|\belectric\b|\bprimary\b|\bsecondary\b/i, color: "#ff3b30" },
    { pattern: /\bstorm\b|\bdrain\b/i, color: "#00c2ff" },
    { pattern: /\btelecom\b|\bphone\b|\bfiber\b|\bcommunication\b/i, color: "#ff8c00" }
  ];

  const fieldToFinishHighVisibilityPalette = [
    "#ff2d55", "#00c7ff", "#ffd60a", "#39ff14", "#bf5af2", "#ff9f0a", "#64d2ff", "#ff375f", "#30d158", "#ff453a", "#0a84ff", "#ffd1dc"
  ];

  function pickFieldToFinishLayerColor(layerName = "") {
    const normalizedName = String(layerName ?? "").trim();
    for (const rule of fieldToFinishStandardLayerColorRules) {
      if (rule.pattern.test(normalizedName)) return rule.color;
    }

    const usedColors = new Set();
    for (const layer of layers.values()) usedColors.add(String(layer.color || "").toLowerCase());
    const available = fieldToFinishHighVisibilityPalette.filter((color) => !usedColors.has(color.toLowerCase()));
    const palette = available.length ? available : fieldToFinishHighVisibilityPalette;
    const index = Math.floor(Math.random() * palette.length);
    return palette[index] || "#00c7ff";
  }

  function ensureLayerByName(layerName = "") {
    const desiredName = String(layerName ?? "").trim();
    if (!desiredName) return null;
    for (const layer of layers.values()) {
      if (String(layer.name).trim().toUpperCase() === desiredName.toUpperCase()) return layer.id;
    }
    const baseId = buildLayerIdFromName(desiredName);
    let id = baseId;
    let suffix = 2;
    while (layers.has(id)) {
      id = `${baseId}-${suffix}`;
      suffix++;
    }
    const color = pickFieldToFinishLayerColor(desiredName);
    layers.set(id, sanitizeLayer({ id, name: desiredName, color, lineWeight: 1.5, locked: false, visible: true, fill: false }, id));
    renderLayerControls();
    scheduleLayersTableRender();
    return id;
  }

  function resolveFieldToFinishLayerIdForCode(pointCode = "") {
    const { tokensUpper } = parseFieldToFinishCommands(pointCode);
    for (const token of tokensUpper) {
      const layerName = fieldToFinishRuleState.codeLayers.get(token);
      if (!layerName) continue;
      return ensureLayerByName(layerName);
    }
    return null;
  }

  function extractJpnTargetPointNumbers(code = "") {
    const targets = [];
    const seen = new Set();
    const { commands } = parseFieldToFinishCommands(code);
    for (const cmd of commands) {
      if (cmd.type !== "join-point-number") continue;
      const target = String(cmd.targetPointNumber ?? "").trim();
      if (target && !seen.has(target)) {
        seen.add(target);
        targets.push(target);
      }
    }
    return targets;
  }

  function buildPointIdByNumberMap() {
    const byNum = new Map();
    for (const p of points.values()) byNum.set(String(p.num), p.id);
    return byNum;
  }


  function getNormalizedLineKey(aPointId, bPointId) {
    const a = Number(aPointId);
    const b = Number(bPointId);
    if (!Number.isFinite(a) || !Number.isFinite(b) || a === b) return "";
    return a < b ? `${a}:${b}` : `${b}:${a}`;
  }

  function buildExpectedJpnLineCommands() {
    const byNum = buildPointIdByNumberMap();
    const commands = [];
    const seen = new Set();
    for (const sourcePoint of points.values()) {
      const targets = extractJpnTargetPointNumbers(sourcePoint.code);
      for (const targetNum of targets) {
        const targetPointId = byNum.get(String(targetNum));
        if (!targetPointId || targetPointId === sourcePoint.id) continue;
        const key = getNormalizedLineKey(sourcePoint.id, targetPointId);
        if (!key || seen.has(key)) continue;
        seen.add(key);
        commands.push({ a: sourcePoint.id, b: targetPointId, type: "jpn", sourcePointId: sourcePoint.id });
      }
    }
    return commands;
  }

  function resolveAutoLineLayerId(aPointId, bPointId, { type = "sequential", baseCode = "", sourcePointId = null } = {}) {
    const aPoint = points.get(aPointId);
    const bPoint = points.get(bPointId);
    const aLayerId = aPoint?.layerId;
    const bLayerId = bPoint?.layerId;
    if (aLayerId && aLayerId === bLayerId) return aLayerId;

    if (type === "jpn") {
      const sourceLayerId = points.get(sourcePointId)?.layerId;
      if (sourceLayerId && layers.has(sourceLayerId)) return sourceLayerId;
    }

    if (baseCode) {
      const lineworkLayerName = fieldToFinishRuleState.codeLayers.get(baseCode);
      const lineworkLayerId = lineworkLayerName ? ensureLayerByName(lineworkLayerName) : null;
      if (lineworkLayerId && layers.has(lineworkLayerId)) return lineworkLayerId;
    }

    if (aLayerId && layers.has(aLayerId)) return aLayerId;
    if (bLayerId && layers.has(bLayerId)) return bLayerId;
    return selectedLayerId || DEFAULT_LAYER_ID;
  }

  function createAutoFieldToFinishLine(aPointId, bPointId, { type = "sequential", baseCode = "", sourcePointId = null, middlePointId = null } = {}) {
    const layerId = resolveAutoLineLayerId(aPointId, bPointId, { type, baseCode, sourcePointId });
    const lineId = addLine(aPointId, bPointId, false, layerId, { curveMiddlePointId: middlePointId });
    const line = lines.get(lineId);
    if (line) {
      line.generatedBy = "field-to-finish";
      line.fieldToFinishType = type;
      line.fieldToFinishBaseCode = String(baseCode || "").trim().toUpperCase();
      line.fieldToFinishCurveMiddlePointId = Number.isFinite(Number(middlePointId)) ? Number(middlePointId) : null;
    }
    return lineId;
  }

  function ensureLegacyAutoFieldToFinishLineMetadata() {
    const expectedKeys = new Set();
    const curveCommands = buildFieldToFinishCurveLineCommands();
    const curveSuppressedSequentialKeys = buildCurveSuppressedSequentialLineKeys(curveCommands);
    for (const cmd of buildExpectedJpnLineCommands()) expectedKeys.add(getNormalizedLineKey(cmd.a, cmd.b));
    for (const cmd of buildFieldToFinishSequentialLineCommands()) {
      const key = getNormalizedLineKey(cmd.a, cmd.b);
      if (!key || curveSuppressedSequentialKeys.has(key)) continue;
      expectedKeys.add(key);
    }
    for (const cmd of curveCommands) expectedKeys.add(getNormalizedLineKey(cmd.a, cmd.b));
    for (const ln of lines.values()) {
      if (ln.generatedBy === "field-to-finish") continue;
      if (isMovable(ln.movable)) continue;
      const key = getNormalizedLineKey(ln.a, ln.b);
      if (!key || !expectedKeys.has(key)) continue;
      ln.generatedBy = "field-to-finish";
      ln.fieldToFinishType = "legacy";
    }
  }

  function syncFieldToFinishLinework() {
    ensureLegacyAutoFieldToFinishLineMetadata();
    const curveCommands = buildFieldToFinishCurveLineCommands();
    const curveSuppressedSequentialKeys = buildCurveSuppressedSequentialLineKeys(curveCommands);
    const expected = new Map();
    for (const cmd of buildExpectedJpnLineCommands()) {
      const key = getNormalizedLineKey(cmd.a, cmd.b);
      if (key) expected.set(key, { ...cmd });
    }
    for (const cmd of buildFieldToFinishSequentialLineCommands()) {
      const key = getNormalizedLineKey(cmd.a, cmd.b);
      if (key && curveSuppressedSequentialKeys.has(key)) continue;
      if (!key || expected.has(key)) continue;
      expected.set(key, { ...cmd, type: "sequential" });
    }
    for (const cmd of curveCommands) {
      const key = getNormalizedLineKey(cmd.a, cmd.b);
      if (!key || expected.has(key)) continue;
      expected.set(key, { ...cmd, type: "curve" });
    }

    let removed = 0;
    for (const [lineId, ln] of Array.from(lines.entries())) {
      if (ln.generatedBy !== "field-to-finish") continue;
      const key = getNormalizedLineKey(ln.a, ln.b);
      if (key && expected.has(key)) continue;
      lines.delete(lineId);
      removed++;
    }

    let addedJpn = 0;
    let addedSequential = 0;
    let addedCurve = 0;
    for (const cmd of expected.values()) {
      if (!points.has(cmd.a) || !points.has(cmd.b) || cmd.a === cmd.b) continue;
      const existingLine = findDirectConnectionLine(cmd.a, cmd.b);
      if (existingLine) {
        if (cmd.type === "curve" && existingLine.generatedBy === "field-to-finish") {
          const nextMiddlePointId = Number.isFinite(Number(cmd.middlePointId)) ? Number(cmd.middlePointId) : null;
          const prevMiddlePointId = Number.isFinite(Number(existingLine.fieldToFinishCurveMiddlePointId))
            ? Number(existingLine.fieldToFinishCurveMiddlePointId)
            : null;
          const nextBaseCode = String(cmd.baseCode || "").trim().toUpperCase();
          if (
            existingLine.fieldToFinishType !== "curve"
            || existingLine.fieldToFinishBaseCode !== nextBaseCode
            || prevMiddlePointId !== nextMiddlePointId
          ) {
            existingLine.fieldToFinishType = "curve";
            existingLine.fieldToFinishBaseCode = nextBaseCode;
            existingLine.fieldToFinishCurveMiddlePointId = nextMiddlePointId;
            addedCurve++;
          }
        }
        continue;
      }
      createAutoFieldToFinishLine(cmd.a, cmd.b, {
        type: cmd.type === "jpn" ? "jpn" : (cmd.type === "curve" ? "curve" : "sequential"),
        baseCode: cmd.baseCode,
        sourcePointId: cmd.sourcePointId,
        middlePointId: cmd.middlePointId,
      });
      if (cmd.type === "jpn") addedJpn++;
      else if (cmd.type === "curve") addedCurve++;
      else addedSequential++;
    }

    updateCounts();
    return { addedJpn, addedSequential, addedCurve, removed };
  }

  function buildFieldToFinishSequentialLineCommands() {
    const pointsInOrder = [...points.values()].sort((a, b) => {
      const aNum = Number(a.num);
      const bNum = Number(b.num);
      if (Number.isFinite(aNum) && Number.isFinite(bNum) && aNum !== bNum) return aNum - bNum;
      return a.id - b.id;
    });
    const lineCommands = [];
    const activeSequences = new Map();
    const explicitSequentialBaseCodes = new Set();

    for (const point of pointsInOrder) {
      const { tokensUpper, commands } = parseFieldToFinishCommands(point.code);
      const tokenSet = new Set(tokensUpper);
      const lineworkCodes = fieldToFinishRuleState.lineworkCodes;
      const curveLineworkCodes = extractCurveLineworkCodes(point.code);

      const explicitActions = new Set();
      for (const cmd of commands) {
        if (cmd.type !== "sequential-line") continue;
        const baseCode = cmd.baseCode;
        const action = cmd.action;
        explicitSequentialBaseCodes.add(baseCode);
        explicitActions.add(baseCode);
        if (action === "BEG") {
          activeSequences.set(baseCode, { startPointId: point.id, lastPointId: point.id });
          continue;
        }
        const active = activeSequences.get(baseCode);
        if (!active) continue;
        if (point.id !== active.lastPointId) {
          lineCommands.push({ a: active.lastPointId, b: point.id, baseCode });
          active.lastPointId = point.id;
        }
        if (action === "CLO" && active.startPointId !== active.lastPointId) {
          lineCommands.push({ a: active.lastPointId, b: active.startPointId, baseCode });
        }
        activeSequences.delete(baseCode);
      }

      const pointImplicitSequenceCodes = [...tokenSet].filter((token) => (
        (lineworkCodes.has(token) || explicitSequentialBaseCodes.has(token))
        && !curveLineworkCodes.has(token)
      ));

      const hasGlobalEndDirective = tokenSet.has("END") && !commands.some((cmd) => cmd.type === "sequential-line");
      if (hasGlobalEndDirective) activeSequences.clear();

      // Maintain sequence continuity for normal linework codes even when a point
      // also carries join directives (e.g. "FNL JPN131 ...").
      for (const baseCode of [...activeSequences.keys()]) {
        if (explicitActions.has(baseCode)) continue;
        if (pointSupportsLineworkSequenceToken(tokenSet, baseCode)) continue;
        activeSequences.delete(baseCode);
      }

      for (const lineCode of pointImplicitSequenceCodes) {
        if (explicitActions.has(lineCode)) continue;
        if (!activeSequences.has(lineCode)) {
          activeSequences.set(lineCode, { startPointId: point.id, lastPointId: point.id });
        }
      }

      for (const [baseCode, active] of activeSequences.entries()) {
        if (explicitActions.has(baseCode)) continue;
        if (!pointSupportsLineworkSequenceToken(tokenSet, baseCode)) continue;
        if (point.id === active.lastPointId) continue;
        lineCommands.push({ a: active.lastPointId, b: point.id, baseCode });
        active.lastPointId = point.id;
      }
    }

    return lineCommands;
  }

  function buildFieldToFinishCircleCommands() {
    const circles = [];
    for (const point of points.values()) {
      const { commands } = parseFieldToFinishCommands(point.code);
      for (const cmd of commands) {
        if (cmd.type !== "circle") continue;
        if (!Number.isFinite(cmd.radius) || cmd.radius <= 0) continue;
        circles.push({ centerPointId: point.id, radius: cmd.radius });
      }
    }
    return circles;
  }

  function pointHasCurveMarker(pointCode = "", marker = "PC") {
    const markerUpper = String(marker ?? "").trim().toUpperCase();
    if (!markerUpper) return false;

    const { tokensUpper } = parseFieldToFinishCommands(pointCode);
    if (tokensUpper.includes(markerUpper)) return true;

    const isKnownLineworkToken = (token = "") => (
      fieldToFinishRuleState.lineworkCodes.has(token)
      || fieldToFinishRuleState.companionToLineworkCodes.has(token)
    );

    for (const token of tokensUpper) {
      if (!token || token === markerUpper) continue;
      if (token.startsWith(markerUpper) && isKnownLineworkToken(token.slice(markerUpper.length))) return true;
      if (token.endsWith(markerUpper) && isKnownLineworkToken(token.slice(0, -markerUpper.length))) return true;
    }

    return false;
  }

  function pointHasCurveStartToken(pointCode = "") {
    return pointHasCurveMarker(pointCode, "PC");
  }

  function pointHasCurveEndToken(pointCode = "") {
    return pointHasCurveMarker(pointCode, "PT");
  }

  function extractCurveLineworkCodes(pointCode = "") {
    const { tokensUpper } = parseFieldToFinishCommands(pointCode);
    const curveLineworkCodes = new Set();
    const hasStandaloneCurveMarker = tokensUpper.includes("PC") || tokensUpper.includes("PT");

    if (hasStandaloneCurveMarker) {
      for (const token of tokensUpper) {
        if (fieldToFinishRuleState.lineworkCodes.has(token)) curveLineworkCodes.add(token);
      }
    }

    const collectCurveBaseCode = (token = "", marker = "PC") => {
      if (!token || token === marker) return;
      if (token.startsWith(marker)) {
        const base = token.slice(marker.length);
        if (fieldToFinishRuleState.lineworkCodes.has(base)) curveLineworkCodes.add(base);
      }
      if (token.endsWith(marker)) {
        const base = token.slice(0, -marker.length);
        if (fieldToFinishRuleState.lineworkCodes.has(base)) curveLineworkCodes.add(base);
      }
    };

    for (const token of tokensUpper) {
      collectCurveBaseCode(token, "PC");
      collectCurveBaseCode(token, "PT");
    }

    return curveLineworkCodes;
  }

  function buildFieldToFinishCurveLineCommands() {
    const pointsInOrder = [...points.values()].sort((a, b) => {
      const aNum = Number(a.num);
      const bNum = Number(b.num);
      if (Number.isFinite(aNum) && Number.isFinite(bNum) && aNum !== bNum) return aNum - bNum;
      return a.id - b.id;
    });

    const lineCommands = [];
    let activeCurve = null;
    for (const point of pointsInOrder) {
      if (pointHasCurveStartToken(point.code)) {
        activeCurve = { startPointId: point.id, middlePointId: null };
        continue;
      }
      if (!activeCurve) continue;
      if (!activeCurve.middlePointId && point.id !== activeCurve.startPointId) {
        activeCurve.middlePointId = point.id;
      }
      if (pointHasCurveEndToken(point.code)) {
        if (activeCurve.startPointId && activeCurve.middlePointId && point.id !== activeCurve.startPointId && point.id !== activeCurve.middlePointId) {
          lineCommands.push({
            a: activeCurve.startPointId,
            b: point.id,
            middlePointId: activeCurve.middlePointId,
            baseCode: "CURVE"
          });
        }
        activeCurve = null;
      }
    }
    return lineCommands;
  }

  function buildCurveSuppressedSequentialLineKeys(curveCommands = []) {
    const suppressed = new Set();
    for (const cmd of curveCommands) {
      const startMiddleKey = getNormalizedLineKey(cmd?.a, cmd?.middlePointId);
      if (startMiddleKey) suppressed.add(startMiddleKey);
      const middleEndKey = getNormalizedLineKey(cmd?.middlePointId, cmd?.b);
      if (middleEndKey) suppressed.add(middleEndKey);
    }
    return suppressed;
  }

  function getCurveMiddlePoint(line) {
    if (!line) return null;
    const middlePointId = Number(line.fieldToFinishCurveMiddlePointId);
    if (!Number.isFinite(middlePointId)) return null;
    return points.get(middlePointId) || null;
  }

  function getCircleFromThreePoints(start, middle, end) {
    if (!start || !middle || !end) return null;
    const x1 = Number(start.x);
    const y1 = Number(start.y);
    const x2 = Number(middle.x);
    const y2 = Number(middle.y);
    const x3 = Number(end.x);
    const y3 = Number(end.y);
    if (![x1, y1, x2, y2, x3, y3].every(Number.isFinite)) return null;

    const determinant = (x1 * (y2 - y3)) + (x2 * (y3 - y1)) + (x3 * (y1 - y2));
    if (Math.abs(determinant) < 1e-9) return null;

    const x1SqPlusY1Sq = x1 * x1 + y1 * y1;
    const x2SqPlusY2Sq = x2 * x2 + y2 * y2;
    const x3SqPlusY3Sq = x3 * x3 + y3 * y3;

    const centerX = (
      x1SqPlusY1Sq * (y2 - y3)
      + x2SqPlusY2Sq * (y3 - y1)
      + x3SqPlusY3Sq * (y1 - y2)
    ) / (2 * determinant);
    const centerY = (
      x1SqPlusY1Sq * (x3 - x2)
      + x2SqPlusY2Sq * (x1 - x3)
      + x3SqPlusY3Sq * (x2 - x1)
    ) / (2 * determinant);
    const radius = Math.hypot(x1 - centerX, y1 - centerY);
    if (!Number.isFinite(radius) || radius <= 0) return null;

    return { centerX, centerY, radius };
  }

  function normalizeAngleRadians(angle) {
    let normalized = Number(angle);
    if (!Number.isFinite(normalized)) return 0;
    while (normalized < 0) normalized += Math.PI * 2;
    while (normalized >= Math.PI * 2) normalized -= Math.PI * 2;
    return normalized;
  }

  function describeThreePointCurve(line) {
    if (!line) return null;
    const start = points.get(line.a);
    const middle = getCurveMiddlePoint(line);
    const end = points.get(line.b);
    if (!start || !middle || !end) return null;

    const circle = getCircleFromThreePoints(start, middle, end);
    if (!circle) return null;

    const startAngle = normalizeAngleRadians(Math.atan2(start.y - circle.centerY, start.x - circle.centerX));
    const middleAngle = normalizeAngleRadians(Math.atan2(middle.y - circle.centerY, middle.x - circle.centerX));
    const endAngle = normalizeAngleRadians(Math.atan2(end.y - circle.centerY, end.x - circle.centerX));
    const ccwSweep = (endAngle - startAngle + Math.PI * 2) % (Math.PI * 2);
    const ccwToMiddle = (middleAngle - startAngle + Math.PI * 2) % (Math.PI * 2);
    const clockwise = ccwToMiddle > ccwSweep;
    const sweepRad = clockwise
      ? (startAngle - endAngle + Math.PI * 2) % (Math.PI * 2)
      : ccwSweep;
    if (!(sweepRad > 0)) return null;

    const chord = lineMeasurement(start, end);
    if (!chord) return null;

    return {
      radius: circle.radius,
      arcLength: circle.radius * sweepRad,
      chordBearing: chord.bearing,
      chordDistance: chord.distance,
      deltaAngleDeg: sweepRad * (180 / Math.PI),
    };
  }

  function traceLinePath(context, line, startScreen, endScreen, projectPoint = worldToScreen) {
    context.beginPath();
    context.moveTo(startScreen.x, startScreen.y);
    const middlePoint = getCurveMiddlePoint(line);
    if (!middlePoint) {
      context.lineTo(endScreen.x, endScreen.y);
      return;
    }
    const middleWorld = { x: middlePoint.x, y: middlePoint.y };
    const startWorldPoint = points.get(line.a);
    const endWorldPoint = points.get(line.b);
    if (!startWorldPoint || !endWorldPoint) {
      context.lineTo(endScreen.x, endScreen.y);
      return;
    }
    const startWorld = { x: startWorldPoint.x, y: startWorldPoint.y };
    const endWorld = { x: endWorldPoint.x, y: endWorldPoint.y };
    const circle = getCircleFromThreePoints(startWorld, middleWorld, endWorld);
    if (!circle) {
      context.lineTo(endScreen.x, endScreen.y);
      return;
    }

    const centerScreen = projectPoint(circle.centerX, circle.centerY);
    const radiusScreen = Math.hypot(startScreen.x - centerScreen.x, startScreen.y - centerScreen.y);
    if (!Number.isFinite(radiusScreen) || radiusScreen <= 0) {
      context.lineTo(endScreen.x, endScreen.y);
      return;
    }

    const middleScreen = projectPoint(middleWorld.x, middleWorld.y);
    const startAngle = normalizeAngleRadians(Math.atan2(startScreen.y - centerScreen.y, startScreen.x - centerScreen.x));
    const middleAngle = normalizeAngleRadians(Math.atan2(middleScreen.y - centerScreen.y, middleScreen.x - centerScreen.x));
    const endAngle = normalizeAngleRadians(Math.atan2(endScreen.y - centerScreen.y, endScreen.x - centerScreen.x));

    const ccwSweep = (endAngle - startAngle + Math.PI * 2) % (Math.PI * 2);
    const ccwToMiddle = (middleAngle - startAngle + Math.PI * 2) % (Math.PI * 2);
    const clockwise = ccwToMiddle > ccwSweep;
    context.arc(centerScreen.x, centerScreen.y, radiusScreen, startAngle, endAngle, clockwise);
  }

  function connectFieldToFinishSequentialLines() {
    const { addedSequential } = syncFieldToFinishLinework();
    return addedSequential;
  }

  function connectFieldToFinishCurveLines() {
    const { addedCurve } = syncFieldToFinishLinework();
    return addedCurve;
  }

  function connectJpnReferencedPoints() {
    const { addedJpn } = syncFieldToFinishLinework();
    return addedJpn;
  }

  function connectJpnReferencedPointsForSource(_sourcePointId) {
    const { addedJpn } = syncFieldToFinishLinework();
    return addedJpn;
  }

  function connectFieldToFinishLinework() {
    const { addedJpn, addedSequential, addedCurve } = syncFieldToFinishLinework();
    return { jpnLinesAdded: addedJpn, sequentialLinesAdded: addedSequential, curveLinesAdded: addedCurve };
  }

  function moveSelectionByDelta(dx, dy) {
    const ids = getRotatablePointIdsFromSelection();
    if (!ids.length) return 0;
    for (const pid of ids) {
      const p = points.get(pid);
      if (!p || isLayerLocked(p.layerId)) continue;
      p.x += dx;
      p.y += dy;
    }
    return ids.length;
  }

  function addPoint({num, x, y, z=0, code="", notes="", movable=false, layerId = selectedLayerId}) {
    const id = nextId++;
    points.set(id, {
      id,
      num: String(num),
      x: Number(x),
      y: Number(y),
      z: Number(z),
      code: normalizePointCode(String(code ?? "")),
      notes: String(notes ?? ""),
      movable: !!movable,
      layerId: layers.has(layerId) ? layerId : (selectedLayerId || DEFAULT_LAYER_ID)
    });
    schedulePointsTableRender();
    updateCounts();
    return id;
  }

  function splitCodeTokens(rawCode = "") {
    const normalized = String(rawCode ?? "").trim();
    return normalized ? normalized.split(/\s+/).filter(Boolean) : [];
  }

  function joinCodeTokens(tokens = []) {
    return tokens.filter(Boolean).join(" ").trim();
  }

  function normalizePointCode(rawCode = "") {
    const tokens = splitCodeTokens(rawCode);
    if (!tokens.length) return "";

    const directives = new Set(["BEG", "END", "CLO"]);
    const directivePriority = new Map([["END", 0], ["BEG", 1], ["CLO", 2]]);
    const compactJpnRegex = /^JPN([A-Z0-9]+)$/i;
    const parsedJpnTargets = [];
    const seenJpnTargets = new Set();
    const sequentialByBaseCode = new Map();
    const passthroughTokens = [];

    for (let i = 0; i < tokens.length; i++) {
      const tokenRaw = tokens[i];
      const tokenUpper = tokenRaw.toUpperCase();

      const compactJpnMatch = tokenRaw.match(compactJpnRegex);
      if (compactJpnMatch) {
        const target = String(compactJpnMatch[1] ?? "").trim().toUpperCase();
        if (target && !seenJpnTargets.has(target)) {
          seenJpnTargets.add(target);
          parsedJpnTargets.push(target);
        }
        continue;
      }

      if (tokenUpper === "JPN") {
        const targetRaw = String(tokens[i + 1] ?? "").trim();
        const target = targetRaw.toUpperCase();
        if (/^[A-Z0-9]+$/.test(target) && !seenJpnTargets.has(target)) {
          seenJpnTargets.add(target);
          parsedJpnTargets.push(target);
        }
        if (targetRaw) i += 1;
        continue;
      }

      const nextUpper = String(tokens[i + 1] ?? "").toUpperCase();
      if (nextUpper && directives.has(nextUpper) && !directives.has(tokenUpper)) {
        const existing = sequentialByBaseCode.get(tokenUpper);
        if (!existing || (directivePriority.get(nextUpper) ?? 99) < (directivePriority.get(existing.action) ?? 99)) {
          sequentialByBaseCode.set(tokenUpper, { baseCode: tokenUpper, action: nextUpper });
        }
        i += 1;
        continue;
      }

      if (directives.has(tokenUpper)) continue;

      passthroughTokens.push(tokenRaw);
    }

    const seenOutput = new Set();
    const output = [];
    const pushUnique = (token) => {
      const normalized = String(token ?? "").trim();
      if (!normalized) return;
      const key = normalized.toUpperCase();
      if (seenOutput.has(key)) return;
      seenOutput.add(key);
      output.push(normalized);
    };

    const firstToken = String(tokens[0] ?? "").trim();
    const lineCode = firstToken.toUpperCase();
    if (firstToken) pushUnique(firstToken);

    if (lineCode && sequentialByBaseCode.has(lineCode)) {
      const cmd = sequentialByBaseCode.get(lineCode);
      pushUnique(cmd.baseCode);
      pushUnique(cmd.action);
      sequentialByBaseCode.delete(lineCode);
    }

    for (const cmd of sequentialByBaseCode.values()) {
      pushUnique(cmd.baseCode);
      pushUnique(cmd.action);
    }

    for (const target of parsedJpnTargets) pushUnique(`JPN${target}`);
    for (const token of passthroughTokens) pushUnique(token);

    return joinCodeTokens(output);
  }

  function setPointCode(point, rawCode = "") {
    if (!point) return false;
    const nextCode = normalizePointCode(rawCode);
    const changed = nextCode !== String(point.code ?? "");
    point.code = nextCode;
    return changed;
  }

  function appendTokensToPointCode(pointId, tokens = []) {
    const point = points.get(pointId);
    if (!point || !tokens.length) return false;
    const currentTokens = splitCodeTokens(point.code);
    return setPointCode(point, joinCodeTokens([...currentTokens, ...tokens]));
  }

  function removeJpnDirectiveFromPointCode(pointId, targetPointNumber) {
    const point = points.get(pointId);
    const target = String(targetPointNumber ?? "").trim().toUpperCase();
    if (!point || !target) return false;
    const tokens = splitCodeTokens(point.code);
    if (!tokens.length) return false;
    const nextTokens = [];
    let changed = false;
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      const tokenUpper = token.toUpperCase();
      if (tokenUpper === "JPN" && String(tokens[i + 1] ?? "").trim().toUpperCase() === target) {
        changed = true;
        i += 1;
        continue;
      }
      if (tokenUpper === `JPN${target}`) {
        changed = true;
        continue;
      }
      nextTokens.push(token);
    }
    if (!changed) return false;
    point.code = joinCodeTokens(nextTokens);
    return true;
  }

  function connectsBySequentialLinework(aPointId, bPointId) {
    const key = getNormalizedLineKey(aPointId, bPointId);
    if (!key) return false;
    const sequentialCommands = buildFieldToFinishSequentialLineCommands();
    for (const cmd of sequentialCommands) {
      if (getNormalizedLineKey(cmd.a, cmd.b) === key) return true;
    }
    const curveCommands = buildFieldToFinishCurveLineCommands();
    for (const cmd of curveCommands) {
      if (getNormalizedLineKey(cmd.a, cmd.b) === key) return true;
    }
    return false;
  }

  function ensureSequentialBreakForPair(aPointId, bPointId) {
    const sequentialCommands = buildFieldToFinishSequentialLineCommands();
    let addedTokens = 0;
    const hasSequentialDirective = (pointId, baseCode, action) => {
      const point = points.get(pointId);
      if (!point) return false;
      const { commands } = parseFieldToFinishCommands(point.code);
      return commands.some((cmd) => (
        cmd.type === "sequential-line"
        && cmd.baseCode === baseCode
        && cmd.action === action
      ));
    };
    for (const cmd of sequentialCommands) {
      if (!cmd?.baseCode) continue;
      if (cmd.a === aPointId && cmd.b === bPointId) {
        if (!hasSequentialDirective(aPointId, cmd.baseCode, "END") && appendTokensToPointCode(aPointId, [cmd.baseCode, "END"])) addedTokens += 2;
        if (!hasSequentialDirective(bPointId, cmd.baseCode, "BEG") && appendTokensToPointCode(bPointId, [cmd.baseCode, "BEG"])) addedTokens += 2;
      } else if (cmd.a === bPointId && cmd.b === aPointId) {
        if (!hasSequentialDirective(bPointId, cmd.baseCode, "END") && appendTokensToPointCode(bPointId, [cmd.baseCode, "END"])) addedTokens += 2;
        if (!hasSequentialDirective(aPointId, cmd.baseCode, "BEG") && appendTokensToPointCode(aPointId, [cmd.baseCode, "BEG"])) addedTokens += 2;
      }
    }
    return addedTokens;
  }

  function applyManualConnectionCode(pointAId, pointBId) {
    const source = points.get(pointAId);
    const target = points.get(pointBId);
    if (!source || !target) return "none";
    if (connectsBySequentialLinework(pointAId, pointBId)) return "sequential";
    const jpnTargets = extractJpnTargetPointNumbers(source.code).map((targetNum) => String(targetNum).toUpperCase());
    const targetNum = String(target.num ?? "").trim();
    if (!targetNum) return "none";
    if (jpnTargets.includes(targetNum.toUpperCase())) return "jpn";
    appendTokensToPointCode(source.id, [`JPN${targetNum}`]);
    return "jpn";
  }

  function addManualLine(aPointId, bPointId, movable=false, layerId = selectedLayerId) {
    const id = addLine(aPointId, bPointId, movable, layerId);
    const line = lines.get(id);
    if (!line) return id;
    const codeType = applyManualConnectionCode(aPointId, bPointId);
    if (codeType === "jpn") line.fieldToFinishType = "jpn";
    if (codeType === "sequential") line.fieldToFinishType = "sequential";
    schedulePointsTableRender();
    return id;
  }

  function addLine(aPointId, bPointId, movable=false, layerId = selectedLayerId, options = {}) {
    const id = nextId++;
    const curveMiddlePointId = Number(options?.curveMiddlePointId);
    lines.set(id, {
      id,
      a: aPointId,
      b: bPointId,
      movable: !!movable,
      layerId: layers.has(layerId) ? layerId : (selectedLayerId || DEFAULT_LAYER_ID),
      fieldToFinishCurveMiddlePointId: Number.isFinite(curveMiddlePointId) ? curveMiddlePointId : null,
    });
    updateCounts();
    return id;
  }

  function deletePoint(pid) {
    if (!points.has(pid)) return false;
    if (isPointLockedByLayer(pid)) return false;
    for (const [lid, ln] of Array.from(lines.entries())) {
      if (ln.a === pid || ln.b === pid) lines.delete(lid);
    }
    points.delete(pid);
    selectedPointIds = selectedPointIds.filter(id => id !== pid);
    selectedPointId = selectedPointIds.length ? selectedPointIds[selectedPointIds.length-1] : null;
    selectedLines = selectedLines.filter(s => lines.has(s.lineId));
    lastSelectedLineId = lines.has(lastSelectedLineId) ? lastSelectedLineId : null;
    updatePointEditorFromSelection();
    schedulePointsTableRender();
    updateCounts();
    return true;
  }

  function deleteLine(lid) {
    if (isLineLockedByLayer(lid)) return false;
    const ln = lines.get(lid);
    if (!ln) return false;

    const aPoint = points.get(ln.a);
    const bPoint = points.get(ln.b);
    let codeChanged = false;
    if (aPoint && bPoint) {
      const removedForwardJpn = removeJpnDirectiveFromPointCode(aPoint.id, bPoint.num);
      const removedReverseJpn = removeJpnDirectiveFromPointCode(bPoint.id, aPoint.num);
      codeChanged = removedForwardJpn || removedReverseJpn;
      if (!codeChanged) {
        const addedBreakTokens = ensureSequentialBreakForPair(aPoint.id, bPoint.id);
        codeChanged = addedBreakTokens > 0;
      }
    }

    lines.delete(lid);
    if (codeChanged) syncFieldToFinishLinework();
    selectedLines = selectedLines.filter(s => s.lineId !== lid);
    if (lastSelectedLineId === lid) lastSelectedLineId = null;
    if (codeChanged) schedulePointsTableRender();
    updateCounts();
    return true;
  }

  function getRotatablePointIdsFromSelection() {
    const ids = new Set();
    for (const pid of selectedPointIds) {
      if (points.has(pid)) ids.add(pid);
    }
    for (const sel of selectedLines) {
      const ln = lines.get(sel.lineId);
      if (!ln) continue;
      if (points.has(ln.a)) ids.add(ln.a);
      if (points.has(ln.b)) ids.add(ln.b);
    }
    return [...ids];
  }

  const rotateWorkflowSteps = [
    "Select items to rotate",
    "Select a point to rotate around",
    "Select a basis of rotation",
    "Select a target rotation"
  ];

  function getToolWorkflowToastPayload(activeTool = tool) {
    if (activeTool === "select") {
      return null;
    }

    if (activeTool === "addPoint") {
      return {
        title: "Add Point Workflow",
        message: "Click anywhere on the canvas to place a point.",
        steps: ["Click canvas to place a point"],
        currentStepIndex: 0
      };
    }

    if (activeTool === "line2pt") {
      const hasStart = construction.startPointId !== null;
      return {
        title: "Line: 2 Points Workflow",
        message: hasStart
          ? "Now click an endpoint (point or open space) to finish the line."
          : "Click a start point, or click empty space to create one.",
        steps: [
          "Pick line start point",
          "Pick line end point"
        ],
        currentStepIndex: hasStart ? 1 : 0
      };
    }

    if (activeTool === "lineDB") {
      const hasStart = construction.startPointId !== null;
      return {
        title: "Line: Dist/Bearing Workflow",
        message: hasStart
          ? "Enter distance + bearing, then click Create Point + Line."
          : "Click a start point on the canvas first.",
        steps: [
          "Select start point",
          "Enter distance + bearing",
          "Click Create Point + Line"
        ],
        currentStepIndex: hasStart ? 2 : 0
      };
    }

    if (activeTool === "pointOnLine") {
      const hasLine = lastSelectedLineId != null && lines.has(lastSelectedLineId);
      return {
        title: "Point on Line Workflow",
        message: hasLine
          ? "Enter station/offset values, then click Create Point."
          : "Click near a line to select it first.",
        steps: [
          "Select line",
          "Enter station + offset",
          "Click Create Point"
        ],
        currentStepIndex: hasLine ? 2 : 0
      };
    }

    if (activeTool === "pan") {
      return {
        title: "Pan Workflow",
        message: "Press and drag on the canvas to move your view.",
        steps: ["Drag the canvas to pan"],
        currentStepIndex: 0
      };
    }

    return null;
  }

  function syncToolWorkflowToast() {
    if (lineIntersectionCommandSession.active) return;
    if (rotateSelectionSession.active) return;
    const payload = getToolWorkflowToastPayload(tool);
    if (!payload) {
      hideWorkflowToast();
      return;
    }
    showWorkflowToast(payload);
  }

  function syncRotateWorkflowToast() {
    if (!rotateSelectionSession.active) {
      syncToolWorkflowToast();
      return;
    }
    const stepIndex = rotateSelectionSession.awaitingSelection ? 0 : clamp(rotateSelectionSession.step + 1, 1, rotateWorkflowSteps.length - 1);
    showWorkflowToast({
      title: "Rotate Selection Workflow",
      message: rotateWorkflowSteps[stepIndex],
      steps: rotateWorkflowSteps,
      currentStepIndex: stepIndex
    });
  }

  function cancelRotateSelectionSession(silent=true) {
    rotateSelectionSession.active = false;
    rotateSelectionSession.step = 0;
    rotateSelectionSession.basePoint = null;
    rotateSelectionSession.fromPoint = null;
    rotateSelectionSession.awaitingSelection = false;
    syncToolWorkflowToast();
    if (!silent) setStatus("Rotate selection canceled.", "warn");
  }

  function startRotateSelectionSession() {
    rotateSelectionSession.active = true;
    rotateSelectionSession.step = 0;
    rotateSelectionSession.basePoint = null;
    rotateSelectionSession.fromPoint = null;
    const rotateIds = getRotatablePointIdsFromSelection();
    rotateSelectionSession.awaitingSelection = !rotateIds.length;

    if (rotateSelectionSession.awaitingSelection) {
      setTool("select");
      setStatus("Select items to rotate with a window or click selection, then continue the rotate picks.", "warn");
    } else {
      setStatus("Rotate selection: click base point.", "ok");
    }
    syncRotateWorkflowToast();
  }

  function resolveRotatePickWorldPoint(screenX, screenY) {
    const pid = pickPoint(screenX, screenY, 12);
    if (pid && points.has(pid)) {
      const p = points.get(pid);
      return { x: p.x, y: p.y, label: `point ${p.num}` };
    }
    const w = screenToWorld(screenX, screenY);
    return { x: w.x, y: w.y, label: `(${fmt(w.x)}, ${fmt(w.y)})` };
  }

  function rotateSelectedFromReference(basePoint, fromPoint, toPoint) {
    const rotateIds = getRotatablePointIdsFromSelection();
    if (!rotateIds.length) {
      setStatus("Select at least one point or line to rotate.", "warn");
      cancelRotateSelectionSession(true);
      return;
    }

    const baseAngle = Math.atan2(fromPoint.y - basePoint.y, fromPoint.x - basePoint.x);
    const targetAngle = Math.atan2(toPoint.y - basePoint.y, toPoint.x - basePoint.x);
    const delta = targetAngle - baseAngle;
    const cos = Math.cos(delta);
    const sin = Math.sin(delta);

    history.push("rotate selection (reference)");
    for (const pid of rotateIds) {
      const p = points.get(pid);
      if (!p) continue;
      const dx = p.x - basePoint.x;
      const dy = p.y - basePoint.y;
      p.x = basePoint.x + (dx * cos - dy * sin);
      p.y = basePoint.y + (dx * sin + dy * cos);
    }

    updatePointEditorFromSelection();
    schedulePointsTableRender();
    const deltaDeg = (delta * 180 / Math.PI);
    setStatus(`Rotated ${rotateIds.length} point(s) by ${fmt(deltaDeg)}° about ${fmt(basePoint.x)}, ${fmt(basePoint.y)}.`, "ok");
  }

  function handleRotateSelectionCanvasPick(screenX, screenY) {
    if (rotateSelectionSession.awaitingSelection) {
      const rotateIds = getRotatablePointIdsFromSelection();
      if (!rotateIds.length) {
        setStatus("Select items to rotate before picking a rotate point.", "warn");
        syncRotateWorkflowToast();
        return;
      }
      rotateSelectionSession.awaitingSelection = false;
      rotateSelectionSession.step = 0;
      setStatus("Selection captured. Click base point.", "ok");
      syncRotateWorkflowToast();
    }

    const picked = resolveRotatePickWorldPoint(screenX, screenY);
    if (rotateSelectionSession.step === 0) {
      rotateSelectionSession.basePoint = picked;
      rotateSelectionSession.step = 1;
      setStatus(`Base point set at ${picked.label}. Click reference-angle point.`, "ok");
      syncRotateWorkflowToast();
      return;
    }

    if (rotateSelectionSession.step === 1) {
      const base = rotateSelectionSession.basePoint;
      if (dist(base.x, base.y, picked.x, picked.y) < 1e-9) {
        setStatus("Reference-angle point must differ from base point.", "warn");
        return;
      }
      rotateSelectionSession.fromPoint = picked;
      rotateSelectionSession.step = 2;
      setStatus(`Reference angle set from base to ${picked.label}. Click target-angle point.`, "ok");
      syncRotateWorkflowToast();
      return;
    }

    const base = rotateSelectionSession.basePoint;
    if (dist(base.x, base.y, picked.x, picked.y) < 1e-9) {
      setStatus("Target-angle point must differ from base point.", "warn");
      return;
    }

    rotateSelectedFromReference(base, rotateSelectionSession.fromPoint, picked);
    cancelRotateSelectionSession(true);
  }

  // -------------------------
  // Picking
  // -------------------------
  function pickPoint(screenX, screenY, thresholdPx=10) {
    let best = null;
    let bestD2 = thresholdPx*thresholdPx;
    for (const p of points.values()) {
      if (!isLayerVisible(p.layerId)) continue;
      const s = worldToScreen(p.x, p.y);
      const d2 = dist2(screenX, screenY, s.x, s.y);
      if (d2 <= bestD2) {
        bestD2 = d2;
        best = p.id;
      }
    }
    return best;
  }

  function buildPointClusters() {
    if (!pointDisplayVisibility.points || !pointDisplayVisibility.clustering) return [];
    const visiblePoints = [];
    for (const p of points.values()) {
      if (!isLayerVisible(p.layerId)) continue;
      const s = worldToScreen(p.x, p.y);
      visiblePoints.push({ id: p.id, point: p, sx: s.x, sy: s.y });
    }

    const clusters = [];
    const visited = new Set();
    for (let i = 0; i < visiblePoints.length; i++) {
      if (visited.has(i)) continue;
      const queue = [i];
      const members = [];
      visited.add(i);
      while (queue.length) {
        const current = queue.shift();
        const candidate = visiblePoints[current];
        members.push(candidate);
        for (let j = 0; j < visiblePoints.length; j++) {
          if (visited.has(j)) continue;
          const peer = visiblePoints[j];
          if (dist(candidate.sx, candidate.sy, peer.sx, peer.sy) <= POINT_CLUSTER_DISTANCE_PX) {
            visited.add(j);
            queue.push(j);
          }
        }
      }
      if (members.length < 2) continue;
      members.sort((a, b) => String(a.point.num).localeCompare(String(b.point.num)) || a.id - b.id);

      let centerX = 0;
      let centerY = 0;
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      for (const member of members) {
        centerX += member.sx;
        centerY += member.sy;
        minX = Math.min(minX, member.point.x);
        minY = Math.min(minY, member.point.y);
        maxX = Math.max(maxX, member.point.x);
        maxY = Math.max(maxY, member.point.y);
      }
      centerX /= members.length;
      centerY /= members.length;
      const countText = String(members.length);
      const markerRadius = 10 + Math.max(0, countText.length - 2) * 3;
      const minScreenX = Math.min(...members.map((member) => member.sx));
      const maxScreenX = Math.max(...members.map((member) => member.sx));
      const minScreenY = Math.min(...members.map((member) => member.sy));
      const maxScreenY = Math.max(...members.map((member) => member.sy));
      const boundingWidth = maxScreenX - minScreenX;
      const boundingHeight = maxScreenY - minScreenY;
      const boundingArea = boundingWidth * boundingHeight;
      const widthToHeightRatio = boundingHeight > 0 ? boundingWidth / boundingHeight : 0;
      const hullPoints = buildConvexHull(members.map((member) => ({ x: member.sx, y: member.sy })));
      const hullArea = polygonArea2d(hullPoints);
      const hullAreaRatio = boundingArea > 0 ? hullArea / boundingArea : 0;
      const shouldRenderAsPolygon = hullPoints.length >= 3
        && widthToHeightRatio >= POINT_CLUSTER_POLYGON_MIN_WIDTH_TO_HEIGHT_RATIO
        && Math.abs(hullAreaRatio - POINT_CLUSTER_POLYGON_AREA_RATIO_TARGET) <= POINT_CLUSTER_POLYGON_AREA_RATIO_TOLERANCE;

      clusters.push({
        ids: members.map((m) => m.id),
        members,
        centerX,
        centerY,
        minX,
        minY,
        maxX,
        maxY,
        markerRadius,
        countText,
        strokeAlpha: POINT_CLUSTER_MIN_STROKE_ALPHA,
        hullPoints,
        renderAsPolygon: shouldRenderAsPolygon
      });
    }
    if (clusters.length) {
      let minCount = Infinity;
      let maxCount = -Infinity;
      for (const cluster of clusters) {
        const count = cluster.members.length;
        minCount = Math.min(minCount, count);
        maxCount = Math.max(maxCount, count);
      }
      const span = Math.max(1, maxCount - minCount);
      for (const cluster of clusters) {
        const normalized = (cluster.members.length - minCount) / span;
        cluster.strokeAlpha = POINT_CLUSTER_MIN_STROKE_ALPHA + normalized * (POINT_CLUSTER_MAX_STROKE_ALPHA - POINT_CLUSTER_MIN_STROKE_ALPHA);
      }
    }
    return clusters;
  }

  function getPointClusterAtScreen(screenX, screenY) {
    for (const cluster of cachedPointClusters) {
      if (cluster.renderAsPolygon && cluster.hullPoints?.length >= 3) {
        if (isPointInPolygon({ x: screenX, y: screenY }, cluster.hullPoints, POINT_CLUSTER_PICK_PADDING_PX)) {
          return cluster;
        }
        continue;
      }
      const limit = cluster.markerRadius + POINT_CLUSTER_PICK_PADDING_PX;
      if (dist(screenX, screenY, cluster.centerX, cluster.centerY) <= limit) {
        return cluster;
      }
    }
    return null;
  }

  function polygonArea2d(pointsList) {
    if (!Array.isArray(pointsList) || pointsList.length < 3) return 0;
    let areaTwice = 0;
    for (let i = 0; i < pointsList.length; i++) {
      const current = pointsList[i];
      const next = pointsList[(i + 1) % pointsList.length];
      areaTwice += current.x * next.y - next.x * current.y;
    }
    return Math.abs(areaTwice) * 0.5;
  }

  function convexHullCross(o, a, b) {
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
  }

  function buildConvexHull(pointsList) {
    if (!Array.isArray(pointsList) || pointsList.length < 3) return [];
    const sorted = pointsList
      .map((point) => ({ x: point.x, y: point.y }))
      .sort((a, b) => a.x - b.x || a.y - b.y);
    const lower = [];
    for (const point of sorted) {
      while (lower.length >= 2 && convexHullCross(lower[lower.length - 2], lower[lower.length - 1], point) <= 0) {
        lower.pop();
      }
      lower.push(point);
    }
    const upper = [];
    for (let i = sorted.length - 1; i >= 0; i--) {
      const point = sorted[i];
      while (upper.length >= 2 && convexHullCross(upper[upper.length - 2], upper[upper.length - 1], point) <= 0) {
        upper.pop();
      }
      upper.push(point);
    }
    lower.pop();
    upper.pop();
    return lower.concat(upper);
  }

  function pointToSegmentDistance(point, segmentStart, segmentEnd) {
    const vx = segmentEnd.x - segmentStart.x;
    const vy = segmentEnd.y - segmentStart.y;
    const wx = point.x - segmentStart.x;
    const wy = point.y - segmentStart.y;
    const c1 = vx * wx + vy * wy;
    if (c1 <= 0) return Math.hypot(point.x - segmentStart.x, point.y - segmentStart.y);
    const c2 = vx * vx + vy * vy;
    if (c2 <= c1) return Math.hypot(point.x - segmentEnd.x, point.y - segmentEnd.y);
    const t = c1 / c2;
    const px = segmentStart.x + t * vx;
    const py = segmentStart.y + t * vy;
    return Math.hypot(point.x - px, point.y - py);
  }

  function isPointInPolygon(point, polygonPoints, paddingPx = 0) {
    if (!Array.isArray(polygonPoints) || polygonPoints.length < 3) return false;
    if (paddingPx > 0) {
      for (let i = 0; i < polygonPoints.length; i++) {
        const start = polygonPoints[i];
        const end = polygonPoints[(i + 1) % polygonPoints.length];
        if (pointToSegmentDistance(point, start, end) <= paddingPx) return true;
      }
    }
    let inside = false;
    for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {
      const xi = polygonPoints[i].x;
      const yi = polygonPoints[i].y;
      const xj = polygonPoints[j].x;
      const yj = polygonPoints[j].y;
      const intersects = ((yi > point.y) !== (yj > point.y))
        && (point.x < ((xj - xi) * (point.y - yi)) / ((yj - yi) || 1e-9) + xi);
      if (intersects) inside = !inside;
    }
    return inside;
  }

  function escapeHtml(value) {
    return String(value ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function getClusterMemberClosestToScreen(cluster, screenX, screenY) {
    if (!cluster || !cluster.members?.length) return null;
    let closest = cluster.members[0];
    let closestD2 = dist2(screenX, screenY, closest.sx, closest.sy);
    for (let i = 1; i < cluster.members.length; i++) {
      const member = cluster.members[i];
      const d2 = dist2(screenX, screenY, member.sx, member.sy);
      if (d2 < closestD2) {
        closest = member;
        closestD2 = d2;
      }
    }
    return closest;
  }


  function isLineDrawingToolActive() {
    return tool === "line2pt" || tool === "lineDB";
  }

  function clearClusterTooltipHideTimer() {
    if (clusterTooltipHideTimer == null) return;
    window.clearTimeout(clusterTooltipHideTimer);
    clusterTooltipHideTimer = null;
  }

  function scheduleClusterTooltipHide() {
    clearClusterTooltipHideTimer();
    clusterTooltipHideTimer = window.setTimeout(() => {
      clusterTooltipHideTimer = null;
      if (clusterTooltipHovering) return;
      hideClusterTooltip();
    }, POINT_CLUSTER_TOOLTIP_HIDE_DELAY_MS);
  }

  function renderClusterTooltipMembers(cluster, expandedLayerId = null) {
    const showLayerGroups = cluster.members.length > POINT_CLUSTER_TOOLTIP_GROUP_BY_LAYER_LIMIT && !expandedLayerId;
    if (showLayerGroups) {
      const countsByLayer = new Map();
      for (const entry of cluster.members) {
        const point = entry.point;
        const layer = getLayerById(point.layerId);
        const layerId = String(point.layerId || "");
        const layerName = String(layer?.name || "Unassigned").trim() || "Unassigned";
        const layerColor = String(layer?.color || "#ffd54a").trim() || "#ffd54a";
        const existing = countsByLayer.get(layerId);
        if (existing) {
          existing.count += 1;
        } else {
          countsByLayer.set(layerId, { count: 1, name: layerName, color: layerColor });
        }
      }
      return Array.from(countsByLayer.entries())
        .sort((a, b) => b[1].count - a[1].count || a[1].name.localeCompare(b[1].name))
        .map(([layerId, meta]) => `<li><button type="button" class="clusterTooltipAction" data-cluster-action="expand-layer" data-layer-id="${escapeHtml(layerId)}"><b class="clusterTooltipLayerName" style="color:${escapeHtml(meta.color)}">${escapeHtml(meta.name)}</b>: ${meta.count} point${meta.count === 1 ? "" : "s"}</button></li>`)
        .join("");
    }

    const members = expandedLayerId
      ? cluster.members.filter((entry) => String(entry.point?.layerId || "") === String(expandedLayerId))
      : cluster.members;
    return members.map((entry) => {
      const point = entry.point;
      const layer = getLayerById(point.layerId);
      const layerColor = String(layer?.color || "#ffd54a").trim() || "#ffd54a";
      const code = point.code ? ` — ${escapeHtml(getRenderedPointCode(point.code) || point.code)}` : "";
      const pointSymbolUrl = getPointSymbolPreviewUrl(point.code);
      const pointSymbolHtml = pointSymbolUrl ? `<img class="pointSymbolBadge" src="${escapeHtml(pointSymbolUrl)}" alt="Point symbol for ${escapeHtml(String(point.num || ""))}" />` : "";
      const activeClass = point.id === hoveredClusterPointId ? " class=\"active\"" : "";
      return `<li${activeClass}><button type="button" class="clusterTooltipAction" data-cluster-action="select-point" data-point-id="${escapeHtml(point.id)}"><span class="clusterTooltipPointRow">${pointSymbolHtml}<b class="clusterTooltipPointName" style="color:${escapeHtml(layerColor)}">${escapeHtml(point.num)}</b>${code}</span></button></li>`;
    }).join("");
  }

  function showClusterTooltip(cluster, screenX = mouse.x, screenY = mouse.y, options = {}) {
    if (!clusterTooltip || !cluster) return;
    clearClusterTooltipHideTimer();
    const expandedLayerId = Object.prototype.hasOwnProperty.call(options, "expandedLayerId") ? options.expandedLayerId : activeClusterTooltip.expandedLayerId;
    const hoveredMember = getClusterMemberClosestToScreen(cluster, screenX, screenY);
    hoveredClusterPointId = hoveredMember?.id ?? null;
    activeClusterTooltip = { cluster, expandedLayerId };

    const membersHtml = renderClusterTooltipMembers(cluster, expandedLayerId);
    const backButtonHtml = expandedLayerId
      ? `<div><button type="button" class="clusterTooltipAction" data-cluster-action="show-layer-groups">← Back to layers</button></div>`
      : "";
    clusterTooltip.innerHTML = `${backButtonHtml}<div><b>${cluster.members.length} clustered points</b></div><ul>${membersHtml}</ul>`;
    clusterTooltip.classList.remove("hidden");

    const rect = canvas.getBoundingClientRect();
    const localX = mouse.x - rect.left;
    const localY = mouse.y - rect.top;
    const tooltipWidth = clusterTooltip.offsetWidth || 220;
    const tooltipHeight = clusterTooltip.offsetHeight || 80;
    const left = clamp(localX + 14, 10, Math.max(10, rect.width - tooltipWidth - 10));
    const top = clamp(localY + 14, 10, Math.max(10, rect.height - tooltipHeight - 10));
    clusterTooltip.style.left = `${left}px`;
    clusterTooltip.style.top = `${top}px`;
  }

  function hideClusterTooltip() {
    if (!clusterTooltip) return;
    clearClusterTooltipHideTimer();
    activeClusterTooltip = { cluster: null, expandedLayerId: null };
    hoveredClusterPointId = null;
    clusterTooltip.classList.add("hidden");
    clusterTooltip.textContent = "";
  }


  function shouldShowPointHoverTooltip() {
    return !pointDisplayVisibility.names || !pointDisplayVisibility.codes || selectedPointIds.length === 1;
  }

  function showPointHoverTooltip(point, screenX = mouse.x, screenY = mouse.y) {
    if (!pointHoverTooltip || !point || !shouldShowPointHoverTooltip()) return;
    const layer = getLayerById(point.layerId);
    const layerName = String(layer?.name || "Unassigned").trim() || "Unassigned";
    const layerColor = String(layer?.color || "#ffd54a").trim() || "#ffd54a";
    const renderedCode = getRenderedPointCode(point.code);
    const code = renderedCode || String(point.code || "").trim() || "(none)";
    const description = String(point.notes || "").trim() || "(none)";
    const basePointId = selectedPointIds.length === 1 ? selectedPointIds[0] : null;
    const basePoint = basePointId != null ? points.get(basePointId) : null;
    const pointDelta = basePoint && basePoint.id !== point.id ? lineMeasurement(point, basePoint) : null;
    const basePointLayer = basePoint ? getLayerById(basePoint.layerId) : null;
    const fromPointColor = String(basePointLayer?.color || "#ffd54a").trim() || "#ffd54a";
    const fromPointNumber = escapeHtml(String(basePoint?.num || ""));
    const pointDeltaHtml = pointDelta
      ? `<div class="pointHoverTooltipDelta">
        <div class="pointHoverTooltipRow"><span class="pointHoverTooltipLabel">Distance:</span>${pointDelta.distance.toFixed(2)}' from <span class="pointHoverTooltipFromPill" style="background:${escapeHtml(fromPointColor)};">${fromPointNumber}</span></div>
        <div class="pointHoverTooltipRow"><span class="pointHoverTooltipLabel">Bearing:</span>${escapeHtml(pointDelta.bearing)}</div>
      </div>`
      : "";
    pointHoverTooltip.innerHTML = `
      ${pointDeltaHtml}
      <div><b style="color:${escapeHtml(layerColor)}">Point ${escapeHtml(String(point.num || ""))}</b></div>
      <div class="pointHoverTooltipRow"><span class="pointHoverTooltipLabel">Name:</span>${escapeHtml(String(point.num || ""))}</div>
      <div class="pointHoverTooltipRow"><span class="pointHoverTooltipLabel">Code:</span>${escapeHtml(code)}</div>
      <div class="pointHoverTooltipRow"><span class="pointHoverTooltipLabel">Layer:</span>${escapeHtml(layerName)}</div>
      <div class="pointHoverTooltipRow"><span class="pointHoverTooltipLabel">Description:</span>${escapeHtml(description)}</div>
      `;
    pointHoverTooltip.classList.remove("hidden");
    const rect = canvas.getBoundingClientRect();
    const localX = screenX - rect.left;
    const localY = screenY - rect.top;
    const tooltipWidth = pointHoverTooltip.offsetWidth || 220;
    const tooltipHeight = pointHoverTooltip.offsetHeight || 100;
    const left = clamp(localX + 14, 10, Math.max(10, rect.width - tooltipWidth - 10));
    const top = clamp(localY + 14, 10, Math.max(10, rect.height - tooltipHeight - 10));
    pointHoverTooltip.style.left = `${left}px`;
    pointHoverTooltip.style.top = `${top}px`;
  }

  function hidePointHoverTooltip() {
    if (!pointHoverTooltip) return;
    pointHoverTooltip.classList.add("hidden");
    pointHoverTooltip.textContent = "";
  }

  function pickLine(screenX, screenY, thresholdPx=8) {
    const w = screenToWorld(screenX, screenY);
    let best = null;
    let bestDist = thresholdPx / Math.max(view.scale, MIN_SCALE);
    let bestGrip = "a";
    let bestT = 0;

    for (const ln of lines.values()) {
      if (!isLayerVisible(ln.layerId)) continue;
      const pa = points.get(ln.a);
      const pb = points.get(ln.b);
      if (!pa || !pb || !isLayerVisible(pa.layerId) || !isLayerVisible(pb.layerId)) continue;

      let cp = null;
      const middle = getCurveMiddlePoint(ln);
      if (middle && isLayerVisible(middle.layerId)) {
        const circle = getCircleFromThreePoints(pa, middle, pb);
        if (circle) {
          const startAngle = normalizeAngleRadians(Math.atan2(pa.y - circle.centerY, pa.x - circle.centerX));
          const middleAngle = normalizeAngleRadians(Math.atan2(middle.y - circle.centerY, middle.x - circle.centerX));
          const endAngle = normalizeAngleRadians(Math.atan2(pb.y - circle.centerY, pb.x - circle.centerX));
          const targetAngle = normalizeAngleRadians(Math.atan2(w.y - circle.centerY, w.x - circle.centerX));

          const ccwSweep = (endAngle - startAngle + Math.PI * 2) % (Math.PI * 2);
          const ccwToMiddle = (middleAngle - startAngle + Math.PI * 2) % (Math.PI * 2);
          const clockwise = ccwToMiddle > ccwSweep;
          const sweepRad = clockwise
            ? (startAngle - endAngle + Math.PI * 2) % (Math.PI * 2)
            : ccwSweep;
          const sweepToTarget = clockwise
            ? (startAngle - targetAngle + Math.PI * 2) % (Math.PI * 2)
            : (targetAngle - startAngle + Math.PI * 2) % (Math.PI * 2);

          if (sweepRad > 0 && sweepToTarget <= sweepRad) {
            cp = {
              x: circle.centerX + Math.cos(targetAngle) * circle.radius,
              y: circle.centerY + Math.sin(targetAngle) * circle.radius,
              t: sweepToTarget / sweepRad,
            };
          } else {
            const da = dist(w.x, w.y, pa.x, pa.y);
            const db = dist(w.x, w.y, pb.x, pb.y);
            cp = da <= db
              ? { x: pa.x, y: pa.y, t: 0 }
              : { x: pb.x, y: pb.y, t: 1 };
          }
        }
      }

      if (!cp) cp = segmentClosestPoint({x:w.x,y:w.y}, pa, pb);
      const d = dist(w.x, w.y, cp.x, cp.y);
      if (d <= bestDist) {
        bestDist = d;
        best = ln.id;
        bestT = cp.t;
        bestGrip = (cp.t <= 0.5) ? "a" : "b";
      }
    }
    return best ? { lineId: best, grip: bestGrip, t: bestT } : null;
  }

  function selectionSummary() {
    const pts = selectedPointIds.length ? `Pts:${selectedPointIds.length} [${selectedPointIds.map(id=>points.get(id)?.num ?? "?").join(", ")}]` : "";
    const lns = selectedLines.length ? `Lines:${selectedLines.length}` : "";
    return [pts, lns].filter(Boolean).join(" + ") || "none";
  }
  function updateSelectionHUD() {
    const s = selectionSummary();
    selSummary.textContent = s;
    hudSel.textContent = s;
    const layerDisplayState = getSelectionLayerDisplayState();
    const signature = `${layerDisplayState.mode}:${layerDisplayState.layerId || "none"}:${layerDisplayState.label}`;
    if (signature !== lastLayerDisplaySignature) {
      lastLayerDisplaySignature = signature;
      renderLayerControls();
    }
  }

  // -------------------------
  // Rendering
  // -------------------------
  function resize() {
    const rect = canvas.getBoundingClientRect();
    dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    if (view.panX === 0 && view.panY === 0) {
      view.panX = rect.width * 0.5;
      view.panY = rect.height * 0.5;
    }
    if (mapLayerState.enabled) syncMapToView(true);
  }

  function pickGridStep() {
    const targetPx = 80;
    const step = targetPx / Math.max(view.scale, MIN_SCALE);
    const pow = Math.pow(10, Math.floor(Math.log10(step)));
    const candidates = [1,2,5,10].map(m => m*pow);
    let best = candidates[0], bestErr = Math.abs(best - step);
    for (const c of candidates) {
      const err = Math.abs(c - step);
      if (err < bestErr) { bestErr = err; best = c; }
    }
    return best;
  }

  function drawGrid(W,H) {
    const stepWorld = pickGridStep();
    const stepPx = stepWorld * view.scale;
    if (stepPx < 30) return;

    const leftWorld = screenToWorld(0,0).x;
    const rightWorld = screenToWorld(W,0).x;
    const topWorld = screenToWorld(0,0).y;
    const botWorld = screenToWorld(0,H).y;

    const x0 = Math.floor(leftWorld/stepWorld)*stepWorld;
    const x1 = Math.ceil(rightWorld/stepWorld)*stepWorld;
    const y0 = Math.floor(botWorld/stepWorld)*stepWorld;
    const y1 = Math.ceil(topWorld/stepWorld)*stepWorld;

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.lineWidth = 1;

    for (let x = x0; x <= x1; x += stepWorld) {
      const sx = worldToScreen(x,0).x;
      ctx.beginPath();
      ctx.moveTo(sx,0);
      ctx.lineTo(sx,H);
      ctx.stroke();
    }
    for (let y = y0; y <= y1; y += stepWorld) {
      const sy = worldToScreen(0,y).y;
      ctx.beginPath();
      ctx.moveTo(0,sy);
      ctx.lineTo(W,sy);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawCrosshair(W,H) {
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(mouse.x, 0);
    ctx.lineTo(mouse.x, H);
    ctx.moveTo(0, mouse.y);
    ctx.lineTo(W, mouse.y);
    ctx.stroke();

    const snapId = pickPoint(mouse.x, mouse.y, 10);
    const boxSize = 14;
    ctx.strokeStyle = snapId ? "rgba(255,213,74,0.9)" : "rgba(255,255,255,0.4)";
    ctx.beginPath();
    if (snapId) {
      const p = points.get(snapId);
      const sp = worldToScreen(p.x,p.y);
      ctx.rect(sp.x - boxSize/2, sp.y - boxSize/2, boxSize, boxSize);
    } else {
      ctx.rect(mouse.x - boxSize/2, mouse.y - boxSize/2, boxSize, boxSize);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawMarquee() {
    if (!mouse.drag || mouse.dragObj?.type !== "marquee") return;
    const r = rectNorm(mouse.dragObj.x0, mouse.dragObj.y0, mouse.dragObj.x1, mouse.dragObj.y1);
    ctx.save();
    ctx.strokeStyle = "rgba(255,213,74,0.95)";
    ctx.lineWidth = 1.5;
    ctx.setLineDash([6,4]);
    ctx.strokeRect(r.minX, r.minY, r.maxX-r.minX, r.maxY-r.minY);
    ctx.setLineDash([]);
    ctx.fillStyle = "rgba(255,213,74,0.08)";
    ctx.fillRect(r.minX, r.minY, r.maxX-r.minX, r.maxY-r.minY);
    ctx.restore();
  }

  function buildFillPolygonsForLayer(layerId) {
    const adjacency = new Map();
    const addNeighbor = (from, to) => {
      if (!adjacency.has(from)) adjacency.set(from, []);
      adjacency.get(from).push(to);
    };

    for (const ln of lines.values()) {
      if (ln.layerId !== layerId) continue;
      if (!isLayerVisible(ln.layerId)) continue;
      const a = points.get(ln.a);
      const b = points.get(ln.b);
      if (!a || !b || !isLayerVisible(a.layerId) || !isLayerVisible(b.layerId)) continue;
      addNeighbor(ln.a, ln.b);
      addNeighbor(ln.b, ln.a);
    }

    const loops = [];
    const visited = new Set();
    for (const [start, neighbors] of adjacency.entries()) {
      if (visited.has(start) || neighbors.length !== 2) continue;
      const loop = [start];
      let prev = null;
      let current = start;
      let valid = true;
      while (true) {
        visited.add(current);
        const n = adjacency.get(current) || [];
        if (n.length !== 2) { valid = false; break; }
        const next = n[0] === prev ? n[1] : n[0];
        if (next == null) { valid = false; break; }
        prev = current;
        current = next;
        if (current === start) break;
        if (loop.includes(current)) { valid = false; break; }
        loop.push(current);
      }
      if (valid && loop.length >= 3 && current === start) loops.push(loop);
    }
    return loops;
  }

  function drawRotateSelectionPreview() {
    if (!rotateSelectionSession.active || rotateSelectionSession.step < 1 || !rotateSelectionSession.basePoint) return;

    const base = worldToScreen(rotateSelectionSession.basePoint.x, rotateSelectionSession.basePoint.y);
    const cursor = worldToScreen(mouse.wx, mouse.wy);

    ctx.save();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,213,74,0.95)";
    ctx.beginPath();
    ctx.moveTo(base.x, base.y);
    ctx.lineTo(cursor.x, cursor.y);
    ctx.stroke();

    if (rotateSelectionSession.step >= 2 && rotateSelectionSession.fromPoint) {
      const from = worldToScreen(rotateSelectionSession.fromPoint.x, rotateSelectionSession.fromPoint.y);
      ctx.strokeStyle = "rgba(57,255,121,0.95)";
      ctx.beginPath();
      ctx.moveTo(base.x, base.y);
      ctx.lineTo(from.x, from.y);
      ctx.stroke();
    }

    ctx.restore();
  }

  function draw() {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    ctx.clearRect(0,0,W,H);
    if (!mapLayerState.enabled) {
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,W,H);
    }
    
    drawGrid(W,H);

    if (mapLayerState.enabled) {
      syncMapToView();
    }
    else {
        paintBackground(ctx, W,H);
    }
    const blockedTextRects = [];

    // layer fills
    for (const layer of layers.values()) {
      if (!layer.fill || layer.visible === false) continue;
      const loops = buildFillPolygonsForLayer(layer.id);
      if (!loops.length) continue;
      ctx.save();
      ctx.fillStyle = `${layer.color}1A`;
      for (const loop of loops) {
        ctx.beginPath();
        for (let i = 0; i < loop.length; i++) {
          const point = points.get(loop[i]);
          if (!point) continue;
          const sp = worldToScreen(point.x, point.y);
          if (i === 0) ctx.moveTo(sp.x, sp.y);
          else ctx.lineTo(sp.x, sp.y);
        }
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }

    // lines
    const lineLabelCandidates = [];
    const lockVisualState = buildLockVisualState();
    if (pointDisplayVisibility.lines) {
      ctx.lineWidth = 1;
      for (const ln of lines.values()) {
        const a = points.get(ln.a);
        const b = points.get(ln.b);
        if (!a || !b) continue;
        const layer = getLayerById(ln.layerId);
        if (!layer || layer.visible === false) continue;
        if (!isLayerVisible(a.layerId) || !isLayerVisible(b.layerId)) continue;
        const sa = worldToScreen(a.x,a.y);
        const sb = worldToScreen(b.x,b.y);
        const isCollabLockedLine = lockVisualState.lockedLineIds.has(ln.id);
        ctx.strokeStyle = isMovable(ln.movable) ? "#800000" : layer.color;
        ctx.lineWidth = Math.max(0.5, layer.lineWeight);
        if (isCollabLockedLine) {
          ctx.strokeStyle = lockVisualState.flashColor;
          ctx.lineWidth = Math.max(2, layer.lineWeight + 0.5);
        }
        traceLinePath(ctx, ln, sa, sb);
        ctx.stroke();

        if (isMovable(ln.movable)) {
          const mx = (sa.x+sb.x)/2, my=(sa.y+sb.y)/2;
          ctx.save();
          ctx.strokeStyle = "rgba(255,213,74,0.9)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(mx-6, my);
          ctx.lineTo(mx+6, my);
          ctx.stroke();
          ctx.restore();
        }

        if (!getCurveMiddlePoint(ln) && lineIsEligibleForBearingLabels(ln, a, b)) {
          lineLabelCandidates.push({ a, b, sa, sb });
        }
      }

      const circleCommands = buildFieldToFinishCircleCommands();
      for (const cmd of circleCommands) {
        const center = points.get(cmd.centerPointId);
        if (!center || !isLayerVisible(center.layerId)) continue;
        const layer = getLayerById(center.layerId);
        if (!layer || layer.visible === false) continue;
        const radiusPixels = cmd.radius * view.scale;
        if (!Number.isFinite(radiusPixels) || radiusPixels <= 0.5) continue;
        const sc = worldToScreen(center.x, center.y);
        const circleStrokeWidth = Math.max(1, layer.lineWeight);

        ctx.strokeStyle = colorToRgba(layer.color, 0.35) || "rgba(255,255,255,0.35)";
        ctx.lineWidth = circleStrokeWidth;
        ctx.beginPath();
        ctx.arc(sc.x, sc.y, radiusPixels, 0, Math.PI * 2);
        ctx.stroke();
      }

      // highlight selected lines
      if (selectedLines.length) {
        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#ffd54a";
        for (const s of selectedLines) {
          const ln = lines.get(s.lineId);
          if (!ln) continue;
          const a = points.get(ln.a), b = points.get(ln.b);
          if (!a || !b) continue;
          const sa = worldToScreen(a.x,a.y);
          const sb = worldToScreen(b.x,b.y);
          traceLinePath(ctx, ln, sa, sb);
          ctx.stroke();

          const gripPt = (s.grip === "a") ? a : b;
          const sg = worldToScreen(gripPt.x, gripPt.y);
          ctx.fillStyle = "rgba(255,213,74,0.12)";
          ctx.strokeStyle = "#ffd54a";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.rect(sg.x-6, sg.y-6, 12, 12);
          ctx.fill();
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    // points
    cachedPointClusters = buildPointClusters();
    if (!pointDisplayVisibility.clustering && !clusterTooltip.classList.contains("hidden")) hideClusterTooltip();
    const clusteredPointIds = new Set(cachedPointClusters.flatMap((cluster) => cluster.ids));

    for (const p of points.values()) {
      if (!isLayerVisible(p.layerId)) continue;
      if (clusteredPointIds.has(p.id)) continue;
      const layer = getLayerById(p.layerId);
      const sp = worldToScreen(p.x,p.y);

      if (pointDisplayVisibility.points) {
        const pointSymbolMapFile = getPointSymbolMapFile(p.code);
        const symbolImage = getTintedSymbolMarker(pointSymbolMapFile, layer?.color);
        const isCollabLockedPoint = lockVisualState.lockedPointIds.has(p.id);
        if (symbolImage) {
          ctx.drawImage(symbolImage, sp.x - SYMBOL_MARKER_HALF_SIZE_PX, sp.y - SYMBOL_MARKER_HALF_SIZE_PX, SYMBOL_MARKER_SIZE_PX, SYMBOL_MARKER_SIZE_PX);
          if (isCollabLockedPoint) {
            ctx.save();
            ctx.strokeStyle = lockVisualState.flashColor;
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, SYMBOL_MARKER_HALF_SIZE_PX + 3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }
        } else {
          // marker
          ctx.strokeStyle = isCollabLockedPoint ? lockVisualState.flashColor : (layer?.color || "#ff2b2b");
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(sp.x-5, sp.y-5);
          ctx.lineTo(sp.x+5, sp.y+5);
          ctx.moveTo(sp.x-5, sp.y+5);
          ctx.lineTo(sp.x+5, sp.y-5);
          ctx.stroke();
        }

        // movable hint ring
        if (isMovable(p.movable)) {
          ctx.save();
          ctx.strokeStyle = "rgba(255,213,74,0.95)";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(sp.x, sp.y, 8, 0, Math.PI*2);
          ctx.stroke();
          ctx.restore();
        }
      }

      // labels
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textBaseline = "middle";

      if (pointDisplayVisibility.names) {
        ctx.fillStyle = "#ffffff";
        const numText = String(p.num);
        ctx.fillText(numText, sp.x + 8, sp.y - 10);
        blockedTextRects.push({ x: sp.x + 8, y: sp.y - 16, w: ctx.measureText(numText).width, h: 12 });
      }

      if (pointDisplayVisibility.codes && p.code) {
        ctx.fillStyle = "#39ff79";
        const codeText = getRenderedPointCode(p.code);
        if (codeText) {
          ctx.fillText(codeText, sp.x + 8, sp.y + 2);
          blockedTextRects.push({ x: sp.x + 8, y: sp.y - 4, w: ctx.measureText(codeText).width, h: 12 });
        }
      }
      if (pointDisplayVisibility.notes && p.notes) {
        ctx.fillStyle = "#3aa3ff";
        const notesText = String(p.notes);
        ctx.fillText(notesText, sp.x + 8, sp.y + 14);
        blockedTextRects.push({ x: sp.x + 8, y: sp.y + 8, w: ctx.measureText(notesText).width, h: 12 });
      }
    }

    for (const cluster of cachedPointClusters) {
      const strokeAlpha = clamp(cluster.strokeAlpha ?? POINT_CLUSTER_MIN_STROKE_ALPHA, POINT_CLUSTER_MIN_STROKE_ALPHA, POINT_CLUSTER_MAX_STROKE_ALPHA);
      ctx.save();
      ctx.fillStyle = "rgba(255,213,74,0.2)";
      ctx.strokeStyle = `rgba(255,213,74,${strokeAlpha})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      if (cluster.renderAsPolygon && cluster.hullPoints?.length >= 3) {
        ctx.moveTo(cluster.hullPoints[0].x, cluster.hullPoints[0].y);
        for (let i = 1; i < cluster.hullPoints.length; i++) {
          const vertex = cluster.hullPoints[i];
          ctx.lineTo(vertex.x, vertex.y);
        }
        ctx.closePath();
      } else {
        ctx.arc(cluster.centerX, cluster.centerY, cluster.markerRadius, 0, Math.PI * 2);
      }
      ctx.fill();
      ctx.stroke();

      const clusterCountText = cluster.countText || String(cluster.members.length);
      ctx.strokeStyle = `rgba(0,0,0,${POINT_CLUSTER_COUNT_TEXT_STROKE_ALPHA})`;
      ctx.lineWidth = 3;
      ctx.lineJoin = "round";
      ctx.fillStyle = `rgba(255,246,166,${POINT_CLUSTER_COUNT_TEXT_FILL_ALPHA})`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = "bold 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.strokeText(clusterCountText, cluster.centerX, cluster.centerY);
      ctx.fillText(clusterCountText, cluster.centerX, cluster.centerY);
      ctx.restore();

      if (!pointDisplayVisibility.names || cluster.members.length > POINT_CLUSTER_LABEL_BREAKOUT_LIMIT) continue;

      const labelRadius = POINT_LABEL_SPREAD_RADIUS_PX + Math.min(20, cluster.members.length * 2);
      const membersCount = Math.max(1, cluster.members.length);
      for (let i = 0; i < cluster.members.length; i++) {
        const member = cluster.members[i];
        const angle = (Math.PI * 2 * i) / membersCount - Math.PI / 2;
        const labelX = cluster.centerX + Math.cos(angle) * labelRadius;
        const labelY = cluster.centerY + Math.sin(angle) * labelRadius;

        ctx.save();
        ctx.strokeStyle = "rgba(255,213,74,0.45)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cluster.centerX, cluster.centerY);
        ctx.lineTo(labelX - 3, labelY - 2);
        ctx.stroke();
        ctx.restore();

        ctx.fillStyle = "#ffffff";
        ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        const numText = String(member.point.num);
        ctx.fillText(numText, labelX, labelY);
        blockedTextRects.push({ x: labelX, y: labelY - 6, w: ctx.measureText(numText).width, h: 12 });
      }
    }

    if (hoveredClusterPointId != null && points.has(hoveredClusterPointId)) {
      const hoveredPoint = points.get(hoveredClusterPointId);
      if (hoveredPoint && isLayerVisible(hoveredPoint.layerId)) {
        const hoveredPointScreen = worldToScreen(hoveredPoint.x, hoveredPoint.y);
        ctx.save();
        ctx.strokeStyle = "rgba(255,213,74,0.95)";
        ctx.fillStyle = "rgba(255,213,74,0.2)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(hoveredPointScreen.x, hoveredPointScreen.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
    }

    if (pointDisplayVisibility.bearings) {
      ctx.save();
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillStyle = "#ffd54a";

      const groups = buildBearingLabelGroups(lineLabelCandidates);
      const midpoints = groups.flatMap((group) => group.segments.map((segment) => ({
        x: (segment.sa.x + segment.sb.x) * 0.5,
        y: (segment.sa.y + segment.sb.y) * 0.5
      })));
      const centroid = midpoints.length
        ? midpoints.reduce((acc, point) => ({ x: acc.x + point.x, y: acc.y + point.y }), { x: 0, y: 0 })
        : { x: 0, y: 0 };
      if (midpoints.length) {
        centroid.x /= midpoints.length;
        centroid.y /= midpoints.length;
      }

      const baseAz = basisAzimuthRad() ?? 0;
      groups.sort((aGroup, bGroup) => {
        const aSegment = aGroup.segments[0];
        const bSegment = bGroup.segments[0];
        const aDelta = (aSegment.measure.azimuth - baseAz + Math.PI * 2) % (Math.PI * 2);
        const bDelta = (bSegment.measure.azimuth - baseAz + Math.PI * 2) % (Math.PI * 2);
        if (Math.abs(aDelta - bDelta) > 1e-9) return aDelta - bDelta;

        const aMidX = aGroup.segments.reduce((sum, seg) => sum + (seg.sa.x + seg.sb.x) * 0.5, 0) / Math.max(1, aGroup.segments.length);
        const aMidY = aGroup.segments.reduce((sum, seg) => sum + (seg.sa.y + seg.sb.y) * 0.5, 0) / Math.max(1, aGroup.segments.length);
        const bMidX = bGroup.segments.reduce((sum, seg) => sum + (seg.sa.x + seg.sb.x) * 0.5, 0) / Math.max(1, bGroup.segments.length);
        const bMidY = bGroup.segments.reduce((sum, seg) => sum + (seg.sa.y + seg.sb.y) * 0.5, 0) / Math.max(1, bGroup.segments.length);
        const aRadius = Math.hypot(aMidX - centroid.x, aMidY - centroid.y);
        const bRadius = Math.hypot(bMidX - centroid.x, bMidY - centroid.y);
        return bRadius - aRadius;
      });

      for (const group of groups) {
        const totalDistance = group.segments.reduce((sum, seg) => sum + seg.measure.distance, 0);
        const referenceSegment = group.segments[0];
        const groupLabel = `${referenceSegment.measure.bearing} • ${totalDistance.toFixed(3)}`;
        const bearingAngle = normalizeReadableBearingTextAngle(referenceSegment.measure.angle);

        const anchorX = group.segments.reduce((sum, seg) => sum + (seg.sa.x + seg.sb.x) * 0.5, 0) / Math.max(1, group.segments.length);
        const anchorY = group.segments.reduce((sum, seg) => sum + (seg.sa.y + seg.sb.y) * 0.5, 0) / Math.max(1, group.segments.length);
        const dx = Math.sin(referenceSegment.measure.azimuth);
        const dy = -Math.cos(referenceSegment.measure.azimuth);
        const normalX = -dy;
        const normalY = dx;

        const groupLabelWidth = ctx.measureText(groupLabel).width;
        const groupCx = anchorX + normalX * 15;
        const groupCy = anchorY + normalY * 15;
        const groupAabb = rotatedRectAabb(groupCx, groupCy, groupLabelWidth + 6, 16, bearingAngle);
        if (!blockedTextRects.some((r) => rectsOverlap(r, groupAabb))) {
          ctx.save();
          ctx.translate(groupCx, groupCy);
          ctx.rotate(bearingAngle);
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(groupLabel, 0, 0);
          ctx.restore();
          blockedTextRects.push(groupAabb);
        }

        for (const segment of group.segments) {
          const lengthLabel = segment.measure.distance.toFixed(3);
          const lengthLabelWidth = ctx.measureText(lengthLabel).width;
          const segCx = (segment.sa.x + segment.sb.x) * 0.5 - normalX * 13;
          const segCy = (segment.sa.y + segment.sb.y) * 0.5 - normalY * 13;
          const lengthAabb = rotatedRectAabb(segCx, segCy, lengthLabelWidth + 6, 14, bearingAngle);
          if (blockedTextRects.some((r) => rectsOverlap(r, lengthAabb))) continue;

          ctx.save();
          ctx.translate(segCx, segCy);
          ctx.rotate(bearingAngle);
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(lengthLabel, 0, 0);
          ctx.restore();
          blockedTextRects.push(lengthAabb);
        }
      }
      ctx.restore();
    }

    const basisEndpoints = resolveBasisOfBearingEndpoints();
    if (basisEndpoints) {
      const start = worldToScreen(basisEndpoints.start.x, basisEndpoints.start.y);
      const end = worldToScreen(basisEndpoints.end.x, basisEndpoints.end.y);
      const dx = end.x - start.x;
      const dy = end.y - start.y;
      const angle = Math.atan2(dy, dx);
      const lengthPx = Math.hypot(dx, dy);

      ctx.save();
      ctx.strokeStyle = "rgba(255,213,74,0.95)";
      ctx.setLineDash([8, 6]);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();

      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(255,213,74,0.95)";
      ctx.beginPath();
      ctx.arc(start.x, start.y, 3.5, 0, Math.PI * 2);
      ctx.arc(end.x, end.y, 3.5, 0, Math.PI * 2);
      ctx.fill();

      if (lengthPx > 32) {
        const labelX = (start.x + end.x) * 0.5;
        const labelY = (start.y + end.y) * 0.5 - 12;
        const labelAngle = normalizeReadableBearingTextAngle(angle);
        ctx.translate(labelX, labelY);
        ctx.rotate(labelAngle);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "bold 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText("BASIS OF BEARING", 0, 0);
      }
      ctx.restore();
    }

    // highlight selected points
    if (selectedPointIds.length) {
      ctx.save();
      for (const pid of selectedPointIds) {
        const p = points.get(pid);
        if (!p) continue;
        const sp = worldToScreen(p.x,p.y);
        ctx.strokeStyle = (pid === selectedPointId) ? "#ffd54a" : "rgba(255,213,74,0.55)";
        ctx.lineWidth = (pid === selectedPointId) ? 2 : 1.5;
        ctx.beginPath();
        ctx.rect(sp.x-9, sp.y-9, 18, 18);
        ctx.stroke();
      }
      ctx.restore();
    }

    if (selectedPointIds.length === 1) {
      const selectedPoint = points.get(selectedPointIds[0]);
      if (selectedPoint) {
        const selectedPointScreen = worldToScreen(selectedPoint.x, selectedPoint.y);
        ctx.save();
        ctx.lineWidth = 1;
        const leaderGradient = ctx.createLinearGradient(mouse.x, mouse.y, selectedPointScreen.x, selectedPointScreen.y);
        leaderGradient.addColorStop(0, "rgba(220,220,220,0.82)");
        leaderGradient.addColorStop(1, "rgba(220,220,220,0)");
        ctx.strokeStyle = leaderGradient;
        ctx.beginPath();
        ctx.moveTo(selectedPointScreen.x, selectedPointScreen.y);
        ctx.lineTo(mouse.x, mouse.y);
        ctx.stroke();
        ctx.restore();
      }
    }

    // marquee (selection window)
    drawMarquee();

    drawRotateSelectionPreview();

    // crosshair & snap box
    drawCrosshair(W,H);
    drawRemoteCursors();

    // HUD
    hudMouse.textContent = `x: ${fmtPlainCoordinate(mouse.wx)}, y: ${fmtPlainCoordinate(mouse.wy)}`;
    hudZoom.textContent = `${view.scale.toFixed(4)} px/unit`;
    updateSelectionHUD();
    updatePrintScalePreview();
    updateUndoRedoHUD();

    syncArrowHeadPayloadToStorage();

    requestAnimationFrame(draw);
  }

  // -------------------------
  // Tool + UI wiring
  // -------------------------
  function setTool(t) {
    tool = t;
    const names = {
      select:"Select/Move",
      addPoint:"Add Point",
      line2pt:"Line: 2 Points",
      lineDB:"Line: Dist/Bearing",
      pointOnLine:"Point on Line",
      pan:"Pan"
    };
    const label = names[t] ?? t;
    hudTool.textContent = label;
    toolHint.textContent = label;

    for (const id of ["toolSelect","toolAddPoint","toolLine2pt","toolLineDB","toolPointOnLine","toolPan"]) {
      $("#"+id).classList.remove("primary");
    }
    for (const id of ["quickSelect","quickAddPoint","quickLineByPoints"]) {
      const quick = $("#" + id);
      if (quick) quick.classList.remove("primary");
    }
    const map = {
      select:"toolSelect",
      addPoint:"toolAddPoint",
      line2pt:"toolLine2pt",
      lineDB:"toolLineDB",
      pointOnLine:"toolPointOnLine",
      pan:"toolPan"
    };
    const btn = map[t];
    if (btn) $("#"+btn).classList.add("primary");

    const quickMap = {
      select:"quickSelect",
      addPoint:"quickAddPoint",
      line2pt:"quickLineByPoints"
    };
    const quickBtn = quickMap[t];
    if (quickBtn) {
      const quickEl = $("#" + quickBtn);
      if (quickEl) quickEl.classList.add("primary");
    }

    setStatus(`Tool: ${label}`, "");
    syncToolWorkflowToast();
  }

  function runCommandLine(rawCommand) {
    const normalized = String(rawCommand ?? "").trim();
    if (!normalized) {
      setStatus("Enter a command. Try: line 101 205", "warn");
      return false;
    }

    const parts = normalized.split(/\s+/);
    const cmd = parts[0].toLowerCase();

    if (cmd === "line") {
      if (parts.length < 3) {
        setStatus("Usage: line <point1> <point2>", "warn");
        return false;
      }
      const aId = findPointIdByNumber(parts[1]);
      const bId = findPointIdByNumber(parts[2]);
      if (!aId || !bId) {
        setStatus("LINE failed: one or both point numbers were not found.", "warn");
        return false;
      }
      if (aId === bId) {
        setStatus("LINE failed: choose two different points.", "warn");
        return false;
      }
      history.push("command: line");
      const lid = addManualLine(aId, bId, false);
      selectedPointIds = [aId, bId];
      selectedPointId = bId;
      selectedLines = [{ lineId: lid, grip: "b", t: 1 }];
      lastSelectedLineId = lid;
      updatePointEditorFromSelection();
      setStatus(`Command LINE: created line ${lid} from ${parts[1]} to ${parts[2]}.`, "ok");
      return true;
    }

    if (cmd === "move") {
      if (parts.length < 3) {
        setStatus("Usage: move <dx> <dy> (acts on selected points/lines)", "warn");
        return false;
      }
      const dx = Number(parts[1]);
      const dy = Number(parts[2]);
      if (!Number.isFinite(dx) || !Number.isFinite(dy)) {
        setStatus("MOVE failed: dx/dy must be numeric.", "warn");
        return false;
      }
      const affectedPreview = getRotatablePointIdsFromSelection();
      if (!affectedPreview.length) {
        setStatus("MOVE failed: select at least one point or line first.", "warn");
        return false;
      }
      history.push("command: move");
      const moved = moveSelectionByDelta(dx, dy);
      setStatus(`Command MOVE: shifted ${moved} point(s) by Δx=${fmt(dx)}, Δy=${fmt(dy)}.`, "ok");
      return true;
    }

    if (cmd === "rotate") {
      startRotateSelectionSession();
      return true;
    }

    if (cmd === "inverse") {
      if (parts.length < 3) {
        setStatus("Usage: inverse <point1> <point2>", "warn");
        return false;
      }
      const aId = findPointIdByNumber(parts[1]);
      const bId = findPointIdByNumber(parts[2]);
      if (!aId || !bId) {
        setStatus("INVERSE failed: one or both point numbers were not found.", "warn");
        return false;
      }
      if (aId === bId) {
        setStatus("INVERSE failed: choose two different points.", "warn");
        return false;
      }
      const a = points.get(aId);
      const b = points.get(bId);
      const measure = lineMeasurement(a, b);
      if (!measure) {
        setStatus("INVERSE failed: unable to compute bearing/distance.", "warn");
        return false;
      }
      selectedPointIds = [aId, bId];
      selectedPointId = bId;
      selectedLines = [];
      lastSelectedLineId = null;
      setStatus(`Command INVERSE ${parts[1]}→${parts[2]}: Dist ${measure.distance.toFixed(3)}  Bearing ${measure.bearing}`, "ok");
      return true;
    }

    if (cmd === "printview") {
      return generatePrintViewFromSelection();
    }

    setStatus(`Unknown command: ${parts[0]}. Supported: line, move, rotate, inverse, printview.`, "warn");
    return false;
  }

  const COMMAND_AUTOCOMPLETE = [
    { command: "line", usage: "line <point1> <point2>", detail: "Create line from two point numbers" },
    { command: "move", usage: "move <dx> <dy>", detail: "Move selected points/lines by delta" },
    { command: "rotate", usage: "rotate", detail: "Start rotate selection workflow" },
    { command: "inverse", usage: "inverse <point1> <point2>", detail: "Measure bearing and distance" },
    { command: "printview", usage: "printview", detail: "Generate black/white print view from selection" }
  ];
  const QUICK_SEARCH_POINT_SCALE = 10;
  const PRINT_SCALES = [1, 5, 10, 20, 30, 40, 50, 100, 200, 500, 1000];
  const PRINT_PAPER_SIZES_MM = {
    A0: { widthMm: 1189, heightMm: 841 },
    A1: { widthMm: 841, heightMm: 594 },
    A2: { widthMm: 594, heightMm: 420 },
    A3: { widthMm: 420, heightMm: 297 },
    A4: { widthMm: 297, heightMm: 210 }
  };

  function centerViewOnPoint(point) {
    if (!point) return;
    const rect = canvas.getBoundingClientRect();
    view.panX = (rect.width * 0.5) - (point.x * view.scale);
    view.panY = (rect.height * 0.5) + (point.y * view.scale);
    if (mapLayerState.enabled) syncMapToView(true);
  }

  function clearQuickCommandSearchResults() {
    if (!quickCommandSearchResults) return;
    quickCommandSearchResults.classList.add("hidden");
    quickCommandSearchResults.innerHTML = "";
  }

  function isLikelyCommandQuery(rawValue = "") {
    const normalized = String(rawValue || "").trim().toLowerCase();
    if (!normalized) return false;
    const firstToken = normalized.split(/\s+/)[0];
    return COMMAND_AUTOCOMPLETE.some(({ command }) => command.startsWith(firstToken));
  }

  function buildQuickCommandSearchResults(rawValue = "") {
    const normalized = String(rawValue || "").trim();
    if (!normalized) return [];

    if (isLikelyCommandQuery(normalized)) {
      const firstToken = normalized.split(/\s+/)[0].toLowerCase();
      return COMMAND_AUTOCOMPLETE
        .filter(({ command }) => command.startsWith(firstToken))
        .map((item) => ({ ...item, type: "command" }));
    }

    const query = normalized.toLowerCase();
    const matches = [];
    for (const point of points.values()) {
      const layer = getLayerById(point.layerId);
      const searchable = [
        String(point.num || ""),
        String(point.code || ""),
        String(point.notes || ""),
        String(layer?.name || "")
      ].join(" ").toLowerCase();
      if (!searchable.includes(query)) continue;
      matches.push({
        type: "point",
        pointId: point.id,
        pointNumber: point.num,
        pointCode: point.code,
        pointNotes: point.notes,
        layerName: layer?.name || "Layer",
        layerColor: layer?.color || "#2f2f2f"
      });
      if (matches.length >= 10) break;
    }
    return matches;
  }

  function selectPointFromQuickSearch(pointId) {
    const point = points.get(pointId);
    if (!point) return;
    view.scale = clamp(QUICK_SEARCH_POINT_SCALE, MIN_SCALE, MAX_SCALE);
    selectedPointIds = [point.id];
    selectedPointId = point.id;
    selectedLines = [];
    lastSelectedLineId = null;
    updatePointEditorFromSelection();
    centerViewOnPoint(point);
    setTool("select");
    setStatus(`Selected point ${point.num} from quick search.`, "ok");
  }

  function renderQuickCommandSearchResults(rawValue = "") {
    if (!quickCommandSearchResults) return [];
    const results = buildQuickCommandSearchResults(rawValue);
    if (!results.length) {
      clearQuickCommandSearchResults();
      return [];
    }

    quickCommandSearchResults.innerHTML = "";
    for (const result of results) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "quickSearchResultBtn";

      if (result.type === "point") {
        btn.style.borderLeftColor = result.layerColor;
        const pointSymbolUrl = getPointSymbolPreviewUrl(result.pointCode);
        const pointSymbolHtml = pointSymbolUrl ? `<img class="pointSymbolBadge" src="${escapeHtml(pointSymbolUrl)}" alt="Point symbol for ${escapeHtml(String(result.pointNumber || ""))}" />` : "";
        btn.innerHTML = `<span class="quickSearchResultWithSymbol">${pointSymbolHtml}<span class="quickSearchResultContent"><span class="quickSearchResultLine"><span class="quickSearchResultTitle" style="color:${escapeHtml(result.layerColor)}">${escapeHtml(result.pointNumber)}</span><span class="quickSearchResultMeta">${escapeHtml(result.layerName)}</span></span><span class="quickSearchResultDescription">${escapeHtml(result.pointCode || "(no code)")} · ${escapeHtml(result.pointNotes || "No notes")}</span></span></span>`;
        btn.addEventListener("click", () => {
          selectPointFromQuickSearch(result.pointId);
          clearQuickCommandSearchResults();
        });
      } else {
        btn.style.borderLeftColor = "#5c4b14";
        btn.innerHTML = `<span class="quickSearchResultLine"><span class="quickSearchResultTitle">${escapeHtml(result.command.toUpperCase())}</span><span class="quickSearchResultMeta">Command</span></span><span class="quickSearchResultDescription">${escapeHtml(result.usage)} · ${escapeHtml(result.detail)}</span>`;
        btn.addEventListener("click", () => {
          if (quickCommandSearchInput) quickCommandSearchInput.value = result.command;
          renderQuickCommandSearchResults(result.command);
          quickCommandSearchInput?.focus();
        });
      }

      quickCommandSearchResults.appendChild(btn);
    }
    quickCommandSearchResults.classList.remove("hidden");
    return results;
  }

  function maybeRouteKeystrokeToQuickCommandSearch(event) {
    if (!quickCommandSearchInput) return false;
    if (event.defaultPrevented || event.isComposing) return false;
    if (event.ctrlKey || event.metaKey || event.altKey) return false;
    if (event.key.length !== 1) return false;
    if (isEditableTarget(event.target) || isEditableTarget(document.activeElement)) return false;

    event.preventDefault();

    const currentValue = quickCommandSearchInput.value || "";
    const start = Number.isFinite(quickCommandSearchInput.selectionStart)
      ? quickCommandSearchInput.selectionStart
      : currentValue.length;
    const end = Number.isFinite(quickCommandSearchInput.selectionEnd)
      ? quickCommandSearchInput.selectionEnd
      : currentValue.length;
    const nextValue = `${currentValue.slice(0, start)}${event.key}${currentValue.slice(end)}`;
    quickCommandSearchInput.value = nextValue;
    const cursor = start + event.key.length;
    quickCommandSearchInput.setSelectionRange(cursor, cursor);
    quickCommandSearchInput.focus();
    renderQuickCommandSearchResults(nextValue);
    return true;
  }

  quickCommandSearchInput?.addEventListener("input", () => {
    renderQuickCommandSearchResults(quickCommandSearchInput.value || "");
  });

  quickCommandSearchInput?.addEventListener("focus", () => {
    renderQuickCommandSearchResults(quickCommandSearchInput.value || "");
  });

  quickCommandSearchInput?.addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
      clearQuickCommandSearchResults();
      return;
    }
    if (e.key !== "Enter") return;
    e.preventDefault();
    const raw = quickCommandSearchInput.value || "";
    renderQuickCommandSearchResults(raw);
    if (!isLikelyCommandQuery(raw)) return;
    if (runCommandLine(raw)) {
      quickCommandSearchInput.value = "";
      clearQuickCommandSearchResults();
    }
  });

  document.addEventListener("click", (event) => {
    if (!quickCommandSearchResults || !quickCommandSearchInput) return;
    const target = event.target;
    if (!(target instanceof Node)) return;
    if (quickCommandSearchResults.contains(target) || quickCommandSearchInput.contains(target)) return;
    clearQuickCommandSearchResults();
  });

  printPaperSizeInput?.addEventListener("change", updatePrintScalePreview);
  printCustomWidthMmInput?.addEventListener("input", updatePrintScalePreview);
  printCustomHeightMmInput?.addEventListener("input", updatePrintScalePreview);
  generatePrintViewBtn?.addEventListener("click", beginPrintWindowCapture);

  $("#toolSelect").addEventListener("click", ()=>setTool("select"));
  $("#toolAddPoint").addEventListener("click", ()=>setTool("addPoint"));
  $("#toolLine2pt").addEventListener("click", ()=>{ construction.startPointId = null; setTool("line2pt"); });
  $("#toolLineDB").addEventListener("click", ()=>setTool("lineDB"));

  function setQuickToggleButtonState(button, enabled) {
    if (!button) return;
    button.classList.toggle("active", !!enabled);
    button.setAttribute("aria-pressed", enabled ? "true" : "false");
  }

  function setPointMarkerVisibility(enabled) {
    pointDisplayVisibility.points = !!enabled;
    if (showPointsInput) showPointsInput.checked = pointDisplayVisibility.points;
    setQuickToggleButtonState(quickShowPointsBtn, pointDisplayVisibility.points);
    if (!pointDisplayVisibility.points) {
      hideClusterTooltip();
      hidePointHoverTooltip();
    }
  }

  function setLineVisibility(enabled) {
    pointDisplayVisibility.lines = !!enabled;
    if (showLinesInput) showLinesInput.checked = pointDisplayVisibility.lines;
    setQuickToggleButtonState(quickShowLinesBtn, pointDisplayVisibility.lines);
  }

  function setBearingVisibility(enabled) {
    pointDisplayVisibility.bearings = !!enabled;
    if (showBearingsInput) showBearingsInput.checked = pointDisplayVisibility.bearings;
    setQuickToggleButtonState(quickShowBearingsBtn, pointDisplayVisibility.bearings);
  }

  function setPointNameVisibility(enabled) {
    pointDisplayVisibility.names = !!enabled;
    if (showPointNamesInput) showPointNamesInput.checked = pointDisplayVisibility.names;
    setQuickToggleButtonState(quickShowPointNamesBtn, pointDisplayVisibility.names);
    if (!shouldShowPointHoverTooltip()) hidePointHoverTooltip();
  }

  function setPointCodeVisibility(enabled) {
    pointDisplayVisibility.codes = !!enabled;
    if (showPointCodesInput) showPointCodesInput.checked = pointDisplayVisibility.codes;
    setQuickToggleButtonState(quickShowPointCodesBtn, pointDisplayVisibility.codes);
    if (!shouldShowPointHoverTooltip()) hidePointHoverTooltip();
  }

  function setPointNotesVisibility(enabled) {
    pointDisplayVisibility.notes = !!enabled;
    if (showPointNotesInput) showPointNotesInput.checked = pointDisplayVisibility.notes;
    setQuickToggleButtonState(quickShowPointNotesBtn, pointDisplayVisibility.notes);
  }

  function setPointClusteringEnabled(enabled) {
    pointDisplayVisibility.clustering = !!enabled;
    if (enablePointClusteringInput) enablePointClusteringInput.checked = pointDisplayVisibility.clustering;
    setQuickToggleButtonState(quickTogglePointClusteringBtn, pointDisplayVisibility.clustering);
    if (!pointDisplayVisibility.clustering) hideClusterTooltip();
  }

  function setMapTileType(tileType) {
    mapLayerState.tileType = String(tileType || "satellite");
    if (mapTileTypeInput) mapTileTypeInput.value = mapLayerState.tileType;
    if (quickMapTileTypeInput) quickMapTileTypeInput.value = mapLayerState.tileType;
    applyMapTileType();
    syncMapToView(true);
  }

  showLinesInput?.addEventListener("change", () => {
    setLineVisibility(showLinesInput.checked);
    setStatus(`Lines ${pointDisplayVisibility.lines ? "shown" : "hidden"}.`, "ok");
  });

  quickShowLinesBtn?.addEventListener("click", () => {
    setLineVisibility(!pointDisplayVisibility.lines);
    setStatus(`Lines ${pointDisplayVisibility.lines ? "shown" : "hidden"}.`, "ok");
  });

  showBearingsInput?.addEventListener("change", () => {
    setBearingVisibility(showBearingsInput.checked);
    setStatus(`Bearings ${pointDisplayVisibility.bearings ? "shown" : "hidden"}.`, "ok");
  });

  quickShowBearingsBtn?.addEventListener("click", () => {
    setBearingVisibility(!pointDisplayVisibility.bearings);
    setStatus(`Bearings ${pointDisplayVisibility.bearings ? "shown" : "hidden"}.`, "ok");
  });

  showPointsInput?.addEventListener("change", () => {
    setPointMarkerVisibility(showPointsInput.checked);
    setStatus(`Point markers ${pointDisplayVisibility.points ? "shown" : "hidden"}.`, "ok");
  });

  quickShowPointsBtn?.addEventListener("click", () => {
    setPointMarkerVisibility(!pointDisplayVisibility.points);
    setStatus(`Point markers ${pointDisplayVisibility.points ? "shown" : "hidden"}.`, "ok");
  });

  showPointNamesInput?.addEventListener("change", () => {
    setPointNameVisibility(showPointNamesInput.checked);
    setStatus(`Point names ${pointDisplayVisibility.names ? "shown" : "hidden"}.`, "ok");
  });

  quickShowPointNamesBtn?.addEventListener("click", () => {
    setPointNameVisibility(!pointDisplayVisibility.names);
    setStatus(`Point names ${pointDisplayVisibility.names ? "shown" : "hidden"}.`, "ok");
  });

  showPointCodesInput?.addEventListener("change", () => {
    setPointCodeVisibility(showPointCodesInput.checked);
    setStatus(`Point code labels ${pointDisplayVisibility.codes ? "shown" : "hidden"}.`, "ok");
  });

  quickShowPointCodesBtn?.addEventListener("click", () => {
    setPointCodeVisibility(!pointDisplayVisibility.codes);
    setStatus(`Point code labels ${pointDisplayVisibility.codes ? "shown" : "hidden"}.`, "ok");
  });

  showPointNotesInput?.addEventListener("change", () => {
    setPointNotesVisibility(showPointNotesInput.checked);
    setStatus(`Point notes labels ${pointDisplayVisibility.notes ? "shown" : "hidden"}.`, "ok");
  });

  quickShowPointNotesBtn?.addEventListener("click", () => {
    setPointNotesVisibility(!pointDisplayVisibility.notes);
    setStatus(`Point notes labels ${pointDisplayVisibility.notes ? "shown" : "hidden"}.`, "ok");
  });

  enablePointClusteringInput?.addEventListener("change", () => {
    setPointClusteringEnabled(enablePointClusteringInput.checked);
    setStatus(`Point clustering ${pointDisplayVisibility.clustering ? "enabled" : "disabled"}.`, "ok");
  });

  quickTogglePointClusteringBtn?.addEventListener("click", () => {
    setPointClusteringEnabled(!pointDisplayVisibility.clustering);
    setStatus(`Point clustering ${pointDisplayVisibility.clustering ? "enabled" : "disabled"}.`, "ok");
  });

  mapEnabledInput.addEventListener("change", () => {
    setMapLayerEnabled(mapEnabledInput.checked);
    setStatus(`Map layer ${mapLayerState.enabled ? "enabled" : "disabled"}.`, "ok");
  });
  quickMapEnabledBtn?.addEventListener("click", () => {
    setMapLayerEnabled(!mapLayerState.enabled);
    setStatus(`Map layer ${mapLayerState.enabled ? "enabled" : "disabled"}.`, "ok");
  });
  mapTileTypeInput.addEventListener("change", () => {
    setMapTileType(mapTileTypeInput.value);
  });
  quickMapTileTypeInput?.addEventListener("change", () => {
    setMapTileType(quickMapTileTypeInput.value);
  });
  mapOpacityInput.addEventListener("input", () => {
    mapLayerState.opacity = clamp(parseNum(mapOpacityInput.value, 10) / 100, 0, 1);
    applyMapOpacity();
  });

  resetLayers();
  setPointMarkerVisibility(true);
  setPointNameVisibility(true);
  setPointCodeVisibility(true);
  setPointNotesVisibility(false);
  setPointClusteringEnabled(true);
  setQuickToggleButtonState(quickMapEnabledBtn, mapEnabledInput.checked);
  if (quickMapTileTypeInput) quickMapTileTypeInput.value = mapTileTypeInput.value;
  $("#toolPointOnLine").addEventListener("click", ()=>setTool("pointOnLine"));
  $("#toolPan").addEventListener("click", ()=>setTool("pan"));

  if (drawerToggle) {
    drawerToggle.addEventListener("click", () => {
      const isOpen = appShell?.classList.contains("drawerOpen");
      setDrawerOpen(!isOpen);
    });
  }
  if (mobileToolbarToggle) {
    mobileToolbarToggle.addEventListener("click", () => {
      setMobileToolbarsHidden(!mobileToolbarsHidden);
    });
  }
  if (panelCollapseHandle) {
    panelCollapseHandle.addEventListener("click", () => setPanelCollapsed(true));
  }
  if (drawerEdgeExpand) {
    drawerEdgeExpand.addEventListener("click", () => setPanelCollapsed(false));
  }

  window.addEventListener("resize", () => {
    syncPanelCollapseWithSelection();
  });

  $("#undoBtn").addEventListener("click", ()=>history.undoAction());
  $("#redoBtn").addEventListener("click", ()=>history.redoAction());

  $("#quickSave")?.addEventListener("click", () => $("#saveDrawingToProject").click());
  $("#quickPrintView")?.addEventListener("click", () => $("#generatePrintView")?.click());
  syncPrintWindowCaptureUi();
  $("#quickOpenArrowHead")?.addEventListener("click", openArrowHeadFromLineSmith);
  $("#quickSelect")?.addEventListener("click", () => setTool("select"));
  $("#quickAddPoint")?.addEventListener("click", () => setTool("addPoint"));
  function startLineByPointsFromToolbar() {
    if (selectedPointIds.length >= 2) {
      runLineBetweenSelectedPoints({ returnToSelectionTool: true });
      return;
    }
    construction.startPointId = null;
    setTool("line2pt");
  }

  $("#quickLineByPoints")?.addEventListener("click", () => startLineByPointsFromToolbar());
  $("#quickUndo")?.addEventListener("click", () => history.undoAction());
  $("#quickRedo")?.addEventListener("click", () => history.redoAction());
  $("#quickZoomExtents")?.addEventListener("click", () => zoomExtents());
  $("#quickCenterOnLocation")?.addEventListener("click", () => centerOnMyLocation());
  $("#quickExtend")?.addEventListener("click", () => $("#extendToIntersect").click());
  $("#quickTrimIntersect")?.addEventListener("click", () => $("#trimToIntersect").click());
  $("#quickOffsetLine")?.addEventListener("click", () => $("#offsetSelectedLine")?.click());
  $("#quickRotateSelection")?.addEventListener("click", () => startRotateSelectionSession());
  $("#quickPointManager")?.addEventListener("click", () => openPointsManagerBtn?.click());
  $("#quickFtfManager")?.addEventListener("click", () => openFldEditorBtn?.click());

  quickLayerDropdownButton?.addEventListener("click", (event) => {
    event.preventDefault();
    setQuickLayerDropdownOpen(!quickLayerDropdownOpen);
  });
  document.addEventListener("mousedown", (event) => {
    if (!quickLayerDropdown || !quickLayerDropdownOpen) return;
    if (!quickLayerDropdown.contains(event.target)) setQuickLayerDropdownOpen(false);
  });
  window.addEventListener("keydown", (event) => {
    if (event.key === "Escape") setQuickLayerDropdownOpen(false);
  });
  quickLayerManagerBtn?.addEventListener("click", () => openLayersModal());
  layersModalClose?.addEventListener("click", () => closeLayersModal());
  layersModal?.addEventListener("mousedown", (e) => { if (e.target === layersModal) closeLayersModal(); });
  openFldEditorBtn?.addEventListener("click", () => openFldEditor());
  downloadFldLocalBtn?.addEventListener("click", () => downloadFldLocalOverride());
  fldModalClose?.addEventListener("click", () => closeFldEditor());
  fldModal?.addEventListener("mousedown", (e) => { if (e.target === fldModal) closeFldEditor(); });
  fldFilterInput?.addEventListener("input", () => renderFldEditorTable());
  fldAddRuleBtn?.addEventListener("click", () => addFldRule());
  fldSaveLocalBtn?.addEventListener("click", () => saveFldEditorLocalOverride());
  fldResetServerBtn?.addEventListener("click", () => resetFldEditorToServer());
  fldDownloadLocalInlineBtn?.addEventListener("click", () => downloadFldLocalOverride());
  fldDownloadCurrentBtn?.addEventListener("click", () => downloadFldCurrentConfig());
  layersAddBtn?.addEventListener("click", () => {
    const id = `layer-${Date.now()}`;
    layers.set(id, sanitizeLayer({ id, name: `Layer ${layers.size + 1}`, color: "#00a6ff", lineWeight: 1.5 }, id));
    selectedLayerId = id;
    renderLayerControls();
    renderLayersTable();
  });

  $("#zoomExtents").addEventListener("click", () => zoomExtents());

  $("#clearSelection").addEventListener("click", () => clearSelection());
  $("#rotateSelectionReference").addEventListener("click", () => startRotateSelectionSession());
  $("#clearConstruction").addEventListener("click", () => {
    construction.startPointId = null;
    setStatus("Construction cleared.", "");
  });
  $("#deleteSelected").addEventListener("click", () => doDeleteSelected());

  function clearSelection() {
    selectedPointIds = [];
    selectedPointId = null;
    selectedLines = [];
    lastSelectedLineId = null;
    updatePointEditorFromSelection();
    schedulePointsTableRender();
    setStatus("Selection cleared.", "");
  }

  function rememberLastUnlockedEntity(type, id, isUnlocked) {
    if (isUnlocked) {
      lastUnlockedEntity = { type, id };
      return;
    }
    if (lastUnlockedEntity?.type === type && lastUnlockedEntity?.id === id) {
      lastUnlockedEntity = null;
      pendingEscapeLockEntity = null;
    }
  }

  function lockLastUnlockedEntityFromEscape() {
    if (!lastUnlockedEntity) return false;
    const { type, id } = lastUnlockedEntity;

    if (type === "point") {
      const p = points.get(id);
      if (!p || !isMovable(p.movable)) return false;
      history.push("lock point by escape");
      p.movable = false;
      setStatus(`Locked point ${p.num} via Escape.`, "ok");
    } else if (type === "line") {
      const ln = lines.get(id);
      if (!ln || !isMovable(ln.movable)) return false;
      history.push("lock line by escape");
      ln.movable = false;
      setStatus(`Locked line ${ln.id} via Escape.`, "ok");
    } else {
      return false;
    }

    lastUnlockedEntity = null;
    pendingEscapeLockEntity = null;
    schedulePointsTableRender();
    return true;
  }

  function hasSelection() {
    return selectedPointIds.length > 0 || selectedLines.length > 0;
  }

  function moveSelectionToLayer(layerId) {
    if (!layers.has(layerId)) return { moved: 0, skippedLocked: 0, total: 0 };
    const targetLayerId = String(layerId);
    const uniqueLineIds = [...new Set(selectedLines.map((entry) => entry.lineId))];
    let moved = 0;
    let skippedLocked = 0;

    for (const pointId of selectedPointIds) {
      const point = points.get(pointId);
      if (!point) continue;
      if (isLayerLocked(point.layerId)) {
        skippedLocked++;
        continue;
      }
      if (point.layerId === targetLayerId) continue;
      point.layerId = targetLayerId;
      moved++;
    }

    for (const lineId of uniqueLineIds) {
      const line = lines.get(lineId);
      if (!line) continue;
      if (isLayerLocked(line.layerId)) {
        skippedLocked++;
        continue;
      }
      if (line.layerId === targetLayerId) continue;
      line.layerId = targetLayerId;
      moved++;
    }

    return { moved, skippedLocked, total: selectedPointIds.length + uniqueLineIds.length };
  }

  function applyLayerChoice(layerId, { closeDropdown = false } = {}) {
    if (!layers.has(layerId)) return;
    const layer = getLayerById(layerId);
    if (hasSelection()) {
      history.push("move selection to layer");
      const { moved, skippedLocked, total } = moveSelectionToLayer(layerId);
      const lockSuffix = skippedLocked ? ` (${skippedLocked} locked item(s) skipped)` : "";
      if (moved > 0) {
        setStatus(`Moved ${moved} selected item(s) to layer ${layer?.name || layerId}.${lockSuffix}`, skippedLocked ? "warn" : "ok");
      } else if (total > 0) {
        setStatus(`Selection already on layer ${layer?.name || layerId}.${lockSuffix}`, skippedLocked ? "warn" : "ok");
      }
    }
    selectedLayerId = layerId;
    renderLayerControls();
    scheduleLayersTableRender();
    if (closeDropdown) setQuickLayerDropdownOpen(false);
  }

  function cancelActiveCanvasCommand() {
    let canceled = false;

    if (rotateSelectionSession.active) {
      cancelRotateSelectionSession(true);
      canceled = true;
    }

    if (lineIntersectionCommandSession.active) {
      stopLineIntersectionCommand();
      canceled = true;
    }

    if (construction.startPointId !== null) {
      construction.startPointId = null;
      canceled = true;
    }

    if (tool !== "select" && tool !== "pan") {
      setTool("select");
      canceled = true;
    }

    if (canceled) {
      setStatus("Command canceled. Selection kept (right-click again to clear selection).", "warn");
    }

    return canceled;
  }

  function runCanvasCancelOrClearAction({ trigger = "generic" } = {}) {
    if (modalIsOpen()) return;
    if (cancelActiveCanvasCommand()) {
      pendingEscapeLockEntity = null;
      return;
    }
    if (hasSelection()) {
      clearSelection();
      pendingEscapeLockEntity = null;
      return;
    }

    if ((trigger === "escape" || trigger === "right-click") && lastUnlockedEntity) {
      const sameEntityPending = pendingEscapeLockEntity
        && pendingEscapeLockEntity.type === lastUnlockedEntity.type
        && pendingEscapeLockEntity.id === lastUnlockedEntity.id;

      if (sameEntityPending) {
        lockLastUnlockedEntityFromEscape();
      } else {
        pendingEscapeLockEntity = { ...lastUnlockedEntity };
        setStatus("Press Escape or right-click again to lock the last unlocked point/line.", "warn");
      }
      return;
    }

    pendingEscapeLockEntity = null;
  }

  function consumePendingMarqueeZoomRect() {
    if (!pendingMarqueeZoomRect) return null;
    const rect = pendingMarqueeZoomRect;
    pendingMarqueeZoomRect = null;
    return rect;
  }

  function consumePendingMarqueeSelectionSnapshot() {
    if (!pendingMarqueeSelectionSnapshot) return null;
    const snapshot = pendingMarqueeSelectionSnapshot;
    pendingMarqueeSelectionSnapshot = null;
    return snapshot;
  }

  function captureSelectionSnapshot() {
    return {
      selectedPointIds: [...selectedPointIds],
      selectedPointId,
      selectedLines: selectedLines.map((entry) => ({ ...entry })),
      lastSelectedLineId
    };
  }

  function applySelectionSnapshot(snapshot) {
    if (!snapshot) return;
    selectedPointIds = Array.isArray(snapshot.selectedPointIds)
      ? snapshot.selectedPointIds.filter((id) => points.has(id))
      : [];

    selectedPointId = snapshot.selectedPointId;
    if (selectedPointId != null && !points.has(selectedPointId)) {
      selectedPointId = selectedPointIds.length ? selectedPointIds[selectedPointIds.length - 1] : null;
    }

    selectedLines = Array.isArray(snapshot.selectedLines)
      ? snapshot.selectedLines.filter((entry) => entry?.lineId != null && lines.has(entry.lineId))
      : [];

    lastSelectedLineId = snapshot.lastSelectedLineId;
    if (lastSelectedLineId != null && !lines.has(lastSelectedLineId)) {
      lastSelectedLineId = selectedLines.length ? selectedLines[selectedLines.length - 1].lineId : null;
    }

    updatePointEditorFromSelection();
    schedulePointsTableRender();
  }

  function doDeleteSelected() {
    const hasPts = selectedPointIds.length > 0;
    const hasLns = selectedLines.length > 0;
    if (!hasPts && !hasLns) { setStatus("Nothing selected.", "warn"); return; }

    history.push("delete selected");

    const pointIds = [...selectedPointIds];
    const lineIds = [...new Set(selectedLines.map(s => s.lineId))];

    clearSelection();

    let deletedPoints = 0;
    let deletedLines = 0;
    let lockedSkipped = 0;
    for (const pid of pointIds) {
      if (deletePoint(pid)) deletedPoints++;
      else lockedSkipped++;
    }
    for (const lid of lineIds) {
      if (!lines.has(lid)) continue;
      if (deleteLine(lid)) deletedLines++;
      else lockedSkipped++;
    }

    const lockSuffix = lockedSkipped ? ` (${lockedSkipped} locked item(s) skipped)` : "";
    setStatus(`Deleted ${deletedPoints} point(s) and ${deletedLines} line(s).${lockSuffix}`, lockedSkipped ? "warn" : "ok");
  }

  $("#focusSelected").addEventListener("click", () => {
    const rect = canvas.getBoundingClientRect();
    const cx = rect.width*0.5, cy = rect.height*0.5;
    if (selectedPointId && points.has(selectedPointId)) {
      history.push("focus point");
      const p = points.get(selectedPointId);
      view.panX = cx - p.x*view.scale;
      view.panY = cy + p.y*view.scale;
      setStatus("Centered on selected point.", "ok");
      return;
    }
    if (lastSelectedLineId && lines.has(lastSelectedLineId)) {
      const ln = lines.get(lastSelectedLineId);
      const a = points.get(ln.a), b = points.get(ln.b);
      if (a && b) {
        history.push("focus line");
        const mx = (a.x+b.x)/2, my=(a.y+b.y)/2;
        view.panX = cx - mx*view.scale;
        view.panY = cy + my*view.scale;
        setStatus("Centered on selected line.", "ok");
        return;
      }
    }
    setStatus("Nothing to center on.", "warn");
  });

  // -------------------------
  // Modal (Points Manager)
  // -------------------------
  function modalIsOpen(){
    return !modal.classList.contains("hidden")
      || !connectLinesModal.classList.contains("hidden")
      || (layersModal && !layersModal.classList.contains("hidden"))
      || (fldModal && !fldModal.classList.contains("hidden"));
  }

  function askConnectLinesOrder() {
    return new Promise((resolve) => {
      connectLinesModal.classList.remove("hidden");
      connectLinesModal.setAttribute("aria-hidden", "false");

      function cleanup(choice) {
        connectLinesModal.classList.add("hidden");
        connectLinesModal.setAttribute("aria-hidden", "true");
        connectLinesSequentialBtn.removeEventListener("click", onSequential);
        connectLinesByDistanceBtn.removeEventListener("click", onByDistance);
        window.removeEventListener("keydown", onKeydown);
        resolve(choice);
      }

      const onSequential = () => cleanup("sequential");
      const onByDistance = () => cleanup("distance");
      const onKeydown = (e) => {
        if (e.key === "Escape") {
          e.preventDefault();
          cleanup("sequential");
        }
      };

      connectLinesSequentialBtn.addEventListener("click", onSequential);
      connectLinesByDistanceBtn.addEventListener("click", onByDistance);
      window.addEventListener("keydown", onKeydown);
      connectLinesSequentialBtn.focus();
    });
  }

  function openModal() {
    modal.classList.remove("hidden");
    modal.setAttribute("aria-hidden","false");
    closePointsManagerBtn.disabled = false;

    if (!modalWindow.style.left || !modalWindow.style.top) {
      const vw = window.innerWidth, vh = window.innerHeight;
      const w = Math.min(1100, vw - 36);
      const h = Math.min(640, vh - 36);
      modalWindow.style.width = w + "px";
      modalWindow.style.height = h + "px";
      modalWindow.style.left = Math.max(18, (vw - w)/2) + "px";
      modalWindow.style.top = Math.max(18, (vh - h)/2) + "px";
    }

    schedulePointsTableRender();
    updateCounts();
    $("#ptFilter").focus();
  }

  function closeModal() {
    modal.classList.add("hidden");
    modal.setAttribute("aria-hidden","true");
    closePointsManagerBtn.disabled = true;
  }

  openPointsManagerBtn.addEventListener("click", openModal);
  closePointsManagerBtn.addEventListener("click", closeModal);
  modalClose.addEventListener("click", closeModal);

  modal.addEventListener("mousedown", (e) => {
    if (e.target === modal) closeModal();
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && modalIsOpen() && !isEditableTarget(e.target)) {
      e.preventDefault();
      if (fldModal && !fldModal.classList.contains("hidden")) {
        closeFldEditor();
        return;
      }
      if (layersModal && !layersModal.classList.contains("hidden")) {
        closeLayersModal();
        return;
      }
      closeModal();
    }
  });

  let modalDrag = null;
  modalHeader.addEventListener("mousedown", (e) => {
    if (e.target.closest("button") || isEditableTarget(e.target)) return;
    e.preventDefault();
    const rect = modalWindow.getBoundingClientRect();
    modalDrag = {
      offX: e.clientX - rect.left,
      offY: e.clientY - rect.top
    };
  });
  window.addEventListener("mousemove", (e) => {
    if (!modalDrag) return;
    const vw = window.innerWidth, vh = window.innerHeight;
    const r = modalWindow.getBoundingClientRect();
    let left = e.clientX - modalDrag.offX;
    let top = e.clientY - modalDrag.offY;
    left = clamp(left, 10 - r.width + 80, vw - 80);
    top = clamp(top, 10, vh - 60);
    modalWindow.style.left = left + "px";
    modalWindow.style.top = top + "px";
  });
  window.addEventListener("mouseup", ()=>{ modalDrag = null; });

  // -------------------------
  // Point editor panel
  // -------------------------
  function parseCpfInstruments(value = "") {
    const raw = String(value ?? "").trim();
    if (!raw) return [];
    const normalized = raw.replace(/^CPNFS?:\s*/i, "");
    const parts = normalized
      .split(/\.\.\.|[,;|\n]+/)
      .map((item) => item.trim())
      .filter(Boolean);
    return [...new Set(parts)];
  }

  function buildCpfInstrumentUrl(instrument) {
    return ADA_CPF_PDF_BASE + encodeURIComponent(String(instrument).trim()) + ".pdf";
  }

  const CPNF_NEARBY_DISTANCE_FEET = 15;

  function collectNearbyCpfInstruments(point, radiusFeet = CPNF_NEARBY_DISTANCE_FEET) {
    if (!point) return [];
    const merged = new Set(parseCpfInstruments(point.notes));
    const radiusSquared = Math.max(0, Number(radiusFeet) || 0) ** 2;
    for (const candidate of points.values()) {
      if (!candidate || candidate.id === point.id) continue;
      if (dist2(point.x, point.y, candidate.x, candidate.y) > radiusSquared) continue;
      for (const instrument of parseCpfInstruments(candidate.notes)) merged.add(instrument);
    }
    return [...merged];
  }

  function readPointFieldValues(basePoint, fields) {
    if (!basePoint) return null;
    const getValue = (key, fallback) => {
      const element = fields?.[key];
      if (!element) return fallback;
      return String(element.value ?? fallback);
    };
    return {
      num: getValue("num", basePoint.num),
      x: getValue("x", basePoint.x),
      y: getValue("y", basePoint.y),
      z: getValue("z", basePoint.z),
      code: getValue("code", basePoint.code),
      notes: getValue("notes", basePoint.notes)
    };
  }

  function getSelectedPoints() {
    return selectedPointIds.map((id) => points.get(id)).filter(Boolean);
  }

  function summarizeSelectedPointValues(selectedPoints, keys) {
    const summary = {};
    for (const key of keys) {
      const values = selectedPoints.map((point) => String(point?.[key] ?? ""));
      const first = values[0] ?? "";
      summary[key] = {
        value: first,
        varied: values.some((value) => value !== first)
      };
    }
    return summary;
  }

  function applyEditsToMultiplePoints(fields, sourceLabel = "inspector", options = {}) {
    const { lockDuringSinglePointCollabEdit = true } = options;
    const selectedPoints = getSelectedPoints();
    if (!selectedPoints.length) {
      setStatus("Select at least one point to apply edits.", "warn");
      return false;
    }

    for (const point of selectedPoints) {
      if (isObjectLockedByOther("point", point.id)) {
        setStatus(`Point ${point.num} is locked by another collaborator.`, "warn");
        triggerLockDeniedFlash();
        return false;
      }
    }

    const selectedPointIdSet = new Set(selectedPoints.map((point) => point.id));
    const outsideNumbers = new Set(
      [...points.values()]
        .filter((point) => point && !selectedPointIdSet.has(point.id))
        .map((point) => String(point.num || "").trim())
    );
    const proposedNumbers = new Set();
    const editsByPoint = [];
    for (const point of selectedPoints) {
      const values = readPointFieldValues(point, fields);
      if (!values) continue;
      const proposedNum = String(values.num || point.num).trim();
      if (outsideNumbers.has(proposedNum)) {
        setStatus(`Point number ${proposedNum} already exists.`, "warn");
        return false;
      }
      if (proposedNumbers.has(proposedNum)) {
        setStatus(`Point number ${proposedNum} would be duplicated.`, "warn");
        return false;
      }
      proposedNumbers.add(proposedNum);
      editsByPoint.push({ point, values, proposedNum });
    }

    function commitEdits() {
      history.push(editsByPoint.length === 1 ? "edit point" : "edit points");

      let pointCodeChanged = false;
      for (const { point, values, proposedNum } of editsByPoint) {
        point.num = proposedNum;
        point.x = parseNum(values.x, point.x);
        point.y = parseNum(values.y, point.y);
        point.z = parseNum(values.z, point.z);
        if (setPointCode(point, String(values.code ?? point.code))) pointCodeChanged = true;
        point.notes = String(values.notes ?? point.notes);
      }

      if (pointCodeChanged) {
        ensureLegacyAutoFieldToFinishLineMetadata();
        syncFieldToFinishLinework();
      }

      scheduleCollabStateSync();
      schedulePointsTableRender();
      setStatus(`Updated ${editsByPoint.length} selected point${editsByPoint.length === 1 ? "" : "s"} from ${sourceLabel}.`, "ok");
      updateCounts();
      updatePointEditorFromSelection();
    }

    if (lockDuringSinglePointCollabEdit && editsByPoint.length === 1 && collab.enabled && collab.socket?.readyState === WebSocket.OPEN) {
      const point = editsByPoint[0].point;
      requestObjectEditLock({
        entityType: "point",
        entityId: point.id,
        onGranted: () => {
          commitEdits();
          sendLockRelease({ entityType: "point", entityId: point.id });
        },
        onDenied: () => {
          setStatus(`Point ${point.num} is locked by another collaborator.`, "warn");
        }
      });
    } else {
      commitEdits();
    }

    return true;
  }

  function applySelectedPointEdits(fields, sourceLabel = "inspector", options = {}) {
    return applyEditsToMultiplePoints(fields, sourceLabel, options);
  }

  function hasPendingPrimaryPointEditorEdits(point) {
    if (!point) return false;
    return String($("#ptNum")?.value ?? point.num).trim() !== String(point.num ?? "")
      || String($("#ptX")?.value ?? point?.x).trim() !== String(point?.x ?? "")
      || String($("#ptY")?.value ?? point?.y).trim() !== String(point?.y ?? "")
      || String($("#ptZ")?.value ?? point?.z).trim() !== String(point?.z ?? "")
      || normalizePointCode(String($("#ptCode")?.value ?? point?.code ?? "")) !== String(point?.code ?? "")
      || String($("#ptNotes")?.value ?? point?.notes ?? "") !== String(point?.notes ?? "");
  }

  function applyPendingPrimaryPointEditorEdits(sourceLabel = "point editor") {
    const point = selectedPointId ? points.get(selectedPointId) : null;
    if (!point || !hasPendingPrimaryPointEditorEdits(point)) return true;
    if (isObjectLockedByOther("point", point.id)) {
      setStatus(`Point ${point.num} is locked by another collaborator.`, "warn");
      triggerLockDeniedFlash();
      return false;
    }

    history.push("edit point");
    point.num = String($("#ptNum")?.value ?? point.num).trim();
    point.x = parseNum($("#ptX")?.value, point.x);
    point.y = parseNum($("#ptY")?.value, point.y);
    point.z = parseNum($("#ptZ")?.value, point.z);
    const pointCodeChanged = setPointCode(point, String($("#ptCode")?.value ?? point.code));
    point.notes = String($("#ptNotes")?.value ?? point.notes);

    if (pointCodeChanged) {
      ensureLegacyAutoFieldToFinishLineMetadata();
      syncFieldToFinishLinework();
    }

    scheduleCollabStateSync();
    schedulePointsTableRender();
    setStatus(`Updated point ${point.num} from ${sourceLabel}.`, "ok");
    updateCounts();
    updatePointEditorFromSelection();
    return true;
  }

  function applySharedFieldToSelectedPoints(key, rawValue, sourceLabel = "point inspector") {
    const selectedPoints = getSelectedPoints();
    if (!selectedPoints.length) return false;
    for (const point of selectedPoints) {
      if (isObjectLockedByOther("point", point.id)) {
        setStatus(`Point ${point.num} is locked by another collaborator.`, "warn");
        triggerLockDeniedFlash();
        return false;
      }
    }
    history.push(selectedPoints.length === 1 ? "edit point" : "edit points");
    let pointCodeChanged = false;
    for (const point of selectedPoints) {
      if (key === "x" || key === "y" || key === "z") {
        point[key] = parseNum(rawValue, point[key]);
      } else if (key === "code") {
        if (setPointCode(point, String(rawValue ?? point[key]))) pointCodeChanged = true;
      } else if (key === "notes") {
        point[key] = String(rawValue ?? point[key]);
      }
    }
    if (pointCodeChanged) {
      ensureLegacyAutoFieldToFinishLineMetadata();
      syncFieldToFinishLinework();
    }
    scheduleCollabStateSync();
    schedulePointsTableRender();
    setStatus(`Updated ${key.toUpperCase()} for ${selectedPoints.length} selected point${selectedPoints.length === 1 ? "" : "s"} from ${sourceLabel}.`, "ok");
    updateCounts();
    updatePointEditorFromSelection();
    return true;
  }

  function buildSharedPointInspector(selectedPoints) {
    const summaryLabel = document.createElement("div");
    summaryLabel.style.marginBottom = "6px";
    summaryLabel.textContent = `Selected points (${selectedPoints.length}) shared values:`;
    pointInspector.appendChild(summaryLabel);

    const fieldSpecs = [
      ["X", "x"],
      ["Y", "y"],
      ["Z", "z"],
      ["Code", "code"],
      ["Notes", "notes"]
    ];
    const summary = summarizeSelectedPointValues(selectedPoints, fieldSpecs.map(([, key]) => key));

    for (const [label, key] of fieldSpecs) {
      const row = document.createElement("div");
      row.className = "inspectorRow";
      const left = document.createElement("span");
      left.textContent = label;
      const right = document.createElement("div");
      right.className = "inspectorValueWrap";
      if (summary[key].varied) {
        const variedButton = document.createElement("button");
        variedButton.type = "button";
        variedButton.className = "inspectorVariedPill";
        variedButton.textContent = "Varied";
        variedButton.addEventListener("click", () => {
          const nextValue = window.prompt(`Set ${label} for ${selectedPoints.length} selected points:`, "");
          if (nextValue === null) return;
          applySharedFieldToSelectedPoints(key, nextValue, `point inspector ${label} bulk set`);
        });
        right.appendChild(variedButton);
      } else {
        const valueEl = document.createElement("b");
        valueEl.textContent = summary[key].value;
        right.appendChild(valueEl);
      }
      row.append(left, right);
      pointInspector.appendChild(row);
    }

    if (selectedPoints.length > 1) {
      const pickerRow = document.createElement("div");
      pickerRow.className = "inspectorRow";
      const pickerLabel = document.createElement("span");
      pickerLabel.textContent = "Inspect point";
      const picker = document.createElement("select");
      picker.className = "inspectorSelect";
      for (const point of selectedPoints) {
        const option = document.createElement("option");
        option.value = String(point.id);
        option.textContent = `${point.num} (${fmt(point.x)}, ${fmt(point.y)})`;
        if (point.id === selectedPointId) option.selected = true;
        picker.appendChild(option);
      }
      picker.addEventListener("change", () => {
        const nextId = Number(picker.value);
        if (!Number.isFinite(nextId) || !points.has(nextId)) return;
        selectedPointId = nextId;
        updatePointEditorFromSelection();
      });
      pickerRow.append(pickerLabel, picker);
      pointInspector.appendChild(pickerRow);
    }
  }

  function updatePointInspectorFromSelection() {
    pointInspector.innerHTML = "";
    const selectedPoints = getSelectedPoints();
    const p = selectedPointId ? points.get(selectedPointId) : null;
    if (!p) {
      pointInspector.textContent = "Select one point to inspect point details.";
      return;
    }
    if (selectedPoints.length > 1) {
      buildSharedPointInspector(selectedPoints);
    }

    const pointSymbolUrl = getPointSymbolPreviewUrl(p.code);
    const inspectorPointHeader = document.createElement("div");
    inspectorPointHeader.className = "inspectorPointHeader";
    const inspectorPointHeaderTitle = document.createElement("div");
    inspectorPointHeaderTitle.className = "inspectorPointHeaderTitle";
    inspectorPointHeaderTitle.textContent = `Point ${p.num || ""}`;
    inspectorPointHeader.appendChild(inspectorPointHeaderTitle);
    if (pointSymbolUrl) {
      const symbolBadge = document.createElement("img");
      symbolBadge.className = "pointSymbolBadge large";
      symbolBadge.src = pointSymbolUrl;
      symbolBadge.alt = `Point symbol for ${p.num || ""}`;
      inspectorPointHeader.appendChild(symbolBadge);
    }
    pointInspector.appendChild(inspectorPointHeader);

    const fieldSpecs = [
      ["Point", "num", p.num],
      ["X", "x", p.x],
      ["Y", "y", p.y],
      ["Z", "z", p.z],
      ["Code", "code", p.code || ""],
      ["Notes", "notes", p.notes || ""]
    ];

    const inspectorFields = {};
    for (const [label, key, value] of fieldSpecs) {
      const row = document.createElement("div");
      row.className = "inspectorRow";
      const left = document.createElement("span");
      left.textContent = label;
      const right = document.createElement("input");
      right.type = "text";
      right.value = String(value);
      right.dataset.pointInspectorField = key;
      right.style.width = "58%";
      right.style.minWidth = "130px";
      right.style.background = "#0f1726";
      right.style.color = "var(--text)";
      right.style.border = "1px solid #2a3550";
      right.style.borderRadius = "6px";
      right.style.padding = "4px 6px";
      row.append(left, right);
      pointInspector.appendChild(row);
      inspectorFields[key] = right;
    }

    const actionsRow = document.createElement("div");
    actionsRow.className = "inspectorRow";
    const actionsLabel = document.createElement("span");
    actionsLabel.textContent = "Actions";
    const applyBtn = document.createElement("button");
    applyBtn.type = "button";
    applyBtn.id = "pointInspectorApply";
    applyBtn.className = "cellBtn ok";
    applyBtn.textContent = "Apply Inspector Edits";
    applyBtn.addEventListener("click", () => {
      applySelectedPointEdits(inspectorFields, "point inspector");
    });
    actionsRow.append(actionsLabel, applyBtn);
    pointInspector.appendChild(actionsRow);

    const cpfInstruments = collectNearbyCpfInstruments(p);
    const cpfRow = document.createElement("div");
    cpfRow.className = "inspectorRow";
    const cpfLabel = document.createElement("span");
    cpfLabel.textContent = `CP&F (≤${CPNF_NEARBY_DISTANCE_FEET}ft)`;
    const cpfValue = document.createElement("b");
    cpfValue.textContent = cpfInstruments.length ? cpfInstruments.join(", ") : "None";
    cpfRow.append(cpfLabel, cpfValue);
    pointInspector.appendChild(cpfRow);

    if (cpfInstruments.length) {
      const links = document.createElement("div");
      links.className = "inspectorLinks";
      for (const instrument of cpfInstruments) {
        const a = document.createElement("a");
        a.href = buildCpfInstrumentUrl(instrument);
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = `Open ${instrument}`;
        links.appendChild(a);
      }
      pointInspector.appendChild(links);
    }
  }

  function updatePointEditorFromSelection() {
    const p = selectedPointId ? points.get(selectedPointId) : null;
    if (p) {
      $("#ptNum").value = p.num;
      $("#ptX").value = p.x;
      $("#ptY").value = p.y;
      $("#ptZ").value = p.z;
      $("#ptCode").value = p.code;
      $("#ptNotes").value = p.notes;
    } else {
      $("#ptX").value = "";
      $("#ptY").value = "";
    }

    if (pointEditorSymbolRow) {
      if (!p) {
        pointEditorSymbolRow.textContent = "Select a point to preview mapped symbol.";
      } else {
        const pointSymbolUrl = getPointSymbolPreviewUrl(p.code);
        if (pointSymbolUrl) {
          pointEditorSymbolRow.innerHTML = `<img class="pointSymbolBadge" src="${escapeHtml(pointSymbolUrl)}" alt="Point symbol for ${escapeHtml(String(p.num || ""))}" /><span>Mapped symbol preview</span>`;
        } else {
          pointEditorSymbolRow.textContent = "No mapped symbol for this point code.";
        }
      }
    }
    updatePointInspectorFromSelection();
    syncPanelCollapseWithSelection();
  }

  $("#applyPoint").addEventListener("click", () => {
    applySelectedPointEdits({
      num: $("#ptNum"),
      x: $("#ptX"),
      y: $("#ptY"),
      z: $("#ptZ"),
      code: $("#ptCode"),
      notes: $("#ptNotes")
    }, "point editor");
  });

  $("#ptCode")?.addEventListener("input", () => {
    if (!pointEditorSymbolRow) return;
    const currentCode = String($("#ptCode")?.value || "");
    const pointSymbolUrl = getPointSymbolPreviewUrl(currentCode);
    if (pointSymbolUrl) {
      pointEditorSymbolRow.innerHTML = `<img class="pointSymbolBadge" src="${escapeHtml(pointSymbolUrl)}" alt="Point symbol preview" /><span>Mapped symbol preview</span>`;
    } else {
      pointEditorSymbolRow.textContent = "No mapped symbol for this point code.";
    }
  });

  // -------------------------
  // Zoom extents
  // -------------------------
  function zoomToWorldBounds(minX, minY, maxX, maxY, { paddingFraction = 0.05 } = {}) {
    if (![minX, minY, maxX, maxY].every(Number.isFinite)) return false;
    const rect = canvas.getBoundingClientRect();
    const pad = Math.max(20, Math.min(rect.width, rect.height) * paddingFraction);
    const w = Math.max(1, rect.width - pad*2);
    const h = Math.max(1, rect.height - pad*2);

    const dx = maxX - minX;
    const dy = maxY - minY;

    const safeDx = dx < EPS ? 1 : dx;
    const safeDy = dy < EPS ? 1 : dy;

    const scaleX = w / safeDx;
    const scaleY = h / safeDy;
    const newScale = clamp(Math.min(scaleX, scaleY) * 0.95, MIN_SCALE, MAX_SCALE);

    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;

    view.scale = newScale;
    view.panX = rect.width * 0.5 - cx * view.scale;
    view.panY = rect.height * 0.5 + cy * view.scale;
    return true;
  }

  function zoomExtents(options = {}) {
    const { skipHistory = false, silent = false } = options;
    if (points.size === 0) {
      if (!silent) setStatus("No points to zoom to.", "warn");
      return false;
    }
    if (!skipHistory) history.push("zoom extents");
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const p of points.values()) {
      minX = Math.min(minX, p.x);
      minY = Math.min(minY, p.y);
      maxX = Math.max(maxX, p.x);
      maxY = Math.max(maxY, p.y);
    }

    zoomToWorldBounds(minX, minY, maxX, maxY, { paddingFraction: 0.05 });

    if (!silent) {
      setStatus(`Zoomed to extents.
X: [${fmt(minX)}, ${fmt(maxX)}]
Y: [${fmt(minY)}, ${fmt(maxY)}]`, "ok");
    }
    return true;
  }

  function centerOnMyLocation() {
    if (!navigator.geolocation) {
      setStatus("Geolocation is not supported by this browser.", "warn");
      return;
    }
    if (!mapGeoreference) {
      setStatus("No georeference set — cannot convert GPS to drawing coordinates.", "warn");
      return;
    }
    setStatus("Acquiring GPS location…", "");
    const btn = $("#quickCenterOnLocation");
    if (btn) btn.classList.add("primary");
    navigator.geolocation.getCurrentPosition(
      (position) => {
        if (btn) btn.classList.remove("primary");
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;
        const world = latLngToWorld(lat, lng);
        const radius = 25;
        zoomToWorldBounds(
          world.x - radius, world.y - radius,
          world.x + radius, world.y + radius,
          { paddingFraction: 0.05 }
        );
        syncMapToView(true);
        requestAnimationFrame(draw);
        setStatus(`Centered on GPS location (${lat.toFixed(6)}, ${lng.toFixed(6)}).`, "ok");
      },
      (error) => {
        if (btn) btn.classList.remove("primary");
        const msgs = {
          1: "Location permission denied.",
          2: "Location unavailable.",
          3: "Location request timed out."
        };
        setStatus(msgs[error.code] || "Could not get location.", "warn");
      },
      { enableHighAccuracy: true, timeout: 15000, maximumAge: 5000 }
    );
  }

  function zoomToScreenRect(screenRect, options = {}) {
    const { skipHistory = false, silent = false, extentPaddingFraction = 0.06 } = options;
    if (!screenRect) return false;

    const widthPx = Math.max(1, screenRect.maxX - screenRect.minX);
    const heightPx = Math.max(1, screenRect.maxY - screenRect.minY);
    if (widthPx < 3 && heightPx < 3) {
      if (!silent) setStatus("Zoom window is too small.", "warn");
      return false;
    }

    const rect = canvas.getBoundingClientRect();
    const pad = 60;
    const usableW = Math.max(1, rect.width - pad * 2);
    const usableH = Math.max(1, rect.height - pad * 2);

    const worldA = screenToWorld(screenRect.minX, screenRect.maxY);
    const worldB = screenToWorld(screenRect.maxX, screenRect.minY);

    const minX = Math.min(worldA.x, worldB.x);
    const maxX = Math.max(worldA.x, worldB.x);
    const minY = Math.min(worldA.y, worldB.y);
    const maxY = Math.max(worldA.y, worldB.y);

    const padX = Math.max(EPS, (maxX - minX) * extentPaddingFraction);
    const padY = Math.max(EPS, (maxY - minY) * extentPaddingFraction);
    const paddedMinX = minX - padX;
    const paddedMaxX = maxX + padX;
    const paddedMinY = minY - padY;
    const paddedMaxY = maxY + padY;

    const dx = Math.max(EPS, paddedMaxX - paddedMinX);
    const dy = Math.max(EPS, paddedMaxY - paddedMinY);

    const scaleX = usableW / dx;
    const scaleY = usableH / dy;
    const newScale = clamp(Math.min(scaleX, scaleY) * 0.95, MIN_SCALE, MAX_SCALE);

    const cx = (paddedMinX + paddedMaxX) * 0.5;
    const cy = (paddedMinY + paddedMaxY) * 0.5;

    if (!skipHistory) history.push("zoom window");
    view.scale = newScale;
    view.panX = rect.width * 0.5 - cx * view.scale;
    view.panY = rect.height * 0.5 + cy * view.scale;

    if (!silent) {
      setStatus(`Zoomed to window.\nX: [${fmt(paddedMinX)}, ${fmt(paddedMaxX)}]\nY: [${fmt(paddedMinY)}, ${fmt(paddedMaxY)}]`, "ok");
    }
    return true;
  }

  function mmToInches(mm) {
    return Number(mm) / 25.4;
  }

  function resolvePrintPaperSizeInches() {
    const preset = String(printPaperSizeInput?.value || "A3");
    if (preset === "custom") {
      const rawW = Number(printCustomWidthMmInput?.value);
      const rawH = Number(printCustomHeightMmInput?.value);
      const widthIn = mmToInches(Number.isFinite(rawW) ? Math.max(100, rawW) : 420);
      const heightIn = mmToInches(Number.isFinite(rawH) ? Math.max(100, rawH) : 297);
      return {
        label: `Custom ${widthIn.toFixed(2)}" x ${heightIn.toFixed(2)}"`,
        widthIn: Math.max(widthIn, heightIn),
        heightIn: Math.min(widthIn, heightIn)
      };
    }
    const presetSize = PRINT_PAPER_SIZES_MM[preset] || PRINT_PAPER_SIZES_MM.A3;
    return {
      label: preset,
      widthIn: mmToInches(presetSize.widthMm),
      heightIn: mmToInches(presetSize.heightMm)
    };
  }

  function getSelectionWorldBounds() {
    const selectedPointSet = new Set(selectedPointIds);
    for (const selectedLine of selectedLines) {
      const line = lines.get(selectedLine.lineId);
      if (!line) continue;
      selectedPointSet.add(line.a);
      selectedPointSet.add(line.b);
    }
    const selectedPoints = [...selectedPointSet].map((id) => points.get(id)).filter(Boolean);
    if (!selectedPoints.length) return null;

    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    for (const point of selectedPoints) {
      minX = Math.min(minX, point.x);
      minY = Math.min(minY, point.y);
      maxX = Math.max(maxX, point.x);
      maxY = Math.max(maxY, point.y);
    }

    const spanX = Math.max(EPS, maxX - minX);
    const spanY = Math.max(EPS, maxY - minY);
    const padX = Math.max(0.5, spanX * 0.03);
    const padY = Math.max(0.5, spanY * 0.03);

    return {
      minX: minX - padX,
      minY: minY - padY,
      maxX: maxX + padX,
      maxY: maxY + padY
    };
  }

  function chooseClosestPrintScale(bounds, paper, marginIn = 0.5) {
    const worldWidthFeet = Math.max(EPS, bounds.maxX - bounds.minX);
    const worldHeightFeet = Math.max(EPS, bounds.maxY - bounds.minY);
    // Engineering print scales are interpreted as 1" = N' (feet on the ground).
    const printableWidthInches = Math.max(EPS, paper.widthIn - (marginIn * 2));
    const printableHeightInches = Math.max(EPS, paper.heightIn - (marginIn * 2));
    const targetScale = Math.max(worldWidthFeet / printableWidthInches, worldHeightFeet / printableHeightInches);

    let selectedScale = PRINT_SCALES[0];
    let bestDelta = Infinity;
    for (const candidate of PRINT_SCALES) {
      const delta = Math.abs(candidate - targetScale);
      if (delta < bestDelta) {
        bestDelta = delta;
        selectedScale = candidate;
      }
    }

    return { selectedScale, targetScale };
  }

  function worldBoundsFromScreenRect(screenRect) {
    if (!screenRect) return null;
    const worldA = screenToWorld(screenRect.minX, screenRect.maxY);
    const worldB = screenToWorld(screenRect.maxX, screenRect.minY);
    if (!worldA || !worldB) return null;
    return {
      minX: Math.min(worldA.x, worldB.x),
      minY: Math.min(worldA.y, worldB.y),
      maxX: Math.max(worldA.x, worldB.x),
      maxY: Math.max(worldA.y, worldB.y)
    };
  }

  function renderSelectionToPrintDataUrl(bounds, paper, selectedScale) {
    const dpi = 180;
    const pageWidthPx = Math.max(1, Math.round(paper.widthIn * dpi));
    const pageHeightPx = Math.max(1, Math.round(paper.heightIn * dpi));
    const marginPx = Math.round(0.5 * dpi);

    const workingCanvas = document.createElement("canvas");
    workingCanvas.width = pageWidthPx;
    workingCanvas.height = pageHeightPx;
    const printCtx = workingCanvas.getContext("2d");

    printCtx.fillStyle = "#ffffff";
    printCtx.fillRect(0, 0, pageWidthPx, pageHeightPx);

    printCtx.strokeStyle = "#000000";
    printCtx.lineWidth = 1.5;
    printCtx.strokeRect(marginPx * 0.5, marginPx * 0.5, pageWidthPx - marginPx, pageHeightPx - marginPx);

    const titleBlockH = Math.round(0.9 * dpi);
    const drawingLeft = marginPx;
    const drawingTop = marginPx;
    const drawingWidth = pageWidthPx - (marginPx * 2);
    const drawingHeight = pageHeightPx - (marginPx * 2) - titleBlockH;

    printCtx.strokeRect(drawingLeft, drawingTop, drawingWidth, drawingHeight);
    printCtx.strokeRect(drawingLeft, drawingTop + drawingHeight, drawingWidth, titleBlockH);

    const worldWidth = Math.max(EPS, bounds.maxX - bounds.minX);
    const worldHeight = Math.max(EPS, bounds.maxY - bounds.minY);
    const drawScale = Math.min(drawingWidth / worldWidth, drawingHeight / worldHeight);

    const offsetX = drawingLeft + ((drawingWidth - (worldWidth * drawScale)) * 0.5);
    const offsetY = drawingTop + ((drawingHeight - (worldHeight * drawScale)) * 0.5);

    const worldToPrint = (x, y) => ({
      x: offsetX + ((x - bounds.minX) * drawScale),
      y: offsetY + ((bounds.maxY - y) * drawScale)
    });

    const lineInBounds = (line) => {
      const a = points.get(line.a);
      const b = points.get(line.b);
      if (!a || !b) return false;
      const middle = getCurveMiddlePoint(line);
      const xs = middle ? [a.x, b.x, middle.x] : [a.x, b.x];
      const ys = middle ? [a.y, b.y, middle.y] : [a.y, b.y];
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      return !(maxX < bounds.minX || minX > bounds.maxX || maxY < bounds.minY || minY > bounds.maxY);
    };

    printCtx.strokeStyle = "#000000";
    printCtx.lineWidth = 1.8;
    for (const line of lines.values()) {
      if (!lineInBounds(line)) continue;
      const a = points.get(line.a);
      const b = points.get(line.b);
      if (!a || !b) continue;
      const pa = worldToPrint(a.x, a.y);
      const pb = worldToPrint(b.x, b.y);
      traceLinePath(printCtx, line, pa, pb, worldToPrint);
      printCtx.stroke();
    }

    printCtx.lineWidth = 1.2;
    for (const point of points.values()) {
      if (point.x < bounds.minX || point.x > bounds.maxX || point.y < bounds.minY || point.y > bounds.maxY) continue;
      const p = worldToPrint(point.x, point.y);
      printCtx.beginPath();
      printCtx.moveTo(p.x - 5, p.y - 5);
      printCtx.lineTo(p.x + 5, p.y + 5);
      printCtx.moveTo(p.x + 5, p.y - 5);
      printCtx.lineTo(p.x - 5, p.y + 5);
      printCtx.stroke();
    }

    printCtx.fillStyle = "#000000";
    printCtx.font = '16px "Arial", sans-serif';
    printCtx.fillText("Record of Survey Template (Landscape Placeholder)", drawingLeft + 12, drawingTop + drawingHeight + 30);
    printCtx.font = '14px "Arial", sans-serif';
    printCtx.fillText(`Scale 1:${selectedScale} (auto from selected window)`, drawingLeft + 12, drawingTop + drawingHeight + 58);

    return workingCanvas.toDataURL("image/png");
  }

  function updatePrintScalePreview() {
    const bounds = getSelectionWorldBounds();
    if (!bounds) {
      if (printScalePreviewInput) printScalePreviewInput.value = "Select geometry";
      return;
    }
    const paper = resolvePrintPaperSizeInches();
    const result = chooseClosestPrintScale(bounds, paper);
    if (printScalePreviewInput) printScalePreviewInput.value = `1:${result.selectedScale}`;
  }

  function syncPrintWindowCaptureUi() {
    const quickPrintBtn = $("#quickPrintView");
    quickPrintBtn?.classList.toggle("printCaptureArmed", pendingPrintWindowCapture);

    if (pendingPrintWindowCapture) {
      showWorkflowToast({
        title: "Print Window Ready",
        message: "Drag a selection window over the area you want to print, then release.",
        steps: [
          "Click and drag to draw the print window",
          "Release to generate print preview"
        ],
        currentStepIndex: 0
      });
      return;
    }

    hideWorkflowToast();
  }

  function beginPrintWindowCapture() {
    pendingPrintWindowCapture = true;
    setTool("select");
    syncPrintWindowCaptureUi();
    setStatus("Draw a selection window over the area to print, then release.", "ok");
    return true;
  }

  function generatePrintViewFromBounds(bounds) {
    if (!bounds) {
      setStatus("Select at least one point or line before generating print view.", "warn");
      return false;
    }

    const paper = resolvePrintPaperSizeInches();
    const { selectedScale } = chooseClosestPrintScale(bounds, paper);
    const imageUrl = renderSelectionToPrintDataUrl(bounds, paper, selectedScale);
    const printWindow = window.open("", "_blank");
    if (!printWindow) {
      setStatus("Popup blocked. Allow popups to open print preview.", "warn");
      return false;
    }

    const title = `Print View 1:${selectedScale}`;
    printWindow.document.open();
    printWindow.document.write(`<!doctype html><html><head><title>${title}</title><style>body{margin:0;background:#f4f4f4;font-family:Arial,sans-serif;}main{max-width:96vw;margin:12px auto;padding:8px;}img{width:100%;height:auto;background:#fff;border:1px solid #111;box-shadow:0 2px 8px rgba(0,0,0,.15);}button{margin:6px 0;padding:8px 12px;font-size:14px;}</style></head><body><main><button onclick="window.print()">Print</button><div>Paper: ${paper.label} · Scale: 1:${selectedScale}</div><img src="${imageUrl}" alt="Print-ready black and white survey excerpt"/></main></body></html>`);
    printWindow.document.close();

    if (printScalePreviewInput) printScalePreviewInput.value = `1:${selectedScale}`;
    setStatus(`Generated print view on ${paper.label} at 1:${selectedScale}.`, "ok");
    return true;
  }

  function generatePrintViewFromSelection() {
    return generatePrintViewFromBounds(getSelectionWorldBounds());
  }

  // -------------------------
  // CSV import / export
  // -------------------------
  function parseCSV(text) {
    const rows = [];
    let i=0, field="", row=[], inQuotes=false;

    const pushField = () => { row.push(field); field=""; };
    const pushRow = () => { rows.push(row); row=[]; };

    while (i < text.length) {
      const c = text[i];
      if (inQuotes) {
        if (c === '"') {
          if (text[i+1] === '"') { field += '"'; i+=2; continue; }
          inQuotes = false; i++; continue;
        } else {
          field += c; i++; continue;
        }
      } else {
        if (c === '"') { inQuotes = true; i++; continue; }
        if (c === ',') { pushField(); i++; continue; }
        if (c === '\n') { pushField(); pushRow(); i++; continue; }
        if (c === '\r') { i++; continue; }
        field += c; i++; continue;
      }
    }
    pushField();
    pushRow();
    if (rows.length && rows[rows.length-1].every(v => String(v).trim()==="")) rows.pop();
    return rows;
  }
  function normalizeHeader(h) {
    return String(h||"").trim().toLowerCase().replace(/\s+/g,"");
  }
  function csvEscape(v) {
    const s = String(v ?? "");
    if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  }

  // ADDED: Swap all points X/Y (undoable)
  $("#swapXYAll").addEventListener("click", () => {
    if (points.size === 0) { setStatus("No points to swap.", "warn"); return; }
    history.push("swap x y all");
    for (const p of points.values()) {
      const t = p.x;
      p.x = p.y;
      p.y = t;
    }
    schedulePointsTableRender();
    updatePointEditorFromSelection();
    setStatus("Swapped X↔Y for ALL points. (Undo available)", "ok");
  });

  function importCsvText(text, sourceLabel = "CSV import") {
    const rows = parseCSV(text);
    if (!rows.length) { setStatus("CSV appears empty.", "warn"); return false; }

    history.push("csv import");

    let startRow = 0;
    let idx = { num:0, x:1, y:2, z:3, code:4, notes:5 };
    const h = rows[0].map(normalizeHeader);
    const headerLikely = h.includes("number") || h.includes("num") || h.includes("x") || h.includes("y") || h.includes("northing") || h.includes("easting") || h.includes("n") || h.includes("e");
    if (headerLikely) {
      startRow = 1;
      const map = new Map(h.map((v,i)=>[v,i]));
      const pick = (...names)=> {
        for (const n of names) if (map.has(n)) return map.get(n);
        return null;
      };
      idx.num = pick("number","num","pt","point","pointnumber") ?? 0;
      idx.x = pick("x","e","east","easting") ?? 1;
      idx.y = pick("y","n","north","northing") ?? 2;
      idx.z = pick("z","elev","elevation") ?? 3;
      idx.code = pick("code","desc","description") ?? 4;
      idx.notes = pick("notes","note","comments","comment") ?? 5;
    }

    const mode = $("#importMode").value;
    const coordOrder = $("#csvCoordOrder").value; // "xy" | "yx" (used ONLY when header is absent)

    const byNum = new Map();
    for (const p of points.values()) byNum.set(String(p.num), p.id);

    let added=0, updated=0, skipped=0, renamed=0;
    let swappedApplied = 0;

    for (let r = startRow; r < rows.length; r++) {
      const row = rows[r];
      const numRaw = (row[idx.num] ?? "").toString().trim();
      const xRaw = row[idx.x];
      const yRaw = row[idx.y];
      if (!numRaw || xRaw==null || yRaw==null) { skipped++; continue; }

      let x = Number(String(xRaw).trim());
      let y = Number(String(yRaw).trim());
      if (!Number.isFinite(x) || !Number.isFinite(y)) { skipped++; continue; }

      // FIX: root cause for headerless N,E files
      // If there is NO real header and user says columns are Y,X (N,E),
      // then swap parsed values so internal point data remains x=easting, y=northing.
      if (!headerLikely && coordOrder === "yx") {
        const t = x; x = y; y = t;
        swappedApplied++;
      }

      const z = parseNum(row[idx.z], 0);
      const code = String(row[idx.code] ?? "");
      const notes = String(row[idx.notes] ?? "");
      const ruleLayerId = resolveFieldToFinishLayerIdForCode(code);

      let num = numRaw;

      if (byNum.has(num)) {
        if (mode === "merge") {
          const pid = byNum.get(num);
          const p = points.get(pid);
          p.x = x; p.y = y; p.z = z; p.code = code; p.notes = notes;
          if (ruleLayerId && layers.has(ruleLayerId)) p.layerId = ruleLayerId;
          updated++;
          continue;
        }
        if (mode === "skip") { skipped++; continue; }
        if (mode === "rename") {
          const open = nextOpenPointNumber(1);
          num = String(open);
          renamed++;
        }
      }

      const pid = addPoint({ num, x, y, z, code, notes, movable:false, layerId: ruleLayerId || selectedLayerId });
      byNum.set(String(num), pid);
      added++;
    }

    const { jpnLinesAdded, sequentialLinesAdded, curveLinesAdded } = connectFieldToFinishLinework();

    setStatus(`${sourceLabel} done.
Added: ${added}
Updated: ${updated}
Renamed: ${renamed}
Skipped: ${skipped}
Coord-swap applied (headerless only): ${swappedApplied}
JPN lines added: ${jpnLinesAdded}
Field-to-finish sequential lines added: ${sequentialLinesAdded}
Field-to-finish curve segments added: ${curveLinesAdded}`, "ok");

    schedulePointsTableRender();
    if ($("#autoZoomAfterImport").checked) zoomExtents();
    return true;
  }

  function tryImportPointforgePayload() {
    if (launchSource !== "pointforge") return false;

    const raw = localStorage.getItem(POINTFORGE_IMPORT_STORAGE_KEY);
    if (!raw) {
      setStatus("PointForge launch detected, but no import payload was found in local storage.", "warn");
      return false;
    }

    try {
      const payload = JSON.parse(raw);
      if (!payload?.csv) {
        setStatus("PointForge payload was invalid (missing CSV content).", "warn");
        return false;
      }
      importCsvText(payload.csv, "PointForge import");
      const aligned = syncViewToGeoreference(payload);
      setMapLayerEnabled(true);
      if (aligned && mapLayerState.enabled) {
        syncMapToView(true);
      }
      localStorage.removeItem(POINTFORGE_IMPORT_STORAGE_KEY);
      return true;
    } catch (_err) {
      setStatus("PointForge payload could not be parsed.", "warn");
      return false;
    }
  }


  function projectFileStorageKey(projectId) {
    return `${PROJECT_FILE_STORAGE_PREFIX}:${projectId}`;
  }

  function projectLastDrawingStorageKey(projectId) {
    return `${PROJECT_LAST_DRAWING_STORAGE_PREFIX}:${projectId}`;
  }

  function saveLastOpenedProjectDrawing(projectId, storageKey) {
    if (!projectId || !storageKey) return;
    localStorage.setItem(projectLastDrawingStorageKey(projectId), storageKey);
  }

  function loadLastOpenedProjectDrawing(projectId) {
    if (!projectId) return "";
    return String(localStorage.getItem(projectLastDrawingStorageKey(projectId)) || "").trim();
  }

  function drawingStorageKey(projectId, drawingId) {
    return `${PROJECT_DRAWING_STORAGE_PREFIX}:${projectId}:${drawingId}`;
  }

  function normalizeDrawingId(name = "") {
    const slug = String(name || "")
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
    return slug || `drawing-${Date.now()}`;
  }

  function getSerializableStateObject() {
    return JSON.parse(serializeState());
  }

  function markDrawingAsSaved() {
    lastSavedDrawingSnapshot = serializeState();
  }

  function hasUnsavedDrawingChanges() {
    if (!lastSavedDrawingSnapshot) return false;
    return serializeState() !== lastSavedDrawingSnapshot;
  }

  function loadStoredDrawingRecord(storageKey) {
    if (!storageKey) return null;
    try {
      const raw = localStorage.getItem(storageKey);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed?.versions)) return null;
      return parsed;
    } catch {
      return null;
    }
  }

  function materializeDrawingVersion(record, versionIndex = -1) {
    if (!record?.versions?.length) return null;
    const targetIndex = versionIndex >= 0 ? Math.min(versionIndex, record.versions.length - 1) : record.versions.length - 1;
    let state = deepClone(record.versions[0]?.baseState || null);
    if (!state) return null;
    for (let i = 1; i <= targetIndex; i += 1) {
      state = applyStateDiff(state, record.versions[i]?.diffFromPrevious);
    }
    if (!state.mapGeoreference) {
      const fallbackGeoreference = sanitizeMapGeoreference(record.latestMapGeoreference);
      if (fallbackGeoreference) state.mapGeoreference = fallbackGeoreference;
    }
    return state;
  }

  function restoreDrawingVersion(storageKey, versionIndex = -1) {
    const record = loadStoredDrawingRecord(storageKey);
    if (!record) return false;
    const state = materializeDrawingVersion(record, versionIndex);
    if (!state) return false;
    restoreState(JSON.stringify(state));
    markDrawingAsSaved();
    return true;
  }

  function upsertProjectDrawingResource({ projectId, drawingId, drawingName, storageKey, versionCount, latestVersionId, latestMapGeoreference }) {
    if (!projectId) return;
    const key = projectFileStorageKey(projectId);
    const raw = localStorage.getItem(key);
    if (!raw) return;
    let projectFile;
    try {
      projectFile = JSON.parse(raw);
    } catch {
      return;
    }
    if (!Array.isArray(projectFile?.folders)) return;
    const drawingsFolder = projectFile.folders.find((folder) => folder.key === "drawings");
    if (!drawingsFolder) return;
    if (!Array.isArray(drawingsFolder.index)) drawingsFolder.index = [];
    drawingsFolder.index = drawingsFolder.index.filter((entry) => entry && typeof entry === "object");
    const resourceId = `linesmith-${drawingId}`;
    const existing = drawingsFolder.index.find((entry) => entry.id === resourceId);
    const next = {
      id: resourceId,
      folder: "drawings",
      title: drawingName,
      exportFormat: "json",
      reference: {
        type: "local-storage",
        value: storageKey,
        resolverHint: "linesmith-drawing-history",
        metadata: {
          drawingId,
          drawingName,
          versionCount,
          latestVersionId,
          latestSavedAt: new Date().toISOString(),
          latestMapGeoreference,
        },
      },
    };
    if (existing) Object.assign(existing, next);
    else drawingsFolder.index.push(next);
    drawingsFolder.index.sort((a, b) => {
      const aSaved = Date.parse(a?.reference?.metadata?.latestSavedAt || a?.reference?.metadata?.savedAt || "");
      const bSaved = Date.parse(b?.reference?.metadata?.latestSavedAt || b?.reference?.metadata?.savedAt || "");
      const aValue = Number.isFinite(aSaved) ? aSaved : Number.NEGATIVE_INFINITY;
      const bValue = Number.isFinite(bSaved) ? bSaved : Number.NEGATIVE_INFINITY;
      return bValue - aValue;
    });
    localStorage.setItem(key, JSON.stringify(projectFile));
  }

  function saveDrawingToProject() {
    const appliedPendingEdits = applyPendingPrimaryPointEditorEdits("point editor save");
    if (!appliedPendingEdits) return false;

    if (!activeProjectId) {
      setStatus("Open LineSmith from an active project to save drawing history.", "warn");
      return false;
    }
    const drawingNameInput = $("#drawingName");
    const hint = $("#drawingSaveHint");
    let drawingName = String(drawingNameInput?.value || "").trim();
    if (!drawingName) {
      const response = window.prompt("Name this drawing before saving:", "Boundary Base Map");
      drawingName = String(response || "").trim();
      if (!drawingName) {
        setStatus("Enter a drawing name before saving.", "warn");
        return false;
      }
      if (drawingNameInput) drawingNameInput.value = drawingName;
    }

    const drawingId = normalizeDrawingId(drawingName);
    const storageKey = drawingStorageKey(activeProjectId, drawingId);
    const now = new Date().toISOString();
    const currentState = getSerializableStateObject();
    const existing = loadStoredDrawingRecord(storageKey);

    let record;
    if (!existing || !existing.versions?.length) {
      record = {
        schemaVersion: "1.0.0",
        projectId: activeProjectId,
        projectName: activeProjectName,
        drawingId,
        drawingName,
        createdAt: now,
        updatedAt: now,
        versions: [
          {
            versionId: `v-${Date.now()}`,
            savedAt: now,
            label: drawingName,
            baseState: currentState,
          },
        ],
      };
    } else {
      const prevState = materializeDrawingVersion(existing, -1);
      const diff = diffState(prevState, currentState);
      const changePatch = diff === undefined ? {} : diff;
      record = existing;
      record.updatedAt = now;
      record.drawingName = drawingName;
      record.versions.push({
        versionId: `v-${Date.now()}`,
        savedAt: now,
        label: drawingName,
        diffFromPrevious: changePatch,
      });
    }
    record.latestMapGeoreference = sanitizeMapGeoreference(currentState.mapGeoreference);

    localStorage.setItem(storageKey, JSON.stringify(record));
    activeDrawingStorageKey = storageKey;
    saveLastOpenedProjectDrawing(activeProjectId, storageKey);
    upsertProjectDrawingResource({
      projectId: activeProjectId,
      drawingId,
      drawingName,
      storageKey,
      versionCount: record.versions.length,
      latestVersionId: record.versions[record.versions.length - 1]?.versionId || null,
      latestMapGeoreference: record.latestMapGeoreference,
    });
    if (hint) hint.textContent = `Saved ${record.versions.length} version(s) for "${drawingName}" in project ${activeProjectId}.`;
    setStatus(`Saved drawing "${drawingName}" to project history (${record.versions.length} version${record.versions.length === 1 ? "" : "s"}).`, "ok");
    triggerQuickSaveSuccessPulse();
    markDrawingAsSaved();
    return true;
  }

  function triggerQuickSaveSuccessPulse() {
    const quickSaveBtn = $("#quickSave");
    if (!quickSaveBtn) return;
    quickSaveBtn.classList.remove("saveSuccessPulse");
    void quickSaveBtn.offsetWidth;
    quickSaveBtn.classList.add("saveSuccessPulse");
    const removePulseClass = () => quickSaveBtn.classList.remove("saveSuccessPulse");
    quickSaveBtn.addEventListener("animationend", removePulseClass, { once: true });
  }

  function promptRestoreDrawingVersion() {
    const storageKey = activeDrawingStorageKey;
    if (!storageKey) {
      setStatus("No project-linked drawing has been loaded yet.", "warn");
      return;
    }
    const record = loadStoredDrawingRecord(storageKey);
    if (!record?.versions?.length) {
      setStatus("No saved versions were found for this drawing.", "warn");
      return;
    }
    const options = record.versions
      .map((version, index) => `${index + 1}: ${version.savedAt}`)
      .join("\n");
    const response = window.prompt(`Restore which version for ${record.drawingName}?\n${options}\nEnter version number:`, String(record.versions.length));
    if (response === null) return;
    const parsed = Number(response);
    if (!Number.isFinite(parsed) || parsed < 1 || parsed > record.versions.length) {
      setStatus("Invalid version number.", "warn");
      return;
    }
    history.push("restore drawing version");
    const ok = restoreDrawingVersion(storageKey, parsed - 1);
    if (!ok) {
      setStatus("Failed to restore the selected drawing version.", "warn");
      return;
    }
    setStatus(`Restored drawing version ${parsed} of ${record.versions.length}.`, "ok");
  }

  function tryImportProjectBrowserDrawingPayload() {
    if (queryParams.get("source") !== "project-browser-drawing") return false;
    const raw = localStorage.getItem(PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY);
    if (!raw) {
      setStatus("Project Browser drawing launch detected, but payload is missing.", "warn");
      return false;
    }
    try {
      const payload = JSON.parse(raw);
      const storageKey = payload?.storageKey;
      if (!storageKey) {
        setStatus("Project Browser drawing payload was invalid.", "warn");
        return false;
      }
      const restored = restoreDrawingVersion(storageKey, -1);
      if (!restored) {
        setStatus("Drawing file could not be opened from project storage.", "warn");
        return false;
      }
      activeDrawingStorageKey = storageKey;
    saveLastOpenedProjectDrawing(activeProjectId, storageKey);
      const drawingName = String(payload?.drawingName || "").trim();
      if (drawingName) $("#drawingName").value = drawingName;
      localStorage.removeItem(PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY);
      setStatus(`Opened drawing "${drawingName || "Project Drawing"}" from Project Browser.`, "ok");
      return true;
    } catch {
      setStatus("Project Browser drawing payload could not be parsed.", "warn");
      return false;
    }
  }


  function tryRestoreLastOpenedProjectDrawing() {
    if (queryParams.get("source")) return false;
    if (!activeProjectId) return false;
    const storageKey = loadLastOpenedProjectDrawing(activeProjectId);
    if (!storageKey) return false;
    const restored = restoreDrawingVersion(storageKey, -1);
    if (!restored) return false;
    activeDrawingStorageKey = storageKey;
    const record = loadStoredDrawingRecord(storageKey);
    const drawingName = String(record?.drawingName || "").trim();
    if (drawingName) $("#drawingName").value = drawingName;
    setStatus(`Opened last drawing for project ${activeProjectName || activeProjectId}.`, "ok");
    return true;
  }

  $("#saveDrawingToProject").addEventListener("click", saveDrawingToProject);
  $("#restoreDrawingVersion").addEventListener("click", promptRestoreDrawingVersion);
  $("#openArrowHead")?.addEventListener("click", openArrowHeadFromLineSmith);

  $("#csvIn").addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const text = await f.text();
    importCsvText(text);
    $("#csvIn").value = "";
  });



  function buildArrowHeadPayload() {
    return {
      createdAt: new Date().toISOString(),
      source: "linesmith",
      points: Array.from(points.values()).map((p) => ({
        id: p.id,
        num: String(p.num ?? ""),
        x: Number(p.x),
        y: Number(p.y),
        z: Number(p.z),
        code: String(p.code ?? ""),
        notes: String(p.notes ?? "")
      })),
      lines: Array.from(lines.values()).map((line) => ({
        id: line.id,
        a: line.a,
        b: line.b
      })),
      georeference: mapGeoreference ? {
        lat: { ...mapGeoreference.lat },
        lng: { ...mapGeoreference.lng }
      } : null,
      collabRoomId: resolveCollabRoomId()
    };
  }

  function syncArrowHeadPayloadToStorage(options = {}) {
    const force = options.force === true;
    const now = Date.now();
    if (!force && (now - lastArrowHeadPayloadSyncAt) < ARROWHEAD_SYNC_INTERVAL_MS) return;
    lastArrowHeadPayloadSyncAt = now;
    const payloadJson = JSON.stringify(buildArrowHeadPayload());
    if (!force && payloadJson === lastArrowHeadPayloadJson) return;
    lastArrowHeadPayloadJson = payloadJson;
    localStorage.setItem(ARROWHEAD_IMPORT_STORAGE_KEY, payloadJson);
  }

  function openArrowHeadFromLineSmith() {
    if (!ensureArrowHeadLaunchDrawing()) {
      setStatus("Open a project drawing or connect collaboration before opening ArrowHead.", "warn");
      return;
    }
    syncArrowHeadPayloadToStorage({ force: true });
    const params = new URLSearchParams(window.location.search);
    const activeProjectIdParam = params.get("activeProjectId");
    const activeProjectNameParam = params.get("activeProjectName");
    const targetParams = new URLSearchParams({ source: "linesmith" });
    if (activeProjectIdParam) targetParams.set("activeProjectId", activeProjectIdParam);
    if (activeProjectNameParam) targetParams.set("activeProjectName", activeProjectNameParam);
    const targetPath = `/ArrowHead.html?${targetParams.toString()}`;

    try {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({
          type: "survey-cad:navigate-app",
          path: targetPath,
        }, window.location.origin);
      } else {
        window.location.assign(targetPath);
      }
      setStatus("Opening ArrowHead AR with current LineSmith geometry…", "ok");
    } catch (_error) {
      window.location.assign(targetPath);
    }
  }

  function isCollabSocketConnected() {
    return Boolean(collab.enabled && collab.socket && collab.socket.readyState === WebSocket.OPEN);
  }

  function ensureArrowHeadLaunchDrawing() {
    if (points.size) return true;
    if (activeDrawingStorageKey) {
      const restoredActiveDrawing = restoreDrawingVersion(activeDrawingStorageKey, -1);
      if (restoredActiveDrawing && points.size) return true;
    }
    if (activeProjectId) {
      const lastDrawingStorageKey = loadLastOpenedProjectDrawing(activeProjectId);
      if (lastDrawingStorageKey) {
        const restoredLastDrawing = restoreDrawingVersion(lastDrawingStorageKey, -1);
        if (restoredLastDrawing && points.size) {
          activeDrawingStorageKey = lastDrawingStorageKey;
          return true;
        }
      }

    }
    return isCollabSocketConnected();
  }

  $("#exportCsv").addEventListener("click", () => {
    const rows = [];
    rows.push(["number","x","y","z","code","notes"]);
    const sorted = Array.from(points.values()).sort((a,b)=>Number(a.num)-Number(b.num));
    for (const p of sorted) rows.push([p.num, p.x, p.y, p.z, p.code, p.notes].map(v => csvEscape(v)));
    const csv = rows.map(r=>r.join(",")).join("\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "points.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    setStatus("Exported points.csv", "ok");
  });

  // -------------------------
  // Points table (modal) — inline editing
  // -------------------------
  let pointsSortMode = "num";
  let pointsGroupMode = "none";
  let pointsTableDirty = true;
  let pointsTableRaf = null;

  function schedulePointsTableRender() {
    pointsTableDirty = true;
    if (pointsTableRaf) return;
    pointsTableRaf = requestAnimationFrame(() => {
      pointsTableRaf = null;
      if (pointsTableDirty) renderPointsTable();
      pointsTableDirty = false;
    });
  }

  function getFilteredSortedPoints() {
    const filter = String($("#ptFilter").value || "").trim().toLowerCase();
    let arr = Array.from(points.values());

    if (filter) {
      arr = arr.filter(p => {
        const hay = `${p.num} ${p.code} ${p.notes}`.toLowerCase();
        return hay.includes(filter);
      });
    }

    if (pointsSortMode === "num") arr.sort((a,b)=> (Number(a.num)||0) - (Number(b.num)||0));
    else if (pointsSortMode === "id") arr.sort((a,b)=>a.id-b.id);
    else if (pointsSortMode === "code") arr.sort((a,b)=>String(a.code).localeCompare(String(b.code)));
    return arr;
  }

  function colorToRgba(color, alpha = 0.1) {
    const raw = String(color || "").trim();
    let hex = raw;
    if (/^#[0-9a-fA-F]{3}$/.test(hex)) {
      hex = `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}`;
    }
    if (!/^#[0-9a-fA-F]{6}$/.test(hex)) return null;
    const r = Number.parseInt(hex.slice(1, 3), 16);
    const g = Number.parseInt(hex.slice(3, 5), 16);
    const b = Number.parseInt(hex.slice(5, 7), 16);
    return `rgba(${r},${g},${b},${clamp(alpha, 0, 1)})`;
  }

  function pointsGroupLabel(point) {
    if (pointsGroupMode === "layer") {
      return getLayerById(point.layerId)?.name || "(Unknown Layer)";
    }
    if (pointsGroupMode === "code") {
      const code = String(point.code || "").trim();
      return code || "(No Code)";
    }
    return null;
  }

  function getGroupedPoints(sortedPoints) {
    if (pointsGroupMode === "none") return [{ label: null, points: sortedPoints }];

    const groupsByLabel = new Map();
    for (const point of sortedPoints) {
      const label = pointsGroupLabel(point);
      if (!groupsByLabel.has(label)) groupsByLabel.set(label, []);
      groupsByLabel.get(label).push(point);
    }

    return Array.from(groupsByLabel.entries())
      .sort((a, b) => String(a[0]).localeCompare(String(b[0]), undefined, { numeric: true }))
      .map(([label, groupedPoints]) => ({ label, points: groupedPoints }));
  }

  function renderPointsTable() {
    if (!modalIsOpen()) return;

    const tbody = $("#pointsTbody");
    const frag = document.createDocumentFragment();
    tbody.innerHTML = "";

    const arr = getFilteredSortedPoints();
    const groups = getGroupedPoints(arr);
    for (const group of groups) {
      if (group.label != null) {
        const groupRow = document.createElement("tr");
        groupRow.className = "groupRow";
        const groupCell = document.createElement("td");
        groupCell.colSpan = 7;
        const groupCount = group.points.length;
        groupCell.textContent = `${pointsGroupMode === "layer" ? "Layer" : "Code"}: ${group.label} (${groupCount} point${groupCount === 1 ? "" : "s"})`;
        groupRow.appendChild(groupCell);
        frag.appendChild(groupRow);
      }

      for (const p of group.points) {
        const tr = document.createElement("tr");
        const tint = colorToRgba(getLayerById(p.layerId)?.color, 0.12);
        if (tint) tr.style.background = tint;
        if (selectedPointIds.includes(p.id)) tr.classList.add("sel");

        const cellInput = (value, field) => {
        const td = document.createElement("td");
        const inp = document.createElement("input");
        inp.className = "cellInput";
        inp.value = value;
        inp.dataset.pid = p.id;
        inp.dataset.field = field;
        inp.addEventListener("keydown", (e) => e.stopPropagation());
        inp.addEventListener("input", onPointCellInput);
        td.appendChild(inp);
        return { td, inp };
      };

      const numCell = cellInput(p.num, "num");
      const xCell = cellInput(p.x, "x");
      const yCell = cellInput(p.y, "y");
      const zCell = cellInput(p.z, "z");
      const codeCell = cellInput(p.code, "code");
      const notesCell = cellInput(p.notes, "notes");

      const pointSymbolUrl = getPointSymbolPreviewUrl(p.code);
      if (pointSymbolUrl) {
        const numberCellWrap = document.createElement("div");
        numberCellWrap.className = "pointNumberCell";
        const symbolBadge = document.createElement("img");
        symbolBadge.className = "pointSymbolBadge";
        symbolBadge.src = pointSymbolUrl;
        symbolBadge.alt = `Point symbol for ${p.num || ""}`;
        numberCellWrap.append(symbolBadge, numCell.inp);
        numCell.td.innerHTML = "";
        numCell.td.appendChild(numberCellWrap);
      }

      const tdAct = document.createElement("td");
      tdAct.style.whiteSpace = "nowrap";

      const btnSel = document.createElement("button");
      btnSel.className = "cellBtn";
      btnSel.textContent = "Select";
      btnSel.addEventListener("click", (e) => {
        e.preventDefault(); e.stopPropagation();
        selectedPointIds = [p.id];
        selectedPointId = p.id;
        selectedLines = [];
        lastSelectedLineId = null;
        updatePointEditorFromSelection();
        schedulePointsTableRender();
        setStatus(`Selected point ${p.num}.`, "ok");
      });

      const btnMov = document.createElement("button");
      btnMov.className = "cellBtn";
      btnMov.style.marginLeft = "8px";
      btnMov.textContent = isMovable(p.movable) ? "Lock" : "Unlock";
      btnMov.addEventListener("click", (e) => {
        e.preventDefault(); e.stopPropagation();
        if (isLayerLocked(p.layerId)) { setStatus(`Layer ${getLayerById(p.layerId)?.name || p.layerId} is locked.`, "warn"); return; }
        history.push("toggle point movable");
        p.movable = !isMovable(p.movable);
        schedulePointsTableRender();
        setStatus(`Point ${p.num} is now ${isMovable(p.movable) ? "MOVABLE" : "LOCKED"}.`, "ok");
      });

      const btnDel = document.createElement("button");
      btnDel.className = "cellBtn danger";
      btnDel.style.marginLeft = "8px";
      btnDel.textContent = "Delete";
      btnDel.addEventListener("click", (e) => {
        e.preventDefault(); e.stopPropagation();
        if (isLayerLocked(p.layerId)) { setStatus(`Layer ${getLayerById(p.layerId)?.name || p.layerId} is locked.`, "warn"); return; }
        history.push("delete point");
        deletePoint(p.id);
        setStatus(`Deleted point ${p.num}.`, "warn");
      });

      tdAct.appendChild(btnSel);
      tdAct.appendChild(btnMov);
      tdAct.appendChild(btnDel);

      tr.appendChild(numCell.td);
      tr.appendChild(xCell.td);
      tr.appendChild(yCell.td);
      tr.appendChild(zCell.td);
      tr.appendChild(codeCell.td);
      tr.appendChild(notesCell.td);
      tr.appendChild(tdAct);

        frag.appendChild(tr);

        if (pointNumberExists(numCell.inp.value, p.id)) numCell.inp.classList.add("bad");
      }
    }

    tbody.appendChild(frag);
    updateSelectionHUD();
    updateCounts();
  }

  let tableEditPushed = false;
  let tableEditTimer = null;

  function pushTableEditHistoryOnce() {
    if (tableEditPushed) return;
    tableEditPushed = true;
    history.push("edit point table");
    clearTimeout(tableEditTimer);
    tableEditTimer = setTimeout(()=>{ tableEditPushed = false; }, 900);
  }

  function onPointCellInput(e) {
    const inp = e.target;
    const pid = Number(inp.dataset.pid);
    const field = inp.dataset.field;
    const p = points.get(pid);
    if (!p) return;
    if (isLayerLocked(p.layerId)) {
      inp.classList.add("bad");
      setStatus(`Layer ${getLayerById(p.layerId)?.name || p.layerId} is locked.`, "warn");
      return;
    }
    if (isObjectLockedByOther("point", pid)) {
      inp.classList.add("bad");
      setStatus(`Point ${p.num} is locked by another collaborator.`, "warn");
      triggerLockDeniedFlash();
      return;
    }

    pushTableEditHistoryOnce();

    if (field === "num") {
      const raw = String(inp.value).trim();
      if (!raw || pointNumberExists(raw, p.id)) { inp.classList.add("bad"); return; }
      inp.classList.remove("bad");
      p.num = raw;
      if (selectedPointId === pid) $("#ptNum").value = raw;
      updateCounts();
      scheduleCollabStateSync();
      return;
    }

    if (field === "x" || field === "y" || field === "z") {
      const val = Number(String(inp.value).trim());
      if (!Number.isFinite(val)) { inp.classList.add("bad"); return; }
      inp.classList.remove("bad");
      p[field] = val;
      if (selectedPointId === pid) {
        if (field === "x") $("#ptX").value = val;
        if (field === "y") $("#ptY").value = val;
        if (field === "z") $("#ptZ").value = val;
      }
      scheduleCollabStateSync();
      return;
    }

    if (field === "code" || field === "notes") {
      inp.classList.remove("bad");
      if (field === "code") setPointCode(p, String(inp.value));
      else p[field] = String(inp.value);
      if (selectedPointId === pid) {
        if (field === "code") $("#ptCode").value = p.code;
        if (field === "notes") $("#ptNotes").value = p.notes;
      }
      if (field === "code") {
        ensureLegacyAutoFieldToFinishLineMetadata();
        const { addedJpn, addedSequential, addedCurve, removed } = syncFieldToFinishLinework();
        if (addedJpn > 0 || addedSequential > 0 || addedCurve > 0 || removed > 0) {
          setStatus(`Auto-updated linework for point ${p.num}: +${addedJpn} JPN, +${addedSequential} sequential, +${addedCurve} curve, -${removed} removed.`, "ok");
        }
      }
      scheduleCollabStateSync();
      return;
    }
  }

  $("#ptFilter").addEventListener("input", () => schedulePointsTableRender());
  $("#ptGroupBy").addEventListener("change", (event) => {
    pointsGroupMode = String(event.target?.value || "none");
    schedulePointsTableRender();
  });
  $("#refreshPoints").addEventListener("click", () => schedulePointsTableRender());
  $("#sortPoints").addEventListener("click", () => {
    pointsSortMode = (pointsSortMode === "num") ? "code" : (pointsSortMode === "code" ? "id" : "num");
    $("#sortPoints").textContent = `Sort: ${pointsSortMode === "num" ? "Num" : (pointsSortMode === "code" ? "Code" : "ID")}`;
    schedulePointsTableRender();
  });

  // -------------------------
  // Line creation & ops (unchanged behavior)
  // -------------------------
  setBasisOfBearingBtn?.addEventListener("click", () => {
    const startRef = String(basisBearingStartPointInput?.value ?? "").trim();
    const endRef = String(basisBearingEndPointInput?.value ?? "").trim();
    const recordBearingInput = String(basisBearingRecordBearingInput?.value ?? "").trim();
    const recordDistanceInput = String(basisBearingRecordDistanceInput?.value ?? "").trim();
    const startPoint = resolvePointByNumberOrName(startRef);
    const endPoint = resolvePointByNumberOrName(endRef);
    const value = sanitizeBasisOfBearing({
      startPointId: startPoint?.id,
      endPointId: endPoint?.id
    });
    if (!value) {
      setStatus("Basis of bearing requires two existing, distinct points by point number/name.", "warn");
      return;
    }

    const parsedRecordAz = recordBearingInput ? bearingToAzimuthRad(recordBearingInput) : null;
    if (recordBearingInput && parsedRecordAz == null) {
      setStatus("Record basis bearing format is not recognized.", "warn");
      return;
    }

    history.push("set basis of bearing");
    basisOfBearing = value;
    recordBasisBearing = recordBearingInput;
    recordBasisDistance = recordDistanceInput;
    syncBasisOfBearingInputs();
    scheduleCollabStateSync();

    const basisAz = basisAzimuthRad();
    const measuredBearing = basisAz == null ? null : azimuthRadToQuadrantString(geometryAzimuthToDrawingAzimuth(basisAz));
    if (recordBearingInput && measuredBearing) {
      setStatus(`Basis of bearing set. Measured ${measuredBearing} vs record ${recordBasisBearing}. Drawing rotation applied from start point.`, "ok");
      return;
    }
    setStatus("Basis of bearing set from selected points and labeled on the drawing.", "ok");
  });

  clearBasisOfBearingBtn?.addEventListener("click", () => {
    if (!basisOfBearing && !recordBasisBearing && !recordBasisDistance) {
      setStatus("No basis of bearing is currently defined.", "warn");
      return;
    }
    history.push("clear basis of bearing");
    basisOfBearing = null;
    recordBasisBearing = "";
    recordBasisDistance = "";
    syncBasisOfBearingInputs();
    scheduleCollabStateSync();
    setStatus("Basis of bearing cleared.", "ok");
  });

  $("#setStartFromSel").addEventListener("click", () => {
    if (!selectedPointId) { setStatus("Select a start point first.", "warn"); return; }
    construction.startPointId = selectedPointId;
    setStatus(`Start point set to ${points.get(selectedPointId)?.num ?? "?"}.`, "ok");
    syncToolWorkflowToast();
  });

  function clearPointNumberField() { $("#ptNum").value = ""; }

  $("#makeLineDB").addEventListener("click", () => {
    const startId = construction.startPointId ?? selectedPointId;
    if (!startId || !points.has(startId)) {
      setStatus("Select a start point (or click 'Use Selected Point as Start').", "warn");
      return;
    }
    const d = parseNum($("#dist").value, NaN);
    const azInput = bearingToAzimuthRad($("#bearing").value);
    if (!Number.isFinite(d) || d <= 0) { setStatus("Distance must be a positive number.", "warn"); return; }
    if (azInput == null) { setStatus("Bearing/Azimuth not recognized.", "warn"); return; }

    const az = drawingAzimuthToGeometryAzimuth(azInput);

    history.push("line dist/bearing");

    const sp = points.get(startId);
    const dx = Math.sin(az);
    const dy = Math.cos(az);
    const x2 = sp.x + dx*d;
    const y2 = sp.y + dy*d;

    const num = resolveDesiredPointNumber($("#ptNum").value);
    const z = parseNum($("#ptZ").value, 0);
    const code = String($("#ptCode").value || "");
    const notes = String($("#ptNotes").value || "");
    const pid2 = addPoint({ num, x:x2, y:y2, z, code, notes, movable:false });
    const lid = addManualLine(startId, pid2, false);

    selectedPointIds = [pid2];
    selectedPointId = pid2;
    selectedLines = [{ lineId: lid, grip: "b", t: 1 }];
    lastSelectedLineId = lid;

    updatePointEditorFromSelection();
    clearPointNumberField();
    setStatus(`Created point ${points.get(pid2).num} and line from ${sp.num}.\nAz: ${azimuthRadToQuadrantString(azInput)}  Dist: ${d}`, "ok");
    syncToolWorkflowToast();
  });

  async function runLineBetweenSelectedPoints({ returnToSelectionTool = false } = {}) {
    if (selectedPointIds.length < 2) {
      setStatus("Select at least two points (Shift-click to multi-select, or window-drag).", "warn");
      return;
    }
    const ids = selectedPointIds.filter(id => points.has(id));
    if (ids.length < 2) { setStatus("Selected points are invalid.", "warn"); return; }

    function pointComparatorByNumber(aId, bId) {
      const a = points.get(aId);
      const b = points.get(bId);
      const aNumRaw = Number.parseFloat(String(a?.num ?? ""));
      const bNumRaw = Number.parseFloat(String(b?.num ?? ""));
      const aFinite = Number.isFinite(aNumRaw);
      const bFinite = Number.isFinite(bNumRaw);
      if (aFinite && bFinite && aNumRaw !== bNumRaw) return aNumRaw - bNumRaw;
      if (aFinite !== bFinite) return aFinite ? -1 : 1;
      return String(a?.num ?? "").localeCompare(String(b?.num ?? ""), undefined, { numeric: true, sensitivity: "base" });
    }

    function arePointsDirectlyConnected(aId, bId) {
      for (const ln of lines.values()) {
        if ((ln.a === aId && ln.b === bId) || (ln.a === bId && ln.b === aId)) return true;
      }
      return false;
    }

    function getDistanceBetweenPoints(aId, bId) {
      const a = points.get(aId);
      const b = points.get(bId);
      if (!a || !b) return Number.POSITIVE_INFINITY;
      return dist(a.x, a.y, b.x, b.y);
    }

    function shouldSuggestNearestNonConnectedOrder(pointIds) {
      if (pointIds.length <= 2) return false;
      const sequentialIds = [...pointIds].sort(pointComparatorByNumber);
      for (let i = 0; i < sequentialIds.length - 1; i += 1) {
        const currentId = sequentialIds[i];
        const sequentialId = sequentialIds[i + 1];
        const sequentialDistance = getDistanceBetweenPoints(currentId, sequentialId);
        let nearestNonConnectedDistance = Number.POSITIVE_INFINITY;
        for (const candidateId of sequentialIds) {
          if (candidateId === currentId || arePointsDirectlyConnected(currentId, candidateId)) continue;
          const candidateDistance = getDistanceBetweenPoints(currentId, candidateId);
          if (candidateDistance < nearestNonConnectedDistance) nearestNonConnectedDistance = candidateDistance;
        }
        if (Number.isFinite(nearestNonConnectedDistance) && nearestNonConnectedDistance + EPS < sequentialDistance) return true;
      }
      return false;
    }

    function buildNearestNonConnectedOrder(pointIds) {
      if (pointIds.length <= 2) return [...pointIds];
      const order = [pointIds[0]];
      const remaining = new Set(pointIds.slice(1));
      while (remaining.size) {
        const currentId = order[order.length - 1];
        const candidates = [...remaining];
        let bestId = null;
        let bestDistance = Number.POSITIVE_INFINITY;
        for (const candidateId of candidates) {
          if (arePointsDirectlyConnected(currentId, candidateId)) continue;
          const candidateDistance = getDistanceBetweenPoints(currentId, candidateId);
          if (candidateDistance < bestDistance) {
            bestDistance = candidateDistance;
            bestId = candidateId;
          }
        }
        if (bestId == null) {
          for (const candidateId of candidates) {
            const candidateDistance = getDistanceBetweenPoints(currentId, candidateId);
            if (candidateDistance < bestDistance) {
              bestDistance = candidateDistance;
              bestId = candidateId;
            }
          }
        }
        order.push(bestId);
        remaining.delete(bestId);
      }
      return order;
    }

    function createLinesFromOrderedPoints(orderedIds) {
      let created = 0;
      let lastLine = null;
      if (orderedIds.length === 2) {
        lastLine = addManualLine(orderedIds[0], orderedIds[1], false);
        created = 1;
      } else {
        for (let i = 0; i < orderedIds.length - 1; i += 1) {
          lastLine = addManualLine(orderedIds[i], orderedIds[i + 1], false);
          created += 1;
        }
      }
      return { created, lastLine };
    }

    let connectIds = ids;
    let connectionLabel = "selection order";
    if (shouldSuggestNearestNonConnectedOrder(ids)) {
      const orderChoice = await askConnectLinesOrder();
      if (orderChoice === "distance") {
        connectIds = buildNearestNonConnectedOrder(ids);
        connectionLabel = "nearest non-connected selected points";
      }
    }

    history.push("line between points");
    const { created, lastLine } = createLinesFromOrderedPoints(connectIds);

    selectedLines = lastLine ? [{ lineId: lastLine, grip:"b", t: 1 }] : [];
    lastSelectedLineId = lastLine;

    const nums = connectIds.map(id => points.get(id)?.num ?? "?");
    setStatus(`Created ${created} line(s) using ${connectionLabel}:\n${nums.join(" → ")}`, "ok");
    if (returnToSelectionTool) setTool("select");
  }

  $("#lineBetweenSelected").addEventListener("click", () => {
    runLineBetweenSelectedPoints();
  });

  function getTwoSelectedLines() {
    if (selectedLines.length < 2) return null;
    const aSel = selectedLines[selectedLines.length - 2];
    const bSel = selectedLines[selectedLines.length - 1];
    const la = lines.get(aSel.lineId);
    const lb = lines.get(bSel.lineId);
    if (!la || !lb) return null;
    const a1 = points.get(la.a), a2 = points.get(la.b);
    const b1 = points.get(lb.a), b2 = points.get(lb.b);
    if (!a1 || !a2 || !b1 || !b2) return null;
    return { aSel, bSel, la, lb, a1, a2, b1, b2 };
  }

  function intersectionPointDefaults() {
    const z = parseNum($("#ptZ").value, 0);
    let code = String($("#ptCode").value || "").trim();
    const notes = String($("#ptNotes").value || "").trim();
    if (!code) code = "INT";
    return { z, code, notes };
  }

  function trimGripFromClickSide(activeSelection, hitParam) {
    if (!Number.isFinite(hitParam)) return activeSelection.grip;
    if (!Number.isFinite(activeSelection?.t)) return activeSelection.grip;
    if (Math.abs(activeSelection.t - hitParam) < 1e-9) return activeSelection.grip;
    return activeSelection.t < hitParam ? "a" : "b";
  }

  function offsetSelectedLineByDistance(rawDistance) {
    if (!lastSelectedLineId || !lines.has(lastSelectedLineId)) {
      setStatus("Select a line first.", "warn");
      return false;
    }
    const distance = parseNum(rawDistance, NaN);
    if (!Number.isFinite(distance)) {
      setStatus("Offset distance must be a number.", "warn");
      return false;
    }

    const ln = lines.get(lastSelectedLineId);
    const a = points.get(ln.a);
    const b = points.get(ln.b);
    if (!a || !b) return false;

    const vx = b.x - a.x;
    const vy = b.y - a.y;
    const len = Math.hypot(vx, vy);
    if (len < EPS) {
      setStatus("Cannot offset a zero-length line.", "warn");
      return false;
    }

    history.push("offset selected line");

    const nx = -vy / len;
    const ny = vx / len;
    const dx = nx * distance;
    const dy = ny * distance;

    const defaultZ = parseNum($("#ptZ").value, 0);
    const defaultCode = String($("#ptCode").value || "").trim();
    const defaultNotes = String($("#ptNotes").value || "").trim();

    const aNum = nextOpenPointNumber();
    const aId = addPoint({ num: aNum, x: a.x + dx, y: a.y + dy, z: defaultZ, code: defaultCode, notes: defaultNotes, movable:false });
    const bNum = nextOpenPointNumber();
    const bId = addPoint({ num: bNum, x: b.x + dx, y: b.y + dy, z: defaultZ, code: defaultCode, notes: defaultNotes, movable:false });
    const newLineId = addManualLine(aId, bId, false);

    selectedPointIds = [aId, bId];
    selectedPointId = bId;
    selectedLines = [{ lineId: newLineId, grip: "b", t: 1 }];
    lastSelectedLineId = newLineId;
    updatePointEditorFromSelection();
    schedulePointsTableRender();

    const sideLabel = distance >= 0 ? "left" : "right";
    setStatus(`Offset line created at ${fmt(Math.abs(distance))} ${sideLabel} of selected line.`, "ok");
    return true;
  }

  $("#extendToIntersect").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) {
      startLineIntersectionCommand("extend");
      return;
    }

    stopLineIntersectionCommand();
    const hit = lineLineIntersection(s.a1, s.a2, s.b1, s.b2);
    if (!hit) { setStatus("Lines are parallel/colinear; no unique intersection.", "warn"); return; }

    const activeSel = s.bSel;
    const ln = lines.get(activeSel.lineId);
    const A = points.get(ln.a), B = points.get(ln.b);
    if (!A || !B) return;

    const t = pointOnLineParam({x:hit.x,y:hit.y}, A, B);
    if (t >= 0 && t <= 1) {
      setStatus("Intersection already lies on the active segment. (Extend does nothing.)", "ok");
      return;
    }

    history.push("extend to intersect (new point)");

    const num = resolveDesiredPointNumber($("#ptNum").value);
    const { z, code, notes } = intersectionPointDefaults();
    const pidNew = addPoint({ num, x: hit.x, y: hit.y, z, code, notes, movable:false });

    if (t < 0) ln.a = pidNew;
    else ln.b = pidNew;

    selectedPointIds = [pidNew];
    selectedPointId = pidNew;
    selectedLines = [{ lineId: ln.id, grip: (t < 0 ? "a" : "b"), t: 0.5 }];
    lastSelectedLineId = ln.id;
    updatePointEditorFromSelection();
    clearPointNumberField();

    setStatus(
      `Extended active line to intersection WITHOUT moving the original endpoint.\n` +
      `Created point ${points.get(pidNew).num} at (${fmt(hit.x)}, ${fmt(hit.y)}).`,
      "ok"
    );
  });

  $("#trimToIntersect").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) {
      startLineIntersectionCommand("trim");
      return;
    }
    stopLineIntersectionCommand();
    const hit = lineLineIntersection(s.a1, s.a2, s.b1, s.b2);
    if (!hit) { setStatus("Lines are parallel/colinear; no unique intersection.", "warn"); return; }

    history.push("trim to intersect");

    const active = s.bSel;
    const ln = lines.get(active.lineId);
    if (isLineLockedByLayer(active.lineId)) { setStatus("Layer is locked; line edits are blocked.", "warn"); return; }
    const A = points.get(ln.a), B = points.get(ln.b);
    if (!A || !B) return;
    const hitT = pointOnLineParam({x:hit.x, y:hit.y}, A, B);
    const trimGrip = trimGripFromClickSide(active, hitT);
    const gripPid = (trimGrip === "a") ? ln.a : ln.b;
    const gp = points.get(gripPid);
    gp.x = hit.x; gp.y = hit.y;
    active.grip = trimGrip;

    schedulePointsTableRender();
    setStatus(`Trimmed active line (grip ${trimGrip.toUpperCase()}) to intersection at (${fmt(hit.x)}, ${fmt(hit.y)}).`, "ok");
  });

  $("#pointAtIntersection").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) { setStatus("Select two lines (Shift-click) to create an intersection point.", "warn"); return; }
    const hit = lineLineIntersection(s.a1, s.a2, s.b1, s.b2);
    if (!hit) { setStatus("Lines are parallel/colinear; no unique intersection.", "warn"); return; }

    history.push("create point at intersection");

    const num = resolveDesiredPointNumber($("#ptNum").value);
    const z = parseNum($("#ptZ").value, 0);
    const code = String($("#ptCode").value || "");
    const notes = String($("#ptNotes").value || "");
    const pid = addPoint({ num, x: hit.x, y: hit.y, z, code, notes, movable:false });

    selectedPointIds = [pid];
    selectedPointId = pid;
    selectedLines = [];
    lastSelectedLineId = null;
    updatePointEditorFromSelection();
    clearPointNumberField();

    setStatus(`Created point ${points.get(pid).num} at intersection (${fmt(hit.x)}, ${fmt(hit.y)}).`, "ok");
  });

  $("#trimOverlap").addEventListener("click", () => {
    const s = getTwoSelectedLines();
    if (!s) { setStatus("Select two colinear overlapping lines (Shift-click).", "warn"); return; }

    const ov = isColinearOverlap(s.a1,s.a2,s.b1,s.b2);
    if (!ov) { setStatus("No colinear overlap detected (or lines not colinear).", "warn"); return; }

    history.push("trim overlap");

    const active = s.bSel;
    const ln = lines.get(active.lineId);
    if (isLineLockedByLayer(active.lineId)) { setStatus("Layer is locked; line edits are blocked.", "warn"); return; }
    const pA = points.get(ln.a), pB = points.get(ln.b);
    if (!pA || !pB) return;

    const proj = (p)=> ov.useX ? p.x : p.y;

    const grip = active.grip;
    const gPid = (grip === "a") ? ln.a : ln.b;
    const oPid = (grip === "a") ? ln.b : ln.a;
    const gp = points.get(gPid);
    const op = points.get(oPid);

    const gVal = proj(gp);
    const candidates = [ov.oMin, ov.oMax];

    let best = candidates[0];
    let bestD = Math.abs(gVal - best);
    for (const c of candidates.slice(1)) {
      const d = Math.abs(gVal - c);
      if (d < bestD) { bestD = d; best = c; }
    }

    const denom = (ov.useX ? (op.x - gp.x) : (op.y - gp.y));
    if (Math.abs(denom) < EPS) {
      setStatus("Cannot trim overlap (degenerate line).", "warn");
      return;
    }
    const t = (best - (ov.useX ? gp.x : gp.y)) / denom;
    gp.x = gp.x + t*(op.x - gp.x);
    gp.y = gp.y + t*(op.y - gp.y);

    schedulePointsTableRender();
    setStatus("Trimmed overlap on active line at overlap boundary.", "ok");
  });

  $("#offsetSelectedLine").addEventListener("click", () => {
    offsetSelectedLineByDistance($("#lineOffsetDistance").value);
  });

  // -------------------------
  // Point on line
  // -------------------------
  $("#makePointOnLine").addEventListener("click", () => {
    if (!lastSelectedLineId || !lines.has(lastSelectedLineId)) {
      setStatus("Select a line first.", "warn");
      return;
    }
    const ln = lines.get(lastSelectedLineId);
    if (isLineLockedByLayer(lastSelectedLineId)) { setStatus("Layer is locked; line edits are blocked.", "warn"); return; }
    const pa = points.get(ln.a), pb = points.get(ln.b);
    if (!pa || !pb) return;

    const station = parseNum($("#station").value, NaN);
    const offset = parseNum($("#offset").value, 0);
    if (!Number.isFinite(station)) { setStatus("Station must be a number.", "warn"); return; }

    const from = $("#stationFrom").value;
    const A = (from === "a") ? pa : pb;
    const B = (from === "a") ? pb : pa;

    const vx = B.x - A.x, vy = B.y - A.y;
    const L = Math.hypot(vx,vy);
    if (L < EPS) { setStatus("Line is too short.", "warn"); return; }

    history.push("point on line");

    const t = station / L;
    const x = A.x + vx * t;
    const y = A.y + vy * t;

    const nx = -vy / L;
    const ny =  vx / L;

    const x2 = x + nx * offset;
    const y2 = y + ny * offset;

    const num = resolveDesiredPointNumber($("#ptNum").value);
    const z = parseNum($("#ptZ").value, 0);
    const code = String($("#ptCode").value || "");
    const notes = String($("#ptNotes").value || "");
    const pid = addPoint({ num, x:x2, y:y2, z, code, notes, movable:false });

    selectedPointIds = [pid];
    selectedPointId = pid;
    selectedLines = [];
    lastSelectedLineId = null;
    updatePointEditorFromSelection();
    clearPointNumberField();

    setStatus(`Created point ${points.get(pid).num} on line at station ${station} offset ${offset}.`, "ok");
    syncToolWorkflowToast();
  });

  $("#swapLineEnds").addEventListener("click", () => {
    if (!lastSelectedLineId || !lines.has(lastSelectedLineId)) {
      setStatus("Select a line first.", "warn");
      return;
    }
    if (isLineLockedByLayer(lastSelectedLineId)) { setStatus("Layer is locked; line edits are blocked.", "warn"); return; }
    history.push("swap line ends");
    const ln = lines.get(lastSelectedLineId);
    const tmp = ln.a; ln.a = ln.b; ln.b = tmp;
    setStatus("Swapped line ends A ↔ B.", "ok");
  });

  // -------------------------
  // Canvas interaction
  // -------------------------
  function updateMouseFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
    const w = screenToWorld(mouse.x, mouse.y);
    mouse.wx = w.x;
    mouse.wy = w.y;
  }

  function beginDrag(obj) {
    mouse.drag = true;
    mouse.dragObj = obj;
    mouse.dragStartX = mouse.x;
    mouse.dragStartY = mouse.y;
    mouse.dragStartPanX = view.panX;
    mouse.dragStartPanY = view.panY;
    mouse.dragStartWorldX = mouse.wx;
    mouse.dragStartWorldY = mouse.wy;
  }
  function endDrag() {
    mouse.drag = false;
    mouse.dragObj = null;
    if (collab.activeDragLock) {
      const activeLock = collab.activeDragLock;
      collab.activeDragLock = null;
      if (collab.enabled && collab.socket?.readyState === WebSocket.OPEN
        && (collab.stateDebounce || collab.pendingState || collab.stateInFlight)) {
        collab.pendingDragLockRelease = activeLock;
        flushPendingDragLockRelease();
      } else {
        sendLockRelease(activeLock);
      }
    }
  }

  const keys = { space:false, shift:false };

  function toolIsPan() {
    return tool === "pan" || keys.space || mouse.button === 1;
  }

  function clearLongPressTimer() {
    if (mobileInteraction.longPressTimer) {
      window.clearTimeout(mobileInteraction.longPressTimer);
      mobileInteraction.longPressTimer = null;
    }
  }

  function setDrawerOpen(open) {
    if (!appShell) return;
    appShell.classList.toggle("drawerOpen", !!open);
    if (drawerToggle) drawerToggle.textContent = open ? "Close" : "Tools";
  }

  function setMobileToolbarsHidden(hidden) {
    if (!appShell) return;
    const shouldHide = isMobileViewport() && !!hidden;
    mobileToolbarsHidden = shouldHide;
    appShell.classList.toggle("mobileToolbarsHidden", shouldHide);
    if (mobileToolbarToggle) {
      mobileToolbarToggle.textContent = shouldHide ? "Show Bars" : "Hide Bars";
      mobileToolbarToggle.setAttribute("aria-pressed", shouldHide ? "true" : "false");
      mobileToolbarToggle.setAttribute("aria-label", shouldHide ? "Show quick toolbars" : "Hide quick toolbars");
    }
  }

  function setPanelCollapsed(collapsed) {
    if (!appShell) return;
    const shouldCollapse = !isMobileViewport() && !!collapsed;
    appShell.classList.toggle("panelCollapsed", shouldCollapse);
    window.requestAnimationFrame(() => {
      resize();
      if (mapLayerState.enabled) syncMapToView(true);
    });
  }

  function syncPanelCollapseWithSelection() {
    const hasSelection = selectedPointIds.length > 0 || selectedLines.length > 0;
    if (isMobileViewport()) {
      setDrawerOpen(hasSelection);
      setPanelCollapsed(false);
      setMobileToolbarsHidden(mobileToolbarsHidden);
      return;
    }
    setDrawerOpen(false);
    setMobileToolbarsHidden(false);
    setPanelCollapsed(!hasSelection);
  }

  function isMobileViewport() {
    return window.matchMedia("(max-width: 960px)").matches;
  }

  function updateTouchPoint(e) {
    const rect = canvas.getBoundingClientRect();
    touchGesture.points.set(e.pointerId, {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    });
  }

  function removeTouchPoint(pointerId) {
    touchGesture.points.delete(pointerId);
  }

  function getTouchCenter() {
    const pts = [...touchGesture.points.values()];
    if (!pts.length) return null;
    const sum = pts.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
    return { x: sum.x / pts.length, y: sum.y / pts.length };
  }

  function getTouchDistance() {
    const pts = [...touchGesture.points.values()];
    if (pts.length < 2) return 0;
    return dist(pts[0].x, pts[0].y, pts[1].x, pts[1].y);
  }

  // ADDED: hard-reset keys/drag on blur so Space-pan can't get "stuck"
  window.addEventListener("blur", () => {
    keys.space = false;
    keys.shift = false;
    mouse.down = false;
    endDrag();
  });

  window.addEventListener("keydown", (e) => {
    const typing = isEditableTarget(e.target);
    const key = e.key.toLowerCase();

    if (maybeRouteKeystrokeToQuickCommandSearch(e)) return;

    if ((e.ctrlKey || e.metaKey) && !e.altKey && key === "s") {
      e.preventDefault();
      saveDrawingToProject();
      return;
    }

    if ((e.ctrlKey || e.metaKey) && !e.altKey && key === "p") {
      e.preventDefault();
      $("#generatePrintView")?.click();
      return;
    }

    if (e.code === "Space") {
      keys.space = true;
      if (!typing) e.preventDefault();
    }
    if (e.key === "Shift") keys.shift = true;

    if (!typing && (e.key === "Delete")) {
      e.preventDefault();
      doDeleteSelected();
    }

    if (!typing && e.key === "Escape") {
      e.preventDefault();
      runCanvasCancelOrClearAction({ trigger: "escape" });
    }

    if (!typing && (e.ctrlKey || e.metaKey) && !e.altKey) {
      if (key === "z") {
        e.preventDefault();
        if (e.shiftKey) history.redoAction();
        else history.undoAction();
      } else if (key === "y") {
        e.preventDefault();
        history.redoAction();
      }
    }
  });

  window.addEventListener("keyup", (e) => {
    if (e.code === "Space") keys.space = false;
    if (e.key === "Shift") keys.shift = false;
  });

  canvas.addEventListener("dblclick", (e) => {
    updateMouseFromEvent(e);
    const cluster = pointDisplayVisibility.clustering ? getPointClusterAtScreen(mouse.x, mouse.y) : null;
    if (cluster) {
      selectedPointIds = [];
      selectedPointId = null;
      selectedLines = [];
      lastSelectedLineId = null;
      updatePointEditorFromSelection();
      schedulePointsTableRender();
      history.push("zoom to point cluster");
      zoomToWorldBounds(cluster.minX, cluster.minY, cluster.maxX, cluster.maxY, { paddingFraction: 0.15 });
      setStatus(`Zoomed to ${cluster.members.length}-point cluster with 15% padding.`, "ok");
      return;
    }

    const pid = pickPoint(mouse.x, mouse.y, 10);
    const lpick = pid ? null : pickLine(mouse.x, mouse.y, 8);

    if (pid) {
      if (isPointLockedByLayer(pid)) { setStatus("Layer is locked; point edits are blocked.", "warn"); return; }
      history.push("toggle point movable");
      const p = points.get(pid);
      p.movable = !isMovable(p.movable);
      rememberLastUnlockedEntity("point", pid, isMovable(p.movable));
      setStatus(`Point ${p.num} is now ${isMovable(p.movable) ? "MOVABLE (drag enabled)" : "LOCKED (drag disabled)"}.`, "ok");
      schedulePointsTableRender();
      return;
    }
    if (lpick) {
      if (isLineLockedByLayer(lpick.lineId)) { setStatus("Layer is locked; line edits are blocked.", "warn"); return; }
      history.push("toggle line movable");
      const ln = lines.get(lpick.lineId);
      ln.movable = !isMovable(ln.movable);
      rememberLastUnlockedEntity("line", lpick.lineId, isMovable(ln.movable));
      setStatus(`Line ${ln.id} is now ${isMovable(ln.movable) ? "MOVABLE (drag enabled)" : "LOCKED (drag disabled)"}.`, "ok");
      schedulePointsTableRender();
      return;
    }
  });

  function handleCanvasPrimaryAction({ additive = false, forcedPointId = null } = {}) {
    const pid = forcedPointId != null ? forcedPointId : pickPoint(mouse.x, mouse.y, 10);
    const lpick = pid ? null : pickLine(mouse.x, mouse.y, 8);

    if (rotateSelectionSession.active && !rotateSelectionSession.awaitingSelection) {
      handleRotateSelectionCanvasPick(mouse.x, mouse.y);
      return;
    }

    if (tool === "select") {
      if (pid) {
        if (!additive) { selectedLines = []; lastSelectedLineId = null; }
        const idx = selectedPointIds.indexOf(pid);
        if (!additive) selectedPointIds = [pid];
        else {
          if (idx >= 0) selectedPointIds.splice(idx,1);
          else selectedPointIds.push(pid);
        }
        selectedPointId = selectedPointIds.length ? selectedPointIds[selectedPointIds.length-1] : null;
        updatePointEditorFromSelection();
        schedulePointsTableRender();
        if (rotateSelectionSession.active) {
          if (rotateSelectionSession.awaitingSelection && getRotatablePointIdsFromSelection().length) {
            rotateSelectionSession.awaitingSelection = false;
            rotateSelectionSession.step = 0;
            setStatus("Selection captured. Click base point.", "ok");
          }
          syncRotateWorkflowToast();
        }

        const p = points.get(pid);
        if (selectedPointId === pid && isMovable(p?.movable) && !isPointLockedByLayer(pid)) {
          history.push("move point");
          const lockRequested = requestObjectEditLock({
            entityType: "point",
            entityId: pid,
            onGranted: () => {
              collab.activeDragLock = { entityType: "point", entityId: pid };
              beginDrag({type:"point", id: pid, _moved:false});
            },
            onDenied: () => {
              history.undo.pop();
              updateUndoRedoHUD();
            }
          });
          if (!lockRequested) {
            history.undo.pop();
            updateUndoRedoHUD();
          }
        }
        return;
      }

      if (lpick) {
        const guidedLineSelection = lineIntersectionCommandSession.active;
        if (!additive) { selectedPointIds = []; selectedPointId = null; }
        const idx = selectedLines.findIndex(s => s.lineId === lpick.lineId);
        if (guidedLineSelection) {
          if (idx >= 0) selectedLines[idx] = { lineId: lpick.lineId, grip: lpick.grip, t: lpick.t };
          else selectedLines.push({ lineId: lpick.lineId, grip: lpick.grip, t: lpick.t });
        } else if (!additive) {
          selectedLines = [{ lineId: lpick.lineId, grip: lpick.grip, t: lpick.t }];
        } else {
          if (idx >= 0) selectedLines.splice(idx,1);
          else selectedLines.push({ lineId: lpick.lineId, grip: lpick.grip, t: lpick.t });
        }
        lastSelectedLineId = selectedLines.length ? selectedLines[selectedLines.length-1].lineId : null;
        updatePointEditorFromSelection();
        schedulePointsTableRender();
        if (lineIntersectionCommandSession.active) {
          syncLineIntersectionCommandToast();
          if (selectedLines.length >= 2) {
            const commandButtonId = lineIntersectionCommandSession.mode === "extend" ? "#extendToIntersect" : "#trimToIntersect";
            window.setTimeout(() => $(commandButtonId)?.click(), 0);
          }
        }
        if (rotateSelectionSession.active) {
          if (rotateSelectionSession.awaitingSelection && getRotatablePointIdsFromSelection().length) {
            rotateSelectionSession.awaitingSelection = false;
            rotateSelectionSession.step = 0;
            setStatus("Selection captured. Click base point.", "ok");
          }
          syncRotateWorkflowToast();
        }

        const ln = lines.get(lpick.lineId);
        if (isMovable(ln?.movable) && !isLineLockedByLayer(lpick.lineId)) {
          history.push("move line");
          const lockRequested = requestObjectEditLock({
            entityType: "line",
            entityId: lpick.lineId,
            onGranted: () => {
              collab.activeDragLock = { entityType: "line", entityId: lpick.lineId };
              beginDrag({type:"line", id: lpick.lineId, _moved:false});
            },
            onDenied: () => {
              history.undo.pop();
              updateUndoRedoHUD();
            }
          });
          if (!lockRequested) {
            history.undo.pop();
            updateUndoRedoHUD();
          }
        }
        return;
      }

      beginDrag({type:"marquee", x0: mouse.x, y0: mouse.y, x1: mouse.x, y1: mouse.y, additive});
      return;
    }

    if (tool === "addPoint") {
      history.push("add point");
      const num = resolveDesiredPointNumber($("#ptNum").value);
      const z = parseNum($("#ptZ").value, 0);
      const code = String($("#ptCode").value || "");
      const notes = String($("#ptNotes").value || "");
      const pidNew = addPoint({ num, x: mouse.wx, y: mouse.wy, z, code, notes, movable:false });

      selectedPointIds = [pidNew];
      selectedPointId = pidNew;
      selectedLines = [];
      lastSelectedLineId = null;
      updatePointEditorFromSelection();
      clearPointNumberField();

      setStatus(`Added point ${points.get(pidNew).num} at (${fmt(mouse.wx)}, ${fmt(mouse.wy)}).`, "ok");
      schedulePointsTableRender();
      return;
    }

    if (tool === "line2pt") {
      if (construction.startPointId == null) {
        history.push("line 2pt start");
        if (pid) {
          construction.startPointId = pid;
          setStatus(`Line start set: point ${points.get(pid).num}. Click endpoint (point or empty space).`, "ok");
          syncToolWorkflowToast();
          return;
        } else {
          const num = nextOpenPointNumber();
          const pidNew = addPoint({ num, x: mouse.wx, y: mouse.wy, z:0, code:"", notes:"", movable:false });
          construction.startPointId = pidNew;
          selectedPointIds = [pidNew];
          selectedPointId = pidNew;
          updatePointEditorFromSelection();
          setStatus(`Created start point ${points.get(pidNew).num}. Click endpoint.`, "ok");
          syncToolWorkflowToast();
          return;
        }
      } else {
        history.push("line 2pt end");
        let endId = pid;
        if (!endId) {
          const num = nextOpenPointNumber();
          endId = addPoint({ num, x: mouse.wx, y: mouse.wy, z:0, code:"", notes:"", movable:false });
        }
        if (endId === construction.startPointId) {
          setStatus("Endpoint cannot be the same as start point.", "warn");
          return;
        }
        const lid = addManualLine(construction.startPointId, endId, false);
        selectedLines = [{ lineId: lid, grip:"b", t: 1 }];
        lastSelectedLineId = lid;
        selectedPointIds = [endId];
        selectedPointId = endId;
        construction.startPointId = null;
        updatePointEditorFromSelection();
        setStatus(`Created line to point ${points.get(endId).num}.`, "ok");
        schedulePointsTableRender();
        syncToolWorkflowToast();
        return;
      }
    }

    if (tool === "lineDB") {
      if (pid) {
        construction.startPointId = pid;
        selectedPointIds = [pid];
        selectedPointId = pid;
        updatePointEditorFromSelection();
        schedulePointsTableRender();
        setStatus(`Start point set: ${points.get(pid).num}. Enter dist/bearing then click "Create Point + Line".`, "ok");
        syncToolWorkflowToast();
        return;
      }
      setStatus("Select a start point first (click a point).", "warn");
      return;
    }

    if (tool === "pointOnLine") {
      if (lpick) {
        if (!additive) { selectedPointIds = []; selectedPointId = null; selectedLines = []; }
        selectedLines = [{ lineId: lpick.lineId, grip: lpick.grip, t: lpick.t }];
        lastSelectedLineId = lpick.lineId;
        setStatus("Line selected for station/offset. Enter station/offset and click 'Create Point'.", "ok");
        schedulePointsTableRender();
        syncToolWorkflowToast();
        return;
      }
      setStatus("Select a line (click near it).", "warn");
      return;
    }
  }

  canvas.addEventListener("mousedown", (e) => {
    if (modalIsOpen()) return;
    updateMouseFromEvent(e);
    mouse.down = true;
    mouse.button = e.button;

    const additive = e.shiftKey;
    pendingMarqueeZoomRect = null;
    pendingMarqueeSelectionSnapshot = null;

    if (toolIsPan()) {
      beginDrag({type:"pan"});
      return;
    }

    if (e.button !== 0) return;
    handleCanvasPrimaryAction({ additive });
  });

  canvas.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    updateMouseFromEvent(e);
    const now = performance.now();
    const isDoubleRightClick = now - lastRightClickAtMs <= DOUBLE_RIGHT_CLICK_ZOOM_OUT_MS;
    lastRightClickAtMs = now;
    if (mouse.dragObj?.type === "marquee") {
      mouse.dragObj.x1 = mouse.x;
      mouse.dragObj.y1 = mouse.y;
      const windowRect = rectNorm(mouse.dragObj.x0, mouse.dragObj.y0, mouse.dragObj.x1, mouse.dragObj.y1);
      zoomToScreenRect(windowRect);
      endDrag();
      return;
    }

    const pendingWindowRect = consumePendingMarqueeZoomRect();
    if (pendingWindowRect) {
      zoomToScreenRect(pendingWindowRect);
      applySelectionSnapshot(consumePendingMarqueeSelectionSnapshot());
      setStatus("Zoomed to window without changing selection.", "ok");
      return;
    }

    if (isDoubleRightClick && !hasSelection() && !modalIsOpen()) {
      zoomOutToNextMapLevelAtScreenPoint(mouse.x, mouse.y);
      pendingEscapeLockEntity = null;
      return;
    }

    runCanvasCancelOrClearAction({ trigger: "right-click" });
  });

  canvas.addEventListener("pointerdown", (e) => {
    if (e.pointerType !== "touch" || modalIsOpen()) return;
    e.preventDefault();
    mobileInteraction.pointerDown = true;
    mobileInteraction.moved = false;
    mobileInteraction.activePointerId = e.pointerId;
    updateMouseFromEvent(e);
    mobileInteraction.downX = mouse.x;
    mobileInteraction.downY = mouse.y;
    updateTouchPoint(e);
    canvas.setPointerCapture?.(e.pointerId);

    if (touchGesture.points.size === 2) {
      clearLongPressTimer();
      touchGesture.mode = "pinch";
      touchGesture.boxSelectActive = false;
      touchGesture.startDistance = Math.max(1, getTouchDistance());
      touchGesture.startScale = view.scale;
      touchGesture.startPanX = view.panX;
      touchGesture.startPanY = view.panY;
      touchGesture.startCenter = getTouchCenter();
      touchGesture.startWorldAtCenter = touchGesture.startCenter
        ? screenToWorld(touchGesture.startCenter.x, touchGesture.startCenter.y)
        : null;
      return;
    }

    if (touchGesture.points.size === 1) {
      touchGesture.mode = "pending";
      clearLongPressTimer();
      mobileInteraction.longPressTimer = window.setTimeout(() => {
        if (!mobileInteraction.pointerDown || mobileInteraction.moved) return;
        updateMouseFromEvent(e);
        if (tool === "addPoint") {
          history.push("add point");
          const num = resolveDesiredPointNumber($("#ptNum").value);
          const z = parseNum($("#ptZ").value, 0);
          const code = String($("#ptCode").value || "");
          const notes = String($("#ptNotes").value || "");
          const pidNew = addPoint({ num, x: mouse.wx, y: mouse.wy, z, code, notes, movable:false });

          selectedPointIds = [pidNew];
          selectedPointId = pidNew;
          selectedLines = [];
          lastSelectedLineId = null;
          updatePointEditorFromSelection();
          clearPointNumberField();

          setStatus(`Added point ${points.get(pidNew).num} at (${fmt(mouse.wx)}, ${fmt(mouse.wy)}).`, "ok");
          schedulePointsTableRender();
          touchGesture.mode = "long-press-add";
          return;
        }
        const pid = pickPoint(mouse.x, mouse.y, 14);
        const lpick = pid ? null : pickLine(mouse.x, mouse.y, 12);
        if (pid) {
          selectedPointIds = [pid];
          selectedPointId = pid;
          selectedLines = [];
          lastSelectedLineId = null;
          updatePointEditorFromSelection();
          schedulePointsTableRender();
          const p = points.get(pid);
          if (isMovable(p?.movable)) {
            requestObjectEditLock({
              entityType: "point",
              entityId: pid,
              onGranted: () => {
                history.push("move point");
                collab.activeDragLock = { entityType: "point", entityId: pid };
                beginDrag({type:"point", id: pid, _moved:false});
                touchGesture.mode = "drag-selection";
              }
            });
          }
        } else if (lpick) {
          selectedPointIds = [];
          selectedPointId = null;
          selectedLines = [{ lineId: lpick.lineId, grip: lpick.grip, t: lpick.t }];
          lastSelectedLineId = lpick.lineId;
          updatePointEditorFromSelection();
          schedulePointsTableRender();
          const ln = lines.get(lpick.lineId);
          if (isMovable(ln?.movable)) {
            requestObjectEditLock({
              entityType: "line",
              entityId: lpick.lineId,
              onGranted: () => {
                history.push("move line");
                collab.activeDragLock = { entityType: "line", entityId: lpick.lineId };
                beginDrag({type:"line", id: lpick.lineId, _moved:false});
                touchGesture.mode = "drag-selection";
              }
            });
          }
        } else {
          touchGesture.boxSelectActive = true;
          beginDrag({type:"marquee", x0: mouse.x, y0: mouse.y, x1: mouse.x, y1: mouse.y, additive:false});
          touchGesture.mode = "box-select";
        }
      }, mobileInteraction.longPressMs);
    }
  });

  canvas.addEventListener("pointermove", (e) => {
    if (e.pointerType !== "touch" || modalIsOpen()) return;
    e.preventDefault();
    updateTouchPoint(e);
    updateMouseFromEvent(e);
    broadcastCursor();

    const moveDist = dist(mobileInteraction.downX, mobileInteraction.downY, mouse.x, mouse.y);
    if (moveDist > mobileInteraction.moveTolerance) {
      mobileInteraction.moved = true;
      clearLongPressTimer();
    }

    if (touchGesture.points.size === 2 && touchGesture.mode === "pinch") {
      const center = getTouchCenter();
      const distance = Math.max(1, getTouchDistance());
      if (!center || !touchGesture.startCenter || !touchGesture.startWorldAtCenter) return;
      const factor = distance / Math.max(1, touchGesture.startDistance);
      const newScale = clamp(touchGesture.startScale * factor, MIN_SCALE, MAX_SCALE);
      const rotatedAnchor = rotateWorldPointAroundBasis(touchGesture.startWorldAtCenter.x, touchGesture.startWorldAtCenter.y);
      view.scale = newScale;
      view.panX = center.x - rotatedAnchor.x * view.scale;
      view.panY = center.y + rotatedAnchor.y * view.scale;
      return;
    }

    if (touchGesture.points.size === 1 && touchGesture.mode === "pending" && moveDist > mobileInteraction.moveTolerance) {
      touchGesture.mode = "pan";
      beginDrag({type:"pan"});
    }
  });

  function handlePointerUp(e) {
    if (e.pointerType !== "touch") return;
    removeTouchPoint(e.pointerId);
    clearLongPressTimer();
    updateMouseFromEvent(e);
    const shouldTreatAsTap = touchGesture.mode === "pending" && !mobileInteraction.moved;
    mobileInteraction.pointerDown = false;
    if (mouse.drag) handleMouseUpCommon();
    if (shouldTreatAsTap) {
      handleCanvasPrimaryAction();
    }
    touchGesture.mode = null;
    touchGesture.startWorldAtCenter = null;
    touchGesture.boxSelectActive = false;
  }

  canvas.addEventListener("pointerup", handlePointerUp);
  canvas.addEventListener("pointercancel", handlePointerUp);

  canvas.addEventListener("mousemove", (e) => {
    if (modalIsOpen()) return;
    updateMouseFromEvent(e);
    broadcastCursor();

    if (!mouse.drag) {
      const cluster = pointDisplayVisibility.clustering ? getPointClusterAtScreen(mouse.x, mouse.y) : null;
      if (cluster) {
        showClusterTooltip(cluster);
        hidePointHoverTooltip();
      } else {
        if (isLineDrawingToolActive() && activeClusterTooltip.cluster) {
          scheduleClusterTooltipHide();
        } else {
          hideClusterTooltip();
        }
        const pid = pointDisplayVisibility.points ? pickPoint(mouse.x, mouse.y, 10) : null;
        if (pid != null && points.has(pid) && shouldShowPointHoverTooltip()) {
          showPointHoverTooltip(points.get(pid), mouse.x, mouse.y);
        } else {
          hidePointHoverTooltip();
        }
      }
      return;
    }

    hideClusterTooltip();
    hidePointHoverTooltip();

    if (mouse.dragObj?.type === "pan") {
      const dx = mouse.x - mouse.dragStartX;
      const dy = mouse.y - mouse.dragStartY;
      view.panX = mouse.dragStartPanX + dx;
      view.panY = mouse.dragStartPanY + dy;
      scheduleCollabStateSync();
      return;
    }

    if (mouse.dragObj?.type === "marquee") {
      mouse.dragObj.x1 = mouse.x;
      mouse.dragObj.y1 = mouse.y;
      return;
    }

    if (mouse.dragObj?.type === "point") {
      const pid = mouse.dragObj.id;
      const p = points.get(pid);
      if (!p) return;

      if (!mouse.dragObj._orig) mouse.dragObj._orig = { x:p.x, y:p.y };
      p.x = mouse.wx;
      p.y = mouse.wy;

      if (Math.abs(p.x - mouse.dragObj._orig.x) > 1e-12 || Math.abs(p.y - mouse.dragObj._orig.y) > 1e-12) {
        mouse.dragObj._moved = true;
      }

      if (selectedPointId === pid) {
        $("#ptX").value = p.x;
        $("#ptY").value = p.y;
      }
      scheduleCollabStateSync();
      schedulePointsTableRender();
      return;
    }

    if (mouse.dragObj?.type === "line") {
      const lid = mouse.dragObj.id;
      const ln = lines.get(lid);
      if (!ln) return;
      const a = points.get(ln.a), b = points.get(ln.b);
      if (!a || !b) return;

      const dx = mouse.wx - mouse.dragStartWorldX;
      const dy = mouse.wy - mouse.dragStartWorldY;

      if (!mouse.dragObj._orig) {
        mouse.dragObj._orig = { ax:a.x, ay:a.y, bx:b.x, by:b.y };
      }
      a.x = mouse.dragObj._orig.ax + dx;
      a.y = mouse.dragObj._orig.ay + dy;
      b.x = mouse.dragObj._orig.bx + dx;
      b.y = mouse.dragObj._orig.by + dy;

      if (Math.abs(dx) > 1e-12 || Math.abs(dy) > 1e-12) mouse.dragObj._moved = true;

      scheduleCollabStateSync();
      schedulePointsTableRender();
      return;
    }
  });

  function applyMarqueeSelection(obj) {
    const r = rectNorm(obj.x0, obj.y0, obj.x1, obj.y1);

    if (r.w < 3 && r.h < 3) {
      if (!obj.additive) clearSelection();
      return;
    }

    const ptsIn = [];
    for (const p of points.values()) {
      const sp = worldToScreen(p.x,p.y);
      if (sp.x >= r.minX && sp.x <= r.maxX && sp.y >= r.minY && sp.y <= r.maxY) ptsIn.push(p.id);
    }

    const lnsIn = [];
    const rectCenter = {x:r.cx, y:r.cy};
    for (const ln of lines.values()) {
      const a = points.get(ln.a), b = points.get(ln.b);
      if (!a || !b) continue;
      const sa = worldToScreen(a.x,a.y);
      const sb = worldToScreen(b.x,b.y);

      if (segIntersectsRect(sa, sb, r)) {
        const grip = (dist2(rectCenter.x,rectCenter.y, sa.x,sa.y) <= dist2(rectCenter.x,rectCenter.y, sb.x,sb.y)) ? "a" : "b";
        lnsIn.push({ lineId: ln.id, grip, t: 0.5 });
      }
    }

    if (!obj.additive) {
      selectedPointIds = ptsIn;
      selectedPointId = selectedPointIds.length ? selectedPointIds[selectedPointIds.length-1] : null;
      selectedLines = lnsIn;
      lastSelectedLineId = selectedLines.length ? selectedLines[selectedLines.length-1].lineId : null;
    } else {
      const setPts = new Set(selectedPointIds);
      for (const id of ptsIn) if (!setPts.has(id)) selectedPointIds.push(id);
      selectedPointId = selectedPointIds.length ? selectedPointIds[selectedPointIds.length-1] : selectedPointId;

      const setLns = new Set(selectedLines.map(s=>s.lineId));
      for (const s of lnsIn) if (!setLns.has(s.lineId)) selectedLines.push(s);
      lastSelectedLineId = selectedLines.length ? selectedLines[selectedLines.length-1].lineId : lastSelectedLineId;
    }

    updatePointEditorFromSelection();
    schedulePointsTableRender();
    setStatus(`Window selected: ${ptsIn.length} point(s), ${lnsIn.length} line(s).`, "ok");
    if (rotateSelectionSession.active) {
      const rotateIds = getRotatablePointIdsFromSelection();
      if (rotateSelectionSession.awaitingSelection && rotateIds.length) {
        rotateSelectionSession.awaitingSelection = false;
        rotateSelectionSession.step = 0;
        setStatus(`Window selected: ${ptsIn.length} point(s), ${lnsIn.length} line(s). Click base point.`, "ok");
      }
      syncRotateWorkflowToast();
    }
  }

  // ADDED: common mouseup handler + window-level mouseup to prevent stuck pan/drags
  function handleMouseUpCommon() {
    mouse.down = false;
    if (!mouse.drag) return;

    if (mouse.dragObj?.type === "marquee") {
      const selectionSnapshot = captureSelectionSnapshot();
      const marqueeRect = rectNorm(mouse.dragObj.x0, mouse.dragObj.y0, mouse.dragObj.x1, mouse.dragObj.y1);
      pendingMarqueeZoomRect = marqueeRect;
      pendingMarqueeSelectionSnapshot = selectionSnapshot;
      if (pendingPrintWindowCapture) {
        pendingPrintWindowCapture = false;
        syncPrintWindowCaptureUi();
        const printBounds = worldBoundsFromScreenRect(marqueeRect);
        generatePrintViewFromBounds(printBounds);
        applySelectionSnapshot(selectionSnapshot);
      } else {
        applyMarqueeSelection(mouse.dragObj);
      }
      endDrag();
      return;
    }

    if (mouse.dragObj && mouse.dragObj.type !== "pan") {
      if (!mouse.dragObj._moved) {
        history.undo.pop();
        updateUndoRedoHUD();
      } else {
        setStatus("Move committed. (Undo available)", "ok");
        scheduleCollabStateSync();
      }
      schedulePointsTableRender();
    }

    endDrag();
    updatePointEditorFromSelection();
  }

  canvas.addEventListener("mouseup", (e) => {
    if (modalIsOpen()) return;
    handleMouseUpCommon();
  });

  window.addEventListener("mouseup", (e) => {
    // Only run if the mouseup didn't occur on the canvas itself (prevents double-fire)
    if (e.target === canvas) return;
    handleMouseUpCommon();
  });

  clusterTooltip?.addEventListener("mouseenter", () => {
    clusterTooltipHovering = true;
    clearClusterTooltipHideTimer();
  });

  clusterTooltip?.addEventListener("mouseleave", () => {
    clusterTooltipHovering = false;
    if (!isLineDrawingToolActive()) {
      hideClusterTooltip();
      return;
    }
    scheduleClusterTooltipHide();
  });

  clusterTooltip?.addEventListener("click", (event) => {
    const target = event.target.closest("[data-cluster-action]");
    if (!target) return;
    const action = target.dataset.clusterAction;
    if (action === "expand-layer") {
      const layerId = String(target.dataset.layerId || "");
      if (!activeClusterTooltip.cluster) return;
      showClusterTooltip(activeClusterTooltip.cluster, mouse.x, mouse.y, { expandedLayerId: layerId });
      return;
    }
    if (action === "show-layer-groups") {
      if (!activeClusterTooltip.cluster) return;
      showClusterTooltip(activeClusterTooltip.cluster, mouse.x, mouse.y, { expandedLayerId: null });
      return;
    }
    if (action !== "select-point") return;
    const pointId = String(target.dataset.pointId || "");
    if (!points.has(pointId)) return;
    handleCanvasPrimaryAction({ forcedPointId: pointId });
    if (!isLineDrawingToolActive()) hideClusterTooltip();
  });

  canvas.addEventListener("mouseleave", () => {
    mouse.down = false;
    endDrag();
    if (isLineDrawingToolActive() && activeClusterTooltip.cluster) {
      scheduleClusterTooltipHide();
    } else {
      hideClusterTooltip();
    }
    hidePointHoverTooltip();
  });

  canvas.addEventListener("wheel", (e) => {
    if (modalIsOpen()) return;
    e.preventDefault();
    updateMouseFromEvent(e);

    const before = screenToWorld(mouse.x, mouse.y);
    const zoomFactor = Math.exp(-e.deltaY * 0.0015);
    const newScale = clamp(view.scale * zoomFactor, MIN_SCALE, MAX_SCALE);
    view.scale = newScale;

    view.panX = mouse.x - before.x * view.scale;
    view.panY = mouse.y + before.y * view.scale;
  }, {passive:false});

  function scheduleLayersTableRender() {
    layersTableDirty = true;
    if (!layersModal || layersModal.classList.contains("hidden")) return;
    renderLayersTable();
  }

  function setQuickLayerDropdownOpen(open) {
    quickLayerDropdownOpen = !!open;
    if (quickLayerDropdownMenu) quickLayerDropdownMenu.classList.toggle("hidden", !quickLayerDropdownOpen);
    if (quickLayerDropdownButton) quickLayerDropdownButton.setAttribute("aria-expanded", quickLayerDropdownOpen ? "true" : "false");
  }

  function toggleLayerFlag(layer, key) {
    if (!layer) return;
    if (key === "visible") layer.visible = !(layer.visible !== false);
    else layer[key] = !layer[key];
    renderLayerControls();
    scheduleLayersTableRender();
    const enabled = key === "visible" ? layer.visible !== false : layer[key] === true;
    setStatus(`Layer ${layer.name}: ${key} ${enabled ? "on" : "off"}.`, "ok");
  }

  function renderLayerControls() {
    if (!quickLayerDropdownButton || !quickLayerDropdownMenu) return;
    if (!layers.has(selectedLayerId)) selectedLayerId = layers.keys().next().value;
    const layerDisplayState = getSelectionLayerDisplayState();
    const toolbarLayerId = layerDisplayState.mode === "single" ? layerDisplayState.layerId : selectedLayerId;
    if (quickLayerColor) quickLayerColor.style.background = layerDisplayState.color;
    if (quickLayerDropdownLabel) quickLayerDropdownLabel.textContent = layerDisplayState.label;

    quickLayerDropdownMenu.innerHTML = "";
    for (const layer of layers.values()) {
      const isActive = layer.id === toolbarLayerId && layerDisplayState.mode !== "multiple";
      const rowBtn = document.createElement("button");
      rowBtn.className = `quickLayerDropdownItem${isActive ? " active" : ""}`;
      rowBtn.type = "button";
      rowBtn.setAttribute("role", "option");
      rowBtn.setAttribute("aria-selected", isActive ? "true" : "false");

      const swatch = document.createElement("span");
      swatch.className = "quickToolLayerSwatch";
      swatch.style.background = layer.color;

      const name = document.createElement("span");
      name.className = "quickLayerItemName";
      name.textContent = layer.name;

      const flags = document.createElement("span");
      flags.className = "quickLayerItemFlags";
      const toggles = [
        { key: "locked", icon: "fa-lock", offIcon: "fa-lock-open", title: "Toggle lock" },
        { key: "visible", icon: "fa-eye", offIcon: "fa-eye-slash", title: "Toggle visibility" },
        { key: "fill", icon: "fa-fill-drip", offIcon: "fa-fill-drip", title: "Toggle polygon fill" }
      ];
      for (const toggle of toggles) {
        const enabled = toggle.key === "visible" ? layer.visible !== false : layer[toggle.key] === true;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = `quickToolIconBtn${enabled ? " active" : ""}`;
        btn.title = `${toggle.title} (${layer.name})`;
        btn.innerHTML = `<i class="fa-solid ${enabled ? toggle.icon : toggle.offIcon}"></i>`;
        btn.addEventListener("click", (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleLayerFlag(layer, toggle.key);
          setQuickLayerDropdownOpen(true);
        });
        flags.appendChild(btn);
      }

      rowBtn.append(swatch, name, flags);
      rowBtn.addEventListener("click", () => {
        applyLayerChoice(layer.id, { closeDropdown: true });
      });
      quickLayerDropdownMenu.appendChild(rowBtn);
    }
  }


  function renderLayersTable() {
    if (!layersTbody) return;
    layersTbody.innerHTML = "";
    const frag = document.createDocumentFragment();
    for (const layer of layers.values()) {
      const tr = document.createElement("tr");
      if (layer.locked) tr.classList.add("layerRowLocked");

      const nameTd = document.createElement("td");
      const nameInput = document.createElement("input");
      nameInput.className = "cellInput layerNameCell";
      nameInput.value = layer.name;
      nameInput.addEventListener("input", () => { layer.name = String(nameInput.value || "").trim() || layer.id; renderLayerControls(); });
      nameTd.appendChild(nameInput);

      const colorTd = document.createElement("td");
      const colorInput = document.createElement("input");
      colorInput.type = "color";
      colorInput.value = layer.color;
      colorInput.addEventListener("input", () => { layer.color = colorInput.value; renderLayerControls(); });
      colorTd.appendChild(colorInput);

      const lwTd = document.createElement("td");
      const lwInput = document.createElement("input");
      lwInput.className = "cellInput";
      lwInput.type = "number";
      lwInput.min = "0.5";
      lwInput.max = "12";
      lwInput.step = "0.25";
      lwInput.value = String(layer.lineWeight);
      lwInput.addEventListener("input", () => { layer.lineWeight = clampLayerLineWeight(lwInput.value); });
      lwTd.appendChild(lwInput);

      const mkToggleTd = (key) => {
        const td = document.createElement("td");
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.checked = key === "visible" ? layer.visible !== false : layer[key] === true;
        chk.addEventListener("change", () => {
          if (key === "visible") layer.visible = chk.checked;
          else layer[key] = chk.checked;
          renderLayerControls();
          scheduleLayersTableRender();
        });
        td.appendChild(chk);
        return td;
      };

      const actTd = document.createElement("td");
      const useBtn = document.createElement("button");
      useBtn.className = "cellBtn";
      useBtn.textContent = "Use";
      useBtn.addEventListener("click", () => { applyLayerChoice(layer.id); });
      actTd.appendChild(useBtn);

      if (layer.id !== DEFAULT_LAYER_ID) {
        const delBtn = document.createElement("button");
        delBtn.className = "cellBtn danger";
        delBtn.style.marginLeft = "8px";
        delBtn.textContent = "Delete";
        delBtn.addEventListener("click", () => {
          for (const p of points.values()) if (p.layerId === layer.id) p.layerId = DEFAULT_LAYER_ID;
          for (const ln of lines.values()) if (ln.layerId === layer.id) ln.layerId = DEFAULT_LAYER_ID;
          layers.delete(layer.id);
          if (selectedLayerId === layer.id) selectedLayerId = DEFAULT_LAYER_ID;
          renderLayerControls();
          scheduleLayersTableRender();
        });
        actTd.appendChild(delBtn);
      }

      tr.append(nameTd, colorTd, lwTd, mkToggleTd("locked"), mkToggleTd("visible"), mkToggleTd("fill"), actTd);
      frag.appendChild(tr);
    }
    layersTbody.appendChild(frag);
    layersTableDirty = false;
  }

  function openLayersModal() {
    if (!layersModal) return;
    layersModal.classList.remove("hidden");
    layersModal.setAttribute("aria-hidden", "false");
    if (layersModalWindow && (!layersModalWindow.style.left || !layersModalWindow.style.top)) {
      const w = Math.min(window.innerWidth - 36, 920);
      const h = Math.min(window.innerHeight - 36, 520);
      layersModalWindow.style.width = `${w}px`;
      layersModalWindow.style.height = `${h}px`;
      layersModalWindow.style.left = `${Math.max(18, (window.innerWidth - w) / 2)}px`;
      layersModalWindow.style.top = `${Math.max(18, (window.innerHeight - h) / 2)}px`;
    }
    renderLayersTable();
  }

  function closeLayersModal() {
    if (!layersModal) return;
    layersModal.classList.add("hidden");
    layersModal.setAttribute("aria-hidden", "true");
  }

  function getFldRuleTemplateRaw(config) {
    const columns = Array.isArray(config?.columns) ? config.columns : [];
    const source = config?.rules?.[0]?.raw || {};
    const base = {};
    for (const column of columns) base[column.key] = source[column.key] ?? "";
    return base;
  }

  function syncFldRuleDerivedFields(rule) {
    const raw = rule.raw || {};
    rule.code = String(raw.code || "").trim();
    rule.description = String(raw.description || "").trim();
    rule.fullName = String(raw.full_name || "").trim();
    rule.layer = String(raw.layer || "").trim();
    rule.entityType = String(raw.entity_type || "").trim();
    rule.lineType = String(raw.linetype || "").trim();
    rule.symbol = String(raw.symbol || "").trim();
    rule.symbolScale = String(raw.symbol_size || "").trim();
    rule.processingOn = String(raw.processing_on || "") === "1";
    rule.companionCodes = String(raw.companion_codes || "").split(",").map((item) => item.trim()).filter(Boolean);
  }

  function updateFldSourceLabel() {
    if (!fldSourceLabel) return;
    fldSourceLabel.textContent = fldEditorState.source === "local" ? "Local Override" : "Server";
  }

  function renderFldEditorTable() {
    if (!fldTbody) return;
    const config = fldEditorState.activeConfig;
    const rules = Array.isArray(config?.rules) ? config.rules : [];
    const lineTypeOptions = buildLineTypeOptions(config);
    const symbolMapChoices = buildSymbolMapChoices(config);
    const filter = String(fldFilterInput?.value || "").trim().toUpperCase();
    fldTbody.innerHTML = "";
    const frag = document.createDocumentFragment();
    rules.forEach((rule) => {
      const code = String(rule?.raw?.code || "").trim();
      const description = String(rule?.raw?.description || "").trim();
      if (filter && !code.toUpperCase().includes(filter) && !description.toUpperCase().includes(filter)) return;
      const tr = document.createElement("tr");
      const mkInputCell = (key, { width = "", onInput = null, type = "text" } = {}) => {
        const td = document.createElement("td");
        const input = document.createElement("input");
        input.className = "cellInput";
        if (width) input.style.width = width;
        input.type = type;
        input.value = String(rule.raw?.[key] ?? "");
        input.addEventListener("input", () => {
          if (!rule.raw) rule.raw = {};
          rule.raw[key] = input.type === "checkbox" ? (input.checked ? "1" : "0") : input.value;
          syncFldRuleDerivedFields(rule);
          if (typeof onInput === "function") onInput(input);
        });
        td.appendChild(input);
        return td;
      };

      const codeCell = mkInputCell("code");
      const entityTd = document.createElement("td");
      const entitySelect = document.createElement("select");
      entitySelect.className = "cellInput";
      const entityOptions = [
        { value: "2", label: "Linework" },
        { value: "1", label: "2D Polyline (Linework)" },
        { value: "0", label: "Symbol" },
      ];
      entityOptions.forEach((item) => {
        const option = document.createElement("option");
        option.value = item.value;
        option.textContent = item.label;
        entitySelect.appendChild(option);
      });
      entitySelect.value = String(rule.raw?.entity_type || "0");
      entitySelect.addEventListener("change", () => {
        rule.raw.entity_type = entitySelect.value;
        normalizeLineworkRuleDefaults(rule);
        syncFldRuleDerivedFields(rule);
        renderFldEditorTable();
      });
      entityTd.appendChild(entitySelect);
      const processTd = document.createElement("td");
      const processInput = document.createElement("input");
      processInput.type = "checkbox";
      processInput.checked = String(rule.raw?.processing_on || "") === "1";
      processInput.addEventListener("change", () => {
        rule.raw.processing_on = processInput.checked ? "1" : "0";
        syncFldRuleDerivedFields(rule);
      });
      processTd.appendChild(processInput);
      const layerCell = mkInputCell("layer");
      const descCell = mkInputCell("description");
      const typeConfigTd = document.createElement("td");
      typeConfigTd.className = "fldTypeConfigCell";
      const typeConfigStack = document.createElement("div");
      typeConfigStack.className = "fldTypeConfigStack";
      const isLinework = isLineworkEntityType(rule.raw?.entity_type);
      if (isLinework) {
        const lineTypeSelect = document.createElement("select");
        lineTypeSelect.className = "cellInput";
        lineTypeOptions.forEach((lineType) => {
          const option = document.createElement("option");
          option.value = lineType;
          option.textContent = lineType;
          lineTypeSelect.appendChild(option);
        });
        const currentLineType = String(rule.raw?.linetype || "").trim() || "BYLAYER";
        if (!lineTypeOptions.includes(currentLineType)) {
          const extraOption = document.createElement("option");
          extraOption.value = currentLineType;
          extraOption.textContent = currentLineType;
          lineTypeSelect.appendChild(extraOption);
        }
        lineTypeSelect.value = currentLineType;
        lineTypeSelect.title = "Line type";
        lineTypeSelect.addEventListener("change", () => {
          rule.raw.linetype = lineTypeSelect.value;
          syncFldRuleDerivedFields(rule);
        });
        const helper = document.createElement("div");
        helper.className = "muted";
        helper.textContent = " ";
        typeConfigStack.append(lineTypeSelect, helper);
      } else {
        const symbolIdInput = document.createElement("input");
        symbolIdInput.className = "cellInput";
        symbolIdInput.placeholder = "Symbol ID (FLD Symbol column)";
        symbolIdInput.value = String(rule.raw?.symbol || "");
        symbolIdInput.addEventListener("input", () => {
          rule.raw.symbol = symbolIdInput.value;
          syncFldRuleDerivedFields(rule);
        });

        const symbolPreviewPicker = buildFldSymbolPreviewPicker({
          symbolMapChoices: [{ value: "", label: "No SVG mapping" }, ...symbolMapChoices],
          currentValue: getSymbolMapFileForRule(rule),
          onPick: (value) => {
            const applied = setSymbolMapFileForRule(rule, value);
            if (!applied) return;
            syncFldRuleDerivedFields(rule);
            applyFieldToFinishConfig(fldEditorState.activeConfig, fldEditorState.source === "local" ? "localStorage" : defaultFldConfigPath);
            renderFldEditorTable();
          },
        });

        const symbolScaleInput = document.createElement("input");
        symbolScaleInput.className = "cellInput";
        symbolScaleInput.type = "number";
        symbolScaleInput.step = "0.0001";
        symbolScaleInput.placeholder = "Scale";
        symbolScaleInput.value = String(rule.raw?.symbol_size || "");
        symbolScaleInput.addEventListener("input", () => {
          rule.raw.symbol_size = symbolScaleInput.value;
          syncFldRuleDerivedFields(rule);
        });
        typeConfigStack.append(symbolIdInput, symbolScaleInput, symbolPreviewPicker);
      }
      typeConfigTd.appendChild(typeConfigStack);
      const companionsCell = mkInputCell("companion_codes");

      const actionTd = document.createElement("td");
      const delBtn = document.createElement("button");
      delBtn.className = "cellBtn danger";
      delBtn.textContent = "Delete";
      delBtn.addEventListener("click", () => {
        const idx = config.rules.indexOf(rule);
        if (idx >= 0) config.rules.splice(idx, 1);
        renderFldEditorTable();
      });
      actionTd.appendChild(delBtn);

      tr.append(codeCell, entityTd, processTd, layerCell, descCell, typeConfigTd, companionsCell, actionTd);
      frag.appendChild(tr);
    });
    fldTbody.appendChild(frag);
    updateFldSourceLabel();
  }

  function openFldEditor() {
    if (!fldModal) return;
    fldModal.classList.remove("hidden");
    fldModal.setAttribute("aria-hidden", "false");
    if (fldModalWindow && (!fldModalWindow.style.left || !fldModalWindow.style.top)) {
      const w = Math.min(window.innerWidth - 36, 1200);
      const h = Math.min(window.innerHeight - 36, 680);
      fldModalWindow.style.width = `${w}px`;
      fldModalWindow.style.height = `${h}px`;
      fldModalWindow.style.left = `${Math.max(18, (window.innerWidth - w) / 2)}px`;
      fldModalWindow.style.top = `${Math.max(18, (window.innerHeight - h) / 2)}px`;
    }
    renderFldEditorTable();
  }

  function closeFldEditor() {
    if (!fldModal) return;
    fldModal.classList.add("hidden");
    fldModal.setAttribute("aria-hidden", "true");
  }

  function addFldRule() {
    const config = fldEditorState.activeConfig;
    if (!config || !Array.isArray(config.rules)) return;
    const template = getFldRuleTemplateRaw(config);
    const raw = { ...template, code: "", description: "", full_name: "", layer: "", entity_type: "0", symbol: "", symbol_size: "0.1000", symbol_name_2: "", linetype: "BYLAYER", processing_on: "1", companion_codes: "" };
    const rule = { rowNumber: config.rules.length + 2, raw };
    normalizeLineworkRuleDefaults(rule);
    syncFldRuleDerivedFields(rule);
    config.rules.push(rule);
    renderFldEditorTable();
  }

  function saveFldEditorLocalOverride() {
    if (!fldEditorState.activeConfig) return;
    fldEditorState.source = "local";
    saveLocalFldOverride(fldEditorState.activeConfig);
    applyFieldToFinishConfig(fldEditorState.activeConfig, "localStorage");
    syncFieldToFinishLinework();
    setStatus("Saved FLD local override.", "ok");
    renderFldEditorTable();
  }

  function resetFldEditorToServer() {
    if (!fldEditorState.serverConfig) return;
    clearLocalFldOverride();
    fldEditorState.activeConfig = cloneFldConfig(fldEditorState.serverConfig);
    fldEditorState.source = "server";
    applyFieldToFinishConfig(fldEditorState.activeConfig, defaultFldConfigPath);
    syncFieldToFinishLinework();
    setStatus("Reset FLD config to server version.", "ok");
    renderFldEditorTable();
  }

  function downloadFldLocalOverride() {
    const local = loadLocalFldOverride();
    if (!local) {
      setStatus("No local FLD override found to download.", "warn");
      return;
    }
    downloadTextFile("LineSmith-LocalOverride.fld", serializeFieldToFinishConfig(local));
  }

  function downloadFldCurrentConfig() {
    if (!fldEditorState.activeConfig) return;
    downloadTextFile("LineSmith-Current.fld", serializeFieldToFinishConfig(fldEditorState.activeConfig));
  }

  // -------------------------
  // Counts / tool hint enrichment
  // -------------------------
  function updateCounts() {
    pointsCount.textContent = `${points.size} point${points.size===1?"":"s"} / ${lines.size} line${lines.size===1?"":"s"}`;
    modalPointsCount.textContent = String(points.size);
  }

  function updateDerivedSelectionInfo() {
    if (lastSelectedLineId && lines.has(lastSelectedLineId)) {
      const ln = lines.get(lastSelectedLineId);
      const measure = lineMeasurement(points.get(ln.a), points.get(ln.b));
      if (measure) {
        const baseName = ({
          select:"Select/Move",
          addPoint:"Add Point",
          line2pt:"Line: 2 Points",
          lineDB:"Line: Dist/Bearing",
          pointOnLine:"Point on Line",
          pan:"Pan"
        })[tool] ?? tool;
        toolHint.textContent = `${baseName} — L=${measure.distance.toFixed(3)}  ${measure.bearing}`;
        return;
      }
    }
    const names = {
      select:"Select/Move",
      addPoint:"Add Point",
      line2pt:"Line: 2 Points",
      lineDB:"Line: Dist/Bearing",
      pointOnLine:"Point on Line",
      pan:"Pan"
    };
    toolHint.textContent = names[tool] ?? tool;
  }

  function updateLineInspector() {
    let source = "";
    let measure = null;
    let curveTable = null;
    if (lastSelectedLineId && lines.has(lastSelectedLineId)) {
      const ln = lines.get(lastSelectedLineId);
      measure = lineMeasurement(points.get(ln.a), points.get(ln.b));
      curveTable = describeThreePointCurve(ln);
      source = "Selected line";
    } else if (selectedPointIds.length === 2) {
      const a = points.get(selectedPointIds[0]);
      const b = points.get(selectedPointIds[1]);
      measure = lineMeasurement(a, b);
      source = "Selected points";
    }

    if (!measure) {
      lineInspector.textContent = "Select one line or two points to inspect bearing + distance.";
      return;
    }
    lineInspector.innerHTML =
      `<div class="inspectorRow"><span>Source</span><b>${source}</b></div>` +
      `<div class="inspectorRow"><span>Distance</span><b>${measure.distance.toFixed(3)}</b></div>` +
      `<div class="inspectorRow"><span>Bearing</span><b>${measure.bearing}</b></div>`;

    if (curveTable) {
      lineInspector.innerHTML +=
        `<div class="inspectorRow"><span>Radius</span><b>${curveTable.radius.toFixed(3)}</b></div>` +
        `<div class="inspectorRow"><span>Arc Length</span><b>${curveTable.arcLength.toFixed(3)}</b></div>` +
        `<div class="inspectorRow"><span>Chord Bearing</span><b>${curveTable.chordBearing}</b></div>` +
        `<div class="inspectorRow"><span>Chord Distance</span><b>${curveTable.chordDistance.toFixed(3)}</b></div>` +
        `<div class="inspectorRow"><span>Delta Angle</span><b>${curveTable.deltaAngleDeg.toFixed(4)}°</b></div>`;
    }
  }
  setInterval(updateDerivedSelectionInfo, 250);
  setInterval(updateLineInspector, 250);

  window.addEventListener("message", (event) => {
    if (event.origin !== window.location.origin) return;
    if (event.source !== window.parent) return;
    const message = event.data;
    if (!message || typeof message.type !== "string") return;

    if (message.type === "survey-cad:request-unsaved-state") {
      window.parent.postMessage({
        type: "survey-cad:request-unsaved-state:response",
        requestId: message.requestId,
        hasUnsavedChanges: hasUnsavedDrawingChanges(),
        canSave: Boolean(activeProjectId),
      }, window.location.origin);
      return;
    }

    if (message.type === "survey-cad:request-save-before-navigate") {
      const hadUnsavedChanges = hasUnsavedDrawingChanges();
      let saved = !hadUnsavedChanges;
      if (hadUnsavedChanges) {
        saved = saveDrawingToProject();
      }
      window.parent.postMessage({
        type: "survey-cad:request-save-before-navigate:response",
        requestId: message.requestId,
        saved: Boolean(saved),
      }, window.location.origin);
      return;
    }

    if (message.type === "survey-cad:request-drawing-points") {
      const rows = ["Point,Northing,Easting,Elevation,Code,Notes"];
      for (const p of points.values()) {
        const num = p.num ?? p.id;
        const n = p.y ?? "";
        const e = p.x ?? "";
        const z = p.z ?? "";
        const code = String(p.code || "").replace(/"/g, '""');
        const notes = String(p.notes || "").replace(/"/g, '""');
        rows.push(`${num},${n},${e},${z},"${code}","${notes}"`);
      }
      window.parent.postMessage({
        type: "survey-cad:request-drawing-points:response",
        requestId: message.requestId,
        csv: rows.join("\n"),
        pointCount: points.size,
      }, window.location.origin);
      return;
    }
  });

  // -------------------------
  // Boot
  // -------------------------
  async function boot() {
    showLineSmithLoadingOverlay("Connecting survey points…");
    try {
      await loadFieldToFinishRulesFromFld(defaultFldConfigPath);
      setLineSmithLoadingStage("Calibrating canvas and map controls…");
      resize();
      window.addEventListener("resize", resize);
      mapEnabledInput.checked = false;
      mapTileTypeInput.value = "satellite";
      mapOpacityInput.value = "66";
      mapLayerState.opacity = 0.66;
      applyMapOpacity();
      setMapLayerEnabled(false);
      setTool("select");
      updatePointEditorFromSelection();
      updateUndoRedoHUD();
      updateCounts();
      syncBasisOfBearingInputs();
      requestAnimationFrame(draw);
      markDrawingAsSaved();

      const drawingHint = $("#drawingSaveHint");
      if (drawingHint) {
        drawingHint.textContent = activeProjectId
          ? `Project-linked saves enabled for ${activeProjectName || activeProjectId}.`
          : "Open LineSmith from an active SurveyFoundry project to enable project-linked drawing saves.";
      }

      setLineSmithLoadingStage("Restoring saved drawing state…");
      const openedFromProjectBrowser = tryImportProjectBrowserDrawingPayload();
      if (openedFromProjectBrowser) {
        setLineSmithLoadingStage("Syncing collaboration room…");
        connectCollaboration();
        return;
      }

      const importedFromPointforge = tryImportPointforgePayload();
      if (importedFromPointforge) {
        setLineSmithLoadingStage("Applying PointForge payload…");
        connectCollaboration({ skipInitialStateHydration: true, syncLocalStateOnConnect: true });
        return;
      }

      const restoredLastDrawing = tryRestoreLastOpenedProjectDrawing();
      if (restoredLastDrawing) {
        setLineSmithLoadingStage("Opening previous project drawing…");
        connectCollaboration();
        return;
      }

      setLineSmithLoadingStage("Finalizing workspace…");
      connectCollaboration();

      setStatus(
        "Ready.\n" +
        "This build preserves your baseline interaction.\n" +
        "Fixes added:\n" +
        "• CSV headerless N,E vs E,N import control (prevents X/Y swapped point data).\n" +
        "• Swap X↔Y for ALL points (Undoable) for already-imported transposed datasets.\n" +
        "• Pan/drag release robustness (window mouseup + blur reset).",
        "ok"
      );
    } catch (error) {
      console.error(error);
      setStatus("LineSmith could not finish loading. Refresh to try again.", "warn");
    } finally {
      window.setTimeout(() => {
        hideLineSmithLoadingOverlay();
      }, 180);
    }
  }

  boot();

})();
</script>
</body>
</html>
