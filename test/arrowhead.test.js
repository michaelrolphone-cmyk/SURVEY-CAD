import test from 'node:test';
import assert from 'node:assert/strict';
import { readFile } from 'node:fs/promises';

test('ArrowHead mobile AR app reads LineSmith payload and projects using bearing/elevation camera angles', async () => {
  const html = await readFile(new URL('../ArrowHead.html', import.meta.url), 'utf8');

  assert.match(html, /const\s+ARROWHEAD_IMPORT_STORAGE_KEY\s*=\s*'lineSmithArrowHeadImport'/, 'ArrowHead should consume the LineSmith handoff storage key');
  assert.match(html, /const\s+PROJECT_LAST_DRAWING_STORAGE_PREFIX\s*=\s*'surveyfoundryLastLineSmithDrawing'/, 'ArrowHead should know where LineSmith tracks the last-opened drawing key per project');
  assert.match(html, /\.app\s*\{[\s\S]*position:\s*fixed;[\s\S]*top:\s*0;[\s\S]*right:\s*0;[\s\S]*bottom:\s*0;[\s\S]*left:\s*0;[\s\S]*inset:\s*0;/, 'ArrowHead should include top/right/bottom/left fallbacks alongside inset for older iOS Safari support');
  assert.match(html, /video, canvas\s*\{[\s\S]*position:\s*absolute;[\s\S]*top:\s*0;[\s\S]*right:\s*0;[\s\S]*bottom:\s*0;[\s\S]*left:\s*0;[\s\S]*inset:\s*0;/, 'ArrowHead camera and overlay layers should include inset fallbacks for older iOS Safari support');

  assert.doesNotMatch(html, /\?\./, 'ArrowHead should avoid optional chaining so older Safari/iOS engines can parse the script');
  assert.doesNotMatch(html, /\.\.\./, 'ArrowHead should avoid object spread syntax for broader iOS Safari compatibility');
  assert.match(html, /navigator\.mediaDevices\.getUserMedia\(/, 'ArrowHead should request camera access for AR video feed');
  assert.match(html, /function\s+getCameraRequestor\(\)\s*\{[\s\S]*navigator\.webkitGetUserMedia[\s\S]*navigator\.msGetUserMedia[\s\S]*navigator\.mediaDevices\.webkitGetUserMedia[\s\S]*\}/, 'ArrowHead should resolve camera requestors from modern and legacy navigator/mediaDevices APIs for older mobile Safari and embedded browsers');
  assert.match(html, /function\s+requestCameraStream\(constraints\)\s*\{[\s\S]*const\s+requestCamera\s*=\s*getCameraRequestor\(\);[\s\S]*return\s+requestCamera\(constraints\);[\s\S]*\}/, 'ArrowHead should request camera streams through a unified camera-requestor resolver');
  assert.match(html, /function\s+describeError\(error, fallbackMessage\)\s*\{[\s\S]*if \(name && message\) return `\$\{name\}: \$\{message\}`;[\s\S]*\}/, 'ArrowHead should normalize thrown startup errors into a stable name/message string for status and alerts');
  assert.match(html, /function\s+alertCameraStartError\(error, contextMessage\)\s*\{[\s\S]*const\s+alertText\s*=\s*`ArrowHead camera start failed\.\\n\$\{detail\}`;[\s\S]*window\.alert\(alertText\);[\s\S]*\}/, 'ArrowHead should surface camera startup failures via window alert text for devices without console access');
  assert.match(html, /function\s+isSecureContextForDevicePermissions\(\)\s*\{[\s\S]*window\.isSecureContext[\s\S]*isPotentiallyTrustworthyLocalHost[\s\S]*\}/, 'ArrowHead should gate mobile sensor startup behind secure contexts (https/localhost) required by iOS Safari permission prompts');
  assert.match(html, /stream\s*=\s*await\s*requestCameraStream\(\{\s*video:\s*\{\s*facingMode:\s*\{\s*ideal:\s*'environment'\s*\}\s*\},\s*audio:\s*false\s*\}\);[\s\S]*stream\s*=\s*await\s*requestCameraStream\(\{\s*video:\s*true,\s*audio:\s*false\s*\}\);/, 'ArrowHead should retry camera startup with broad video constraints when environment-facing constraints fail on older iOS camera stacks');
  assert.match(html, /const\s+context\s*=\s*`Primary request failed \(\$\{describeError\(primaryError, 'Camera constraint error'\)\}\)\. Fallback request failed\.`;[\s\S]*alertCameraStartError\(fallbackError, context\);/, 'ArrowHead should include both primary and fallback camera error details in the fallback alert message');
  assert.match(html, /typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent\.requestPermission === 'function'/, 'ArrowHead should request devicemotion permission on iOS versions that gate motion sensor access');
  assert.match(html, /const\s+orientationPermissionPromise\s*=\s*requestOrientationPermissionIfNeeded\(\);[\s\S]*const\s+motionPermissionPromise\s*=\s*requestMotionPermissionIfNeeded\(\);/, 'ArrowHead should explicitly request both orientation and motion permissions during startup');
  assert.match(html, /const\s+cameraStartPromise\s*=\s*startCamera\(\);[\s\S]*const\s+orientationPermissionPromise\s*=\s*requestOrientationPermissionIfNeeded\(\);[\s\S]*const\s+motionPermissionPromise\s*=\s*requestMotionPermissionIfNeeded\(\);/, 'ArrowHead should kick off camera and iOS sensor permission requests synchronously from the start button gesture');
  assert.match(html, /await\s+cameraStartPromise;[\s\S]*const\s+orientationPermissionGranted\s*=\s*await\s+orientationPermissionPromise;[\s\S]*const\s+motionPermissionGranted\s*=\s*await\s+motionPermissionPromise;/, 'ArrowHead should await the already-started permission requests after preserving click-gesture timing');
  assert.match(html, /if \(!isSecureContextForDevicePermissions\(\)\) \{[\s\S]*require HTTPS on iOS Safari/, 'ArrowHead should explain when insecure origins prevent iOS permission prompts');
  assert.match(html, /if \(!orientationPermissionGranted \|\| !motionPermissionGranted\) \{[\s\S]*enableMouseLookFallback\(/, 'ArrowHead should fall back to mouse look when iOS sensor permissions are denied');
  assert.match(html, /if \(\/getUserMedia\|camera\/i\.test\(String\(errorMessage\)\) && !hasCameraApi\(\)\) \{[\s\S]*Camera API unavailable on this device\/browser\./, 'ArrowHead should classify camera-unavailable status from startup failures only after evaluating all camera API variants');
  assert.match(html, /navigator\.geolocation\.watchPosition\(/, 'ArrowHead should watch GPS updates for world alignment');
  assert.match(html, /navigator\.geolocation\.getCurrentPosition\(/, 'ArrowHead should explicitly invoke getCurrentPosition during startup so iOS prompts for location permission before the watch stream begins');
  assert.match(html, /const\s+GEOLOCATION_OPTIONS\s*=\s*\{\s*enableHighAccuracy:\s*true,\s*timeout:\s*30000,\s*maximumAge:\s*1000\s*\};/, 'ArrowHead should allow extra time for iOS geolocation permission/fix acquisition before timing out');
  assert.match(html, /const\s+GEOLOCATION_RELAXED_OPTIONS\s*=\s*\{\s*enableHighAccuracy:\s*false,\s*maximumAge:\s*15000\s*\};/, 'ArrowHead should define a relaxed geolocation fallback profile for older devices');
  assert.match(html, /if \(error && error\.code === error\.TIMEOUT && !hasFreshFix && options === GEOLOCATION_OPTIONS\) \{[\s\S]*startWatch\(GEOLOCATION_RELAXED_OPTIONS\);/, 'ArrowHead should retry geolocation watches with relaxed options after initial timeout without a fix');
  assert.match(html, /const\s+geolocationPermissionPromise\s*=\s*requestInitialGeolocationPermissionIfNeeded\(\);[\s\S]*const\s+geolocationPermissionGranted\s*=\s*await\s+geolocationPermissionPromise;/, 'ArrowHead startup should request geolocation permission before attaching ongoing GPS watches');
  assert.match(html, /window\.addEventListener\('deviceorientationabsolute'/, 'ArrowHead should subscribe to absolute orientation updates when available');
  assert.match(html, /window\.addEventListener\('deviceorientation'/, 'ArrowHead should subscribe to orientation sensor updates');
  assert.match(html, /window\.addEventListener\('devicemotion'/, 'ArrowHead should subscribe to motion sensor updates');
  assert.match(html, /const\s+zFeet\s*=\s*resolvePayloadPointElevationFeet\(p\);/, 'ArrowHead should resolve point elevation through open-dataset fallback before rendering');
  assert.match(html, /import\s+\{\s*deriveDevicePoseRadians,\s*integrateGyroscopeHeadingRadians,\s*normalizeRadians\s*\}\s+from\s+"\.\/src\/arrowhead-math\.js";/, 'ArrowHead should use shared orientation math helpers, including gyroscope heading integration');
  assert.match(html, /import\s+\{\s*computeForwardDistanceMeters,\s*computeObserverElevationFeet,\s*computeRelativeBearingRad,\s*projectEnuPointToScreen,\s*resolvePointElevationFeet\s*\}\s+from\s+"\.\/src\/arrowhead-projection\.js";/, 'ArrowHead should use shared projection helpers');
  assert.match(html, /import\s+\{\s*latLngToWorldAffine,\s*worldToLatLngAffine\s*\}\s+from\s+"\.\/src\/georeference-transform\.js";/, 'ArrowHead should use shared georeference helpers for bidirectional coordinate projection');
  assert.match(html, /const\s+pose\s*=\s*deriveDevicePoseRadians\(event, currentScreenAngle\(\), state\.headingOffsetRad\);/, 'ArrowHead should derive heading and tilt from the normalized orientation helper');
  assert.match(html, /<button id="useGyro">Use Gyroscope Heading: Off<\/button>/, 'ArrowHead should expose a gyroscope heading mode toggle button');
  assert.match(html, /<button id="useMouseLook">Use Mouse Look: Off<\/button>/, 'ArrowHead should expose a mouse-look toggle for desktop browsers without orientation sensors');
  assert.match(html, /<pre id="debugInfo" class="debug">Debug info will appear after sensors start\.<\/pre>/, 'ArrowHead should render an inline debug panel for field diagnostics');
  assert.match(html, /function\s+updateDebugInfo\(stats\s*=\s*null\)\s*\{[\s\S]*GPS lat\/lon\/alt\(ft\):[\s\S]*Projection projected\/total:[\s\S]*Nearest bearing abs\/relative:/, 'ArrowHead should publish GPS, projection, and nearest-point diagnostics to the debug panel');
  assert.match(html, /updateDebugInfo\(drawStats\);[\s\S]*setStatus\(`AR live/, 'ArrowHead should refresh debug diagnostics each draw tick before status updates');
  assert.match(html, /if \(!state\.useGyroscopeHeading && Number\.isFinite\(pose\.headingRad\)\) state\.headingRad = pose\.headingRad;/, 'ArrowHead should default to magnetometer heading updates unless gyroscope mode is enabled');
  assert.match(html, /state\.gyroHeadingRawRad = integrateGyroscopeHeadingRadians\(state\.gyroHeadingRawRad, rotationRateAlpha, dtMs\);/, 'ArrowHead should integrate gyroscope rotationRate alpha into heading when gyroscope mode is enabled');
  assert.match(html, /state\.gyroHeadingOffsetRad = normalizeRadians\(-state\.gyroHeadingRawRad\);/, 'ArrowHead should support center calibration for gyroscope heading mode');
  assert.match(html, /function\s+attachMouseLookControls\(\)/, 'ArrowHead should register pointer-driven mouse-look controls');
  assert.match(html, /state\.headingRad = normalizeRadians\(state\.headingRad - \(dx \* state\.mouseLookSensitivity\)\);/, 'ArrowHead mouse look should update heading from horizontal drag distance');
  assert.match(html, /state\.pitchRad = clamp\(state\.pitchRad \+ \(dy \* state\.mouseLookSensitivity\), -pitchLimit, pitchLimit\);/, 'ArrowHead mouse look should update and clamp pitch from vertical drag distance');
  assert.match(html, /function\s+autoEnableMouseLookWhenSensorsUnavailable\(\)/, 'ArrowHead should automatically enable mouse look when orientation sensors are unavailable');
  assert.match(html, /setStatus\('Device orientation unavailable\. Mouse look enabled; drag to look around\.'/, 'ArrowHead should show a desktop fallback status message when enabling mouse look automatically');
  assert.match(html, /const\s+socket\s*=\s*new\s+WebSocket\(wsUrl\);/, 'ArrowHead should join the LineSmith collaboration websocket room');
  assert.match(html, /function\s+refreshPayloadFromStorage\(options\s*=\s*\{\}\)/, 'ArrowHead should support refreshing LineSmith payload updates while running');
  assert.match(html, /function\s+tryLoadPayloadFromLastOpenedDrawing\(\)/, 'ArrowHead should support bootstrapping payloads from the active project\'s last-opened LineSmith drawing');
  assert.match(html, /const\s+storageKey\s*=\s*loadLastOpenedProjectDrawing\(activeProjectId\);/, 'ArrowHead should resolve the last-opened drawing key by active project');
  assert.match(html, /const\s+payload\s*=\s*parsePayloadFromDrawingRecord\(storageKey\);/, 'ArrowHead should convert saved LineSmith drawing history into an ArrowHead payload');
  assert.match(html, /localStorage\.setItem\(ARROWHEAD_IMPORT_STORAGE_KEY, payloadRaw\);/, 'ArrowHead should persist reconstructed payloads so refresh watchers remain in sync');
  assert.match(html, /if \(refreshPayloadFromStorage\(\)\) return true;[\s\S]*if \(tryLoadPayloadFromLastOpenedDrawing\(\)\)/, 'ArrowHead should prioritize live LineSmith handoff payloads and fall back to last-opened project drawings');
  assert.doesNotMatch(html, /params\.get\('source'\) !== 'linesmith'/, 'ArrowHead should no longer require a strict LineSmith source query parameter to load geometry');
  assert.match(html, /window\.addEventListener\('storage',\s*\(event\)\s*=>\s*\{[\s\S]*event\.key\s*!==\s*ARROWHEAD_IMPORT_STORAGE_KEY/, 'ArrowHead should watch localStorage events for live LineSmith geometry updates');
  assert.match(html, /state\.payloadSyncIntervalId\s*=\s*window\.setInterval\(\(\)\s*=>\s*\{[\s\S]*refreshPayloadFromStorage\(\);[\s\S]*\},\s*1000\);/, 'ArrowHead should poll localStorage to pick up payload changes when storage events are unavailable');
  assert.match(html, /type:\s*'ar-presence'/, 'ArrowHead should publish AR user position and orientation to websocket peers');
  assert.match(html, /worldToLatLngAffine\(/, 'ArrowHead should project LineSmith world coordinates to lat\/lon for AR cursor overlays');
  assert.match(html, /latLngToWorldAffine\(/, 'ArrowHead should convert GPS lat\/lon into state-plane coordinates before publishing presence');

  assert.match(html, /import \{ computeForwardDistanceMeters, computeObserverElevationFeet, computeRelativeBearingRad, projectEnuPointToScreen, resolvePointElevationFeet \} from "\.\/src\/arrowhead-projection\.js";/, 'ArrowHead should import camera-space projection helpers from shared module code');
  assert.match(html, /import \{ createGuardedSensorHandler, safeSocketSend, toErrorMessage \} from "\.\/src\/arrowhead-sensor-guard\.js";/, 'ArrowHead should import sensor event guard utilities for resilient handler execution');
  assert.match(html, /function\s+handleSensorEventError\(error\)\s*\{[\s\S]*state\.sensorEventErrorCount\s*\+=\s*1;[\s\S]*toErrorMessage/, 'ArrowHead should track and surface recovered sensor handler exceptions for debugging');
  assert.match(html, /const\s+guardedApplyOrientationEvent\s*=\s*createGuardedSensorHandler\(applyOrientationEvent, handleSensorEventError\);/, 'ArrowHead should guard orientation callbacks against runtime event exceptions');
  assert.match(html, /window\.addEventListener\('devicemotion',\s*createGuardedSensorHandler\(\(event\)\s*=>\s*\{/, 'ArrowHead should guard motion callbacks against runtime event exceptions');
  assert.match(html, /safeSocketSend\(state\.collabSocket, JSON\.stringify\(\{[\s\S]*type:\s*'ar-presence'/, 'ArrowHead should avoid throwing from websocket presence publishes during sensor updates');
  assert.match(html, /const\s+DEFAULT_OBSERVER_HEIGHT_OFFSET_FEET\s*=\s*3;/, 'ArrowHead should default the observer altitude to 3 feet above point elevation');
  assert.match(html, /const\s+OPEN_ELEVATION_ENDPOINT\s*=\s*'https:\/\/api\.open-meteo\.com\/v1\/elevation';/, 'ArrowHead should use an open elevation dataset endpoint for zero-elevation points');
  assert.match(html, /async\s+function\s+requestOpenElevationMeters\(points\)\s*\{[\s\S]*OPEN_ELEVATION_ENDPOINT[\s\S]*payload\.elevation/, 'ArrowHead should request fallback point elevations from the open dataset API');
  assert.match(html, /function\s+resolvePayloadPointElevationFeet\(point\)\s*\{[\s\S]*state\.pointElevationFallbackFeetById[\s\S]*resolvePointElevationFeet/, 'ArrowHead should resolve zero-elevation points using fetched fallback elevations');
  assert.match(html, /state\.userAltFeet\s*=\s*computeObserverElevationFeet\(state\.rawUserAltFeet, baselinePointElevationFeet, DEFAULT_OBSERVER_HEIGHT_OFFSET_FEET\);/, 'ArrowHead should place the observer in world space using GPS altitude plus the default 3-foot offset');
  assert.match(html, /const\s+projection\s*=\s*projectEnuPointToScreen\(\{[\s\S]*nearClipMeters:\s*0\.5,[\s\S]*\}\);/, 'ArrowHead should project ENU deltas through camera-space yaw/pitch/roll with near-plane clipping');
  assert.match(html, /if \(!projection\) return null;/, 'ArrowHead should cull points that land behind or too close to the camera after orientation transforms');
  assert.match(html, /const\s+ON_TARGET_CENTER_FRACTION\s*=\s*0\.1;/, 'ArrowHead should define a center-target fraction matching the middle 10% of the feed');
  assert.match(html, /const\s+centerHalfWidth\s*=\s*canvas\.width\s*\*\s*ON_TARGET_CENTER_FRACTION\s*\*\s*0\.5;/, 'ArrowHead should compute horizontal center-zone bounds');
  assert.match(html, /const\s+centerHalfHeight\s*=\s*canvas\.height\s*\*\s*ON_TARGET_CENTER_FRACTION\s*\*\s*0\.5;/, 'ArrowHead should compute vertical center-zone bounds');
  assert.match(html, /ctx\.arc\(onTargetPoint\.x, onTargetPoint\.y, ringRadius, 0, Math\.PI \* 2\);/, 'ArrowHead should draw an on-target circle around the centered point');
  assert.match(html, /On target â€¢ \$\{onTargetPoint\.distanceM\.toFixed\(1\)\} m \(\$\{distanceFeet\.toFixed\(1\)\} ft\)/, 'ArrowHead should overlay on-target distance guidance text');
});
