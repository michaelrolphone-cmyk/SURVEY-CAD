<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PointForge // NAD83 Idaho West // G+REF Renumber + Map</title>

  <!-- Leaflet (map preview). For fully-offline use, download these assets and replace CDN links. -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    :root{
      --bg0:#0f172a;
      --bg1:#111c35;
      --line: rgba(148,163,184,.25);
      --line2: rgba(148,163,184,.15);

      --text:#e2e8f0;
      --muted:#94a3b8;

      --c1:#2a3dff;
      --c2:#22c55e;
      --c3:#4ade80;
      --warn:#ffbd2e;
      --bad:#ff4d6d;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --r: 16px;
    }

    *{ box-sizing: border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(900px 600px at 20% 0%, rgba(51,65,85,.45), transparent 60%),
                  radial-gradient(700px 500px at 80% 10%, rgba(30,41,59,.45), transparent 55%),
                  linear-gradient(180deg, var(--bg0) 0%, var(--bg1) 100%);
      overflow-x: hidden;
    }

    header{
      position: sticky; top:0; z-index: 50;
      backdrop-filter: blur(4px);
      background: rgba(15, 23, 42, 0.88);
      border-bottom: 1px solid var(--line);
    }
    .top{
      padding: 14px 18px;
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 14px;
    }
    .brand{
      display:flex;
      flex-direction: column;
      gap: 4px;
      min-width: 280px;
    }
    .brand .title{
      display:flex; align-items: baseline; gap: 10px;
      font-weight: 800;
      letter-spacing: .8px;
      text-transform: uppercase;
      font-size: 12px;
    }
    .badge{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(116,140,255,.7);
      background: rgba(42,61,255,.25);
      color: #dbe5ff;
    }
    .brand .sub{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }
    .statusbar{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      align-items: center;
      min-width: 280px;
    }
    .mapMetaRow{
      margin-top: 8px;
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .workflowHeaderAction{ margin-left:auto; }
    .chip{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(30,41,59,.4);
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    .dot{
      width:8px; height:8px;
      border-radius: 99px;
      background: var(--c3);
      box-shadow: none;
    }
    .mono{ font-family: var(--mono); color: var(--text); }

    main{
      padding: 16px 18px 24px;
      display:grid;
      grid-template-columns: 460px 1fr;
      gap: 14px;
      transition: grid-template-columns .25s ease;
    }
    @media (max-width: 1020px){
      main{ grid-template-columns: 1fr; }
    }

    .leftStack{ display:grid; gap:10px; }
    .accordionStack{ position:relative; min-height: 780px; }

    .panel{
      border-radius: var(--r);
      background: rgba(30,41,59,.35);
      border: 1px solid var(--line);
      box-shadow: 0 8px 24px rgba(2,6,23,.32);
      overflow:hidden;
      position: relative;
    }
    .panel::before{
      content:none;
    }
    #outputPanel{
      position:relative;
      inset:auto;
      z-index:auto;
      opacity:1;
      pointer-events:auto;
      transform:none;
      transition: transform .25s ease, opacity .2s ease;
    }
    main.pointEditorFocusOutput #outputPanel{
      position:absolute;
      inset:0;
      z-index: 2;
      opacity:1;
      pointer-events:auto;
      transform: translateX(0);
      left: 56px;
    }
    main.pointEditorFocusOutput #ingestPanel{
      position:absolute;
      inset:0 auto 0 0;
      width:56px;
      z-index:3;
    }
    main.pointEditorFocusOutput #ingestPanel .panelbody{ display:none; }
    main.pointEditorFocusOutput #ingestPanel .panelhead{ cursor:pointer; min-height:100%; justify-content:center; }
    main.pointEditorFocusOutput #ingestPanel .panelhead h2{ writing-mode:vertical-rl; text-orientation:mixed; }
    main.pointEditorFocusOutput #ingestPanel #ingestControls{ display:none; }
    main.pointEditorFocusOutput #outputPanel .panelbody textarea,
    main.pointEditorFocusOutput #outputPanel .panelbody .pointsTableWrap.active{ min-height: 640px; }
    main.pointEditorFocusInput #ingestPanel{ margin-right:56px; }
    main.pointEditorFocusInput #outputPanel{
      position:absolute;
      opacity:1;
      pointer-events:auto;
      transform: translateX(0);
      inset:0 0 0 auto;
      width:56px;
      z-index:3;
    }
    main.pointEditorFocusInput #outputPanel .panelbody{ display:none; }
    main.pointEditorFocusInput #outputPanel .panelhead{ cursor:pointer; min-height:100%; justify-content:center; }
    main.pointEditorFocusInput #outputPanel .panelhead h2{ writing-mode:vertical-lr; text-orientation:mixed; }
    main.pointEditorFocusInput #outputPanel .chip{ display:none; }
    .panelhead{
      position: relative;
      padding: 12px 12px;
      border-bottom: 1px solid var(--line2);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      background: rgba(15,23,42,.6);
      backdrop-filter: blur(4px);
    }
    .panelhead h2{
      margin:0;
      font-size: 12px;
      letter-spacing: .9px;
      text-transform: uppercase;
      font-weight: 850;
      color: rgba(231,240,255,.92);
      display:flex;
      align-items:center;
      gap: 10px;
    }
    .panelhead h2 .sig{
      width: 10px; height: 10px;
      border-radius: 2px;
      background: linear-gradient(135deg, var(--c1), var(--c2));
      box-shadow: none;
    }

    .panelbody{
      position: relative;
      padding: 12px;
    }

    .row{ display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    label{ font-size: 12px; color: var(--muted); }
    input[type="file"]{ width: 100%; color: var(--muted); }
    input[type="number"]{
      width: 110px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(15,23,42,.8);
      color: var(--text);
      font-size: 12px;
    }
    input[type="number"]:focus{
      outline: none;
      border-color: rgba(116,140,255,.75);
    }
    .coordInput{
      width: 132px !important;
    }
    .localizationPanel{
      margin-top: 10px;
      padding: 10px;
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 12px;
      background: rgba(8,10,16,.42);
      display:grid;
      gap: 8px;
    }
    .leftStack > .localizationPanel{
      margin: 0 0 10px;
    }
    .localizationRow{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap: wrap;
    }

    textarea{
      width: 100%;
      min-height: 260px;
      resize: vertical;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,.4);
      background: rgba(15,23,42,.82);
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
      outline: none;
    }
    textarea:focus{
      border-color: rgba(116,140,255,.85);
    }

    select{
      appearance:none;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      color: var(--text);
      outline:none;
      font-size: 12px;
    }
    select:focus{ border-color: rgba(116,140,255,.75); box-shadow: none; }

    .btn{
      border: 1px solid rgba(116,140,255,.75);
      color: rgba(231,240,255,.95);
      background: linear-gradient(180deg, rgba(42,61,255,.92), rgba(26,37,95,.95));
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 850;
      font-size: 12px;
      letter-spacing: .5px;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow: 0 0 0 1px rgba(255,255,255,.16) inset;
      transition: transform .08s ease, box-shadow .15s ease, border-color .15s ease;
    }
    .btn:hover{
      border-color: rgba(116,140,255,.95);
    }
    .btn:active{ transform: translateY(1px); }
    .btn.secondary{
      border-color: rgba(255,255,255,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      box-shadow: 0 0 0 1px rgba(255,255,255,.05) inset;
    }
    .btn.secondary:hover{
      border-color: rgba(255,255,255,.26);
      box-shadow: 0 0 0 1px rgba(255,255,255,.07) inset, 0 0 22px rgba(255,255,255,.06);
    }
    .btn.workflowPrimary{
      border-color: rgba(116,140,255,.9);
      background: linear-gradient(180deg, rgba(42,61,255,1), rgba(26,37,95,.96));
      box-shadow: 0 0 0 1px rgba(255,255,255,.16) inset, 0 10px 26px rgba(42,61,255,.28);
    }
    .btn.workflowPrimary:hover{
      border-color: rgba(138,158,255,.95);
    }
    .btn[disabled]{ opacity: .45; cursor: not-allowed; filter: grayscale(.2); box-shadow: none; }

    .pill{
      display:inline-flex; align-items:center; gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,14,22,.44);
      color: var(--muted);
      font-size: 12px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset;
      flex-wrap: wrap;
    }
    input[type="checkbox"]{ width: 16px; height: 16px; accent-color: var(--c1); }
    .hint{ margin: 8px 0 0; font-size: 12px; color: var(--muted); line-height: 1.35; }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 540px){ .grid2{ grid-template-columns:1fr; } }
    @media (max-width: 700px){
      .top{ align-items: center; }
      .brand,
      .statusbar{ min-width: 0; }
      .statusbar{ width: 100%; }
      .workflowHeaderAction{ margin-left: 0; width: 100%; }
    }

    .log{ display:none; }
    .ok{ color: var(--c3); }
    .warn{ color: var(--warn); }
    .bad{ color: var(--bad); }

    #map{
      height: 380px;
      width: 100%;
      border-radius: var(--r);
      border: 1px solid rgba(0,229,255,.22);
      box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset;
      overflow: hidden;
    }
    .leaflet-container{ background: #06101b; }
    .leaflet-control-zoom a{
      background: rgba(15,23,42,.88) !important;
      color: var(--text) !important;
      border: 1px solid rgba(255,255,255,.16) !important;
      box-shadow: none;
    }
    .leaflet-control-attribution{
      background: rgba(8,10,16,.55) !important;
      color: rgba(138,164,194,.85) !important;
      border-radius: 10px !important;
      border: 1px solid rgba(255,255,255,.10) !important;
      margin: 0 8px 8px 0 !important;
    }

    .right{
      display:grid;
      grid-template-rows: auto 1fr;
      gap: 14px;
    }
    .outputArea{ min-height: 320px; }

    .kbd{
      font-family: var(--mono);
      padding: 2px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(8,10,16,.55);
      color: var(--text);
      font-size: 11px;
    }
    .toggleRow{ margin-top: 10px; display:flex; justify-content:flex-end; }
    .pointsTableWrap{
      --point-table-line-item-height: 30px;
      --point-table-visible-line-items: 25;
      border:1px solid rgba(255,255,255,.14);
      border-radius:12px;
      overflow:hidden;
      background: rgba(5,7,11,.75);
      max-height: calc((var(--point-table-visible-line-items) + 1) * var(--point-table-line-item-height));
      display:none;
      flex-direction:column;
    }
    .pointsTableWrap.active{ display:flex; }
    .pointsTableScroll{ overflow:auto; }
    .pointsTable{ width:100%; border-collapse:collapse; font-size:12px; }
    .pointsTable th, .pointsTable td{ padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.09); text-align:left; white-space:nowrap; }
    .pointsTable thead th{ position:sticky; top:0; background: rgba(9,12,18,.95); color: var(--muted); }
    .pointsTable input{
      width:100%;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(8,10,16,.75);
      color: var(--text);
      border-radius:8px;
      padding:6px;
      font-size:12px;
    }
    .pointGroupExplorer{ margin-top:10px; border:1px solid var(--line2); border-radius:12px; padding:10px; display:grid; gap:8px; background: rgba(8,10,16,.3); }
    .pointGroupList{ display:grid; gap:8px; max-height:280px; overflow:auto; padding-right:4px; }
    .pointGroupCard{ display:grid; gap:6px; border:1px solid var(--line2); border-radius:10px; padding:8px; background: rgba(15,23,42,.55); }
    .pointGroupButton{ width:100%; text-align:left; background:transparent; border:1px solid transparent; color:var(--text); border-radius:10px; padding:6px; cursor:pointer; display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .pointGroupButton.active{ border-color: rgba(116,140,255,.85); background: rgba(42,61,255,.2); }
    .pointGroupMeta{ font-size:11px; color: var(--muted); }
    .pointGroupThumb{ width:88px; height:52px; border-radius:8px; border:1px solid var(--line2); object-fit:cover; background: rgba(2,6,23,.5); }
    .pointGroupChildren{ display:grid; gap:6px; margin-left:10px; border-left:1px solid var(--line2); padding-left:8px; }
  </style>
  <script type="module" src="/src/browser-localstorage-sync.js"></script>
</head>

<body>
  <header>
    <div class="top">
      <div class="brand">
        <div class="title">
          <span class="badge">POINTFORGE</span>
        </div>
      </div>

      <div class="statusbar">
        <select id="pointFileSelect" style="min-width:200px; max-width:320px;">
          <option value="">Select point file…</option>
        </select>
        <button id="btnDownload" class="btn secondary" disabled>Download</button>
        <button id="btnOpenLineSmith" class="btn workflowPrimary workflowHeaderAction" disabled>Open in LineSmith</button>
      </div>
    </div>
  </header>

  <main>
    <!-- Left: Input + Output accordion -->
    <section class="leftStack">
    <div class="localizationPanel">
      <div class="localizationRow">
        <input id="enableLocalization" type="checkbox" />
        <label for="enableLocalization" style="color:var(--text); margin:0;">Localize points with anchor GPS</label>
      </div>
      <div class="localizationRow">
        <label for="anchorPointNumber" style="color:var(--text); margin:0;">Anchor point #</label>
        <input id="anchorPointNumber" class="coordInput" type="number" min="1" step="1" placeholder="100" disabled />
        <label for="anchorLat" style="color:var(--text); margin:0;">Lat/Lon</label>
        <input id="anchorLat" class="coordInput" type="number" step="0.000001" placeholder="43.610000" disabled />
        <input id="anchorLon" class="coordInput" type="number" step="0.000001" placeholder="-116.200000" disabled />
      </div>
      <div class="hint" id="localizationHint" style="margin:0;">Optional: select an existing point number as the local anchor and pair it with one known GPS anchor.</div>
    </div>
    <div class="accordionStack">
    <section class="panel" id="ingestPanel">
      <div class="panelhead">
        <h2><span class="sig"></span> Ingest Console</h2>
        <div class="pill" id="ingestControls">
          <input id="autoProcess" type="checkbox" checked />
          <label for="autoProcess" style="color:var(--text); margin:0;">Auto-process</label>
        </div>
      </div>
      <div class="panelbody">
        <div class="row" style="width:100%;">
          <div style="flex:1 1 100%;">
            <label for="file">Load point file (.txt / .csv)</label>
            <input id="file" type="file" accept=".txt,.csv,text/plain,text/csv" />
            <div class="hint">Or paste into the field below. Processing keeps coordinates unchanged while renumbering point IDs.</div>
          </div>
        </div>

        <label for="inText">Raw points</label>
        <textarea id="inText" spellcheck="false" placeholder="Paste points here... (no sample data loaded)"></textarea>
        <div class="toggleRow">
          <button id="btnToggleInputView" class="btn secondary" type="button">Switch to Point Editor View</button>
        </div>
        <div id="inputTableWrap" class="pointsTableWrap" aria-hidden="true">
          <div class="pointsTableScroll">
            <table class="pointsTable">
              <thead>
                <tr><th>#</th><th>X</th><th>Y</th><th>Z</th><th>Code</th><th>Notes</th></tr>
              </thead>
              <tbody id="inputPointsBody"></tbody>
            </table>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnProcess" class="btn">Process</button>
        </div>

        <div class="grid2" style="margin-top: 10px; display:none;">
          <div class="pill">
            <span class="mono">Zone</span>
            <select id="zone" title="State Plane zone" style="min-width: 160px;">
              <option value="west" selected>Idaho West</option>
              <option value="central">Idaho Central</option>
              <option value="east">Idaho East</option>
            </select>
          </div>

          <div class="pill">
            <input id="showLabels" type="checkbox" checked />
            <label for="showLabels" style="color:var(--text); margin:0;">Show marker labels</label>
          </div>
        </div>

        <div class="grid2" style="margin-top: 10px; display:none;">
          <div class="pill">
            <input id="swapXY" type="checkbox" checked disabled />
            <label for="swapXY" style="color:var(--text); margin:0;">Swap X/Y (locked default)</label>
          </div>
          <div class="pill">
            <span class="mono">Units</span>
            <select id="units" style="min-width: 160px;" disabled>
              <option value="usft" selected>US-ft (locked)</option>
            </select>
          </div>
        </div>

        <div class="log" id="log"></div>
      </div>
    </section>

    <section class="panel outputArea" id="outputPanel">
      <div class="panelhead">
        <h2><span class="sig"></span> Output Stream</h2>
        <div class="chip">Sorted: <span class="mono">numeric point id</span></div>
      </div>
      <div class="panelbody">
        <label for="outText">Transformed points</label>
        <textarea id="outText" spellcheck="false" readonly></textarea>
        <div id="outputActions" class="row" style="margin-top:10px;" hidden>
          <button id="btnRenumber" class="btn secondary" disabled>Renumber Output</button>
          <span class="pill">
            <label for="renumberStart" style="color:var(--text); margin:0;">Renumber start</label>
            <input id="renumberStart" type="number" min="1" step="1" value="1" />
          </span>
        </div>
        <div id="outputTableWrap" class="pointsTableWrap" aria-hidden="true">
          <div class="pointsTableScroll">
            <table class="pointsTable">
              <thead>
                <tr><th>#</th><th>X</th><th>Y</th><th>Z</th><th>Code</th><th>Notes</th></tr>
              </thead>
              <tbody id="outputPointsBody"></tbody>
            </table>
          </div>
        </div>
        <div class="hint">Download saves exactly what you see here.</div>
      </div>
    </section>
    </div>
    </section>

    <!-- Right: Map -->
    <section class="right">
      <section class="panel">
        <div class="panelhead">
          <h2><span class="sig"></span> Spatial HUD</h2>
          <div class="chip">Projection: <span class="mono">Idaho SP (US-ft)</span></div>
        </div>
        <div class="panelbody">
          <section class="pointGroupExplorer" aria-live="polite">
            <div class="row" style="justify-content:space-between;">
              <strong style="font-size:12px; letter-spacing:.4px;">Point Groups by Code</strong>
              <span id="pointGroupSummary" class="pointGroupMeta">No groups yet.</span>
            </div>
            <div id="pointGroupList" class="pointGroupList"></div>
            <div id="pointGroupAction" class="hint" style="margin:0;">Select a group to open linework in BoundaryLab.</div>
          </section>

          <div id="map"></div>
          <div class="hint" id="mapHint">Load a file or paste points to plot.</div>
          <div class="mapMetaRow">
            <span class="chip">DATUM: <span class="mono">NAD83 (NO_TRANS)</span></span>
            <span class="chip">BASEMAP:
              <select id="basemap" style="min-width: 170px;">
                <option value="street" selected>Street</option>
                <option value="satellite">Satellite</option>
              </select>
            </span>
            <span class="chip">PIPELINE: <span class="mono">PARSE → RENUMB → SORT → PLOT</span></span>
          </div>
        </div>
      </section>

    </section>
  </main>

  <!-- libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/proj4@2.10.0/dist/proj4.js"></script>
  <script type="module" src="/src/point-thumbnail-client.js"></script>

  <script>
    // -----------------------------
    // CSV helpers
    // -----------------------------
    function parseCSVLine(line){
      const out = [];
      let cur = "";
      let inQuotes = false;

      for (let i=0; i<line.length; i++){
        const ch = line[i];
        if (inQuotes){
          if (ch === '"'){
            if (i+1 < line.length && line[i+1] === '"'){ cur += '"'; i++; }
            else inQuotes = false;
          } else cur += ch;
        } else {
          if (ch === ','){ out.push(cur); cur = ""; }
          else if (ch === '"'){ inQuotes = true; }
          else cur += ch;
        }
      }
      out.push(cur);
      return out;
    }

    function csvEscape(v){
      const s = (v ?? "").toString();
      if (/[",\n\r]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
      return s;
    }

    function isIntString(s){ return /^\s*\d+\s*$/.test(s); }
    function toInt(s){ return parseInt(String(s).trim(), 10); }
    function trimOrEmpty(s){ return (s ?? "").toString().trim(); }

    // -----------------------------
    // Point classification
    // -----------------------------
    function classifyName(name){
      const n = trimOrEmpty(name);
      const isRef = /REF/i.test(n);
      const gMatch = n.match(/^(\d+)\s*G(\d+)?\s*$/i); // 15G, 202G, 123G1
      const isG = !!gMatch && !isRef;
      const gPrefix = isG ? parseInt(gMatch[1], 10) : null;
      const gSuffix = (isG && gMatch[2] != null) ? parseInt(gMatch[2], 10) : null;
      return { isRef, isG, gPrefix, gSuffix };
    }

    function appendToDesc(fields, token){
      const last = fields.length - 1;
      const existing = trimOrEmpty(fields[last]);
      fields[last] = existing ? (existing + " " + token) : token;
    }

    // -----------------------------
    // Block allocation logic
    // -----------------------------
    function computeUsedBlocks(usedNums){
      const blocks = new Set();
      for (const n of usedNums){
        if (!Number.isFinite(n)) continue;
        blocks.add(Math.floor(n / 100) * 100);
      }
      return blocks;
    }

    function pickFreeBlock({ start, usedBlocks, allocatedBlocks, avoidBlocks = new Set(), maxBlock = 20000 }){
      for (let b = start; b <= maxBlock; b += 100){
        if (b === 5000) continue; // reserved for REF renumbering
        if (avoidBlocks.has(b)) continue;
        if (allocatedBlocks.has(b)) continue;
        if (usedBlocks.has(b)) continue;
        return b;
      }
      return null;
    }

    function allocatePreferredInBlock(preferred, blockStart, usedNums){
      const blockEnd = blockStart + 99;

      if (Number.isFinite(preferred) && !usedNums.has(preferred) && preferred >= blockStart && preferred <= blockEnd){
        usedNums.add(preferred);
        return preferred;
      }
      for (let n = blockStart; n <= blockEnd; n++){
        if (!usedNums.has(n)){
          usedNums.add(n);
          return n;
        }
      }
      // overflow if block completely full
      let n = blockEnd + 1;
      while (usedNums.has(n)) n++;
      usedNums.add(n);
      return n;
    }

    // -----------------------------
    // Main transform
    // -----------------------------
    function transformPoints(text){
      const rawLines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
      const records = [];
      const log = [];
      let parsedCount = 0;

      for (let i=0; i<rawLines.length; i++){
        const line = rawLines[i];
        if (!line || !line.trim()) continue;

        const fields = parseCSVLine(line);
        if (fields.length < 2){
          records.push({ idx:i, passthrough:true, fields });
          continue;
        }

        // Ensure description column exists (at least 5 columns)
        while (fields.length < 5) fields.push("");

        const name = trimOrEmpty(fields[0]);
        const cls = classifyName(name);

        const x = Number.parseFloat(fields[1]);
        const y = (fields.length > 2) ? Number.parseFloat(fields[2]) : NaN;

        records.push({
          idx: i,
          passthrough:false,
          fields,
          origName: name,
          cls,
          x, y,
          newNum: null
        });
        parsedCount++;
      }

      // Used numeric point numbers from non-special points (so we don't collide).
      const usedNums = new Set();
      for (const r of records){
        if (r.passthrough) continue;
        const name = trimOrEmpty(r.fields[0]);
        if (isIntString(name) && !r.cls.isRef && !r.cls.isG){
          usedNums.add(toInt(name));
        }
      }

      // 1) REF points => 5000+
      let refCount = 0;
      let nextRef = 5000;
      for (const r of records){
        if (r.passthrough) continue;
        if (!r.cls.isRef) continue;

        while (usedNums.has(nextRef)) nextRef++;
        r.newNum = nextRef;
        usedNums.add(nextRef);
        refCount++;

        appendToDesc(r.fields, r.origName);
        r.fields[0] = String(nextRef);
        nextRef++;
      }

      // 2) G points => allocate 100-block ranges
      const gRecords = records.filter(r => !r.passthrough && r.cls.isG);
      const gCount = gRecords.length;

      const usedBlocks = computeUsedBlocks(usedNums);
      const allocatedBlocks = new Set();

      const simpleGroups = new Map(); // origHundreds -> records[] for <digits>G (no suffix)
      const suffixCandidates = [];    // <digits>G<digits>

      for (const r of gRecords){
        if (r.cls.gSuffix == null){
          const h0 = Math.floor(r.cls.gPrefix / 100) * 100; // 0, 100, 200, ...
          const key = String(h0);
          if (!simpleGroups.has(key)) simpleGroups.set(key, []);
          simpleGroups.get(key).push(r);
        } else {
          suffixCandidates.push(r);
        }
      }

      // Determine multiplicity by prefix for suffix candidates
      const byPrefix = new Map();
      for (const r of suffixCandidates){
        const p = r.cls.gPrefix;
        if (!byPrefix.has(p)) byPrefix.set(p, []);
        byPrefix.get(p).push(r);
      }

      const seriesGroups = [];             // multiple per prefix => derive from suffix
      const singletonBySuffix = new Map(); // single per prefix => group by suffix and sequentially number

      for (const [p, arr] of byPrefix.entries()){
        if (arr.length > 1){
          seriesGroups.push({ key: "prefix:" + p, prefix: p, records: arr });
        } else {
          const r = arr[0];
          const sfx = r.cls.gSuffix;
          if (!singletonBySuffix.has(sfx)) singletonBySuffix.set(sfx, []);
          singletonBySuffix.get(sfx).push(r);
        }
      }

      // Allocate blocks for simple groups: start 200.., avoid 500-block (preferred for suffix logic)
      const simpleKeys = Array.from(simpleGroups.keys()).map(k => parseInt(k,10));
      simpleKeys.sort((a,b)=>{
        const az = (a===0)?1:0;
        const bz = (b===0)?1:0;
        if (az !== bz) return az - bz;
        return a - b;
      });

      const groupBlockAssignments = [];

      for (const h0 of simpleKeys){
        const recs = simpleGroups.get(String(h0));
        const avoid = new Set([500]); // reserve 500s for suffix numbering feel
        if (h0 >= 100) avoid.add(h0);

        const block = pickFreeBlock({
          start: 200,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: avoid,
          maxBlock: 20000
        }) ?? pickFreeBlock({
          start: 200,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: new Set([500]),
          maxBlock: 20000
        }) ?? 200;

        allocatedBlocks.add(block);
        usedBlocks.add(block);
        groupBlockAssignments.push({ kind:"simple", origHundreds:h0, block, count: recs.length });

        for (const r of recs){
          const preferred = block + (r.cls.gPrefix % 100);
          const assigned = allocatePreferredInBlock(preferred, block, usedNums);
          r.newNum = assigned;
          appendToDesc(r.fields, r.origName);
          r.fields[0] = String(assigned);
        }
      }

      // Series groups: prefer 500-block upwards so ...G1 becomes X01 (e.g., 501)
      seriesGroups.sort((a,b)=>a.prefix - b.prefix);
      for (const g of seriesGroups){
        const block = pickFreeBlock({
          start: 500,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: new Set(),
          maxBlock: 20000
        }) ?? pickFreeBlock({
          start: 200,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: new Set([5000]),
          maxBlock: 20000
        }) ?? 500;

        allocatedBlocks.add(block);
        usedBlocks.add(block);
        groupBlockAssignments.push({ kind:"series", key:g.key, block, count: g.records.length });

        for (const r of g.records){
          const sfx = r.cls.gSuffix;
          const preferred = block + sfx;
          const assigned = allocatePreferredInBlock(preferred, block, usedNums);
          r.newNum = assigned;
          appendToDesc(r.fields, r.origName);
          r.fields[0] = String(assigned);
        }
      }

      // Singleton-by-suffix groups: sequential numbering inside their allocated block.
      const suffixKeys = Array.from(singletonBySuffix.keys()).sort((a,b)=>a-b);
      for (const sfx of suffixKeys){
        const recs = singletonBySuffix.get(sfx);

        const block = pickFreeBlock({
          start: 500,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: new Set(),
          maxBlock: 20000
        }) ?? pickFreeBlock({
          start: 200,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: new Set([5000]),
          maxBlock: 20000
        }) ?? 500;

        allocatedBlocks.add(block);
        usedBlocks.add(block);
        groupBlockAssignments.push({ kind:"suffixSingles", suffix:sfx, block, count: recs.length });

        recs.sort((a,b)=>a.idx-b.idx);
        for (const r of recs){
          const assigned = allocatePreferredInBlock(block, block, usedNums);
          r.newNum = assigned;
          appendToDesc(r.fields, r.origName);
          r.fields[0] = String(assigned);
        }
      }

      // 3) Sort numerically by final point number
      const sortable = records.filter(r => !r.passthrough);
      sortable.sort((a,b)=>{
        const an = isIntString(a.fields[0]) ? toInt(a.fields[0]) : Number.POSITIVE_INFINITY;
        const bn = isIntString(b.fields[0]) ? toInt(b.fields[0]) : Number.POSITIVE_INFINITY;
        if (an !== bn) return an - bn;
        return a.idx - b.idx;
      });

      const passthrough = records.filter(r => r.passthrough).sort((a,b)=>a.idx-b.idx);

      const outLines = [];
      for (const r of sortable) outLines.push(r.fields.map(csvEscape).join(","));
      for (const r of passthrough) outLines.push(r.fields.map(csvEscape).join(","));

      log.push(`BLOCK ALLOCATION`);
      for (const g of groupBlockAssignments){
        if (g.kind === "simple") log.push(`  simple G (orig hundreds ${g.origHundreds}) -> ${g.block}-${g.block+99}  (${g.count})`);
        else if (g.kind === "series") log.push(`  suffix series (${g.key}) -> ${g.block}-${g.block+99}  (${g.count})`);
        else log.push(`  suffix singletons (G${g.suffix}) -> ${g.block}-${g.block+99}  (${g.count})`);
      }

      return {
        recordsSorted: sortable,
        outputText: outLines.join("\n"),
        stats: { totalLines: rawLines.length, parsedCount, gCount, refCount },
        logText: log.join("\n")
      };
    }

    // -----------------------------
    // Idaho State Plane defs (NAD83; "NO_TRANS": no grid shift terms)
    // Fixed defaults: US-ft + Swap X/Y
    // -----------------------------
    const PROJ_DEFS_USFT = {
      east:   "+proj=tmerc +lat_0=41.6666666666667 +lon_0=-112.166666666667 +k=0.999947368 +x_0=200000.0001016 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs",
      central:"+proj=tmerc +lat_0=41.6666666666667 +lon_0=-114 +k=0.999947368 +x_0=500000.0001016 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs",
      west:   "+proj=tmerc +lat_0=41.6666666666667 +lon_0=-115.75 +k=0.999933333 +x_0=800000.0001016 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs"
    };

    const ID_BBOX = { minLat: 41.8, maxLat: 49.6, minLon: -117.6, maxLon: -110.4 };
    function inIdaho(lat, lon){
      return lat >= ID_BBOX.minLat && lat <= ID_BBOX.maxLat && lon >= ID_BBOX.minLon && lon <= ID_BBOX.maxLon;
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    // -----------------------------
    // UI + Map (basemap switcher)
    // -----------------------------
    const elMain = document.querySelector("main");
    const elIngestPanel = document.getElementById("ingestPanel");
    const elOutputPanel = document.getElementById("outputPanel");
    const elFile = document.getElementById("file");
    const elIn = document.getElementById("inText");
    const elOut = document.getElementById("outText");
    const elOutputActions = document.getElementById("outputActions");
    const elLog = document.getElementById("log");
    const elDownload = document.getElementById("btnDownload");
    const elProcess = document.getElementById("btnProcess");
    const elRenumber = document.getElementById("btnRenumber");
    const elOpenLineSmith = document.getElementById("btnOpenLineSmith");
    const elAuto = document.getElementById("autoProcess");
    const elZone = document.getElementById("zone");
    const elShowLabels = document.getElementById("showLabels");
    const elBasemap = document.getElementById("basemap");
    const elRenumberStart = document.getElementById("renumberStart");
    const elMapHint = document.getElementById("mapHint");
    const elEnableLocalization = document.getElementById("enableLocalization");
    const elAnchorPointNumber = document.getElementById("anchorPointNumber");
    const elAnchorLat = document.getElementById("anchorLat");
    const elAnchorLon = document.getElementById("anchorLon");
    const elLocalizationHint = document.getElementById("localizationHint");
    const elPointGroupList = document.getElementById("pointGroupList");
    const elPointGroupSummary = document.getElementById("pointGroupSummary");
    const elPointGroupAction = document.getElementById("pointGroupAction");

    const elPointFileSelect = document.getElementById("pointFileSelect");

    const st_lines = document.getElementById("st_lines");
    const st_parsed = document.getElementById("st_parsed");
    const st_g = document.getElementById("st_g");
    const st_ref = document.getElementById("st_ref");
    const st_map = document.getElementById("st_map");
    const st_zone = document.getElementById("st_zone");

    const SURVEY_SKETCH_IMPORT_STORAGE_KEY = "lineSmithPointforgeImport";
    const ROS_POINTFORGE_IMPORT_STORAGE_KEY = "pointforgeRosImport";
    const PROJECT_BROWSER_POINTFORGE_IMPORT_STORAGE_KEY = "pointforgeProjectBrowserImport";
    const BOUNDARYLAB_POINTFORGE_IMPORT_STORAGE_KEY = "pointforgeBoundaryLabImport";
    const PROJECT_FILE_STORAGE_PREFIX = "surveyfoundryProjectFile";
    const POINTFORGE_POINT_SET_STORAGE_PREFIX = "pointforgePointSet";
    const PROJECT_LAST_POINT_SET_PREFIX = "surveyfoundryLastPointforgePointSet";

    let latestOutputText = "";
    let latestTransformed = null;
    let latestPointGroups = [];
    let selectedGroupSelection = null;
    let currentImportContext = null;
    let usePointEditorView = false;
    let pointEditorAccordionMode = "input";
    let projectPointFilesCache = [];

    const elInputTableWrap = document.getElementById("inputTableWrap");
    const elOutputTableWrap = document.getElementById("outputTableWrap");
    const elInputPointsBody = document.getElementById("inputPointsBody");
    const elOutputPointsBody = document.getElementById("outputPointsBody");
    const elToggleInputView = document.getElementById("btnToggleInputView");
    const pointThumbnailClient = window.SurveyCadPointThumbnailClient || null;

    function normalizeCodeToken(token = ""){
      return String(token || "").trim().toUpperCase();
    }

    function getPointGroupCodeToken(code = ""){
      const [groupToken] = String(code || "")
        .trim()
        .split(/\s+/)
        .filter(Boolean);
      return normalizeCodeToken(groupToken || "");
    }

    function parseFieldToFinishDirective(code = ""){
      if (pointThumbnailClient?.parseFieldToFinishDirective) {
        return pointThumbnailClient.parseFieldToFinishDirective(code);
      }
      const tokens = String(code || "")
        .split(/[\s;|,/]+/)
        .map(normalizeCodeToken)
        .filter(Boolean);
      if (!tokens.length) return null;
      const directives = new Set(["BEG", "END", "CLO"]);
      let action = "MID";
      let baseCode = "";
      for (const token of tokens){
        if (directives.has(token)){
          action = token;
          continue;
        }
        if (!baseCode && /[A-Z]/.test(token)) baseCode = token;
      }
      if (!baseCode) return null;
      return { action, baseCode };
    }

    function buildLineworkSegments(points = []){
      if (pointThumbnailClient?.buildLineworkSegments) {
        return pointThumbnailClient.buildLineworkSegments(points);
      }
      const segmentsByBase = new Map();
      const activeByBase = new Map();
      for (const point of points){
        const directive = parseFieldToFinishDirective(point.code);
        if (!directive) continue;
        const baseCode = directive.baseCode;
        const action = directive.action;
        if (!segmentsByBase.has(baseCode)) segmentsByBase.set(baseCode, []);
        let active = activeByBase.get(baseCode) || null;

        if (action === "BEG"){
          active = [point];
          segmentsByBase.get(baseCode).push(active);
          activeByBase.set(baseCode, active);
          continue;
        }

        if (!active){
          active = [point];
          segmentsByBase.get(baseCode).push(active);
          activeByBase.set(baseCode, active);
          continue;
        }

        if (active[active.length - 1] !== point) active.push(point);
        if (action === "CLO" && active.length > 2) active.push(active[0]);
        if (action === "END" || action === "CLO") activeByBase.delete(baseCode);
      }

      return [...segmentsByBase.entries()]
        .map(([baseCode, segments])=>({ baseCode, segments: segments.filter((segment)=>segment.length > 1) }))
        .filter((item)=>item.segments.length);
    }

    function buildLineworkThumbnailDataUrl(segments = []){
      if (pointThumbnailClient?.renderLineworkThumbnailDataUrl) {
        const points = segments.flat().map((point)=>({ x: Number(point.x), y: Number(point.y), code: String(point.code || "") }));
        return pointThumbnailClient.renderLineworkThumbnailDataUrl(points, { width: 88, height: 52, stroke: "#4ade80" });
      }
      const points = segments.flat()
        .map((point)=>({ x: Number(point.x), y: Number(point.y) }))
        .filter((coord)=>Number.isFinite(coord.x) && Number.isFinite(coord.y));
      if (points.length < 2) return "";

      const minX = Math.min(...points.map((coord)=>coord.x));
      const maxX = Math.max(...points.map((coord)=>coord.x));
      const minY = Math.min(...points.map((coord)=>coord.y));
      const maxY = Math.max(...points.map((coord)=>coord.y));
      const width = Math.max(maxX - minX, 1);
      const height = Math.max(maxY - minY, 1);
      const pad = 6;
      const w = 88;
      const h = 52;
      const mapPoint = (x, y)=>{
        const nx = ((x - minX) / width) * (w - pad * 2) + pad;
        const ny = h - (((y - minY) / height) * (h - pad * 2) + pad);
        return `${nx.toFixed(1)},${ny.toFixed(1)}`;
      };

      const polylines = segments.map((segment)=>{
        const segmentPoints = segment
          .map((point)=>mapPoint(Number(point.x), Number(point.y)))
          .join(" ");
        return `<polyline points="${segmentPoints}" fill="none" stroke="#4ade80" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />`;
      }).join("");

      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}"><rect width="${w}" height="${h}" rx="8" fill="#0b1220"/>${polylines}</svg>`;
      return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
    }

    function buildPointGroupsFromRecords(recordsSorted = []){
      const byCode = new Map();
      for (const record of recordsSorted){
        const codeRaw = trimOrEmpty(record.fields?.[4]);
        const codeToken = getPointGroupCodeToken(codeRaw);
        const codeKey = codeToken || "UNCODED";
        const codeLabel = codeToken || "(No code)";
        if (!byCode.has(codeKey)) byCode.set(codeKey, { codeKey, codeLabel, points: [] });
        byCode.get(codeKey).points.push({
          number: trimOrEmpty(record.fields?.[0]),
          code: codeRaw,
          x: Number(record.fields?.[1]),
          y: Number(record.fields?.[2]),
        });
      }

      return [...byCode.values()]
        .map((group)=>{
          const lineworks = buildLineworkSegments(group.points);
          const subgroups = lineworks
            .filter((linework)=>linework.segments.length > 1)
            .map((linework, index)=>({
              id: `${group.codeKey}-${linework.baseCode}-${index}`,
              label: `${linework.baseCode} (${linework.segments.length} lines)`,
              linework,
              thumbnail: buildLineworkThumbnailDataUrl(linework.segments),
            }));
          return {
            ...group,
            thumbnail: lineworks.length ? buildLineworkThumbnailDataUrl(lineworks.flatMap((item)=>item.segments)) : "",
            lineworks,
            subgroups,
          };
        })
        .sort((a,b)=>a.codeLabel.localeCompare(b.codeLabel));
    }

    function buildBoundaryLabCsvFromSegments(segments = []){
      const unique = [];
      const seen = new Set();
      for (const segment of segments){
        for (const point of segment){
          const key = `${point.number}|${point.x}|${point.y}`;
          if (seen.has(key)) continue;
          seen.add(key);
          unique.push(point);
        }
      }
      if (unique.length < 2) return "";
      const rows = [["point","x","y"]];
      unique.forEach((point, index)=>rows.push([point.number || String(index + 1), point.x, point.y]));
      return rows.map((row)=>row.map(csvEscape).join(",")).join("\n");
    }

    function selectPointGroupSelection(selection){
      selectedGroupSelection = selection;
      const buttons = elPointGroupList.querySelectorAll(".pointGroupButton");
      buttons.forEach((button)=>button.classList.toggle("active", button.dataset.selectionId === selection?.id));
      if (!selection){
        elPointGroupAction.textContent = "Select a group to open linework in BoundaryLab.";
        return;
      }
      elPointGroupAction.innerHTML = `<button id="openBoundaryLabFromGroup" class="btn secondary" type="button">Open ${escapeHtml(selection.label)} in BoundaryLab</button>`;
      const actionButton = document.getElementById("openBoundaryLabFromGroup");
      actionButton?.addEventListener("click", ()=>{
        const csv = buildBoundaryLabCsvFromSegments(selection.segments || []);
        if (!csv) return;
        localStorage.setItem(BOUNDARYLAB_POINTFORGE_IMPORT_STORAGE_KEY, JSON.stringify({
          csv,
          exportedAt: new Date().toISOString(),
          source: "pointforge-group-explorer",
          label: selection.label,
        }));
        const projectContext = getProjectContext();
        const projectParams = projectContext.projectId ? `&activeProjectId=${encodeURIComponent(projectContext.projectId)}&activeProjectName=${encodeURIComponent(projectContext.projectName || "")}` : "";
        openLinkedApp(`/BoundaryLab.html?source=pointforge${projectParams}`);
      });
    }

    function renderPointGroups(groups = []){
      latestPointGroups = groups;
      elPointGroupList.innerHTML = "";
      if (!groups.length){
        elPointGroupSummary.textContent = "No groups yet.";
        selectPointGroupSelection(null);
        return;
      }

      elPointGroupSummary.textContent = `${groups.length} groups`;
      groups.forEach((group)=>{
        const card = document.createElement("article");
        card.className = "pointGroupCard";

        const groupSelectionId = `group-${group.codeKey}`;
        const groupButton = document.createElement("button");
        groupButton.type = "button";
        groupButton.className = "pointGroupButton";
        groupButton.dataset.selectionId = groupSelectionId;
        const thumb = group.thumbnail ? `<img class="pointGroupThumb" src="${group.thumbnail}" alt="${escapeHtml(group.codeLabel)} line preview" />` : "";
        groupButton.innerHTML = `<span><strong>${escapeHtml(group.codeLabel)}</strong><br/><span class="pointGroupMeta">${group.points.length} pts · ${group.lineworks.length} line code(s)</span></span>${thumb}`;
        groupButton.addEventListener("click", ()=>{
          const firstLinework = group.lineworks[0];
          if (!firstLinework) return selectPointGroupSelection(null);
          selectPointGroupSelection({ id: groupSelectionId, label: `group ${group.codeLabel}`, segments: firstLinework.segments });
        });
        card.appendChild(groupButton);

        if (group.subgroups.length){
          const children = document.createElement("div");
          children.className = "pointGroupChildren";
          group.subgroups.forEach((subgroup)=>{
            const subgroupButton = document.createElement("button");
            subgroupButton.type = "button";
            subgroupButton.className = "pointGroupButton";
            subgroupButton.dataset.selectionId = subgroup.id;
            subgroupButton.innerHTML = `<span>${escapeHtml(subgroup.label)}</span>${subgroup.thumbnail ? `<img class="pointGroupThumb" src="${subgroup.thumbnail}" alt="${escapeHtml(subgroup.label)} line preview" />` : ""}`;
            subgroupButton.addEventListener("click", ()=>{
              selectPointGroupSelection({ id: subgroup.id, label: `subgroup ${subgroup.label}`, segments: subgroup.linework.segments });
            });
            children.appendChild(subgroupButton);
          });
          card.appendChild(children);
        }

        elPointGroupList.appendChild(card);
      });

      selectPointGroupSelection(null);
    }

    function parsePointEditorDocument(text){
      const lines = String(text || "").split(/\r?\n/);
      const entries = [];
      const rows = [];

      for (let idx = 0; idx < lines.length; idx += 1){
        const line = lines[idx];
        if (!line.trim()) {
          entries.push({ type: "blank", raw: line });
          continue;
        }

        const fields = parseCSVLine(line);
        if (fields.length < 4) {
          entries.push({ type: "raw", raw: line });
          continue;
        }

        while (fields.length < 6) fields.push("");
        const rowIndex = rows.length;
        rows.push({
          number: trimOrEmpty(fields[0]),
          x: trimOrEmpty(fields[1]),
          y: trimOrEmpty(fields[2]),
          z: trimOrEmpty(fields[3]),
          code: trimOrEmpty(fields[4]),
          notes: trimOrEmpty(fields[5]),
        });
        entries.push({ type: "point", fields, rowIndex });
      }

      return { rows, entries };
    }

    function pointEditorDocumentToCsv(documentModel){
      const rows = Array.isArray(documentModel?.rows) ? documentModel.rows : [];
      const entries = Array.isArray(documentModel?.entries) ? documentModel.entries : [];
      const lines = [];

      for (const entry of entries){
        if (entry.type === "point") {
          const row = rows[entry.rowIndex] || {};
          const fields = Array.isArray(entry.fields) ? [...entry.fields] : [];
          while (fields.length < 6) fields.push("");
          fields[0] = row.number ?? "";
          fields[1] = row.x ?? "";
          fields[2] = row.y ?? "";
          fields[3] = row.z ?? "";
          fields[4] = row.code ?? "";
          fields[5] = row.notes ?? "";
          lines.push(fields.map(csvEscape).join(","));
          continue;
        }

        if (entry.type === "blank") {
          lines.push(entry.raw ?? "");
          continue;
        }

        if (entry.type === "raw") {
          lines.push(entry.raw ?? "");
          continue;
        }

        lines.push(entry.raw ?? "");
      }

      return lines.join("\n");
    }

    function renderPointRows(rows, tbody, editable, documentModel = null){
      tbody.innerHTML = "";
      if (!rows.length){
        const tr = document.createElement("tr");
        tr.innerHTML = '<td colspan="6" class="muted">No points to display.</td>';
        tbody.appendChild(tr);
        return;
      }
      rows.forEach((row, idx)=>{
        const tr = document.createElement("tr");
        const cells = ["number", "x", "y", "z", "code", "notes"];
        for (const key of cells){
          const td = document.createElement("td");
          if (editable){
            const input = document.createElement("input");
            input.value = row[key] || "";
            input.dataset.index = String(idx);
            input.dataset.field = key;
            input.addEventListener("input", (event)=>{
              const target = event.target;
              rows[Number(target.dataset.index)][target.dataset.field] = target.value;
              if (documentModel) {
                elIn.value = pointEditorDocumentToCsv(documentModel);
              } else {
                elIn.value = rows
                  .map((row)=>[
                    csvEscape(row.number), csvEscape(row.x), csvEscape(row.y), csvEscape(row.z), csvEscape(row.code), csvEscape(row.notes)
                  ].join(","))
                  .join("\n");
              }
              if (elAuto.checked) processNow();
            });
            td.appendChild(input);
          } else {
            td.textContent = row[key] || "";
          }
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      });
    }

    function refreshPointEditorTables(){
      if (!usePointEditorView) return;
      const inputDocument = parsePointEditorDocument(elIn.value);
      const outputDocument = parsePointEditorDocument(elOut.value);
      renderPointRows(inputDocument.rows, elInputPointsBody, true, inputDocument);
      renderPointRows(outputDocument.rows, elOutputPointsBody, false, outputDocument);
    }

    function setPointEditorView(enabled){
      usePointEditorView = !!enabled;
      elIn.style.display = usePointEditorView ? "none" : "block";
      elOut.style.display = usePointEditorView ? "none" : "block";
      elInputTableWrap.classList.toggle("active", usePointEditorView);
      elOutputTableWrap.classList.toggle("active", usePointEditorView);
      elInputTableWrap.setAttribute("aria-hidden", usePointEditorView ? "false" : "true");
      elOutputTableWrap.setAttribute("aria-hidden", usePointEditorView ? "false" : "true");
      elToggleInputView.textContent = usePointEditorView ? "Switch to Textarea View" : "Switch to Point Editor View";
      if (usePointEditorView) refreshPointEditorTables();
    }

    function setPointEditorAccordionMode(mode = "input"){
      pointEditorAccordionMode = mode === "output" ? "output" : "input";
      const outputFocused = usePointEditorView && pointEditorAccordionMode === "output";
      const inputFocused = usePointEditorView && pointEditorAccordionMode === "input";
      if (elMain) {
        elMain.classList.toggle("pointEditorFocusOutput", outputFocused);
        elMain.classList.toggle("pointEditorFocusInput", inputFocused);
      }
      if (elIngestPanel) elIngestPanel.setAttribute("aria-expanded", outputFocused ? "false" : "true");
      if (elOutputPanel) elOutputPanel.setAttribute("aria-expanded", outputFocused ? "true" : "false");
    }

    function activatePointEditorOutputAccordion(){
      setPointEditorView(true);
      setPointEditorAccordionMode("output");
      refreshPointEditorTables();
    }

    function updateOutputActionVisibility(){
      const hasOutput = !!String(latestOutputText || "").trim();
      if (elOutputActions) elOutputActions.hidden = !hasOutput;
    }

    let map = null;
    let layer = null;

    // Base layers (Street + Satellite)
    let streetLayer = null;
    let satLayer = null;
    let activeBase = "street";

    function projectFileStorageKey(projectId){
      return `${PROJECT_FILE_STORAGE_PREFIX}:${projectId}`;
    }

    function pointSetStorageKey(setId){
      return `${POINTFORGE_POINT_SET_STORAGE_PREFIX}:${setId}`;
    }

    function projectLastPointSetKey(projectId){
      return `${PROJECT_LAST_POINT_SET_PREFIX}:${projectId}`;
    }

    function saveLastOpenedProjectPointSet(projectId, storageKey){
      if (!projectId || !storageKey) return;
      localStorage.setItem(projectLastPointSetKey(projectId), storageKey);
    }

    function loadLastOpenedProjectPointSet(projectId){
      if (!projectId) return "";
      return String(localStorage.getItem(projectLastPointSetKey(projectId)) || "").trim();
    }

    function loadStoredPointSet(storageKey){
      if (!storageKey) return null;
      try {
        const raw = localStorage.getItem(storageKey);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        if (!String(parsed.text || "").trim()) return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function getProjectContext(){
      const params = new URLSearchParams(window.location.search || "");
      const projectId = params.get("projectId") || params.get("activeProjectId") || "";
      const projectName = params.get("projectName") || params.get("activeProjectName") || "";
      return { projectId, projectName };
    }

    function loadProjectFileSnapshot(projectId){
      if (!projectId) return null;
      try {
        const raw = localStorage.getItem(projectFileStorageKey(projectId));
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object" || !Array.isArray(parsed.folders)) return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function saveProjectFileSnapshot(projectId, projectFile){
      if (!projectId || !projectFile) return;
      localStorage.setItem(projectFileStorageKey(projectId), JSON.stringify(projectFile));
    }


    function buildProjectPointFileApiUrl(projectId, pointFileId = ""){
      if (!projectId) return "";
      const base = `/api/projects/${encodeURIComponent(projectId)}/point-files`;
      return pointFileId ? `${base}/${encodeURIComponent(pointFileId)}` : base;
    }

    async function fetchProjectPointFiles(projectId){
      if (!projectId) return [];
      const response = await fetch(buildProjectPointFileApiUrl(projectId));
      if (!response.ok) throw new Error(`Unable to list point files (${response.status}).`);
      const payload = await response.json();
      return Array.isArray(payload?.pointFiles) ? payload.pointFiles : [];
    }

    async function fetchProjectPointFile(projectId, pointFileId){
      if (!projectId || !pointFileId) return null;
      const response = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId));
      if (!response.ok) return null;
      const payload = await response.json();
      return payload?.pointFile || null;
    }

    function persistPointFileToApi(projectId, body, pointFileId = ""){
      if (!projectId || !body?.pointFileState?.text) return;
      const method = pointFileId ? "PUT" : "POST";
      fetch(buildProjectPointFileApiUrl(projectId, pointFileId), {
        method,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      }).catch(() => {
        // Keep local PointForge flow working offline even when API persistence fails.
      });
    }

    function ensureProjectFileFolder(projectFile, folderKey){
      if (!projectFile || !Array.isArray(projectFile.folders)) return null;
      const existing = projectFile.folders.find((folder) => folder.key === folderKey);
      if (existing){
        if (!Array.isArray(existing.index)) existing.index = [];
        return existing;
      }
      const created = { key: folderKey, label: folderKey, description: "", index: [] };
      projectFile.folders.push(created);
      return created;
    }

    function addProjectFileResource(projectFile, resource){
      const folder = ensureProjectFileFolder(projectFile, resource.folder);
      if (!folder) return;
      folder.index.push(resource);
    }

    function normalizeBaseName(name, fallback = "Point Set"){
      const normalized = trimOrEmpty(name).replace(/\.[^.]+$/u, "").trim();
      return normalized || fallback;
    }

    function normalizeExtension(name, fallback = ".txt"){
      const match = String(name || "").trim().match(/\.[a-z0-9]+$/i);
      return match ? match[0] : fallback;
    }

    function formatPointFileDate(date = new Date()){
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const year = String(date.getFullYear()).slice(-2);
      return `${month} ${day} ${year}`;
    }

    function hasDateInName(name){
      return /\b\d{1,2}[\s/_-]\d{1,2}[\s/_-]\d{2}\b/.test(String(name || ""));
    }

    function ensureDateInName(name, dateLabel){
      const base = trimOrEmpty(name);
      if (!base) return trimOrEmpty(dateLabel);
      if (hasDateInName(base)) return base;
      return `${base} ${dateLabel}`;
    }

    function ensureImportContextForPaste(promptIfMissing = false){
      if (currentImportContext) return currentImportContext;
      if (!promptIfMissing) return null;

      const entered = window.prompt("Name this pasted point set:", "Pasted Point Set");
      const baseName = normalizeBaseName(entered, "Pasted Point Set");
      currentImportContext = {
        sourceType: "paste",
        sourceLabel: baseName,
        baseName,
        extension: ".txt",
      };
      return currentImportContext;
    }

    function setImportContextFromFile(file){
      currentImportContext = {
        sourceType: "upload",
        sourceLabel: file?.name || "Uploaded File",
        baseName: normalizeBaseName(file?.name, "Uploaded Point Set"),
        extension: normalizeExtension(file?.name, ".txt"),
      };
      return currentImportContext;
    }

    function setImportContextFromRos(){
      currentImportContext = {
        sourceType: "recordquarry",
        sourceLabel: "Exported from RecordQuarry",
        baseName: "Exported from RecordQuarry",
        extension: ".csv",
      };
      return currentImportContext;
    }

    function buildImportFileName(context, importedAt = new Date()){
      const dated = ensureDateInName(context?.baseName || "Point Set", formatPointFileDate(importedAt));
      return `${dated}${context?.extension || ".txt"}`;
    }

    function buildEditedExportFileName(context, exportedAt = new Date()){
      const editedBase = `${context?.baseName || "Point Set"} Edited`;
      const dated = ensureDateInName(editedBase, formatPointFileDate(exportedAt));
      return `${dated}${context?.extension || ".txt"}`;
    }

    function persistPointSetToProjectFile({ kind, text, context, timestamp = new Date() }){
      const projectContext = getProjectContext();
      if (!projectContext.projectId || !text) return null;

      const title = kind === "import" ? buildImportFileName(context, timestamp) : buildEditedExportFileName(context, timestamp);
      const projectFile = loadProjectFileSnapshot(projectContext.projectId);

      const setId = `point-set-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      const storageKey = pointSetStorageKey(setId);
      const isoTimestamp = timestamp.toISOString();
      localStorage.setItem(storageKey, JSON.stringify({
        id: setId,
        kind,
        source: context?.sourceType || "unknown",
        pointFileId: context?.pointFileId || "",
        fileName: title,
        savedAt: isoTimestamp,
        text,
      }));

      if (projectFile) {
        addProjectFileResource(projectFile, {
          id: setId,
          folder: "point-files",
          title,
          exportFormat: "csv",
          reference: {
            type: "local-storage",
            value: storageKey,
            resolverHint: "pointforge-point-set",
            metadata: {
              flow: kind,
              source: context?.sourceType || "unknown",
              sourceLabel: context?.sourceLabel || "",
              timestamp: isoTimestamp,
              charLength: String(text).length,
            },
          },
        });

        projectFile.generatedAt = isoTimestamp;
        saveProjectFileSnapshot(projectContext.projectId, projectFile);
      }

      persistPointFileToApi(projectContext.projectId, {
        pointFileName: title,
        pointFileState: { text, exportFormat: 'csv' },
        source: context?.sourceType || 'pointforge',
        sourceLabel: context?.sourceLabel || title,
      }, context?.pointFileId || "");

      if (kind === "import") saveLastOpenedProjectPointSet(projectContext.projectId, storageKey);
      populatePointFileDropdown();
      return storageKey;
    }

    function tryRestoreLastOpenedProjectPointSet(){
      const params = new URLSearchParams(window.location.search || "");
      if (params.get("source")) return false;

      const projectContext = getProjectContext();
      if (!projectContext.projectId) return false;

      const storageKey = loadLastOpenedProjectPointSet(projectContext.projectId);
      if (!storageKey) return false;

      const pointSet = loadStoredPointSet(storageKey);
      if (!pointSet) return false;

      const title = normalizeBaseName(pointSet.fileName, "Last Opened Point Set");
      currentImportContext = {
        sourceType: "last-opened",
        sourceLabel: title,
        baseName: title,
        extension: normalizeExtension(pointSet.fileName, ".txt"),
      };
      elIn.value = String(pointSet.text);
      processNow();
      activatePointEditorOutputAccordion();
      elMapHint.innerHTML = `<span class="ok">Opened last point file for this active project: ${escapeHtml(title)}.</span>`;
      return true;
    }

    function initMap(){
      map = L.map("map", { preferCanvas:true }).setView([44.2, -116.7], 7);

      // Street: OpenStreetMap
      streetLayer = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors"
      });

      // Satellite: Esri World Imagery (no key)
      satLayer = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution: "Tiles &copy; Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community"
        }
      );

      // Default basemap
      streetLayer.addTo(map);
      activeBase = "street";

      layer = L.layerGroup().addTo(map);
    }

    function setBasemap(mode){
      if (!map) return;
      if (mode === activeBase) return;

      if (mode === "street"){
        if (satLayer && map.hasLayer(satLayer)) map.removeLayer(satLayer);
        if (streetLayer && !map.hasLayer(streetLayer)) streetLayer.addTo(map);
        activeBase = "street";
      } else {
        if (streetLayer && map.hasLayer(streetLayer)) map.removeLayer(streetLayer);
        if (satLayer && !map.hasLayer(satLayer)) satLayer.addTo(map);
        activeBase = "satellite";
      }
    }

    function setStats(stats, plottedCount){
      if (!st_lines || !st_parsed || !st_g || !st_ref || !st_map || !st_zone) return;
      st_lines.textContent = String(stats.totalLines ?? 0);
      st_parsed.textContent = String(stats.parsedCount ?? 0);
      st_g.textContent = String(stats.gCount ?? 0);
      st_ref.textContent = String(stats.refCount ?? 0);
      st_map.textContent = String(plottedCount ?? 0);

      const z = elZone.value;
      st_zone.textContent = z === "west" ? "W" : (z === "central" ? "C" : "E");
    }

    function refreshMap(recordsSorted){
      if (!map || !layer || !window.proj4) {
        elMapHint.innerHTML = `<span class="bad">Map libs not loaded (Leaflet/proj4). Output still works.</span>`;
        return 0;
      }
      layer.clearLayers();

      const zone = elZone.value || "west";
      const def = PROJ_DEFS_USFT[zone];

      const swapXY = true; // LOCKED default
      const showLabels = !!elShowLabels.checked;

      let plotted = 0;
      const bounds = [];

      for (const r of recordsSorted){
        if (!Number.isFinite(r.x) || !Number.isFinite(r.y)) continue;

        const X = swapXY ? r.y : r.x;
        const Y = swapXY ? r.x : r.y;

        try{
          const ll = proj4(def, "WGS84", [X, Y]);
          const lon = ll[0], lat = ll[1];
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
          if (!inIdaho(lat, lon)) continue;

          const ptNum = trimOrEmpty(r.fields[0]);
          const desc = trimOrEmpty(r.fields[r.fields.length-1]);

          const marker = L.circleMarker([lat, lon], {
            radius: 5,
            weight: 2,
            opacity: 0.95,
            fillOpacity: 0.32
          });

          const tip = `${ptNum}${desc ? " — " + desc : ""}\n(X=${X}, Y=${Y})\n(lat=${lat.toFixed(6)}, lon=${lon.toFixed(6)})`;
          marker.bindPopup(
            `<div style="font-family:${getComputedStyle(document.documentElement).getPropertyValue('--mono')}; font-size:12px; white-space:pre-wrap;">${escapeHtml(tip)}</div>`
          );
          if (showLabels) marker.bindTooltip(String(ptNum), { permanent: false, direction: "top", opacity: 0.9 });

          marker.addTo(layer);
          bounds.push([lat, lon]);
          plotted++;
        } catch(_e) {}
      }

      if (plotted > 0){
        const b = L.latLngBounds(bounds);
        map.fitBounds(b.pad(0.15));
        elMapHint.innerHTML = `<span class="ok">Plotted ${plotted} pts</span> — zone <span class="mono">${zone}</span>, <span class="mono">US-ft</span>, <span class="mono">swapXY</span>, basemap <span class="mono">${activeBase}</span>.`;
      } else {
        elMapHint.innerHTML = `<span class="warn">No points plotted.</span> If coords are not Idaho State Plane, they’ll be skipped on the map (output still transforms IDs). Try another zone.`;
      }

      return plotted;
    }


    function buildLineSmithImportPayload(recordsSorted){
      const rows = [["number","x","y","z","code","notes"]];
      const georeferencePoints = [];
      const zone = elZone.value || "west";
      const def = PROJ_DEFS_USFT[zone];
      const swapXY = false;

      for (const record of recordsSorted || []){
        if (!Array.isArray(record?.fields) || record.fields.length < 4) continue;

        const number = trimOrEmpty(record.fields[0]);
        if (!number) continue;

        const x = Number(record.fields[1]);
        const y = Number(record.fields[2]);
        const zRaw = trimOrEmpty(record.fields[3]);
        const z = Number.isFinite(Number(zRaw)) ? Number(zRaw) : 0;
        const code = trimOrEmpty(record.fields[4]);
        const notes = trimOrEmpty(record.fields[5]);

        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

        // PointForge source rows are parsed as number,northing,easting,...
        // Normalize to LineSmith's x=easting,y=northing handoff contract.
        const handoffX = y;
        const handoffY = x;

        rows.push([number, handoffX, handoffY, z, code, notes]);

        try {
          const projectedX = handoffX;
          const projectedY = handoffY;
          const ll = proj4(def, "WGS84", [projectedX, projectedY]);
          const lon = ll[0];
          const lat = ll[1];
          if (Number.isFinite(lat) && Number.isFinite(lon)) {
            georeferencePoints.push({ x: handoffX, y: handoffY, lat, lng: lon });
          }
        } catch (_err) {
          // Ignore malformed coordinates and continue exporting CSV rows.
        }
      }

      return {
        source: "pointforge-transformer",
        exportedAt: new Date().toISOString(),
        csv: rows.map((row)=>row.map(csvEscape).join(",")).join("\n"),
        georeference: {
          type: "idaho-state-plane-usft",
          zone,
          swapXY,
          points: georeferencePoints
        }
      };
    }

    function cloneRecordWithFields(record){
      return {
        ...record,
        fields: Array.isArray(record?.fields) ? [...record.fields] : []
      };
    }

    function getLocalizationSettings(){
      const enabled = !!elEnableLocalization.checked;
      if (!enabled) return { enabled: false };

      const anchorPointNumber = Number.parseInt(String(elAnchorPointNumber.value || ''), 10);
      const lat = Number(elAnchorLat.value);
      const lon = Number(elAnchorLon.value);

      if (!Number.isInteger(anchorPointNumber) || anchorPointNumber < 1 || !Number.isFinite(lat) || !Number.isFinite(lon)) {
        throw new Error("Localization requires anchor point # plus numeric anchor lat/lon values.");
      }

      if (!inIdaho(lat, lon)) {
        throw new Error("Anchor latitude/longitude is outside Idaho bounds used by this workspace.");
      }

      return { enabled, anchorPointNumber, lat, lon };
    }

    function localizeRecords(recordsSorted){
      const settings = getLocalizationSettings();
      if (!settings.enabled) return { recordsSorted, summary: "" };

      if (!window.proj4) {
        throw new Error("Localization requires proj4 to project anchor latitude/longitude.");
      }

      const zone = elZone.value || "west";
      const def = PROJ_DEFS_USFT[zone];
      const projectedAnchor = proj4("WGS84", def, [settings.lon, settings.lat]);
      const anchorEast = Number(projectedAnchor?.[0]);
      const anchorNorth = Number(projectedAnchor?.[1]);

      if (!Number.isFinite(anchorEast) || !Number.isFinite(anchorNorth)) {
        throw new Error("Unable to project anchor latitude/longitude into Idaho state-plane coordinates.");
      }

      const anchorRecord = recordsSorted.find((record)=>{
        const pointNumber = Number.parseInt(trimOrEmpty(record?.fields?.[0]), 10);
        return pointNumber === settings.anchorPointNumber;
      });

      if (!anchorRecord) {
        throw new Error(`Anchor point #${settings.anchorPointNumber} was not found in the processed point set.`);
      }

      const anchorLocalHandoffX = anchorRecord.x;
      const anchorLocalHandoffY = anchorRecord.y;
      const eastOffset = anchorEast - anchorLocalHandoffX;
      const northOffset = anchorNorth - anchorLocalHandoffY;

      const localized = [];
      for (let i = 0; i < recordsSorted.length; i += 1){
        const record = recordsSorted[i];
        if (!Number.isFinite(record?.x) || !Number.isFinite(record?.y)) {
          throw new Error(`Point ${i + 1} is missing numeric X/Y coordinates and cannot be localized.`);
        }

        const localHandoffX = record.x;
        const localHandoffY = record.y;
        const localizedHandoffX = localHandoffX + eastOffset;
        const localizedHandoffY = localHandoffY + northOffset;

        const localizedRecord = cloneRecordWithFields(record);
        localizedRecord.x = localizedHandoffX;
        localizedRecord.y = localizedHandoffY;
        localizedRecord.fields[1] = String(localizedRecord.x);
        localizedRecord.fields[2] = String(localizedRecord.y);
        localized.push(localizedRecord);
      }

      const summary = `LOCALIZATION
  zone: ${zone}
  anchor point #: ${settings.anchorPointNumber}
  anchor lat/lon: ${settings.lat.toFixed(6)}, ${settings.lon.toFixed(6)}
  projected east/north: ${anchorEast.toFixed(3)}, ${anchorNorth.toFixed(3)}
  offsets east/north: ${eastOffset.toFixed(3)}, ${northOffset.toFixed(3)}`;
      return { recordsSorted: localized, summary };
    }

    function setLocalizationInputsEnabled(enabled){
      elAnchorPointNumber.disabled = !enabled;
      elAnchorLat.disabled = !enabled;
      elAnchorLon.disabled = !enabled;
      elLocalizationHint.innerHTML = enabled
        ? 'Localization enabled: PointForge will use the selected point number as the local anchor before offsetting all points into Idaho state plane.'
        : 'Optional: select an existing point number as the local anchor and pair it with one known GPS anchor.';
    }

    function processNow(){
      const input = elIn.value || "";
      if (!input.trim()){
        elOut.value = "";
        elLog.textContent = "";
        latestOutputText = "";
        latestTransformed = null;
        updateOutputActionVisibility();
        elRenumber.disabled = true;
        elDownload.disabled = true;
        elOpenLineSmith.disabled = true;
        if (layer) layer.clearLayers();
        elMapHint.textContent = "Load a file or paste points to plot.";
        setStats({ totalLines: 0, parsedCount: 0, gCount: 0, refCount: 0 }, 0);
        renderPointGroups([]);
        return;
      }

      ensureImportContextForPaste(false);

      const res = transformPoints(input);
      let recordsForOutput = res.recordsSorted;
      let localizationSummary = "";
      try {
        const localized = localizeRecords(recordsForOutput);
        recordsForOutput = localized.recordsSorted;
        localizationSummary = localized.summary;
      } catch (error) {
        elOut.value = "";
        latestOutputText = "";
        latestTransformed = null;
        updateOutputActionVisibility();
        elLog.textContent = `${res.logText}\n\n${String(error?.message || error)}`;
        refreshPointEditorTables();
        if (layer) layer.clearLayers();
        setStats({ totalLines: 0, parsedCount: 0, gCount: 0, refCount: 0 }, 0);
        elMapHint.innerHTML = `<span class="warn">Localization input error.</span> ${escapeHtml(String(error?.message || error))}`;
        elRenumber.disabled = true;
        elDownload.disabled = true;
        elOpenLineSmith.disabled = true;
        renderPointGroups([]);
        return;
      }

      const outputText = recordsForOutput.map((record)=>record.fields.map(csvEscape).join(",")).join("\n");
      latestTransformed = { ...res, recordsSorted: recordsForOutput };
      latestOutputText = outputText;
      updateOutputActionVisibility();
      renderPointGroups(buildPointGroupsFromRecords(recordsForOutput));

      elOut.value = outputText;
      elLog.textContent = localizationSummary ? `${res.logText}\n\n${localizationSummary}` : res.logText;
      refreshPointEditorTables();

      const plotted = refreshMap(recordsForOutput);
      setStats(res.stats, plotted);

      elRenumber.disabled = !latestOutputText;
      elDownload.disabled = !latestOutputText;
      elOpenLineSmith.disabled = !latestTransformed?.recordsSorted?.length;
    }

    // File loader
    elFile.addEventListener("change", async (e)=>{
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const text = await f.text();
      const context = setImportContextFromFile(f);
      elIn.value = text;
      persistPointSetToProjectFile({ kind: "import", text, context, timestamp: new Date() });
      processNow();
      activatePointEditorOutputAccordion();
    });


    function renumberOutputFromStart(startValue){
      if (!latestOutputText) return;
      const parsedStart = Number.parseInt(startValue, 10);
      const renumberStart = Number.isInteger(parsedStart) && parsedStart > 0 ? parsedStart : 1;
      elRenumberStart.value = String(renumberStart);

      const lines = String(latestOutputText || "").split(/\r?\n/);
      let nextNumber = renumberStart;
      const renumberedLines = lines.map((line)=>{
        if (!line.trim()) return line;
        const fields = parseCSVLine(line);
        if (fields.length < 2) return line;
        fields[0] = String(nextNumber++);
        return fields.map(csvEscape).join(",");
      });

      latestOutputText = renumberedLines.join("\n");
      elOut.value = latestOutputText;
      updateOutputActionVisibility();

      const rows = parsePointRows(latestOutputText);
      if (latestTransformed?.recordsSorted?.length){
        const count = Math.min(rows.length, latestTransformed.recordsSorted.length);
        for (let i = 0; i < count; i++){
          latestTransformed.recordsSorted[i].fields[0] = rows[i].number;
        }
      }

      elLog.textContent = `${elLog.textContent}\nSEQUENTIAL RENUMBER\n  start: ${renumberStart}`.trim();
      refreshPointEditorTables();
      elOpenLineSmith.disabled = !latestTransformed?.recordsSorted?.length;
    }

    elRenumber.addEventListener("click", ()=>renumberOutputFromStart(elRenumberStart.value));

    // Manual process
    elProcess.addEventListener("click", ()=>processNow());

    // Auto-process (debounced)
    let t = null;
    elIn.addEventListener("input", ()=>{
      refreshPointEditorTables();
      if (!elAuto.checked) return;
      if (t) clearTimeout(t);
      t = setTimeout(()=>processNow(), 250);
    });


    elToggleInputView.addEventListener("click", ()=>{
      const nextEnabled = !usePointEditorView;
      setPointEditorView(nextEnabled);
      setPointEditorAccordionMode(nextEnabled ? "output" : "input");
    });

    elIn.addEventListener("paste", ()=>{
      requestAnimationFrame(()=>{
        if (!elIn.value.trim()) return;
        activatePointEditorOutputAccordion();
      });
    });

    elIngestPanel?.addEventListener("click", (event)=>{
      if (pointEditorAccordionMode !== "output") return;
      if (!(event.target instanceof Node)) return;
      if (elIn && elIn.contains(event.target)) return;
      setPointEditorAccordionMode("input");
    });

    elOutputPanel?.addEventListener("click", ()=>{
      if (!usePointEditorView) return;
      if (pointEditorAccordionMode === "output") return;
      setPointEditorAccordionMode("output");
    });

    // Re-render map when settings change (does not alter output)
    elZone.addEventListener("change", ()=>{
      if (latestTransformed?.recordsSorted){
        const plotted = refreshMap(latestTransformed.recordsSorted);
        setStats(latestTransformed.stats, plotted);
      } else {
        setStats({ totalLines: 0, parsedCount: 0, gCount: 0, refCount: 0 }, 0);
      }
    });
    elShowLabels.addEventListener("change", ()=>{
      if (latestTransformed?.recordsSorted){
        const plotted = refreshMap(latestTransformed.recordsSorted);
        setStats(latestTransformed.stats, plotted);
      }
    });

    // Basemap switch
    elBasemap.addEventListener("change", ()=>{
      setBasemap(elBasemap.value);
      // no need to re-plot markers; base layer change only
      if (latestTransformed?.recordsSorted){
        const plotted = refreshMap(latestTransformed.recordsSorted);
        setStats(latestTransformed.stats, plotted);
      }
    });

    function rerunProcessingIfNeeded(){
      if (!elAuto.checked && !latestTransformed?.recordsSorted?.length) return;
      processNow();
    }

    elEnableLocalization.addEventListener("change", ()=>{
      setLocalizationInputsEnabled(elEnableLocalization.checked);
      rerunProcessingIfNeeded();
    });

    [elAnchorPointNumber, elAnchorLat, elAnchorLon].forEach((el)=>{
      el.addEventListener("input", ()=>{
        if (!elEnableLocalization.checked) return;
        if (!elAuto.checked) return;
        if (t) clearTimeout(t);
        t = setTimeout(()=>processNow(), 250);
      });
    });

    // Download output
    elDownload.addEventListener("click", ()=>{
      if (!latestOutputText) return;
      const context = ensureImportContextForPaste(true);
      persistPointSetToProjectFile({ kind: "export", text: latestOutputText, context, timestamp: new Date() });

      const blob = new Blob([latestOutputText], {type:"text/plain;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = buildEditedExportFileName(context, new Date());
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1500);
    });


    elOpenLineSmith.addEventListener("click", ()=>{
      const recordsSorted = latestTransformed?.recordsSorted;
      if (!recordsSorted?.length) return;

      const payload = buildLineSmithImportPayload(recordsSorted);
      const originalCsv = elIn.value || "";
      const modifiedCsv = latestOutputText || "";
      const context = ensureImportContextForPaste(true);

      // Persist both original and modified points via API
      const apiBody = {
        originalCsv,
        modifiedCsv,
        georeference: payload.georeference,
        metadata: {
          source: "pointforge-transformer",
          sourceLabel: context?.sourceLabel || "",
          sourceType: context?.sourceType || "unknown",
          exportedAt: payload.exportedAt,
        },
      };

      fetch("/api/pointforge-exports", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(apiBody),
      })
        .then((res) => res.json())
        .then((result) => {
          const exportId = result?.export?.id || "";
          // Also persist the export context to project file
          persistPointSetToProjectFile({ kind: "import", text: originalCsv, context, timestamp: new Date() });
          persistPointSetToProjectFile({ kind: "export", text: modifiedCsv, context, timestamp: new Date() });
          // Store payload in localStorage as fallback, then navigate
          localStorage.setItem(SURVEY_SKETCH_IMPORT_STORAGE_KEY, JSON.stringify(payload));
          const exportParam = exportId ? `&exportId=${encodeURIComponent(exportId)}` : "";
          const projectContext = getProjectContext();
          const projectParams = projectContext.projectId ? `&activeProjectId=${encodeURIComponent(projectContext.projectId)}&activeProjectName=${encodeURIComponent(projectContext.projectName || '')}` : '';
          openLinkedApp(`/VIEWPORT.HTML?source=pointforge${exportParam}${projectParams}`);
        })
        .catch((_err) => {
          // Fallback: still navigate with localStorage handoff if API fails
          persistPointSetToProjectFile({ kind: "import", text: originalCsv, context, timestamp: new Date() });
          persistPointSetToProjectFile({ kind: "export", text: modifiedCsv, context, timestamp: new Date() });
          localStorage.setItem(SURVEY_SKETCH_IMPORT_STORAGE_KEY, JSON.stringify(payload));
          const projectContext = getProjectContext();
          const projectParams = projectContext.projectId ? `&activeProjectId=${encodeURIComponent(projectContext.projectId)}&activeProjectName=${encodeURIComponent(projectContext.projectName || "")}` : "";
          openLinkedApp(`/VIEWPORT.HTML?source=pointforge${projectParams}`);
        });
    });




    function openLinkedApp(path){
      try {
        if (window.parent && window.parent !== window){
          window.parent.postMessage({
            type: "survey-cad:navigate-app",
            path,
          }, window.location.origin);
          return;
        }
      } catch (_error){
        // If parent access is blocked, fallback to same-tab navigation.
      }
      window.location.assign(path);
    }

    function tryImportRosPayload(){
      const params = new URLSearchParams(window.location.search);
      if (params.get("source") !== "ros") return false;

      const raw = localStorage.getItem(ROS_POINTFORGE_IMPORT_STORAGE_KEY);
      if (!raw){
        elMapHint.innerHTML = `<span class="warn">ROS launch detected, but no import payload was found in local storage.</span>`;
        return false;
      }

      try {
        const payload = JSON.parse(raw);
        if (!payload?.csv || !String(payload.csv).trim()){
          elMapHint.innerHTML = `<span class="warn">ROS payload was invalid (missing CSV content).</span>`;
          localStorage.removeItem(ROS_POINTFORGE_IMPORT_STORAGE_KEY);
          return false;
        }

        elIn.value = String(payload.csv);
        const context = setImportContextFromRos();
        persistPointSetToProjectFile({ kind: "import", text: String(payload.csv), context, timestamp: new Date() });
        processNow();
        activatePointEditorOutputAccordion();
        localStorage.removeItem(ROS_POINTFORGE_IMPORT_STORAGE_KEY);
        return true;
      } catch (_error){
        elMapHint.innerHTML = `<span class="warn">ROS payload could not be parsed.</span>`;
        localStorage.removeItem(ROS_POINTFORGE_IMPORT_STORAGE_KEY);
        return false;
      }
    }

    function tryImportProjectBrowserPayload(){
      const params = new URLSearchParams(window.location.search);
      if (params.get("source") !== "project-browser") return false;

      const raw = localStorage.getItem(PROJECT_BROWSER_POINTFORGE_IMPORT_STORAGE_KEY);
      if (!raw) return false;

      try {
        const payload = JSON.parse(raw);
        if (!payload?.csv || !String(payload.csv).trim()){
          localStorage.removeItem(PROJECT_BROWSER_POINTFORGE_IMPORT_STORAGE_KEY);
          return false;
        }
        const title = normalizeBaseName(payload.title, "Project Browser Point File");
        currentImportContext = {
          sourceType: "project-browser",
          sourceLabel: title,
          baseName: title,
          pointFileId: String(payload.pointFileId || "").trim(),
          extension: ".csv",
        };
        elIn.value = String(payload.csv);
        persistPointSetToProjectFile({ kind: "import", text: String(payload.csv), context: currentImportContext, timestamp: new Date() });
        processNow();
        activatePointEditorOutputAccordion();
        localStorage.removeItem(PROJECT_BROWSER_POINTFORGE_IMPORT_STORAGE_KEY);
        return true;
      } catch {
        localStorage.removeItem(PROJECT_BROWSER_POINTFORGE_IMPORT_STORAGE_KEY);
        return false;
      }
    }

    function tryImportBoundaryLabPayload(){
      const params = new URLSearchParams(window.location.search);
      if (params.get("source") !== "boundary-lab") return false;

      const raw = localStorage.getItem(BOUNDARYLAB_POINTFORGE_IMPORT_STORAGE_KEY);
      if (!raw) return false;

      try {
        const payload = JSON.parse(raw);
        if (!payload?.csv || !String(payload.csv).trim()){
          localStorage.removeItem(BOUNDARYLAB_POINTFORGE_IMPORT_STORAGE_KEY);
          return false;
        }
        currentImportContext = {
          sourceType: "boundary-lab",
          sourceLabel: "Exported from BoundaryLab",
          baseName: "BoundaryLab Traversal",
          extension: ".csv",
        };
        elIn.value = String(payload.csv);
        persistPointSetToProjectFile({ kind: "import", text: String(payload.csv), context: currentImportContext, timestamp: new Date() });
        processNow();
        activatePointEditorOutputAccordion();
        elMapHint.innerHTML = `<span class="ok">Imported traversal from BoundaryLab.</span>`;
        localStorage.removeItem(BOUNDARYLAB_POINTFORGE_IMPORT_STORAGE_KEY);
        return true;
      } catch {
        localStorage.removeItem(BOUNDARYLAB_POINTFORGE_IMPORT_STORAGE_KEY);
        return false;
      }
    }

    // -----------------------------
    // Point files dropdown
    // -----------------------------
    async function populatePointFileDropdown(){
      const projectContext = getProjectContext();
      if (!projectContext.projectId){
        elPointFileSelect.style.display = "none";
        return;
      }

      elPointFileSelect.style.display = "inline-flex";
      let items = [];
      try {
        items = await fetchProjectPointFiles(projectContext.projectId);
      } catch {
        const projectFile = loadProjectFileSnapshot(projectContext.projectId);
        const pointFolder = projectFile?.folders?.find((f) => f.key === "point-files");
        items = (pointFolder && Array.isArray(pointFolder.index))
          ? pointFolder.index.map((entry) => ({
            pointFileId: entry?.id || "",
            pointFileName: entry?.title || entry?.id || "Untitled",
          }))
          : [];
      }
      projectPointFilesCache = items;

      // Clear existing options beyond the placeholder
      while (elPointFileSelect.options.length > 1) elPointFileSelect.remove(1);

      if (!items.length){
        elPointFileSelect.options[0].textContent = "No point files in project";
        elPointFileSelect.disabled = true;
        return;
      }

      elPointFileSelect.options[0].textContent = "Select point file\u2026";
      elPointFileSelect.disabled = false;

      for (const item of items){
        const option = document.createElement("option");
        option.value = item.pointFileId || item.id || "";
        option.textContent = item.pointFileName || item.title || item.id || "Untitled";
        option.dataset.pointFileId = item.pointFileId || item.id || "";
        elPointFileSelect.appendChild(option);
      }
    }

    elPointFileSelect.addEventListener("change", async ()=>{
      const pointFileId = elPointFileSelect.value;
      if (!pointFileId) return;

      const projectContext = getProjectContext();
      let text = "";
      let title = "Project Point File";
      const record = await fetchProjectPointFile(projectContext.projectId, pointFileId);
      if (record?.currentState?.text) {
        text = String(record.currentState.text);
        title = normalizeBaseName(record.pointFileName, "Project Point File");
      } else {
        const cached = projectPointFilesCache.find((entry) => (entry.pointFileId || entry.id) === pointFileId);
        const fallback = loadStoredPointSet(pointSetStorageKey(pointFileId));
        text = String(fallback?.text || "");
        title = normalizeBaseName(cached?.pointFileName || cached?.title || fallback?.fileName, "Project Point File");
      }

      if (!text.trim()){
        elMapHint.innerHTML = '<span class="warn">Could not load selected point file from API.</span>';
        return;
      }

      currentImportContext = {
        sourceType: "project-dropdown",
        sourceLabel: title,
        baseName: title,
        pointFileId,
        extension: ".csv",
      };

      elIn.value = text;
      processNow();
      activatePointEditorOutputAccordion();
      saveLastOpenedProjectPointSet(projectContext.projectId, pointSetStorageKey(pointFileId));
      elMapHint.innerHTML = `<span class="ok">Opened point file: ${escapeHtml(title)}.</span>`;
    });

    // Init: blank textarea (no sample data), locked defaults already set in HTML
    initMap();
    setLocalizationInputsEnabled(false);
    elIn.value = "";
    setPointEditorView(false);
    setPointEditorAccordionMode("input");
    updateOutputActionVisibility();
    setBasemap("street");
    setStats({ totalLines: 0, parsedCount: 0, gCount: 0, refCount: 0 }, 0);
    elMapHint.textContent = "Load a file or paste points to plot. Basemap toggle: Street / Satellite.";
    elIn.addEventListener("blur", ()=>{
      if (!elIn.value.trim() || currentImportContext) return;
      ensureImportContextForPaste(true);
      if (currentImportContext){
        persistPointSetToProjectFile({ kind: "import", text: elIn.value, context: currentImportContext, timestamp: new Date() });
      }
    });
    tryImportRosPayload();
    tryImportProjectBrowserPayload();
    tryImportBoundaryLabPayload();
    tryRestoreLastOpenedProjectPointSet();
    populatePointFileDropdown();
  </script>
</body>
</html>
