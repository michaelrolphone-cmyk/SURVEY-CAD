<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PointForge // NAD83 Idaho West // G+REF Renumber + Map</title>

  <!-- Leaflet (map preview). For fully-offline use, download these assets and replace CDN links. -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    :root{
      --bg0:#05060a;
      --bg1:#070a12;
      --glass: rgba(14, 18, 30, .62);
      --glass2: rgba(10, 14, 22, .55);
      --line: rgba(255,255,255,.10);
      --line2: rgba(255,255,255,.06);

      --text:#e7f0ff;
      --muted:#8aa4c2;

      --c1:#00e5ff;
      --c2:#ff2bd6;
      --c3:#a6ff6f;
      --warn:#ffbd2e;
      --bad:#ff4d6d;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --r: 16px;
    }

    *{ box-sizing: border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(1200px 800px at 15% 20%, rgba(0,229,255,.13), transparent 55%),
                  radial-gradient(900px 700px at 85% 30%, rgba(255,43,214,.10), transparent 55%),
                  radial-gradient(900px 900px at 50% 95%, rgba(166,255,111,.06), transparent 60%),
                  linear-gradient(180deg, var(--bg0) 0%, var(--bg1) 100%);
      overflow-x: hidden;
    }

    body::before{
      content:"";
      position: fixed; inset:0;
      pointer-events:none;
      background:
        linear-gradient(rgba(255,255,255,.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,.05) 1px, transparent 1px);
      background-size: 48px 48px;
      opacity:.08;
      mask-image: radial-gradient(closest-side at 50% 40%, black 35%, transparent 80%);
    }
    body::after{
      content:"";
      position: fixed; inset:-40%;
      pointer-events:none;
      background:
        repeating-linear-gradient(
          180deg,
          rgba(255,255,255,.00) 0px,
          rgba(255,255,255,.00) 3px,
          rgba(255,255,255,.02) 4px
        );
      opacity:.12;
      transform: rotate(-3deg);
      animation: scan 7.5s linear infinite;
    }
    @keyframes scan{
      0%{ transform: translateY(-4%) rotate(-3deg); }
      100%{ transform: translateY(4%) rotate(-3deg); }
    }

    header{
      position: sticky; top:0; z-index: 50;
      backdrop-filter: blur(12px);
      background: linear-gradient(90deg, rgba(0,229,255,.10), rgba(255,43,214,.08), rgba(166,255,111,.06));
      border-bottom: 1px solid var(--line);
    }
    .top{
      padding: 14px 18px;
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 14px;
    }
    .brand{
      display:flex;
      flex-direction: column;
      gap: 4px;
      min-width: 280px;
    }
    .brand .title{
      display:flex; align-items: baseline; gap: 10px;
      font-weight: 800;
      letter-spacing: .8px;
      text-transform: uppercase;
      font-size: 13px;
    }
    .badge{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0,229,255,.35);
      background: rgba(0,229,255,.10);
      color: var(--c1);
      box-shadow: 0 0 0 1px rgba(0,229,255,.10), 0 0 18px rgba(0,229,255,.15);
    }
    .brand .sub{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }
    .statusbar{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      align-items: center;
      min-width: 280px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(10,14,22,.48);
      box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset;
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    .dot{
      width:8px; height:8px;
      border-radius: 99px;
      background: var(--c3);
      box-shadow: 0 0 0 2px rgba(166,255,111,.15), 0 0 18px rgba(166,255,111,.35);
    }
    .mono{ font-family: var(--mono); color: var(--text); }

    main{
      padding: 16px 18px 24px;
      display:grid;
      grid-template-columns: 460px 1fr;
      gap: 14px;
    }
    @media (max-width: 1020px){
      main{ grid-template-columns: 1fr; }
    }

    .panel{
      border-radius: var(--r);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border: 1px solid var(--line);
      box-shadow:
        0 0 0 1px rgba(255,255,255,.04) inset,
        0 12px 48px rgba(0,0,0,.40);
      overflow:hidden;
      position: relative;
    }
    .panel::before{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      background: radial-gradient(800px 200px at 20% 0%, rgba(0,229,255,.12), transparent 60%),
                  radial-gradient(800px 220px at 80% 0%, rgba(255,43,214,.10), transparent 60%);
      opacity:.85;
      mix-blend-mode: screen;
    }
    .panelhead{
      position: relative;
      padding: 12px 12px;
      border-bottom: 1px solid var(--line2);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      background: rgba(7,10,18,.55);
      backdrop-filter: blur(12px);
    }
    .panelhead h2{
      margin:0;
      font-size: 12px;
      letter-spacing: .9px;
      text-transform: uppercase;
      font-weight: 850;
      color: rgba(231,240,255,.92);
      display:flex;
      align-items:center;
      gap: 10px;
    }
    .panelhead h2 .sig{
      width: 10px; height: 10px;
      border-radius: 2px;
      background: linear-gradient(135deg, var(--c1), var(--c2));
      box-shadow: 0 0 14px rgba(0,229,255,.25), 0 0 18px rgba(255,43,214,.20);
    }

    .panelbody{
      position: relative;
      padding: 12px;
    }

    .row{ display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    label{ font-size: 12px; color: var(--muted); }
    input[type="file"]{ width: 100%; color: var(--muted); }
    input[type="number"]{
      width: 110px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(8,10,16,.75);
      color: var(--text);
      font-size: 12px;
    }
    input[type="number"]:focus{
      outline: none;
      border-color: rgba(0,229,255,.35);
      box-shadow: 0 0 22px rgba(0,229,255,.12);
    }

    textarea{
      width: 100%;
      min-height: 260px;
      resize: vertical;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(0,229,255,.18);
      background: rgba(6,8,14,.78);
      box-shadow:
        0 0 0 1px rgba(255,255,255,.05) inset,
        0 0 24px rgba(0,229,255,.08);
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
      outline: none;
    }
    textarea:focus{
      border-color: rgba(255,43,214,.30);
      box-shadow:
        0 0 0 1px rgba(255,43,214,.18) inset,
        0 0 26px rgba(255,43,214,.16);
    }

    select{
      appearance:none;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      color: var(--text);
      outline:none;
      font-size: 12px;
    }
    select:focus{ border-color: rgba(0,229,255,.35); box-shadow: 0 0 22px rgba(0,229,255,.12); }

    .btn{
      border: 1px solid rgba(0,229,255,.35);
      color: rgba(231,240,255,.95);
      background: linear-gradient(180deg, rgba(0,229,255,.18), rgba(0,229,255,.06));
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 850;
      font-size: 12px;
      letter-spacing: .5px;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow:
        0 0 0 1px rgba(0,229,255,.10) inset,
        0 0 22px rgba(0,229,255,.12);
      transition: transform .08s ease, box-shadow .15s ease, border-color .15s ease;
    }
    .btn:hover{
      border-color: rgba(255,43,214,.35);
      box-shadow:
        0 0 0 1px rgba(255,43,214,.10) inset,
        0 0 28px rgba(255,43,214,.14);
    }
    .btn:active{ transform: translateY(1px); }
    .btn.secondary{
      border-color: rgba(255,255,255,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      box-shadow: 0 0 0 1px rgba(255,255,255,.05) inset;
    }
    .btn.secondary:hover{
      border-color: rgba(255,255,255,.26);
      box-shadow: 0 0 0 1px rgba(255,255,255,.07) inset, 0 0 22px rgba(255,255,255,.06);
    }
    .btn[disabled]{ opacity: .45; cursor: not-allowed; filter: grayscale(.2); box-shadow: none; }

    .pill{
      display:inline-flex; align-items:center; gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,14,22,.44);
      color: var(--muted);
      font-size: 12px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset;
      flex-wrap: wrap;
    }
    input[type="checkbox"]{ width: 16px; height: 16px; accent-color: var(--c1); }
    .hint{ margin: 8px 0 0; font-size: 12px; color: var(--muted); line-height: 1.35; }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 540px){ .grid2{ grid-template-columns:1fr; } }

    .stats{
      margin-top: 10px;
      border-top: 1px solid var(--line2);
      padding-top: 10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .stat{
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(8,10,16,.55);
      padding: 10px 12px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset;
    }
    .stat .k{
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .8px;
      margin-bottom: 6px;
    }
    .stat .v{
      font-family: var(--mono);
      font-size: 14px;
      color: var(--text);
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
    }
    .stat .v .glow{ color: var(--c1); text-shadow: 0 0 18px rgba(0,229,255,.25); }

    .log{
      margin-top: 10px;
      border-top: 1px solid var(--line2);
      padding-top: 10px;
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(138,164,194,.95);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .ok{ color: var(--c3); }
    .warn{ color: var(--warn); }
    .bad{ color: var(--bad); }

    #map{
      height: 380px;
      width: 100%;
      border-radius: var(--r);
      border: 1px solid rgba(0,229,255,.22);
      box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset, 0 0 30px rgba(0,229,255,.10);
      overflow: hidden;
    }
    .leaflet-container{ background: #06101b; }
    .leaflet-control-zoom a{
      background: rgba(8,10,16,.78) !important;
      color: var(--text) !important;
      border: 1px solid rgba(255,255,255,.16) !important;
      box-shadow: 0 0 18px rgba(0,0,0,.25);
    }
    .leaflet-control-attribution{
      background: rgba(8,10,16,.55) !important;
      color: rgba(138,164,194,.85) !important;
      border-radius: 10px !important;
      border: 1px solid rgba(255,255,255,.10) !important;
      margin: 0 8px 8px 0 !important;
    }

    .right{
      display:grid;
      grid-template-rows: auto 1fr;
      gap: 14px;
    }
    .outputArea{ min-height: 320px; }

    .kbd{
      font-family: var(--mono);
      padding: 2px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(8,10,16,.55);
      color: var(--text);
      font-size: 11px;
    }
    .toggleRow{ margin-top: 10px; display:flex; justify-content:flex-end; }
    .pointsTableWrap{
      border:1px solid rgba(255,255,255,.14);
      border-radius:12px;
      overflow:hidden;
      background: rgba(5,7,11,.75);
      max-height: 300px;
      display:none;
      flex-direction:column;
    }
    .pointsTableWrap.active{ display:flex; }
    .pointsTableScroll{ overflow:auto; }
    .pointsTable{ width:100%; border-collapse:collapse; font-size:12px; }
    .pointsTable th, .pointsTable td{ padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.09); text-align:left; white-space:nowrap; }
    .pointsTable thead th{ position:sticky; top:0; background: rgba(9,12,18,.95); color: var(--muted); }
    .pointsTable input{
      width:100%;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(8,10,16,.75);
      color: var(--text);
      border-radius:8px;
      padding:6px;
      font-size:12px;
    }
  </style>
</head>

<body>
  <header>
    <div class="top">
      <div class="brand">
        <div class="title">
          <span class="badge">POINTFORGE</span>
          <span>G/REF RENUMB + MAP PREVIEW</span>
        </div>
        <div class="sub">
          NAD83 Idaho West map preview and point renumbering.
        </div>
      </div>

      <div class="statusbar">
        <span class="chip"><span class="dot"></span> SYSTEM: ONLINE</span>
        <span class="chip">DATUM: <span class="mono">NAD83 (NO_TRANS)</span></span>
        <span class="chip">PIPELINE: <span class="mono">PARSE → RENUMB → SORT → PLOT</span></span>
      </div>
    </div>
  </header>

  <main>
    <!-- Left: Input + Controls -->
    <section class="panel">
      <div class="panelhead">
        <h2><span class="sig"></span> Ingest Console</h2>
        <div class="pill">
          <input id="autoProcess" type="checkbox" checked />
          <label for="autoProcess" style="color:var(--text); margin:0;">Auto-process</label>
        </div>
      </div>
      <div class="panelbody">
        <div class="row" style="width:100%;">
          <div style="flex:1 1 100%;">
            <label for="file">Load point file (.txt / .csv)</label>
            <input id="file" type="file" accept=".txt,.csv,text/plain,text/csv" />
            <div class="hint">Or paste into the field below. Processing keeps coordinates unchanged while renumbering point IDs.</div>
          </div>
        </div>

        <label for="inText">Raw points</label>
        <textarea id="inText" spellcheck="false" placeholder="Paste points here... (no sample data loaded)"></textarea>
        <div class="toggleRow">
          <button id="btnToggleInputView" class="btn secondary" type="button">Switch to Point Editor View</button>
        </div>
        <div id="inputTableWrap" class="pointsTableWrap" aria-hidden="true">
          <div class="pointsTableScroll">
            <table class="pointsTable">
              <thead>
                <tr><th>#</th><th>X</th><th>Y</th><th>Z</th><th>Code</th><th>Notes</th></tr>
              </thead>
              <tbody id="inputPointsBody"></tbody>
            </table>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnProcess" class="btn">Process</button>
          <button id="btnRenumber" class="btn secondary" disabled>Renumber Output</button>
          <button id="btnDownload" class="btn secondary" disabled>Download</button>
          <button id="btnOpenLineSmith" class="btn secondary" disabled>Open in LineSmith</button>

          <span class="pill">
            <label for="renumberStart" style="color:var(--text); margin:0;">Renumber start</label>
            <input id="renumberStart" type="number" min="1" step="1" value="1" />
          </span>

          <span class="pill">
            <span class="mono">Basemap</span>
            <select id="basemap" style="min-width: 170px;">
              <option value="street" selected>Street</option>
              <option value="satellite">Satellite</option>
            </select>
          </span>

          <span class="pill">Map defaults: <span class="mono">US-ft</span> · <span class="mono">West</span> · <span class="mono">SwapXY</span></span>
        </div>

        <div class="grid2" style="margin-top: 10px; display:none;">
          <div class="pill">
            <span class="mono">Zone</span>
            <select id="zone" title="State Plane zone" style="min-width: 160px;">
              <option value="west" selected>Idaho West</option>
              <option value="central">Idaho Central</option>
              <option value="east">Idaho East</option>
            </select>
          </div>

          <div class="pill">
            <input id="showLabels" type="checkbox" checked />
            <label for="showLabels" style="color:var(--text); margin:0;">Show marker labels</label>
          </div>
        </div>

        <div class="grid2" style="margin-top: 10px; display:none;">
          <div class="pill">
            <input id="swapXY" type="checkbox" checked disabled />
            <label for="swapXY" style="color:var(--text); margin:0;">Swap X/Y (locked default)</label>
          </div>
          <div class="pill">
            <span class="mono">Units</span>
            <select id="units" style="min-width: 160px;" disabled>
              <option value="usft" selected>US-ft (locked)</option>
            </select>
          </div>
        </div>

        <div class="stats">
          <div class="stat">
            <div class="k">Input lines</div>
            <div class="v"><span id="st_lines" class="glow">—</span><span class="mono">ln</span></div>
          </div>
          <div class="stat">
            <div class="k">Parsed points</div>
            <div class="v"><span id="st_parsed" class="glow">—</span><span class="mono">pts</span></div>
          </div>
          <div class="stat">
            <div class="k">G renumbered</div>
            <div class="v"><span id="st_g" class="glow">—</span><span class="mono">pts</span></div>
          </div>
          <div class="stat">
            <div class="k">REF renumbered</div>
            <div class="v"><span id="st_ref" class="glow">—</span><span class="mono">pts</span></div>
          </div>
          <div class="stat">
            <div class="k">Map plotted</div>
            <div class="v"><span id="st_map" class="glow">—</span><span class="mono">pts</span></div>
          </div>
          <div class="stat">
            <div class="k">Active zone</div>
            <div class="v"><span id="st_zone" class="glow">W</span><span class="mono">ID</span></div>
          </div>
        </div>

        <div class="log" id="log"></div>
      </div>
    </section>

    <!-- Right: Map + Output -->
    <section class="right">
      <section class="panel">
        <div class="panelhead">
          <h2><span class="sig"></span> Spatial HUD</h2>
          <div class="chip">Projection: <span class="mono">Idaho SP (US-ft)</span></div>
        </div>
        <div class="panelbody">
          <div id="map"></div>
          <div class="hint" id="mapHint">Load a file or paste points to plot.</div>
        </div>
      </section>

      <section class="panel outputArea">
        <div class="panelhead">
          <h2><span class="sig"></span> Output Stream</h2>
          <div class="chip">Sorted: <span class="mono">numeric point id</span></div>
        </div>
        <div class="panelbody">
          <label for="outText">Transformed points</label>
          <textarea id="outText" spellcheck="false" readonly></textarea>
          <div id="outputTableWrap" class="pointsTableWrap" aria-hidden="true">
            <div class="pointsTableScroll">
              <table class="pointsTable">
                <thead>
                  <tr><th>#</th><th>X</th><th>Y</th><th>Z</th><th>Code</th><th>Notes</th></tr>
                </thead>
                <tbody id="outputPointsBody"></tbody>
              </table>
            </div>
          </div>
          <div class="hint">Download saves exactly what you see here.</div>
        </div>
      </section>
    </section>
  </main>

  <!-- libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/proj4@2.10.0/dist/proj4.js"></script>

  <script>
    // -----------------------------
    // CSV helpers
    // -----------------------------
    function parseCSVLine(line){
      const out = [];
      let cur = "";
      let inQuotes = false;

      for (let i=0; i<line.length; i++){
        const ch = line[i];
        if (inQuotes){
          if (ch === '"'){
            if (i+1 < line.length && line[i+1] === '"'){ cur += '"'; i++; }
            else inQuotes = false;
          } else cur += ch;
        } else {
          if (ch === ','){ out.push(cur); cur = ""; }
          else if (ch === '"'){ inQuotes = true; }
          else cur += ch;
        }
      }
      out.push(cur);
      return out;
    }

    function csvEscape(v){
      const s = (v ?? "").toString();
      if (/[",\n\r]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
      return s;
    }

    function isIntString(s){ return /^\s*\d+\s*$/.test(s); }
    function toInt(s){ return parseInt(String(s).trim(), 10); }
    function trimOrEmpty(s){ return (s ?? "").toString().trim(); }

    // -----------------------------
    // Point classification
    // -----------------------------
    function classifyName(name){
      const n = trimOrEmpty(name);
      const isRef = /REF/i.test(n);
      const gMatch = n.match(/^(\d+)\s*G(\d+)?\s*$/i); // 15G, 202G, 123G1
      const isG = !!gMatch && !isRef;
      const gPrefix = isG ? parseInt(gMatch[1], 10) : null;
      const gSuffix = (isG && gMatch[2] != null) ? parseInt(gMatch[2], 10) : null;
      return { isRef, isG, gPrefix, gSuffix };
    }

    function appendToDesc(fields, token){
      const last = fields.length - 1;
      const existing = trimOrEmpty(fields[last]);
      fields[last] = existing ? (existing + " " + token) : token;
    }

    // -----------------------------
    // Block allocation logic
    // -----------------------------
    function computeUsedBlocks(usedNums){
      const blocks = new Set();
      for (const n of usedNums){
        if (!Number.isFinite(n)) continue;
        blocks.add(Math.floor(n / 100) * 100);
      }
      return blocks;
    }

    function pickFreeBlock({ start, usedBlocks, allocatedBlocks, avoidBlocks = new Set(), maxBlock = 20000 }){
      for (let b = start; b <= maxBlock; b += 100){
        if (b === 5000) continue; // reserved for REF renumbering
        if (avoidBlocks.has(b)) continue;
        if (allocatedBlocks.has(b)) continue;
        if (usedBlocks.has(b)) continue;
        return b;
      }
      return null;
    }

    function allocatePreferredInBlock(preferred, blockStart, usedNums){
      const blockEnd = blockStart + 99;

      if (Number.isFinite(preferred) && !usedNums.has(preferred) && preferred >= blockStart && preferred <= blockEnd){
        usedNums.add(preferred);
        return preferred;
      }
      for (let n = blockStart; n <= blockEnd; n++){
        if (!usedNums.has(n)){
          usedNums.add(n);
          return n;
        }
      }
      // overflow if block completely full
      let n = blockEnd + 1;
      while (usedNums.has(n)) n++;
      usedNums.add(n);
      return n;
    }

    // -----------------------------
    // Main transform
    // -----------------------------
    function transformPoints(text){
      const rawLines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
      const records = [];
      const log = [];
      let parsedCount = 0;

      for (let i=0; i<rawLines.length; i++){
        const line = rawLines[i];
        if (!line || !line.trim()) continue;

        const fields = parseCSVLine(line);
        if (fields.length < 2){
          records.push({ idx:i, passthrough:true, fields });
          continue;
        }

        // Ensure description column exists (at least 5 columns)
        while (fields.length < 5) fields.push("");

        const name = trimOrEmpty(fields[0]);
        const cls = classifyName(name);

        const x = Number.parseFloat(fields[1]);
        const y = (fields.length > 2) ? Number.parseFloat(fields[2]) : NaN;

        records.push({
          idx: i,
          passthrough:false,
          fields,
          origName: name,
          cls,
          x, y,
          newNum: null
        });
        parsedCount++;
      }

      // Used numeric point numbers from non-special points (so we don't collide).
      const usedNums = new Set();
      for (const r of records){
        if (r.passthrough) continue;
        const name = trimOrEmpty(r.fields[0]);
        if (isIntString(name) && !r.cls.isRef && !r.cls.isG){
          usedNums.add(toInt(name));
        }
      }

      // 1) REF points => 5000+
      let refCount = 0;
      let nextRef = 5000;
      for (const r of records){
        if (r.passthrough) continue;
        if (!r.cls.isRef) continue;

        while (usedNums.has(nextRef)) nextRef++;
        r.newNum = nextRef;
        usedNums.add(nextRef);
        refCount++;

        appendToDesc(r.fields, r.origName);
        r.fields[0] = String(nextRef);
        nextRef++;
      }

      // 2) G points => allocate 100-block ranges
      const gRecords = records.filter(r => !r.passthrough && r.cls.isG);
      const gCount = gRecords.length;

      const usedBlocks = computeUsedBlocks(usedNums);
      const allocatedBlocks = new Set();

      const simpleGroups = new Map(); // origHundreds -> records[] for <digits>G (no suffix)
      const suffixCandidates = [];    // <digits>G<digits>

      for (const r of gRecords){
        if (r.cls.gSuffix == null){
          const h0 = Math.floor(r.cls.gPrefix / 100) * 100; // 0, 100, 200, ...
          const key = String(h0);
          if (!simpleGroups.has(key)) simpleGroups.set(key, []);
          simpleGroups.get(key).push(r);
        } else {
          suffixCandidates.push(r);
        }
      }

      // Determine multiplicity by prefix for suffix candidates
      const byPrefix = new Map();
      for (const r of suffixCandidates){
        const p = r.cls.gPrefix;
        if (!byPrefix.has(p)) byPrefix.set(p, []);
        byPrefix.get(p).push(r);
      }

      const seriesGroups = [];             // multiple per prefix => derive from suffix
      const singletonBySuffix = new Map(); // single per prefix => group by suffix and sequentially number

      for (const [p, arr] of byPrefix.entries()){
        if (arr.length > 1){
          seriesGroups.push({ key: "prefix:" + p, prefix: p, records: arr });
        } else {
          const r = arr[0];
          const sfx = r.cls.gSuffix;
          if (!singletonBySuffix.has(sfx)) singletonBySuffix.set(sfx, []);
          singletonBySuffix.get(sfx).push(r);
        }
      }

      // Allocate blocks for simple groups: start 200.., avoid 500-block (preferred for suffix logic)
      const simpleKeys = Array.from(simpleGroups.keys()).map(k => parseInt(k,10));
      simpleKeys.sort((a,b)=>{
        const az = (a===0)?1:0;
        const bz = (b===0)?1:0;
        if (az !== bz) return az - bz;
        return a - b;
      });

      const groupBlockAssignments = [];

      for (const h0 of simpleKeys){
        const recs = simpleGroups.get(String(h0));
        const avoid = new Set([500]); // reserve 500s for suffix numbering feel
        if (h0 >= 100) avoid.add(h0);

        const block = pickFreeBlock({
          start: 200,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: avoid,
          maxBlock: 20000
        }) ?? pickFreeBlock({
          start: 200,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: new Set([500]),
          maxBlock: 20000
        }) ?? 200;

        allocatedBlocks.add(block);
        usedBlocks.add(block);
        groupBlockAssignments.push({ kind:"simple", origHundreds:h0, block, count: recs.length });

        for (const r of recs){
          const preferred = block + (r.cls.gPrefix % 100);
          const assigned = allocatePreferredInBlock(preferred, block, usedNums);
          r.newNum = assigned;
          appendToDesc(r.fields, r.origName);
          r.fields[0] = String(assigned);
        }
      }

      // Series groups: prefer 500-block upwards so ...G1 becomes X01 (e.g., 501)
      seriesGroups.sort((a,b)=>a.prefix - b.prefix);
      for (const g of seriesGroups){
        const block = pickFreeBlock({
          start: 500,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: new Set(),
          maxBlock: 20000
        }) ?? pickFreeBlock({
          start: 200,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: new Set([5000]),
          maxBlock: 20000
        }) ?? 500;

        allocatedBlocks.add(block);
        usedBlocks.add(block);
        groupBlockAssignments.push({ kind:"series", key:g.key, block, count: g.records.length });

        for (const r of g.records){
          const sfx = r.cls.gSuffix;
          const preferred = block + sfx;
          const assigned = allocatePreferredInBlock(preferred, block, usedNums);
          r.newNum = assigned;
          appendToDesc(r.fields, r.origName);
          r.fields[0] = String(assigned);
        }
      }

      // Singleton-by-suffix groups: sequential numbering inside their allocated block.
      const suffixKeys = Array.from(singletonBySuffix.keys()).sort((a,b)=>a-b);
      for (const sfx of suffixKeys){
        const recs = singletonBySuffix.get(sfx);

        const block = pickFreeBlock({
          start: 500,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: new Set(),
          maxBlock: 20000
        }) ?? pickFreeBlock({
          start: 200,
          usedBlocks,
          allocatedBlocks,
          avoidBlocks: new Set([5000]),
          maxBlock: 20000
        }) ?? 500;

        allocatedBlocks.add(block);
        usedBlocks.add(block);
        groupBlockAssignments.push({ kind:"suffixSingles", suffix:sfx, block, count: recs.length });

        recs.sort((a,b)=>a.idx-b.idx);
        for (const r of recs){
          const assigned = allocatePreferredInBlock(block, block, usedNums);
          r.newNum = assigned;
          appendToDesc(r.fields, r.origName);
          r.fields[0] = String(assigned);
        }
      }

      // 3) Sort numerically by final point number
      const sortable = records.filter(r => !r.passthrough);
      sortable.sort((a,b)=>{
        const an = isIntString(a.fields[0]) ? toInt(a.fields[0]) : Number.POSITIVE_INFINITY;
        const bn = isIntString(b.fields[0]) ? toInt(b.fields[0]) : Number.POSITIVE_INFINITY;
        if (an !== bn) return an - bn;
        return a.idx - b.idx;
      });

      const passthrough = records.filter(r => r.passthrough).sort((a,b)=>a.idx-b.idx);

      const outLines = [];
      for (const r of sortable) outLines.push(r.fields.map(csvEscape).join(","));
      for (const r of passthrough) outLines.push(r.fields.map(csvEscape).join(","));

      log.push(`BLOCK ALLOCATION`);
      for (const g of groupBlockAssignments){
        if (g.kind === "simple") log.push(`  simple G (orig hundreds ${g.origHundreds}) -> ${g.block}-${g.block+99}  (${g.count})`);
        else if (g.kind === "series") log.push(`  suffix series (${g.key}) -> ${g.block}-${g.block+99}  (${g.count})`);
        else log.push(`  suffix singletons (G${g.suffix}) -> ${g.block}-${g.block+99}  (${g.count})`);
      }

      return {
        recordsSorted: sortable,
        outputText: outLines.join("\n"),
        stats: { totalLines: rawLines.length, parsedCount, gCount, refCount },
        logText: log.join("\n")
      };
    }

    // -----------------------------
    // Idaho State Plane defs (NAD83; "NO_TRANS": no grid shift terms)
    // Fixed defaults: US-ft + Swap X/Y
    // -----------------------------
    const PROJ_DEFS_USFT = {
      east:   "+proj=tmerc +lat_0=41.6666666666667 +lon_0=-112.166666666667 +k=0.999947368 +x_0=200000.0001016 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs",
      central:"+proj=tmerc +lat_0=41.6666666666667 +lon_0=-114 +k=0.999947368 +x_0=500000.0001016 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs",
      west:   "+proj=tmerc +lat_0=41.6666666666667 +lon_0=-115.75 +k=0.999933333 +x_0=800000.0001016 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs"
    };

    const ID_BBOX = { minLat: 41.8, maxLat: 49.6, minLon: -117.6, maxLon: -110.4 };
    function inIdaho(lat, lon){
      return lat >= ID_BBOX.minLat && lat <= ID_BBOX.maxLat && lon >= ID_BBOX.minLon && lon <= ID_BBOX.maxLon;
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    // -----------------------------
    // UI + Map (basemap switcher)
    // -----------------------------
    const elFile = document.getElementById("file");
    const elIn = document.getElementById("inText");
    const elOut = document.getElementById("outText");
    const elLog = document.getElementById("log");
    const elDownload = document.getElementById("btnDownload");
    const elProcess = document.getElementById("btnProcess");
    const elRenumber = document.getElementById("btnRenumber");
    const elOpenLineSmith = document.getElementById("btnOpenLineSmith");
    const elAuto = document.getElementById("autoProcess");
    const elZone = document.getElementById("zone");
    const elShowLabels = document.getElementById("showLabels");
    const elBasemap = document.getElementById("basemap");
    const elRenumberStart = document.getElementById("renumberStart");
    const elMapHint = document.getElementById("mapHint");

    const st_lines = document.getElementById("st_lines");
    const st_parsed = document.getElementById("st_parsed");
    const st_g = document.getElementById("st_g");
    const st_ref = document.getElementById("st_ref");
    const st_map = document.getElementById("st_map");
    const st_zone = document.getElementById("st_zone");

    const SURVEY_SKETCH_IMPORT_STORAGE_KEY = "lineSmithPointforgeImport";
    const ROS_POINTFORGE_IMPORT_STORAGE_KEY = "pointforgeRosImport";
    const PROJECT_BROWSER_POINTFORGE_IMPORT_STORAGE_KEY = "pointforgeProjectBrowserImport";
    const PROJECT_FILE_STORAGE_PREFIX = "surveyfoundryProjectFile";
    const POINTFORGE_POINT_SET_STORAGE_PREFIX = "pointforgePointSet";

    let latestOutputText = "";
    let latestTransformed = null;
    let currentImportContext = null;
    let usePointEditorView = false;

    const elInputTableWrap = document.getElementById("inputTableWrap");
    const elOutputTableWrap = document.getElementById("outputTableWrap");
    const elInputPointsBody = document.getElementById("inputPointsBody");
    const elOutputPointsBody = document.getElementById("outputPointsBody");
    const elToggleInputView = document.getElementById("btnToggleInputView");

    function parsePointRows(text){
      const lines = String(text || "").split(/\r?\n/);
      const rows = [];
      for (const line of lines){
        if (!line.trim()) continue;
        const fields = parseCSVLine(line);
        if (fields.length < 4) continue;
        rows.push({
          number: trimOrEmpty(fields[0]),
          x: trimOrEmpty(fields[1]),
          y: trimOrEmpty(fields[2]),
          z: trimOrEmpty(fields[3]),
          code: trimOrEmpty(fields[4]),
          notes: trimOrEmpty(fields[5]),
        });
      }
      return rows;
    }

    function rowsToCsv(rows){
      return rows
        .map((row)=>[
          csvEscape(row.number), csvEscape(row.x), csvEscape(row.y), csvEscape(row.z), csvEscape(row.code), csvEscape(row.notes)
        ].join(","))
        .join("\n");
    }

    function renderPointRows(rows, tbody, editable){
      tbody.innerHTML = "";
      if (!rows.length){
        const tr = document.createElement("tr");
        tr.innerHTML = '<td colspan="6" class="muted">No points to display.</td>';
        tbody.appendChild(tr);
        return;
      }
      rows.forEach((row, idx)=>{
        const tr = document.createElement("tr");
        const cells = ["number", "x", "y", "z", "code", "notes"];
        for (const key of cells){
          const td = document.createElement("td");
          if (editable){
            const input = document.createElement("input");
            input.value = row[key] || "";
            input.dataset.index = String(idx);
            input.dataset.field = key;
            input.addEventListener("input", (event)=>{
              const target = event.target;
              rows[Number(target.dataset.index)][target.dataset.field] = target.value;
              elIn.value = rowsToCsv(rows);
              if (elAuto.checked) processNow();
            });
            td.appendChild(input);
          } else {
            td.textContent = row[key] || "";
          }
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      });
    }

    function refreshPointEditorTables(){
      if (!usePointEditorView) return;
      renderPointRows(parsePointRows(elIn.value), elInputPointsBody, true);
      renderPointRows(parsePointRows(elOut.value), elOutputPointsBody, false);
    }

    function setPointEditorView(enabled){
      usePointEditorView = !!enabled;
      elIn.style.display = usePointEditorView ? "none" : "block";
      elOut.style.display = usePointEditorView ? "none" : "block";
      elInputTableWrap.classList.toggle("active", usePointEditorView);
      elOutputTableWrap.classList.toggle("active", usePointEditorView);
      elInputTableWrap.setAttribute("aria-hidden", usePointEditorView ? "false" : "true");
      elOutputTableWrap.setAttribute("aria-hidden", usePointEditorView ? "false" : "true");
      elToggleInputView.textContent = usePointEditorView ? "Switch to Textarea View" : "Switch to Point Editor View";
      if (usePointEditorView) refreshPointEditorTables();
    }

    let map = null;
    let layer = null;

    // Base layers (Street + Satellite)
    let streetLayer = null;
    let satLayer = null;
    let activeBase = "street";

    function projectFileStorageKey(projectId){
      return `${PROJECT_FILE_STORAGE_PREFIX}:${projectId}`;
    }

    function pointSetStorageKey(setId){
      return `${POINTFORGE_POINT_SET_STORAGE_PREFIX}:${setId}`;
    }

    function getProjectContext(){
      const params = new URLSearchParams(window.location.search || "");
      const projectId = params.get("projectId") || params.get("activeProjectId") || "";
      const projectName = params.get("projectName") || params.get("activeProjectName") || "";
      return { projectId, projectName };
    }

    function loadProjectFileSnapshot(projectId){
      if (!projectId) return null;
      try {
        const raw = localStorage.getItem(projectFileStorageKey(projectId));
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object" || !Array.isArray(parsed.folders)) return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function saveProjectFileSnapshot(projectId, projectFile){
      if (!projectId || !projectFile) return;
      localStorage.setItem(projectFileStorageKey(projectId), JSON.stringify(projectFile));
    }

    function ensureProjectFileFolder(projectFile, folderKey){
      if (!projectFile || !Array.isArray(projectFile.folders)) return null;
      const existing = projectFile.folders.find((folder) => folder.key === folderKey);
      if (existing){
        if (!Array.isArray(existing.index)) existing.index = [];
        return existing;
      }
      const created = { key: folderKey, label: folderKey, description: "", index: [] };
      projectFile.folders.push(created);
      return created;
    }

    function addProjectFileResource(projectFile, resource){
      const folder = ensureProjectFileFolder(projectFile, resource.folder);
      if (!folder) return;
      folder.index.push(resource);
    }

    function normalizeBaseName(name, fallback = "Point Set"){
      const normalized = trimOrEmpty(name).replace(/\.[^.]+$/u, "").trim();
      return normalized || fallback;
    }

    function normalizeExtension(name, fallback = ".txt"){
      const match = String(name || "").trim().match(/\.[a-z0-9]+$/i);
      return match ? match[0] : fallback;
    }

    function formatPointFileDate(date = new Date()){
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const year = String(date.getFullYear()).slice(-2);
      return `${month} ${day} ${year}`;
    }

    function hasDateInName(name){
      return /\b\d{1,2}[\s/_-]\d{1,2}[\s/_-]\d{2}\b/.test(String(name || ""));
    }

    function ensureDateInName(name, dateLabel){
      const base = trimOrEmpty(name);
      if (!base) return trimOrEmpty(dateLabel);
      if (hasDateInName(base)) return base;
      return `${base} ${dateLabel}`;
    }

    function ensureImportContextForPaste(promptIfMissing = false){
      if (currentImportContext) return currentImportContext;
      if (!promptIfMissing) return null;

      const entered = window.prompt("Name this pasted point set:", "Pasted Point Set");
      const baseName = normalizeBaseName(entered, "Pasted Point Set");
      currentImportContext = {
        sourceType: "paste",
        sourceLabel: baseName,
        baseName,
        extension: ".txt",
      };
      return currentImportContext;
    }

    function setImportContextFromFile(file){
      currentImportContext = {
        sourceType: "upload",
        sourceLabel: file?.name || "Uploaded File",
        baseName: normalizeBaseName(file?.name, "Uploaded Point Set"),
        extension: normalizeExtension(file?.name, ".txt"),
      };
      return currentImportContext;
    }

    function setImportContextFromRos(){
      currentImportContext = {
        sourceType: "recordquarry",
        sourceLabel: "Exported from RecordQuarry",
        baseName: "Exported from RecordQuarry",
        extension: ".csv",
      };
      return currentImportContext;
    }

    function buildImportFileName(context, importedAt = new Date()){
      const dated = ensureDateInName(context?.baseName || "Point Set", formatPointFileDate(importedAt));
      return `${dated}${context?.extension || ".txt"}`;
    }

    function buildEditedExportFileName(context, exportedAt = new Date()){
      const editedBase = `${context?.baseName || "Point Set"} Edited`;
      const dated = ensureDateInName(editedBase, formatPointFileDate(exportedAt));
      return `${dated}${context?.extension || ".txt"}`;
    }

    function persistPointSetToProjectFile({ kind, text, context, timestamp = new Date() }){
      const projectContext = getProjectContext();
      if (!projectContext.projectId || !text) return null;

      const projectFile = loadProjectFileSnapshot(projectContext.projectId);
      if (!projectFile) return null;

      const setId = `point-set-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      const storageKey = pointSetStorageKey(setId);
      const isoTimestamp = timestamp.toISOString();
      localStorage.setItem(storageKey, JSON.stringify({
        id: setId,
        kind,
        source: context?.sourceType || "unknown",
        fileName: kind === "import" ? buildImportFileName(context, timestamp) : buildEditedExportFileName(context, timestamp),
        savedAt: isoTimestamp,
        text,
      }));

      addProjectFileResource(projectFile, {
        id: setId,
        folder: "point-files",
        title: kind === "import" ? buildImportFileName(context, timestamp) : buildEditedExportFileName(context, timestamp),
        exportFormat: "csv",
        reference: {
          type: "local-storage",
          value: storageKey,
          resolverHint: "pointforge-point-set",
          metadata: {
            flow: kind,
            source: context?.sourceType || "unknown",
            sourceLabel: context?.sourceLabel || "",
            timestamp: isoTimestamp,
            charLength: String(text).length,
          },
        },
      });

      projectFile.generatedAt = isoTimestamp;
      saveProjectFileSnapshot(projectContext.projectId, projectFile);
      return storageKey;
    }

    function initMap(){
      map = L.map("map", { preferCanvas:true }).setView([44.2, -116.7], 7);

      // Street: OpenStreetMap
      streetLayer = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors"
      });

      // Satellite: Esri World Imagery (no key)
      satLayer = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {
          maxZoom: 19,
          attribution: "Tiles &copy; Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community"
        }
      );

      // Default basemap
      streetLayer.addTo(map);
      activeBase = "street";

      layer = L.layerGroup().addTo(map);
    }

    function setBasemap(mode){
      if (!map) return;
      if (mode === activeBase) return;

      if (mode === "street"){
        if (satLayer && map.hasLayer(satLayer)) map.removeLayer(satLayer);
        if (streetLayer && !map.hasLayer(streetLayer)) streetLayer.addTo(map);
        activeBase = "street";
      } else {
        if (streetLayer && map.hasLayer(streetLayer)) map.removeLayer(streetLayer);
        if (satLayer && !map.hasLayer(satLayer)) satLayer.addTo(map);
        activeBase = "satellite";
      }
    }

    function setStats(stats, plottedCount){
      st_lines.textContent = String(stats.totalLines ?? 0);
      st_parsed.textContent = String(stats.parsedCount ?? 0);
      st_g.textContent = String(stats.gCount ?? 0);
      st_ref.textContent = String(stats.refCount ?? 0);
      st_map.textContent = String(plottedCount ?? 0);

      const z = elZone.value;
      st_zone.textContent = z === "west" ? "W" : (z === "central" ? "C" : "E");
    }

    function refreshMap(recordsSorted){
      if (!map || !layer || !window.proj4) {
        elMapHint.innerHTML = `<span class="bad">Map libs not loaded (Leaflet/proj4). Output still works.</span>`;
        return 0;
      }
      layer.clearLayers();

      const zone = elZone.value || "west";
      const def = PROJ_DEFS_USFT[zone];

      const swapXY = true; // LOCKED default
      const showLabels = !!elShowLabels.checked;

      let plotted = 0;
      const bounds = [];

      for (const r of recordsSorted){
        if (!Number.isFinite(r.x) || !Number.isFinite(r.y)) continue;

        const X = swapXY ? r.y : r.x;
        const Y = swapXY ? r.x : r.y;

        try{
          const ll = proj4(def, "WGS84", [X, Y]);
          const lon = ll[0], lat = ll[1];
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
          if (!inIdaho(lat, lon)) continue;

          const ptNum = trimOrEmpty(r.fields[0]);
          const desc = trimOrEmpty(r.fields[r.fields.length-1]);

          const marker = L.circleMarker([lat, lon], {
            radius: 5,
            weight: 2,
            opacity: 0.95,
            fillOpacity: 0.32
          });

          const tip = `${ptNum}${desc ? " — " + desc : ""}\n(X=${X}, Y=${Y})\n(lat=${lat.toFixed(6)}, lon=${lon.toFixed(6)})`;
          marker.bindPopup(
            `<div style="font-family:${getComputedStyle(document.documentElement).getPropertyValue('--mono')}; font-size:12px; white-space:pre-wrap;">${escapeHtml(tip)}</div>`
          );
          if (showLabels) marker.bindTooltip(String(ptNum), { permanent: false, direction: "top", opacity: 0.9 });

          marker.addTo(layer);
          bounds.push([lat, lon]);
          plotted++;
        } catch(_e) {}
      }

      if (plotted > 0){
        const b = L.latLngBounds(bounds);
        map.fitBounds(b.pad(0.15));
        elMapHint.innerHTML = `<span class="ok">Plotted ${plotted} pts</span> — zone <span class="mono">${zone}</span>, <span class="mono">US-ft</span>, <span class="mono">swapXY</span>, basemap <span class="mono">${activeBase}</span>.`;
      } else {
        elMapHint.innerHTML = `<span class="warn">No points plotted.</span> If coords are not Idaho State Plane, they’ll be skipped on the map (output still transforms IDs). Try another zone.`;
      }

      return plotted;
    }


    function buildLineSmithImportPayload(recordsSorted){
      const rows = [["number","x","y","z","code","notes"]];
      const georeferencePoints = [];
      const zone = elZone.value || "west";
      const def = PROJ_DEFS_USFT[zone];
      const swapXY = true;

      for (const record of recordsSorted || []){
        if (!Array.isArray(record?.fields) || record.fields.length < 4) continue;

        const number = trimOrEmpty(record.fields[0]);
        if (!number) continue;

        const x = Number(record.fields[1]);
        const y = Number(record.fields[2]);
        const zRaw = trimOrEmpty(record.fields[3]);
        const z = Number.isFinite(Number(zRaw)) ? Number(zRaw) : 0;
        const code = trimOrEmpty(record.fields[4]);
        const notes = trimOrEmpty(record.fields[5]);

        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

        const handoffX = swapXY ? y : x;
        const handoffY = swapXY ? x : y;

        rows.push([number, handoffX, handoffY, z, code, notes]);

        try {
          const projectedX = handoffX;
          const projectedY = handoffY;
          const ll = proj4(def, "WGS84", [projectedX, projectedY]);
          const lon = ll[0];
          const lat = ll[1];
          if (Number.isFinite(lat) && Number.isFinite(lon)) {
            georeferencePoints.push({ x: handoffX, y: handoffY, lat, lng: lon });
          }
        } catch (_err) {
          // Ignore malformed coordinates and continue exporting CSV rows.
        }
      }

      return {
        source: "pointforge-transformer",
        exportedAt: new Date().toISOString(),
        csv: rows.map((row)=>row.map(csvEscape).join(",")).join("\n"),
        georeference: {
          type: "idaho-state-plane-usft",
          zone,
          swapXY,
          points: georeferencePoints
        }
      };
    }

    function processNow(){
      const input = elIn.value || "";
      if (!input.trim()){
        elOut.value = "";
        elLog.textContent = "";
        latestOutputText = "";
        latestTransformed = null;
        elRenumber.disabled = true;
        elDownload.disabled = true;
        elOpenLineSmith.disabled = true;
        if (layer) layer.clearLayers();
        elMapHint.textContent = "Load a file or paste points to plot.";
        setStats({ totalLines: 0, parsedCount: 0, gCount: 0, refCount: 0 }, 0);
        return;
      }

      ensureImportContextForPaste(false);

      const res = transformPoints(input);
      latestTransformed = res;
      latestOutputText = res.outputText;

      elOut.value = res.outputText;
      elLog.textContent = res.logText;
      refreshPointEditorTables();

      const plotted = refreshMap(res.recordsSorted);
      setStats(res.stats, plotted);

      elRenumber.disabled = !latestOutputText;
      elDownload.disabled = !latestOutputText;
      elOpenLineSmith.disabled = !latestTransformed?.recordsSorted?.length;
    }

    // File loader
    elFile.addEventListener("change", async (e)=>{
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const text = await f.text();
      const context = setImportContextFromFile(f);
      elIn.value = text;
      persistPointSetToProjectFile({ kind: "import", text, context, timestamp: new Date() });
      processNow();
      refreshPointEditorTables();
    });


    function renumberOutputFromStart(startValue){
      if (!latestOutputText) return;
      const parsedStart = Number.parseInt(startValue, 10);
      const renumberStart = Number.isInteger(parsedStart) && parsedStart > 0 ? parsedStart : 1;
      elRenumberStart.value = String(renumberStart);

      const lines = String(latestOutputText || "").split(/\r?\n/);
      let nextNumber = renumberStart;
      const renumberedLines = lines.map((line)=>{
        if (!line.trim()) return line;
        const fields = parseCSVLine(line);
        if (fields.length < 2) return line;
        fields[0] = String(nextNumber++);
        return fields.map(csvEscape).join(",");
      });

      latestOutputText = renumberedLines.join("\n");
      elOut.value = latestOutputText;

      const rows = parsePointRows(latestOutputText);
      if (latestTransformed?.recordsSorted?.length){
        const count = Math.min(rows.length, latestTransformed.recordsSorted.length);
        for (let i = 0; i < count; i++){
          latestTransformed.recordsSorted[i].fields[0] = rows[i].number;
        }
      }

      elLog.textContent = `${elLog.textContent}\nSEQUENTIAL RENUMBER\n  start: ${renumberStart}`.trim();
      refreshPointEditorTables();
      elOpenLineSmith.disabled = !latestTransformed?.recordsSorted?.length;
    }

    elRenumber.addEventListener("click", ()=>renumberOutputFromStart(elRenumberStart.value));

    // Manual process
    elProcess.addEventListener("click", ()=>processNow());

    // Auto-process (debounced)
    let t = null;
    elIn.addEventListener("input", ()=>{
      refreshPointEditorTables();
      if (!elAuto.checked) return;
      if (t) clearTimeout(t);
      t = setTimeout(()=>processNow(), 250);
    });


    elToggleInputView.addEventListener("click", ()=>setPointEditorView(!usePointEditorView));

    // Re-render map when settings change (does not alter output)
    elZone.addEventListener("change", ()=>{
      if (latestTransformed?.recordsSorted){
        const plotted = refreshMap(latestTransformed.recordsSorted);
        setStats(latestTransformed.stats, plotted);
      } else {
        setStats({ totalLines: 0, parsedCount: 0, gCount: 0, refCount: 0 }, 0);
      }
    });
    elShowLabels.addEventListener("change", ()=>{
      if (latestTransformed?.recordsSorted){
        const plotted = refreshMap(latestTransformed.recordsSorted);
        setStats(latestTransformed.stats, plotted);
      }
    });

    // Basemap switch
    elBasemap.addEventListener("change", ()=>{
      setBasemap(elBasemap.value);
      // no need to re-plot markers; base layer change only
      if (latestTransformed?.recordsSorted){
        const plotted = refreshMap(latestTransformed.recordsSorted);
        setStats(latestTransformed.stats, plotted);
      }
    });

    // Download output
    elDownload.addEventListener("click", ()=>{
      if (!latestOutputText) return;
      const context = ensureImportContextForPaste(true);
      persistPointSetToProjectFile({ kind: "export", text: latestOutputText, context, timestamp: new Date() });

      const blob = new Blob([latestOutputText], {type:"text/plain;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = buildEditedExportFileName(context, new Date());
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1500);
    });


    elOpenLineSmith.addEventListener("click", ()=>{
      const recordsSorted = latestTransformed?.recordsSorted;
      if (!recordsSorted?.length) return;

      const payload = buildLineSmithImportPayload(recordsSorted);
      localStorage.setItem(SURVEY_SKETCH_IMPORT_STORAGE_KEY, JSON.stringify(payload));
      openLinkedApp("/VIEWPORT.HTML?source=pointforge");
    });




    function openLinkedApp(path){
      try {
        if (window.parent && window.parent !== window){
          window.parent.postMessage({
            type: "survey-cad:navigate-app",
            path,
          }, window.location.origin);
          return;
        }
      } catch (_error){
        // If parent access is blocked, fallback to same-tab navigation.
      }
      window.location.assign(path);
    }

    function tryImportRosPayload(){
      const params = new URLSearchParams(window.location.search);
      if (params.get("source") !== "ros") return false;

      const raw = localStorage.getItem(ROS_POINTFORGE_IMPORT_STORAGE_KEY);
      if (!raw){
        elMapHint.innerHTML = `<span class="warn">ROS launch detected, but no import payload was found in local storage.</span>`;
        return false;
      }

      try {
        const payload = JSON.parse(raw);
        if (!payload?.csv || !String(payload.csv).trim()){
          elMapHint.innerHTML = `<span class="warn">ROS payload was invalid (missing CSV content).</span>`;
          localStorage.removeItem(ROS_POINTFORGE_IMPORT_STORAGE_KEY);
          return false;
        }

        elIn.value = String(payload.csv);
        const context = setImportContextFromRos();
        persistPointSetToProjectFile({ kind: "import", text: String(payload.csv), context, timestamp: new Date() });
        processNow();
        localStorage.removeItem(ROS_POINTFORGE_IMPORT_STORAGE_KEY);
        return true;
      } catch (_error){
        elMapHint.innerHTML = `<span class="warn">ROS payload could not be parsed.</span>`;
        localStorage.removeItem(ROS_POINTFORGE_IMPORT_STORAGE_KEY);
        return false;
      }
    }

    function tryImportProjectBrowserPayload(){
      const params = new URLSearchParams(window.location.search);
      if (params.get("source") !== "project-browser") return false;

      const raw = localStorage.getItem(PROJECT_BROWSER_POINTFORGE_IMPORT_STORAGE_KEY);
      if (!raw) return false;

      try {
        const payload = JSON.parse(raw);
        if (!payload?.csv || !String(payload.csv).trim()){
          localStorage.removeItem(PROJECT_BROWSER_POINTFORGE_IMPORT_STORAGE_KEY);
          return false;
        }
        const title = normalizeBaseName(payload.title, "Project Browser Point File");
        currentImportContext = {
          sourceType: "project-browser",
          sourceLabel: title,
          baseName: title,
          extension: ".csv",
        };
        elIn.value = String(payload.csv);
        persistPointSetToProjectFile({ kind: "import", text: String(payload.csv), context: currentImportContext, timestamp: new Date() });
        processNow();
        refreshPointEditorTables();
        localStorage.removeItem(PROJECT_BROWSER_POINTFORGE_IMPORT_STORAGE_KEY);
        return true;
      } catch {
        localStorage.removeItem(PROJECT_BROWSER_POINTFORGE_IMPORT_STORAGE_KEY);
        return false;
      }
    }

    // Init: blank textarea (no sample data), locked defaults already set in HTML
    initMap();
    elIn.value = "";
    setPointEditorView(false);
    setBasemap("street");
    setStats({ totalLines: 0, parsedCount: 0, gCount: 0, refCount: 0 }, 0);
    elMapHint.textContent = "Load a file or paste points to plot. Basemap toggle: Street / Satellite.";
    elIn.addEventListener("blur", ()=>{
      if (!elIn.value.trim() || currentImportContext) return;
      ensureImportContextForPaste(true);
      if (currentImportContext){
        persistPointSetToProjectFile({ kind: "import", text: elIn.value, context: currentImportContext, timestamp: new Date() });
      }
    });
    tryImportRosPayload();
    tryImportProjectBrowserPayload();
  </script>
</body>
</html>
