<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EvidenceDesk</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b1220;
      --panel: #172033;
      --panel-alt: #1e293b;
      --border: rgba(148, 163, 184, 0.25);
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #38bdf8;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #1e293b 0%, var(--bg) 60%);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      min-height: 100vh;
      padding: 1rem;
      box-sizing: border-box;
    }

    .app-shell {
      width: 100%;
      box-sizing: border-box;
      background: rgba(15, 23, 42, 0.72);
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow: hidden;
    }

    header {
      padding: 0.95rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.9);
    }

    h1 {
      margin: 0;
      font-size: 1.05rem;
    }

    .subtitle {
      margin: 0.3rem 0 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .content {
      padding: 1rem;
      display: grid;
      gap: 0.75rem;
    }

    .tree-root,
    .folder-row,
    .file-row {
      display: flex;
      align-items: center;
      gap: 0.55rem;
      border-radius: 8px;
      padding: 0.42rem 0.55rem;
    }

    .upload-panel {
      margin-left: 1.65rem;
      border: 1px dashed rgba(56, 189, 248, 0.45);
      border-radius: 10px;
      padding: 0.75rem;
      background: rgba(15, 23, 42, 0.5);
      display: grid;
      gap: 0.55rem;
    }

    .upload-panel.drag-active {
      border-color: #7dd3fc;
      background: rgba(14, 116, 144, 0.2);
    }

    .upload-actions {
      display: flex;
      gap: 0.55rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .upload-actions input[type="file"] {
      display: none;
    }

    .upload-status {
      font-size: 0.82rem;
      color: var(--muted);
      min-height: 1.1rem;
    }

    .upload-progress {
      width: 100%;
      height: 0.4rem;
      accent-color: #38bdf8;
    }

    .upload-progress[hidden] {
      display: none;
    }

    .folder-upload-feedback {
      margin-left: 1.65rem;
      padding: 0 0.75rem;
      display: grid;
      gap: 0.3rem;
    }

    .tree-root,
    .folder-row {
      background: var(--panel);
      border: 1px solid var(--border);
    }

    .folder-row {
      margin-top: 0.45rem;
      background: var(--panel-alt);
      justify-content: space-between;
    }

    .folder-title {
      display: flex;
      align-items: center;
      gap: 0.55rem;
      min-width: 0;
    }

    .file-row {
      margin-left: 1.65rem;
      color: var(--muted);
      font-size: 0.86rem;
      justify-content: space-between;
      gap: 0.8rem;
      flex-wrap: wrap;
    }

    .file-row.pointforge-openable {
      cursor: pointer;
      border: 1px solid transparent;
      transition: border-color 100ms ease, background-color 100ms ease;
    }

    .file-row.pointforge-openable:hover,
    .file-row.pointforge-openable:focus-visible {
      border-color: rgba(56, 189, 248, 0.45);
      background: rgba(30, 41, 59, 0.72);
      color: var(--text);
      outline: none;
    }

    .file-row.file-draggable {
      cursor: grab;
    }

    .file-row.file-draggable.file-dragging {
      opacity: 0.45;
      cursor: grabbing;
    }

    .folder-row.folder-drop-target {
      border-color: rgba(56, 189, 248, 0.6);
      box-shadow: inset 0 0 0 1px rgba(56, 189, 248, 0.35);
    }

    .file-list-container.file-list-drop-target {
      border-radius: 8px;
      background: rgba(56, 189, 248, 0.06);
      outline: 1px dashed rgba(56, 189, 248, 0.45);
      outline-offset: 2px;
    }

    .folder-row.folder-upload-drop-target {
      border-color: rgba(74, 222, 128, 0.6);
      box-shadow: inset 0 0 0 1px rgba(74, 222, 128, 0.35);
    }

    .file-list-container.file-list-upload-drop-target {
      border-radius: 8px;
      background: rgba(74, 222, 128, 0.06);
      outline: 1px dashed rgba(74, 222, 128, 0.45);
      outline-offset: 2px;
    }

    .file-meta {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      min-width: 0;
      flex: 1 1 auto;
    }

    .ros-number-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      margin-left: 0.45rem;
      padding: 0.12rem 0.45rem;
      border-radius: 999px;
      border: 1px solid rgba(125, 211, 252, 0.55);
      color: #bae6fd;
      background: rgba(8, 47, 73, 0.7);
      font-size: 0.72rem;
      white-space: nowrap;
    }

    .point-file-preview-thumb {
      width: 86px;
      height: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      object-fit: cover;
      background: rgba(2, 6, 23, 0.7);
      flex: none;
    }

    .drawing-preview-thumb {
      width: 86px;
      height: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      object-fit: cover;
      background: rgba(2, 6, 23, 0.7);
      flex: none;
    }

    .pdf-preview-thumb {
      width: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.22);
      flex: none;
      object-fit: cover;
      background: #ffffff;
      cursor: zoom-in;
    }

    .cpf-hover-preview-tooltip {
      position: fixed;
      z-index: 1400;
      padding: 0.5rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(2, 6, 23, 0.95);
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.6);
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 120ms ease;
    }

    .cpf-hover-preview-tooltip.visible {
      opacity: 1;
      visibility: visible;
    }

    .cpf-hover-preview-image {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 6px;
      background: #ffffff;
    }

    .image-preview-thumb {
      width: 86px;
      height: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      pointer-events: none;
      flex: none;
      object-fit: cover;
      background: rgba(2, 6, 23, 0.7);
    }

    .pdf-preview-placeholder {
      width: 86px;
      height: 50px;
      border-radius: 6px;
      border: 1px dashed rgba(148, 163, 184, 0.45);
      background: linear-gradient(145deg, #f8fafc 0%, #e2e8f0 100%);
      color: #475569;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.58rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      flex: none;
    }

    .pdf-preview-placeholder.pdf-preview-failed {
      border-style: solid;
      border-color: rgba(248, 113, 113, 0.5);
      background: linear-gradient(145deg, rgba(127, 29, 29, 0.45) 0%, rgba(69, 10, 10, 0.6) 100%);
      color: #fecaca;
    }

    .file-name {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.2rem;
      min-width: 0;
    }

    .file-name-primary {
      display: flex;
      align-items: baseline;
      gap: 0.3rem;
      min-width: 0;
    }

    .association-list {
      margin: 0.1rem 0 0 1.25rem;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 0.1rem;
      font-size: 0.76rem;
      color: #cbd5e1;
    }

    .association-list-item {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .file-preview-slot {
      display: inline-flex;
      align-items: center;
      flex: none;
    }

    .file-drag-ghost {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px;
      background: #0f172a;
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 10px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.55);
    }

    .file-drag-ghost img {
      display: block;
      width: 86px;
      height: 86px;
      border-radius: 6px;
      object-fit: cover;
    }

    .file-name-configured {
      color: #f8fafc;
      font-weight: 600;
      min-width: 0;
      flex: 1 1 auto;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-actions {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 0.4rem;
      margin-left: auto;
      flex-wrap: wrap;
    }


    .point-file-version-details {
      width: 100%;
      margin-top: 0.35rem;
      margin-left: 2.05rem;
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 8px;
      background: rgba(15, 23, 42, 0.45);
      color: #cbd5e1;
      font-size: 0.76rem;
    }

    .point-file-version-summary {
      cursor: pointer;
      padding: 0.35rem 0.55rem;
      user-select: none;
      color: #e2e8f0;
      font-weight: 600;
    }

    .point-file-version-summary:hover {
      color: #f8fafc;
    }

    .point-file-version-list {
      margin: 0;
      padding: 0 0.55rem 0.55rem 1.1rem;
      list-style: decimal;
      display: grid;
      gap: 0.28rem;
    }

    .point-file-version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.45rem;
      flex-wrap: wrap;
    }

    .point-file-version-label {
      color: #cbd5e1;
    }

    .point-file-version-open {
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.85);
      color: #e2e8f0;
      border-radius: 6px;
      padding: 0.15rem 0.45rem;
      font-size: 0.72rem;
      cursor: pointer;
    }

    .launch-btn {
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.8);
      color: var(--text);
      border-radius: 8px;
      padding: 0.25rem 0.55rem;
      font-size: 0.78rem;
      cursor: pointer;
      flex: none;
    }

    .launch-btn:hover {
      border-color: rgba(56, 189, 248, 0.5);
      color: #bae6fd;
    }

    .launch-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .icon {
      width: 1.2rem;
      text-align: center;
      flex: none;
    }

    .muted {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .empty {
      margin-left: 1.65rem;
      color: var(--muted);
      font-style: italic;
      font-size: 0.86rem;
    }
    .empty.err {
      color: #fecaca;
    }

    .corner-group {
      margin-top: 0.6rem;
    }
    .corner-group:first-child {
      margin-top: 0;
    }
    .corner-group-label {
      margin-left: 1.65rem;
      margin-bottom: 0.25rem;
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--accent);
      letter-spacing: 0.02em;
    }

    .error {
      border: 1px solid rgba(239, 68, 68, 0.4);
      border-radius: 10px;
      color: #fecaca;
      background: rgba(127, 29, 29, 0.24);
      padding: 0.75rem;
    }

    .add-folder-panel {
      display: flex;
      gap: 0.45rem;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 0.75rem;
      padding: 0.65rem 0.75rem;
      border: 1px dashed rgba(148, 163, 184, 0.3);
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.45);
    }

    .add-folder-input {
      flex: 1 1 160px;
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid var(--border);
      border-radius: 7px;
      color: var(--text);
      font-size: 0.83rem;
      padding: 0.28rem 0.55rem;
      min-width: 0;
    }

    .add-folder-input::placeholder {
      color: var(--muted);
    }

    .remove-folder-btn {
      border: 1px solid rgba(239, 68, 68, 0.45);
      background: rgba(127, 29, 29, 0.18);
      color: #fca5a5;
      border-radius: 7px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      flex: none;
    }

    .remove-folder-btn:hover {
      border-color: rgba(239, 68, 68, 0.75);
      background: rgba(127, 29, 29, 0.35);
    }

    .folder-children {
      margin-left: 1.25rem;
      padding-left: 0.75rem;
      border-left: 2px solid rgba(148, 163, 184, 0.12);
    }

    .add-subfolder-panel {
      margin-top: 0.35rem;
      padding: 0.45rem 0.65rem;
    }
  </style>
  <script type="module" src="/src/browser-localstorage-sync.js"></script>
</head>
<body>
  <div class="app-shell">
    <header>
      <h1>üìÅ SurveyFoundry EvidenceDesk</h1>
      <p class="subtitle" id="projectLabel">Loading active project‚Ä¶</p>
    </header>
    <section class="content" id="treeContainer"></section>
  </div>

  <script type="module">
    import * as projectBrowserState from './src/project-browser-state.js';
    import { renderLineworkThumbnailDataUrl, renderPointFileThumbnailDataUrl } from './src/point-thumbnail-client.js';

    const {
      loadStoredProjectFile,
      saveStoredProjectFile,
      appendResourceToFolder,
      removeResourceById,
      moveResourceById,
      renameResourceTitle,
      findCpfPointLinksAsync,
      groupCpfsByCorner,
      CPF_CORNER_GROUP_RADIUS_FEET,
      addCustomFolder,
      removeCustomFolder,
      getFolderDepth,
      getFolderChildren,
    } = projectBrowserState;
    const MAX_FOLDER_DEPTH = Number.isFinite(projectBrowserState.MAX_FOLDER_DEPTH)
      ? projectBrowserState.MAX_FOLDER_DEPTH
      : 5;

    const POINTFORGE_PROJECT_BROWSER_IMPORT_STORAGE_KEY = 'pointforgeProjectBrowserImport';
    const LINESMITH_PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY = 'lineSmithProjectBrowserDrawingImport';
    const PROJECT_DRAWING_STORAGE_PREFIX = 'surveyfoundryLineSmithDrawing';
    const ADA_CPF_PDF_BASE = 'https://gisprod.adacounty.id.gov/apps/acdscpf/CpfPdfs/';
    const projectLabel = document.getElementById('projectLabel');
    const treeContainer = document.getElementById('treeContainer');

    function openLinkedApp(path) {
      try {
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({
            type: 'survey-cad:navigate-app',
            path,
          }, window.location.origin);
          return;
        }
      } catch {
        // If parent access is blocked, fallback to same-tab navigation.
      }
      window.location.assign(path);
    }

    function buildProjectPointFileApiUrl(projectId = '', pointFileId = '') {
      if (!projectId) return '';
      const base = `/api/projects/${encodeURIComponent(projectId)}/point-files`;
      return pointFileId ? `${base}/${encodeURIComponent(pointFileId)}` : base;
    }

    function resolveActiveCrewUserLabel() {
      const crewMemberId = String(localStorage.getItem('surveyfoundryActiveCrewMemberId') || '').trim();
      if (!crewMemberId) return 'unknown-user';
      try {
        const profiles = JSON.parse(localStorage.getItem('surveyfoundryCrewProfiles') || '[]');
        const member = Array.isArray(profiles) ? profiles.find((entry) => entry?.id === crewMemberId) : null;
        const displayName = [member?.firstName, member?.lastName]
          .map((value) => String(value || '').trim())
          .filter(Boolean)
          .join(' ');
        return displayName || crewMemberId;
      } catch {
        return crewMemberId;
      }
    }

    function buildPointFileActorMetadata(app = 'project-browser') {
      const actorApp = String(app || 'project-browser').trim() || 'project-browser';
      const user = resolveActiveCrewUserLabel();
      return {
        headers: {
          'x-survey-app': actorApp,
          'x-survey-user': user,
        },
        changeContext: {
          app: actorApp,
          user,
        },
      };
    }

    function buildProjectDrawingApiUrl(projectId = '', drawingId = '') {
      if (!projectId) return '';
      const base = `/api/projects/${encodeURIComponent(projectId)}/drawings`;
      return drawingId ? `${base}/${encodeURIComponent(drawingId)}` : base;
    }

    function buildProjectCpfApiUrl(projectId = '', cpfId = '') {
      if (!projectId) return '';
      const base = `/api/projects/${encodeURIComponent(projectId)}/cpfs`;
      return cpfId ? `${base}/${encodeURIComponent(cpfId)}` : base;
    }

    function mapApiCpfToResource(cpf = {}) {
      const instrument = String(cpf.instrument || '').trim();
      const cpfId = String(cpf.cpfId || '').trim();
      const title = String(cpf.title || `CP&F ${instrument}`).trim();
      return {
        id: cpfId,
        folder: 'cpfs',
        title,
        exportFormat: 'pdf',
        reference: {
          type: 'instrument-number',
          value: instrument,
          resolverHint: 'lookup-cpf-pdf',
          metadata: { instrument, cpfId, source: cpf.source || '', aliquots: cpf.aliquots || [] },
        },
      };
    }

    async function syncProjectCpfsFromApi(projectContext = {}) {
      if (!projectContext?.activeProjectId || !projectContext?.projectFile) return;
      const response = await fetch(buildProjectCpfApiUrl(projectContext.activeProjectId));
      if (!response.ok) throw new Error(`Unable to list project CP&Fs (${response.status}).`);
      const payload = await response.json();
      const list = Array.isArray(payload?.cpfs) ? payload.cpfs : [];

      const folder = projectContext.projectFile?.folders?.find((entry) => entry.key === 'cpfs');
      if (!folder) return;
      folder.index = list.map((entry) => mapApiCpfToResource(entry));
      saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
    }

    function buildProjectDrawingStorageKey(projectId = '', drawingId = '') {
      if (!projectId || !drawingId) return '';
      return `${PROJECT_DRAWING_STORAGE_PREFIX}:${projectId}:${drawingId}`;
    }

    function mapApiPointFileToResource(projectId, pointFile = {}) {
      const pointFileId = String(pointFile.pointFileId || '').trim();
      const pointFileName = String(pointFile.pointFileName || pointFileId || 'Point File').trim();
      return {
        id: pointFileId,
        folder: 'point-files',
        title: pointFileName,
        exportFormat: pointFile.exportFormat || 'csv',
        reference: {
          type: 'project-point-file',
          value: pointFileId,
          resolverHint: 'project-point-file-api',
          metadata: {
            projectId,
            pointFileId,
            source: pointFile.source || '',
            sourceLabel: pointFile.sourceLabel || '',
          },
        },
      };
    }

    async function syncProjectPointFilesFromApi(projectContext = {}) {
      if (!projectContext?.activeProjectId || !projectContext?.projectFile) return;
      const response = await fetch(buildProjectPointFileApiUrl(projectContext.activeProjectId));
      if (!response.ok) throw new Error(`Unable to list project point files (${response.status}).`);
      const payload = await response.json();
      const list = Array.isArray(payload?.pointFiles) ? payload.pointFiles : [];

      const folder = projectContext.projectFile?.folders?.find((entry) => entry.key === 'point-files');
      if (!folder) return;
      folder.index = list.map((entry) => mapApiPointFileToResource(projectContext.activeProjectId, entry));
      saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
    }

    function mapApiDrawingToResource(projectId, drawing = {}) {
      const drawingId = String(drawing.drawingId || '').trim();
      const drawingName = String(drawing.drawingName || drawingId || 'Drawing').trim();
      return {
        id: `linesmith-${drawingId}`,
        folder: 'drawings',
        title: drawingName,
        exportFormat: 'json',
        reference: {
          type: 'project-drawing',
          value: drawingId,
          resolverHint: 'project-drawing-api',
          metadata: {
            projectId,
            drawingId,
            drawingName,
            versionCount: Number(drawing.versionCount) || 0,
            latestVersionId: drawing.latestVersionId || null,
            latestMapGeoreference: drawing.latestMapGeoreference || null,
            linkedPointFileProjectId: drawing.linkedPointFileProjectId || null,
            linkedPointFileId: drawing.linkedPointFileId || null,
            linkedPointFileName: drawing.linkedPointFileName || null,
            updatedAt: drawing.updatedAt || null,
            storageKey: buildProjectDrawingStorageKey(projectId, drawingId),
          },
        },
      };
    }

    function normalizeAssociationId(value = '') {
      return String(value || '')
        .trim()
        .toLowerCase()
        .replace(/\.([a-z0-9]+)$/i, '')
        .replace(/^linesmith-/, '')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
    }

    function buildDrawingAssociationIndex(projectFile = {}) {
      const folders = Array.isArray(projectFile?.folders) ? projectFile.folders : [];
      const pointFolder = folders.find((folder) => folder?.key === 'point-files');
      const drawingFolder = folders.find((folder) => folder?.key === 'drawings');

      const pointFileNameById = new Map();
      for (const pointFile of pointFolder?.index || []) {
        const pointFileId = normalizeAssociationId(pointFile?.reference?.metadata?.pointFileId || pointFile?.reference?.value || pointFile?.id || '');
        if (!pointFileId) continue;
        pointFileNameById.set(pointFileId, pointFile?.title || pointFile?.id || 'Point File');
      }

      const drawingsByPointFileId = new Map();
      const pointFileByDrawingId = new Map();
      for (const drawing of drawingFolder?.index || []) {
        const drawingId = normalizeAssociationId(drawing?.reference?.metadata?.drawingId || drawing?.reference?.value || drawing?.id || '');
        const linkedPointFileId = normalizeAssociationId(drawing?.reference?.metadata?.linkedPointFileId || '');
        if (!drawingId || !linkedPointFileId) continue;
        const drawingTitle = drawing?.title || drawing?.id || 'Drawing';
        const linkedPointFileName = drawing?.reference?.metadata?.linkedPointFileName
          || pointFileNameById.get(linkedPointFileId)
          || linkedPointFileId;
        const associatedDrawings = drawingsByPointFileId.get(linkedPointFileId) || [];
        associatedDrawings.push(drawingTitle);
        drawingsByPointFileId.set(linkedPointFileId, associatedDrawings);
        pointFileByDrawingId.set(drawingId, linkedPointFileName);
      }

      return {
        drawingsByPointFileId,
        pointFileByDrawingId,
      };
    }

    async function syncProjectDrawingsFromApi(projectContext = {}) {
      if (!projectContext?.activeProjectId || !projectContext?.projectFile) return;
      const response = await fetch(buildProjectDrawingApiUrl(projectContext.activeProjectId));
      if (!response.ok) throw new Error(`Unable to list project drawings (${response.status}).`);
      const payload = await response.json();
      const list = Array.isArray(payload?.drawings) ? payload.drawings : [];

      const folder = projectContext.projectFile?.folders?.find((entry) => entry.key === 'drawings');
      if (!folder) return;
      folder.index = list.map((entry) => mapApiDrawingToResource(projectContext.activeProjectId, entry));
      saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
    }

    async function cacheProjectDrawingRecord(resource) {
      const ref = resource?.reference;
      const projectId = ref?.metadata?.projectId || '';
      const drawingId = ref?.metadata?.drawingId || ref?.value || '';
      if (!projectId || !drawingId) return '';

      const storageKey = ref?.metadata?.storageKey || buildProjectDrawingStorageKey(projectId, drawingId);
      const response = await fetch(buildProjectDrawingApiUrl(projectId, drawingId));
      if (!response.ok) {
        throw new Error(`Unable to load drawing (${response.status}).`);
      }
      const payload = await response.json();
      const drawing = payload?.drawing;
      if (!drawing?.versions?.length) {
        throw new Error('Drawing payload was missing version history.');
      }
      localStorage.setItem(storageKey, JSON.stringify(drawing));
      return storageKey;
    }

    async function fetchProjectPointFileRecord(resource, { versionId = '' } = {}) {
      const ref = resource?.reference;
      const projectId = ref?.metadata?.projectId || resource?.projectId || '';
      const pointFileId = ref?.metadata?.pointFileId || ref?.value || resource?.id || '';
      if (!projectId || !pointFileId) return null;

      const endpoint = new URL(buildProjectPointFileApiUrl(projectId, pointFileId), window.location.origin);
      if (versionId) endpoint.searchParams.set('versionId', versionId);
      const response = await fetch(endpoint);
      if (!response.ok) return null;
      const payload = await response.json();
      return payload?.pointFile || null;
    }

    async function resolvePointFileText(resource, { versionId = '' } = {}) {
      const ref = resource?.reference;
      if (!ref?.value) return null;

      if (ref.type === 'local-storage') {
        const raw = localStorage.getItem(ref.value);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        const text = parsed?.text;
        return typeof text === 'string' ? text : null;
      }

      if (ref.type === 'server-upload') {
        const response = await fetch(ref.value);
        if (!response.ok) return null;
        return await response.text();
      }

      if (ref.type === 'project-point-file') {
        const record = await fetchProjectPointFileRecord(resource, { versionId });
        return String(record?.currentState?.text || '');
      }

      return null;
    }



    async function attachPointFilePreview(resource, entry) {
      if (!resource || !entry) return;
      const text = await resolvePointFileText(entry);
      if (!text || !text.trim()) return;
      const previewUrl = renderPointFileThumbnailDataUrl(text, { width: 86, height: 50 });
      if (!previewUrl) return;
      const thumb = document.createElement('img');
      thumb.className = 'point-file-preview-thumb';
      thumb.src = previewUrl;
      thumb.alt = `${entry?.title || entry?.id || 'Point file'} preview`;
      resource.querySelector('.file-preview-slot')?.replaceChildren(thumb);
    }

    async function resolveDrawingPoints(resource) {
      const ref = resource?.reference;
      if (!ref) return [];

      if (ref.type === 'local-storage') {
        const raw = localStorage.getItem(ref.value);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed?.currentState?.points) ? parsed.currentState.points : [];
      }

      if (ref.type === 'project-drawing') {
        const projectId = ref.metadata?.projectId || '';
        const drawingId = ref.metadata?.drawingId || ref.value || '';
        if (!projectId || !drawingId) return [];
        const response = await fetch(buildProjectDrawingApiUrl(projectId, drawingId));
        if (!response.ok) return [];
        const payload = await response.json();
        return Array.isArray(payload?.drawing?.currentState?.points) ? payload.drawing.currentState.points : [];
      }

      return [];
    }

    async function attachDrawingPreview(resource, entry) {
      if (!resource || !entry) return;
      const points = await resolveDrawingPoints(entry);
      if (!Array.isArray(points) || !points.length) return;
      const previewUrl = renderLineworkThumbnailDataUrl(points, { width: 86, height: 50 });
      if (!previewUrl) return;
      const thumb = document.createElement('img');
      thumb.className = 'drawing-preview-thumb';
      thumb.src = previewUrl;
      thumb.alt = `${entry?.title || entry?.id || 'Drawing'} preview`;
      resource.querySelector('.file-preview-slot')?.replaceChildren(thumb);
    }

    async function launchLineSmithFromDrawingResource(resource, projectContext = {}) {
      let storageKey = resource?.reference?.value;
      if (resource?.reference?.type === 'project-drawing') {
        try {
          storageKey = await cacheProjectDrawingRecord(resource);
        } catch (err) {
          renderError(`Selected drawing could not be opened. ${err.message}`);
          return;
        }
      }
      const drawingId = String(resource?.reference?.metadata?.drawingId || resource?.id || '').replace(/^linesmith-/, '').trim();
      if (!storageKey && !drawingId) {

        renderError(`Selected drawing could not be opened. Missing storage key for ${resource?.title || 'resource'}.`);
        return;
      }

      localStorage.setItem(LINESMITH_PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY, JSON.stringify({
        storageKey,
        drawingId,
        drawingName: resource.title || resource.id || 'Drawing',
      }));

      const destination = new URL('/VIEWPORT.HTML', window.location.origin);
      destination.searchParams.set('source', 'project-browser-drawing');
      if (projectContext.projectId) destination.searchParams.set('activeProjectId', projectContext.projectId);
      if (projectContext.projectName) destination.searchParams.set('activeProjectName', projectContext.projectName);
      openLinkedApp(`${destination.pathname}${destination.search}`);
    }

    async function launchPointForgeFromResource(resource, projectContext = {}) {
      const text = await resolvePointFileText(resource);
      if (!text || !text.trim()) {
        renderError(`Selected point file could not be opened. Unable to load text for ${resource?.title || 'resource'}.`);
        return;
      }

      localStorage.setItem(POINTFORGE_PROJECT_BROWSER_IMPORT_STORAGE_KEY, JSON.stringify({
        csv: text,
        title: resource.title || resource.id || 'Point File',
        pointFileId: resource?.reference?.metadata?.pointFileId || resource?.id || '',
      }));

      const destination = new URL('/POINT_TRANSFORMER.HTML', window.location.origin);
      destination.searchParams.set('source', 'project-browser');
      if (projectContext.projectId) destination.searchParams.set('projectId', projectContext.projectId);
      if (projectContext.projectName) destination.searchParams.set('projectName', projectContext.projectName);
      openLinkedApp(`${destination.pathname}${destination.search}`);
    }

    async function renameResourceFromEvidenceDesk(folder, entry, projectContext = {}) {
      const currentTitle = String(entry?.title || '').trim() || 'Untitled';
      const nextTitleRaw = window.prompt('Rename file', currentTitle);
      if (nextTitleRaw == null) return;

      const nextTitle = String(nextTitleRaw || '').trim();
      if (!nextTitle || nextTitle === currentTitle) return;

      const projectId = projectContext?.activeProjectId;
      if (!projectId) {
        renderError('Cannot rename resources without an active project.');
        return;
      }

      try {
        if (entry?.reference?.type === 'project-point-file') {
          const pointFileId = entry?.reference?.metadata?.pointFileId || entry?.reference?.value || entry?.id;
          const detailRes = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId));
          if (!detailRes.ok) throw new Error(`Unable to load point file (${detailRes.status}).`);
          const detail = await detailRes.json();
          const currentState = detail?.pointFile?.currentState;
          if (!currentState || typeof currentState !== 'object') {
            throw new Error('Point file state was missing.');
          }

          const actorMetadata = buildPointFileActorMetadata('project-browser');
          const renameRes = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId), {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json', ...actorMetadata.headers },
            body: JSON.stringify({
              pointFileName: nextTitle,
              pointFileState: currentState,
              source: 'project-browser',
              changeContext: actorMetadata.changeContext,
            }),
          });
          if (!renameRes.ok) throw new Error(`Unable to rename point file (${renameRes.status}).`);
          await syncProjectPointFilesFromApi(projectContext);
        } else if (entry?.reference?.type === 'project-drawing') {
          const drawingId = entry?.reference?.metadata?.drawingId || entry?.reference?.value || entry?.id;
          const detailRes = await fetch(buildProjectDrawingApiUrl(projectId, drawingId));
          if (!detailRes.ok) throw new Error(`Unable to load drawing (${detailRes.status}).`);
          const detail = await detailRes.json();
          const currentState = detail?.drawing?.currentState;
          if (!currentState || typeof currentState !== 'object') {
            throw new Error('Drawing state was missing.');
          }

          const renameRes = await fetch(buildProjectDrawingApiUrl(projectId, drawingId), {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              drawingName: nextTitle,
              drawingState: currentState,
            }),
          });
          if (!renameRes.ok) throw new Error(`Unable to rename drawing (${renameRes.status}).`);
          await syncProjectDrawingsFromApi(projectContext);
        } else {
          const renamed = renameResourceTitle(projectContext?.projectFile, folder?.key, entry?.id, nextTitle);
          if (!renamed) throw new Error('File rename could not be applied.');
        }

        saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
        projectContext.setUploadStatus(`Renamed ${currentTitle} to ${nextTitle}.`);
        renderTree(projectContext.projectFile, projectContext);
      } catch (err) {
        renderError(`Could not rename ${currentTitle}. ${err.message}`);
      }
    }

    async function deleteResourceFromEvidenceDesk(folder, entry, projectContext = {}) {
      const currentTitle = String(entry?.title || entry?.id || '').trim() || 'file';
      try {
        if (folder?.key === 'cpfs') {
          await deleteCpfResource(folder, entry, projectContext);
          return;
        }

        if (!window.confirm(`Remove "${currentTitle}" from the project?`)) return;

        const projectId = projectContext?.activeProjectId;
        if (!projectId) {
          renderError('Cannot delete resources without an active project.');
          return;
        }

        if (entry?.reference?.type === 'project-point-file') {
          const pointFileId = entry?.reference?.metadata?.pointFileId || entry?.reference?.value || entry?.id;
          if (!pointFileId) throw new Error('Point file id was missing.');
          const response = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId), { method: 'DELETE' });
          if (!response.ok) throw new Error(`Unable to delete point file (${response.status}).`);
          await syncProjectPointFilesFromApi(projectContext);
        } else if (entry?.reference?.type === 'project-drawing') {
          const drawingId = entry?.reference?.metadata?.drawingId || entry?.reference?.value || entry?.id;
          if (!drawingId) throw new Error('Drawing id was missing.');
          const response = await fetch(buildProjectDrawingApiUrl(projectId, drawingId), { method: 'DELETE' });
          if (!response.ok) throw new Error(`Unable to delete drawing (${response.status}).`);
          await syncProjectDrawingsFromApi(projectContext);
        } else if (entry?.reference?.type === 'server-upload') {
          await deleteServerUploadResource(projectContext, folder?.key, entry);
          const removed = removeResourceById(projectContext?.projectFile, folder?.key, entry?.id);
          if (!removed) throw new Error('File delete could not be applied.');
        } else {
          const removed = removeResourceById(projectContext?.projectFile, folder?.key, entry?.id);
          if (!removed) throw new Error('File delete could not be applied.');
        }

        saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
        projectContext.setUploadStatus(`Removed ${currentTitle}.`);
        renderTree(projectContext.projectFile, projectContext);
      } catch (err) {
        renderError(`Could not remove ${currentTitle}. ${err.message}`);
      }
    }

    function getCpfPdfUrl(resource) {
      const reference = resource?.reference || {};
      const metadata = reference.metadata || {};
      const referenceType = String(reference.type || '').trim();
      const referenceValue = String(reference.value || '').trim();
      const metadataPdf = typeof metadata.pdfUrl === 'string' ? metadata.pdfUrl.trim() : '';
      const instrument = String(metadata.instrument || referenceValue).trim();

      if (referenceType === 'server-upload' && referenceValue) {
        return new URL(referenceValue, window.location.origin).toString();
      }

      if (metadataPdf.startsWith('/')) {
        return new URL(metadataPdf, window.location.origin).toString();
      }

      let remoteUrl = '';
      if (/^https?:\/\//i.test(metadataPdf)) {
        remoteUrl = metadataPdf;
      } else if (instrument) {
        remoteUrl = `${ADA_CPF_PDF_BASE}${encodeURIComponent(instrument)}.pdf`;
      }

      if (!remoteUrl) return '';

      const proxyUrl = new URL('/api/ros-pdf', window.location.origin);
      proxyUrl.searchParams.set('url', remoteUrl);
      return proxyUrl.toString();
    }

    function buildPrintPreviewPdfUrl(pdfUrl) {
      if (!pdfUrl) return '';
      // PDF Open Parameters hide most built-in viewer chrome and ask for fit-to-page scaling.
      // Browsers may ignore unsupported flags, but this prevents sidebar/tool UI in engines that support them.
      return `${pdfUrl}#toolbar=0&navpanes=0&scrollbar=0&view=Fit&zoom=page-fit`;
    }

    function openCpfPdfFromResource(resource) {
      const pdfUrl = getCpfPdfUrl(resource);
      if (!pdfUrl) {
        renderError(`Selected CP&F file could not be opened. Missing instrument number for ${resource?.title || 'resource'}.`);
        return;
      }
      openPdfInNewWindow(pdfUrl);
    }

    function openPdfInNewWindow(pdfUrl) {
      if (!pdfUrl) return;
      const popup = window.open('', '_blank', 'popup=yes,width=1200,height=900');
      if (!popup) {
        renderError('Your browser blocked the PDF window. Please allow pop-ups and try again.');
        return;
      }
      popup.opener = null;
      popup.location.replace(pdfUrl);
    }

    function canMoveResourceBetweenFolders(entry, sourceFolderKey = '', targetFolderKey = '') {
      if (!entry || !sourceFolderKey || !targetFolderKey || sourceFolderKey === targetFolderKey) return false;
      const referenceType = String(entry?.reference?.type || '').trim();
      if (referenceType === 'project-point-file' || referenceType === 'project-drawing') return false;
      return true;
    }

    function resolveServerUploadLocation(entry, fallbackFolderKey = '') {
      const metadata = entry?.reference?.metadata || {};
      let folderKey = String(fallbackFolderKey || '').trim();
      let storedName = String(metadata?.storedName || '').trim();
      const referenceValue = String(entry?.reference?.value || '').trim();
      if (!referenceValue) return { folderKey, storedName };

      let parsed = null;
      try {
        parsed = new URL(referenceValue, window.location.origin);
      } catch {
        return { folderKey, storedName };
      }

      const queryFolderKey = String(parsed.searchParams.get('folderKey') || '').trim();
      const queryFileName = String(parsed.searchParams.get('fileName') || '').trim();
      if (queryFolderKey) folderKey = queryFolderKey;
      if (queryFileName) storedName = queryFileName;
      return { folderKey, storedName };
    }

    async function moveServerUploadResource(projectContext, sourceFolderKey, targetFolderKey, entry) {
      const projectId = String(projectContext?.activeProjectId || '').trim();
      const initialLocation = resolveServerUploadLocation(entry, sourceFolderKey);
      if (!projectId || !initialLocation?.storedName) throw new Error('Missing project upload metadata for move operation.');

      const sendMoveRequest = async (folderKey, fileName) => {
        const moveUrl = new URL('/api/project-files/file', window.location.origin);
        moveUrl.searchParams.set('projectId', projectId);
        moveUrl.searchParams.set('folderKey', folderKey);
        moveUrl.searchParams.set('fileName', fileName);

        const response = await fetch(moveUrl.toString(), {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ targetFolderKey }),
        });
        const payload = await response.json().catch(() => ({}));
        return { response, payload };
      };

      const firstAttempt = await sendMoveRequest(initialLocation.folderKey || sourceFolderKey, initialLocation.storedName);
      if (firstAttempt.response.ok) return firstAttempt.payload?.resource || null;

      const fallbackLocation = resolveServerUploadLocation(entry, '');
      const shouldRetryWithFallback = firstAttempt.response.status === 404
        && fallbackLocation.folderKey
        && fallbackLocation.storedName
        && (fallbackLocation.folderKey !== (initialLocation.folderKey || sourceFolderKey)
          || fallbackLocation.storedName !== initialLocation.storedName);
      if (shouldRetryWithFallback) {
        const retryAttempt = await sendMoveRequest(fallbackLocation.folderKey, fallbackLocation.storedName);
        if (retryAttempt.response.ok) return retryAttempt.payload?.resource || null;
        throw new Error(retryAttempt.payload?.error || `Unable to move file (${retryAttempt.response.status}).`);
      }

      throw new Error(firstAttempt.payload?.error || `Unable to move file (${firstAttempt.response.status}).`);
    }

    async function deleteServerUploadResource(projectContext, sourceFolderKey, entry) {
      const projectId = String(projectContext?.activeProjectId || '').trim();
      const initialLocation = resolveServerUploadLocation(entry, sourceFolderKey);
      if (!projectId || !initialLocation?.storedName) throw new Error('Missing project upload metadata for delete operation.');

      const sendDeleteRequest = async (folderKey, fileName) => {
        const deleteUrl = new URL('/api/project-files/file', window.location.origin);
        deleteUrl.searchParams.set('projectId', projectId);
        deleteUrl.searchParams.set('folderKey', folderKey);
        deleteUrl.searchParams.set('fileName', fileName);

        const response = await fetch(deleteUrl.toString(), { method: 'DELETE' });
        const payload = await response.json().catch(() => ({}));
        return { response, payload };
      };

      const firstAttempt = await sendDeleteRequest(initialLocation.folderKey || sourceFolderKey, initialLocation.storedName);
      if (firstAttempt.response.ok) return true;

      const fallbackLocation = resolveServerUploadLocation(entry, '');
      const shouldRetryWithFallback = firstAttempt.response.status === 404
        && fallbackLocation.folderKey
        && fallbackLocation.storedName
        && (fallbackLocation.folderKey !== (initialLocation.folderKey || sourceFolderKey)
          || fallbackLocation.storedName !== initialLocation.storedName);
      if (shouldRetryWithFallback) {
        const retryAttempt = await sendDeleteRequest(fallbackLocation.folderKey, fallbackLocation.storedName);
        if (retryAttempt.response.ok) return true;
        throw new Error(retryAttempt.payload?.error || `Unable to delete file (${retryAttempt.response.status}).`);
      }

      throw new Error(firstAttempt.payload?.error || `Unable to delete file (${firstAttempt.response.status}).`);
    }

    let _dragScrollY = 0;
    let _dragScrollActive = false;
    let _dragScrollRaf = null;

    function onDragOverForScroll(event) {
      _dragScrollY = event.clientY;
    }

    function tickDragScroll() {
      if (!_dragScrollActive) return;
      const edgeZone = 100;
      const maxSpeed = 14;
      const vh = window.innerHeight;
      if (_dragScrollY < edgeZone) {
        window.scrollBy(0, -Math.round(maxSpeed * (1 - _dragScrollY / edgeZone)));
      } else if (_dragScrollY > vh - edgeZone) {
        window.scrollBy(0, Math.round(maxSpeed * (1 - (vh - _dragScrollY) / edgeZone)));
      }
      _dragScrollRaf = requestAnimationFrame(tickDragScroll);
    }

    function startDragAutoScroll() {
      _dragScrollY = window.innerHeight / 2;
      _dragScrollActive = true;
      document.addEventListener('dragover', onDragOverForScroll);
      _dragScrollRaf = requestAnimationFrame(tickDragScroll);
    }

    function stopDragAutoScroll() {
      _dragScrollActive = false;
      document.removeEventListener('dragover', onDragOverForScroll);
      if (_dragScrollRaf !== null) {
        cancelAnimationFrame(_dragScrollRaf);
        _dragScrollRaf = null;
      }
    }

    function buildFileDragImage(resource) {
      const thumbImg = resource.querySelector('.file-preview-slot img');
      if (!thumbImg || !thumbImg.src) return null;
      const ghost = document.createElement('div');
      ghost.className = 'file-drag-ghost';
      ghost.style.cssText = 'position:fixed;left:-9999px;top:-9999px;';
      const img = document.createElement('img');
      img.src = thumbImg.src;
      img.width = 86;
      img.height = 86;
      ghost.appendChild(img);
      document.body.appendChild(ghost);
      return ghost;
    }

    async function moveResourceFromEvidenceDesk(sourceFolder, targetFolder, entry, projectContext = {}) {
      const sourceFolderKey = String(sourceFolder?.key || '').trim();
      const targetFolderKey = String(targetFolder?.key || '').trim();
      if (!canMoveResourceBetweenFolders(entry, sourceFolderKey, targetFolderKey)) {
        projectContext.setUploadStatus('Only uploaded/local project-file entries can be moved between folders.');
        return false;
      }

      let moved = false;
      try {
        if (entry?.reference?.type === 'server-upload') {
          const movedResource = await moveServerUploadResource(projectContext, sourceFolderKey, targetFolderKey, entry);
          if (!movedResource) throw new Error('Move response was missing resource data.');
          removeResourceById(projectContext?.projectFile, sourceFolderKey, entry?.id);
          moved = appendResourceToFolder(projectContext?.projectFile, targetFolderKey, movedResource);
        } else {
          moved = moveResourceById(projectContext?.projectFile, sourceFolderKey, targetFolderKey, entry?.id);
        }

        if (!moved) {
          projectContext.setUploadStatus('Unable to move this file.');
          return false;
        }

        saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
        projectContext.setUploadStatus(`Moved ${entry?.title || entry?.id || 'file'} to ${targetFolder?.label || targetFolderKey}.`);
        renderTree(projectContext.projectFile, projectContext);
        return true;
      } catch (error) {
        projectContext.setUploadStatus(`Move failed: ${error.message || 'Unable to move this file.'}`);
        renderTree(projectContext.projectFile, projectContext);
        return false;
      }
    }


    function getPdfPreviewUrl(folder, entry) {
      if (folder?.key === 'cpfs') {
        return getCpfPdfUrl(entry);
      }
      if (entry?.reference?.type === 'server-upload') {
        return String(entry.reference.value || '').trim();
      }
      return '';
    }

    function isImageResource(entry) {
      const format = String(entry?.exportFormat || '').toLowerCase();
      return ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'].includes(format);
    }

    function getMimeTypeFromFormat(format) {
      const mimeMap = {
        pdf: 'application/pdf',
        png: 'image/png',
        jpg: 'image/jpeg',
        jpeg: 'image/jpeg',
        gif: 'image/gif',
        webp: 'image/webp',
        bmp: 'image/bmp',
        svg: 'image/svg+xml',
        csv: 'text/csv',
        txt: 'text/plain',
        json: 'application/json',
      };
      return mimeMap[String(format).toLowerCase()] || 'application/octet-stream';
    }

    const CPH_TOOLTIP_MARGIN = 16;
    const CPH_GAP = 14;
    let cpfHoverPreviewTooltip = null;

    function ensureCpfHoverPreviewTooltip() {
      if (cpfHoverPreviewTooltip && document.body.contains(cpfHoverPreviewTooltip)) {
        return cpfHoverPreviewTooltip;
      }
      const tooltip = document.createElement('div');
      tooltip.className = 'cpf-hover-preview-tooltip';
      tooltip.setAttribute('aria-hidden', 'true');

      const image = document.createElement('img');
      image.className = 'cpf-hover-preview-image';
      image.alt = '';
      tooltip.appendChild(image);
      document.body.appendChild(tooltip);
      cpfHoverPreviewTooltip = tooltip;
      return tooltip;
    }

    function hideCpfHoverPreviewTooltip() {
      if (!cpfHoverPreviewTooltip) return;
      cpfHoverPreviewTooltip.classList.remove('visible');
      cpfHoverPreviewTooltip.style.width = '';
      cpfHoverPreviewTooltip.style.height = '';
      cpfHoverPreviewTooltip.style.left = '';
      cpfHoverPreviewTooltip.style.top = '';
    }

    function showCpfHoverPreviewTooltip(anchor, imageSrc, altText = 'CP&F preview', sourceDimensions = null) {
      if (!anchor || !imageSrc) return;

      const tooltip = ensureCpfHoverPreviewTooltip();
      const previewImage = tooltip.querySelector('.cpf-hover-preview-image');
      if (!previewImage) return;
      previewImage.src = imageSrc;
      previewImage.alt = altText;

      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const maxHeight = Math.max(220, Math.floor(viewportHeight * 0.9));
      const anchorRect = anchor.getBoundingClientRect();
      const imageNaturalWidth = Number(sourceDimensions?.width || previewImage.naturalWidth || anchor.naturalWidth || 0);
      const imageNaturalHeight = Number(sourceDimensions?.height || previewImage.naturalHeight || anchor.naturalHeight || 0);
      const safeImageHeight = imageNaturalHeight > 0 ? imageNaturalHeight : 1;
      const imageAspectRatio = imageNaturalWidth > 0 ? (imageNaturalWidth / safeImageHeight) : (8.5 / 11);
      const maxWidth = Math.max(180, viewportWidth - (CPH_TOOLTIP_MARGIN * 2));
      const maxPreviewWidth = Math.min(maxWidth, Math.floor(viewportWidth * 0.6));
      const previewHeight = Math.max(160, Math.min(maxHeight, Math.floor(maxPreviewWidth / imageAspectRatio)));
      const previewWidth = Math.max(160, Math.min(maxPreviewWidth, Math.floor(previewHeight * imageAspectRatio)));

      const availableRight = viewportWidth - anchorRect.right - CPH_GAP - CPH_TOOLTIP_MARGIN;
      const availableLeft = anchorRect.left - CPH_GAP - CPH_TOOLTIP_MARGIN;
      const shouldPlaceRight = availableRight >= previewWidth || availableRight >= availableLeft;
      const preferredLeft = shouldPlaceRight
        ? Math.round(anchorRect.right + CPH_GAP)
        : Math.round(anchorRect.left - CPH_GAP - previewWidth);
      const clampedLeft = Math.min(
        Math.max(CPH_TOOLTIP_MARGIN, preferredLeft),
        viewportWidth - previewWidth - CPH_TOOLTIP_MARGIN,
      );

      tooltip.style.width = `${Math.round(previewWidth)}px`;
      tooltip.style.height = `${Math.round(previewHeight)}px`;

      const centeredTop = anchorRect.top + (anchorRect.height / 2) - (previewHeight / 2);
      const maxTop = Math.max(CPH_TOOLTIP_MARGIN, viewportHeight - previewHeight - CPH_TOOLTIP_MARGIN);
      const clampedTop = Math.min(Math.max(CPH_TOOLTIP_MARGIN, centeredTop), maxTop);
      tooltip.style.left = `${Math.round(clampedLeft)}px`;
      tooltip.style.top = `${Math.round(clampedTop)}px`;
      tooltip.classList.add('visible');
    }

    function bindCpfHoverPreview(thumb, entry) {
      if (!thumb) return;
      thumb.addEventListener('mouseenter', () => {
        showCpfHoverPreviewTooltip(
          thumb,
          thumb.src,
          `${entry?.title || entry?.id || 'CP&F'} enlarged preview`,
          {
            width: thumb.naturalWidth,
            height: thumb.naturalHeight,
          },
        );
      });
      thumb.addEventListener('mouseleave', () => hideCpfHoverPreviewTooltip());
      thumb.addEventListener('focus', () => {
        showCpfHoverPreviewTooltip(
          thumb,
          thumb.src,
          `${entry?.title || entry?.id || 'CP&F'} enlarged preview`,
          {
            width: thumb.naturalWidth,
            height: thumb.naturalHeight,
          },
        );
      });
      thumb.addEventListener('blur', () => hideCpfHoverPreviewTooltip());
    }

    window.addEventListener('scroll', () => hideCpfHoverPreviewTooltip(), { passive: true });
    window.addEventListener('resize', () => hideCpfHoverPreviewTooltip());

    function attachImagePreview(resource, entry) {
      if (entry?.reference?.type !== 'server-upload') return;
      if (!isImageResource(entry)) return;

      const previewUrl = String(entry?.reference?.metadata?.thumbnailUrl || entry?.reference?.value || '').trim();
      if (!previewUrl) return;

      const slot = resource.querySelector('.file-preview-slot');
      if (!slot) return;

      const thumb = document.createElement('img');
      thumb.className = 'image-preview-thumb';
      thumb.src = previewUrl;
      thumb.alt = `${entry?.title || entry?.id || 'Image'} preview`;
      thumb.title = `${entry?.title || entry?.id || 'Image'} preview`;
      thumb.decoding = 'async';
      thumb.loading = 'lazy';
      slot.replaceChildren(thumb);
    }

    async function attachPdfPreview(resource, folder, entry) {
      const previewBaseUrl = getPdfPreviewUrl(folder, entry);
      if (!previewBaseUrl) return;

      const slot = resource.querySelector('.file-preview-slot');
      if (!slot) return;

      const placeholder = document.createElement('span');
      placeholder.className = 'pdf-preview-placeholder';
      placeholder.textContent = 'PDF';
      placeholder.title = 'Generating thumbnail‚Ä¶';
      slot.replaceChildren(placeholder);

      const thumbnailApiUrl = new URL('/api/project-files/pdf-thumbnail', window.location.origin);
      thumbnailApiUrl.searchParams.set('source', previewBaseUrl);
      const thumbnailKey = thumbnailApiUrl.toString();

      const applyThumbnail = async () => {
        const response = await fetch(thumbnailKey, { method: 'GET' });
        if (response.status === 202) return false;
        if (!response.ok) throw new Error(`thumbnail request failed (${response.status})`);
        const blob = await response.blob();
        const objectUrl = URL.createObjectURL(blob);
        const thumb = document.createElement('img');
        thumb.className = 'pdf-preview-thumb';
        thumb.src = objectUrl;
        thumb.alt = `${entry?.title || entry?.id || 'PDF'} preview`;
        thumb.title = `${entry?.title || entry?.id || 'PDF'} preview`;
        thumb.decoding = 'async';
        thumb.loading = 'lazy';
        if (folder?.key === 'cpfs') {
          thumb.tabIndex = 0;
          bindCpfHoverPreview(thumb, entry);
        }
        slot.replaceChildren(thumb);
        return true;
      };
      try {
        const maxAttempts = 60;
        for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
          const done = await applyThumbnail();
          if (done) return;
          await new Promise((resolve) => setTimeout(resolve, Math.min(4000, 350 + (attempt * 200))));
        }
        placeholder.classList.add('pdf-preview-failed');
        placeholder.textContent = 'Unavailable';
        placeholder.title = 'Thumbnail preview is unavailable right now. Open the PDF to view it.';
      } catch {
        placeholder.classList.add('pdf-preview-failed');
        placeholder.textContent = 'Unavailable';
        placeholder.title = 'Thumbnail preview failed to load. Open the PDF to view it.';
      }
    }

    function describeCpfPointLinks(links = []) {
      if (!Array.isArray(links) || !links.length) return '';
      return links
        .map((link, index) => `${index + 1}. ${link.pointFileTitle} ‚Üí Point ${link.pointNumber} (${link.pointCode})`)
        .join('\n');
    }

    async function deleteCpfResource(folder, resource, projectContext) {
      const instrument = String(resource?.reference?.value || resource?.reference?.metadata?.instrument || '').trim();
      const links = await findCpfPointLinksAsync(projectContext?.projectFile, resolvePointFileText, instrument);
      let shouldDelete = true;
      if (links.length) {
        const detail = describeCpfPointLinks(links);
        shouldDelete = window.confirm(`This CP&F is linked to ${links.length} point${links.length === 1 ? '' : 's'}:\n\n${detail}\n\nDelete CP&F anyway?`);
      }
      if (!shouldDelete) return;

      const projectId = projectContext?.activeProjectId;
      const cpfId = String(resource?.reference?.metadata?.cpfId || resource?.id || '').trim();
      if (projectId && cpfId) {
        try {
          const response = await fetch(buildProjectCpfApiUrl(projectId, cpfId), { method: 'DELETE' });
          if (!response.ok && response.status !== 404) {
            throw new Error(`Server returned ${response.status}`);
          }
          await syncProjectCpfsFromApi(projectContext);
        } catch (err) {
          renderError(`Could not delete CP&F from server: ${err.message}`);
          return;
        }
      } else {
        const removed = removeResourceById(projectContext?.projectFile, folder?.key, resource?.id);
        if (!removed) {
          renderError(`Could not delete CP&F ${resource?.title || resource?.id || ''}.`);
          return;
        }
        const saved = saveStoredProjectFile(window.localStorage, projectContext?.activeProjectId, projectContext?.projectFile);
        if (!saved) {
          renderError('CP&F was removed in memory, but project snapshot could not be saved.');
          return;
        }
      }

      const deletedTitle = resource?.title || resource?.id || instrument || 'CP&F record';
      projectContext.setUploadStatus(`Deleted ${deletedTitle}.`);
      renderTree(projectContext.projectFile, projectContext);
    }

    function escapeHtml(text = '') {
      return String(text)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function openCpfPrintPreview(resources = []) {
      const printableResources = resources
        .map((entry) => ({
          entry,
          url: getCpfPdfUrl(entry),
        }))
        .filter((item) => item.url);

      if (!printableResources.length) {
        renderError('No printable CP&F PDF records were found for this project.');
        return;
      }

      // Use a plain same-origin popup so browsers return a writable window handle.
      // Some engines return `null` when `noopener` is requested, which incorrectly
      // triggers our popup-blocked error path and leaves a blank preview tab.
      const printWindow = window.open('', '_blank');
      if (!printWindow) {
        renderError('Your browser blocked the print-preview window. Please allow pop-ups and try again.');
        return;
      }

      const pagesMarkup = printableResources.map(({ url }, index) => `
        <section class="page-block">
          <iframe src="${escapeHtml(buildPrintPreviewPdfUrl(url))}" title="CP&amp;F PDF ${index + 1}" class="pdf-frame"></iframe>
        </section>
      `).join('');

      printWindow.document.write(`<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CP&amp;F Print Preview</title>
  <style>
    :root { color-scheme: light; }
    body { font-family: Inter, system-ui, sans-serif; margin: 1rem; color: #0f172a; background: #fff; }
    .toolbar { position: sticky; top: 0; background: #fff; padding: 0.5rem 0; margin-bottom: 1rem; border-bottom: 1px solid #cbd5e1; }
    .print-button { font: inherit; padding: 0.45rem 0.8rem; border-radius: 6px; border: 1px solid #334155; background: #fff; cursor: pointer; }
    .page-block { margin: 0 0 1rem; display: flex; justify-content: center; background: #fff; }
    .pdf-frame { width: min(100%, 8.5in); height: 98vh; border: 1px solid #94a3b8; border-radius: 8px; display: block; margin: 0 auto; background: #fff; }
    @media print {
      @page { margin: 0; }
      .toolbar { display: none; }
      body { margin: 0; background: #fff; }
      .page-block { margin: 0; break-inside: avoid; page-break-inside: avoid; display: flex; justify-content: center; background: #fff; }
      .pdf-frame { width: 100%; border: none; border-radius: 0; height: 100vh; background: #fff; }
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <button type="button" class="print-button" onclick="window.print()">Print all CP&amp;F PDFs</button>
  </div>
  ${pagesMarkup}
</body>
</html>`);
      printWindow.document.close();
      printWindow.focus();
    }

    function loadActiveProjectContext(activeProjectId) {
      try {
        const projects = JSON.parse(localStorage.getItem('surveyfoundryProjects') || '[]');
        if (!Array.isArray(projects)) return null;
        return projects.find((project) => project.id === activeProjectId) || null;
      } catch {
        return null;
      }
    }

    function isSupportedPointFile(file) {
      const name = file?.name || '';
      return /\.(csv|txt)$/i.test(name);
    }

    async function uploadPointFilesToServer(files, context) {
      const accepted = Array.from(files || []).filter(isSupportedPointFile);
      if (!accepted.length) {
        context.setUploadStatus('No supported files found. Use .csv or .txt files.');
        return;
      }

      if (!context.activeProjectId || !context.projectFile) {
        context.setUploadStatus('Select an active project before uploading point files.');
        return;
      }

      let uploadedCount = 0;
      const totalFiles = accepted.length;
      for (let index = 0; index < accepted.length; index += 1) {
        const file = accepted[index];
        const currentFileNumber = index + 1;
        try {
          context.setUploadProgress(null);
          context.setUploadStatus(`Uploading point file ${currentFileNumber}/${totalFiles}: ${file.name}‚Ä¶`);
          const text = await file.text();
          const actorMetadata = buildPointFileActorMetadata('evidence-desk-upload');
          const response = await fetch(buildProjectPointFileApiUrl(context.activeProjectId), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', ...actorMetadata.headers },
            body: JSON.stringify({
              pointFileName: file.name,
              pointFileState: { text, exportFormat: 'csv' },
              source: 'evidence-desk-upload',
              sourceLabel: file.name,
              changeContext: actorMetadata.changeContext,
            }),
          });
          if (!response.ok) {
            const err = await response.json().catch(() => ({ error: 'Upload failed.' }));
            context.setUploadStatus(`Failed to upload ${file.name}: ${err.error}`);
            continue;
          }
          uploadedCount += 1;
          context.setUploadStatus(`Uploaded point file ${uploadedCount}/${totalFiles}: ${file.name}`);
        } catch (err) {
          context.setUploadStatus(`Network error uploading ${file.name}: ${err.message}`);
        }
      }

      if (!uploadedCount) {
        context.setUploadProgress(null);
        context.setUploadStatus('No point files were uploaded successfully.');
        return;
      }

      await syncProjectPointFilesFromApi(context);
      context.setUploadProgress(null);
      context.setUploadStatus(`Uploaded ${uploadedCount} point file${uploadedCount === 1 ? '' : 's'} to this project.`);
      renderTree(context.projectFile, context);
    }

    function uploadFileViaXhr(formData, onProgress) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', '/api/project-files/upload');

        xhr.upload.addEventListener('progress', (event) => {
          if (typeof onProgress === 'function') {
            onProgress(event);
          }
        });

        xhr.addEventListener('load', () => {
          let payload = null;
          try {
            payload = xhr.responseText ? JSON.parse(xhr.responseText) : null;
          } catch {
            payload = null;
          }

          if (xhr.status >= 200 && xhr.status < 300) {
            resolve({ ok: true, payload });
            return;
          }

          resolve({ ok: false, payload });
        });

        xhr.addEventListener('error', () => reject(new Error('Network request failed.')));
        xhr.send(formData);
      });
    }


    function normalizeRosNumber(value = '') {
      return String(value || '').trim();
    }

    function normalizePointNumber(value = '') {
      return String(value || '').trim();
    }

    async function uploadFilesToServer(files, folderKey, context, onStatus) {
      const fileList = Array.from(files || []);

      function setStatus(message) {
        if (onStatus) { onStatus(message, null); } else { context.setUploadStatus(message); }
      }
      function setProgress(percent) {
        if (onStatus) { onStatus(null, percent); } else { context.setUploadProgress(percent); }
      }
      function setStatusAndProgress(message, percent) {
        if (onStatus) { onStatus(message, percent); } else { context.setUploadProgress(percent); context.setUploadStatus(message); }
      }

      if (!fileList.length) {
        setStatus('No files selected.');
        return;
      }
      if (!context.activeProjectId || !context.projectFile) {
        setStatus('Select an active project before uploading files.');
        return;
      }
      if (!folderKey) {
        setStatus('Please select a folder to upload into.');
        return;
      }

      let uploadedCount = 0;
      const totalFiles = fileList.length;
      for (let index = 0; index < fileList.length; index += 1) {
        const file = fileList[index];
        const currentFileNumber = index + 1;
        const formData = new FormData();
        formData.append('projectId', context.activeProjectId);
        formData.append('folderKey', folderKey);
        formData.append('file', file, file.name);

        try {
          setProgress(null);
          const response = await uploadFileViaXhr(formData, (event) => {
            if (event.lengthComputable) {
              const progress = Math.round((event.loaded / event.total) * 100);
              setStatusAndProgress(`Uploading ${currentFileNumber}/${totalFiles}: ${file.name} (${progress}%)`, progress);
              return;
            }
            setStatus(`Uploading ${currentFileNumber}/${totalFiles}: ${file.name}‚Ä¶`);
          });
          if (!response.ok) {
            const err = response.payload || { error: 'Upload failed.' };
            setStatus(`Failed to upload ${file.name}: ${err.error}`);
            continue;
          }
          const { resource } = response.payload || {};
          const appended = appendResourceToFolder(context.projectFile, folderKey, resource);
          if (appended) {
            uploadedCount += 1;
            setStatus(`Uploaded ${uploadedCount}/${totalFiles}: ${file.name}`);
          }
        } catch (err) {
          setStatus(`Network error uploading ${file.name}: ${err.message}`);
        }
      }

      if (!uploadedCount) {
        setProgress(null);
        setStatus('No files were uploaded successfully.');
        return;
      }

      saveStoredProjectFile(window.localStorage, context.activeProjectId, context.projectFile);
      setProgress(null);
      setStatus(`Uploaded ${uploadedCount} file${uploadedCount === 1 ? '' : 's'} to project.`);
      renderTree(context.projectFile, context);
    }

    function createFileUploadPanel(context) {
      const panel = document.createElement('div');
      panel.className = 'upload-panel';

      const title = document.createElement('div');
      title.className = 'muted';
      title.textContent = 'Upload files to the project: drag files here, or choose files below.';
      panel.appendChild(title);

      const actions = document.createElement('div');
      actions.className = 'upload-actions';

      const folderSelect = document.createElement('select');
      folderSelect.className = 'launch-btn';
      folderSelect.style.padding = '0.3rem 0.45rem';
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = 'Select folder‚Ä¶';
      folderSelect.appendChild(defaultOption);
      for (const folder of context.projectFile?.folders || []) {
        const option = document.createElement('option');
        option.value = folder.key;
        option.textContent = folder.label;
        folderSelect.appendChild(option);
      }
      actions.appendChild(folderSelect);


      const picker = document.createElement('input');
      picker.type = 'file';
      picker.multiple = true;
      picker.style.display = 'none';
      picker.addEventListener('change', () => {
        if (picker.files.length) {
          uploadFilesToServer(picker.files, folderSelect.value, context);
        }
      });

      const pickerButton = document.createElement('button');
      pickerButton.type = 'button';
      pickerButton.className = 'launch-btn';
      pickerButton.textContent = 'Choose Files';
      pickerButton.addEventListener('click', () => {
        if (!folderSelect.value) {
          context.setUploadStatus('Please select a folder first.');
          const statusEl = panel.querySelector('.upload-status');
          if (statusEl) statusEl.textContent = context.uploadStatus;
          return;
        }
        picker.click();
      });

      actions.appendChild(pickerButton);
      actions.appendChild(picker);
      panel.appendChild(actions);

      const status = document.createElement('div');
      status.className = 'upload-status';
      status.textContent = context.uploadStatus || '';
      panel.appendChild(status);

      const progress = document.createElement('progress');
      progress.className = 'upload-progress';
      progress.max = 100;
      progress.hidden = true;
      panel.appendChild(progress);

      if (context?.addUploadStatusListener) {
        context.addUploadStatusListener((message, percent) => {
          status.textContent = message || '';
          if (typeof percent === 'number' && Number.isFinite(percent)) {
            progress.hidden = false;
            progress.value = Math.max(0, Math.min(100, percent));
          } else {
            progress.hidden = true;
            progress.removeAttribute('value');
          }
        });
      }

      panel.addEventListener('dragover', (event) => {
        event.preventDefault();
        panel.classList.add('drag-active');
      });
      panel.addEventListener('dragleave', () => panel.classList.remove('drag-active'));
      panel.addEventListener('drop', (event) => {
        event.preventDefault();
        panel.classList.remove('drag-active');
        if (!folderSelect.value) {
          context.setUploadStatus('Please select a folder before dropping files.');
          const statusEl = panel.querySelector('.upload-status');
          if (statusEl) statusEl.textContent = context.uploadStatus;
          return;
        }
        uploadFilesToServer(event.dataTransfer?.files, folderSelect.value, context);
      });

      return panel;
    }

    function createPointFileUploadPanel(context) {
      const panel = document.createElement('div');
      panel.className = 'upload-panel';

      const title = document.createElement('div');
      title.className = 'muted';
      title.textContent = 'Attach point files (.csv or .txt): drag files here on desktop, or choose files on mobile.';
      panel.appendChild(title);

      const actions = document.createElement('div');
      actions.className = 'upload-actions';

      const picker = document.createElement('input');
      picker.type = 'file';
      picker.accept = '.csv,text/csv,.txt,text/plain';
      picker.multiple = true;
      picker.addEventListener('change', () => uploadPointFilesToServer(picker.files, context));

      const pickerButton = document.createElement('button');
      pickerButton.type = 'button';
      pickerButton.className = 'launch-btn';
      pickerButton.textContent = 'Choose Point Files';
      pickerButton.addEventListener('click', () => picker.click());

      actions.appendChild(pickerButton);
      actions.appendChild(picker);
      panel.appendChild(actions);

      const status = document.createElement('div');
      status.className = 'upload-status';
      status.textContent = context.uploadStatus || '';
      panel.appendChild(status);

      const progress = document.createElement('progress');
      progress.className = 'upload-progress';
      progress.max = 100;
      progress.hidden = true;
      panel.appendChild(progress);

      if (context?.addUploadStatusListener) {
        context.addUploadStatusListener((message, percent) => {
          status.textContent = message || '';
          if (typeof percent === 'number' && Number.isFinite(percent)) {
            progress.hidden = false;
            progress.value = Math.max(0, Math.min(100, percent));
          } else {
            progress.hidden = true;
            progress.removeAttribute('value');
          }
        });
      }

      panel.addEventListener('dragover', (event) => {
        event.preventDefault();
        panel.classList.add('drag-active');
      });
      panel.addEventListener('dragleave', () => panel.classList.remove('drag-active'));
      panel.addEventListener('drop', (event) => {
        event.preventDefault();
        panel.classList.remove('drag-active');
        uploadPointFilesToServer(event.dataTransfer?.files, context);
      });

      return panel;
    }


    async function saveUploadedResourceMetadata(folder, entry, updatesRaw, projectContext = {}) {
      const metadata = entry?.reference?.metadata || {};
      const projectId = projectContext?.activeProjectId;
      const folderKey = folder?.key;
      const storedFileName = metadata?.storedName;
      if (!projectId || !folderKey || !storedFileName) {
        renderError('Cannot update metadata: missing upload metadata.');
        return null;
      }

      const updates = {};
      if (Object.prototype.hasOwnProperty.call(updatesRaw || {}, 'rosNumber')) {
        updates.rosNumber = normalizeRosNumber(updatesRaw.rosNumber);
      }
      if (Object.prototype.hasOwnProperty.call(updatesRaw || {}, 'pointNumber')) {
        updates.pointNumber = normalizePointNumber(updatesRaw.pointNumber);
      }
      if (!Object.keys(updates).length) {
        renderError('No metadata fields were provided.');
        return null;
      }

      const metadataUrl = new URL('/api/project-files/metadata', window.location.origin);
      metadataUrl.searchParams.set('projectId', projectId);
      metadataUrl.searchParams.set('folderKey', folderKey);
      metadataUrl.searchParams.set('fileName', storedFileName);
      const response = await fetch(metadataUrl, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      });
      const payload = await response.json().catch(() => ({}));
      if (!response.ok || !payload?.resource) {
        renderError(payload?.error || 'Failed to update upload metadata.');
        return null;
      }
      const replaced = removeResourceById(projectContext?.projectFile, folderKey, entry?.id);
      if (replaced) appendResourceToFolder(projectContext?.projectFile, folderKey, payload.resource);
      saveStoredProjectFile(window.localStorage, projectContext?.activeProjectId, projectContext?.projectFile);
      renderTree(projectContext.projectFile, projectContext);
      return payload.resource;
    }

    async function setRosNumberForUploadedResource(folder, entry, rosNumberRaw, projectContext = {}) {
      const metadata = entry?.reference?.metadata || {};
      const storedFileName = metadata?.storedName;
      const rosNumber = normalizeRosNumber(rosNumberRaw);
      projectContext.setUploadStatus(`Updating ROS number for ${entry?.title || storedFileName}‚Ä¶`);
      const resource = await saveUploadedResourceMetadata(folder, entry, { rosNumber }, projectContext);
      if (!resource) return;
      projectContext.setUploadStatus(`Saved ROS # ${rosNumber || '(cleared)'} for ${entry?.title || storedFileName}.`);
    }

    async function setPointNumberForUploadedResource(folder, entry, pointNumberRaw, projectContext = {}) {
      const metadata = entry?.reference?.metadata || {};
      const storedFileName = metadata?.storedName;
      const pointNumber = normalizePointNumber(pointNumberRaw);
      projectContext.setUploadStatus(`Updating point number for ${entry?.title || storedFileName}‚Ä¶`);
      const resource = await saveUploadedResourceMetadata(folder, entry, { pointNumber }, projectContext);
      if (!resource) return;
      projectContext.setUploadStatus(`Saved point # ${pointNumber || '(cleared)'} for ${entry?.title || storedFileName}.`);
    }

    async function openProjectPointFileVersionInPointForge(resource, versionId, projectContext = {}) {
      const text = await resolvePointFileText(resource, { versionId });
      if (!text || !text.trim()) {
        renderError(`Selected point-file version could not be opened. Unable to load text for ${resource?.title || 'resource'}.`);
        return;
      }

      localStorage.setItem(POINTFORGE_PROJECT_BROWSER_IMPORT_STORAGE_KEY, JSON.stringify({
        csv: text,
        title: resource.title || resource.id || 'Point File',
        pointFileId: resource?.reference?.metadata?.pointFileId || resource?.id || '',
        versionId: String(versionId || '').trim() || null,
      }));

      const destination = new URL('/POINT_TRANSFORMER.HTML', window.location.origin);
      destination.searchParams.set('source', 'project-browser');
      if (projectContext.projectId) destination.searchParams.set('projectId', projectContext.projectId);
      if (projectContext.projectName) destination.searchParams.set('projectName', projectContext.projectName);
      openLinkedApp(`${destination.pathname}${destination.search}`);
    }

    function formatVersionTimelineStamp(value = '') {
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return 'Unknown date';
      return date.toLocaleString();
    }

    async function attachProjectPointFileVersionTimeline(resource, entry, projectContext = {}) {
      if (!resource || !entry || entry?.reference?.type !== 'project-point-file') return;

      const details = document.createElement('details');
      details.className = 'point-file-version-details';
      details.innerHTML = '<summary class="point-file-version-summary">Version timeline (loading‚Ä¶)</summary>';
      resource.appendChild(details);

      details.addEventListener('click', (event) => event.stopPropagation());
      details.addEventListener('keydown', (event) => event.stopPropagation());

      details.addEventListener('toggle', async () => {
        if (!details.open || details.dataset.loaded === 'true' || details.dataset.loading === 'true') return;
        details.dataset.loading = 'true';

        const summary = details.querySelector('.point-file-version-summary');
        try {
          const record = await fetchProjectPointFileRecord(entry);
          const versions = Array.isArray(record?.versions) ? [...record.versions].reverse() : [];
          summary.textContent = `Version timeline (${versions.length})`;

          const list = document.createElement('ol');
          list.className = 'point-file-version-list';
          for (const version of versions) {
            const actor = version?.actor || {};
            const actorUser = String(actor?.user || 'unknown-user').trim() || 'unknown-user';
            const actorTool = String(actor?.app || 'unknown-app').trim() || 'unknown-app';
            const savedAt = formatVersionTimelineStamp(version?.savedAt);

            const item = document.createElement('li');
            item.className = 'point-file-version-item';

            const label = document.createElement('span');
            label.className = 'point-file-version-label';
            label.textContent = `${savedAt} ‚Äî ${actorUser} via ${actorTool}`;

            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'point-file-version-open';
            openButton.textContent = 'Open in PointForge';
            openButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await openProjectPointFileVersionInPointForge(entry, version?.versionId, projectContext);
            });

            item.append(label, openButton);
            list.appendChild(item);
          }

          details.appendChild(list);
          details.dataset.loaded = 'true';
        } catch (err) {
          summary.textContent = 'Version timeline (failed to load)';
          const error = document.createElement('div');
          error.className = 'muted';
          error.style.padding = '0 0.55rem 0.55rem';
          error.textContent = err?.message || 'Unable to load version timeline.';
          details.appendChild(error);
        } finally {
          delete details.dataset.loading;
        }
      });
    }

    function renderTree(projectFile, projectContext = {}) {
      treeContainer.innerHTML = '';
      if (Array.isArray(projectContext.uploadStatusListeners)) {
        projectContext.uploadStatusListeners = [];
      }

      const root = document.createElement('div');
      root.className = 'tree-root';
      root.innerHTML = `<span class="icon">üóÇÔ∏è</span><strong>${projectFile.archive.rootFolderName}</strong><span class="muted">(symbolic root folder)</span>`;
      treeContainer.appendChild(root);

      treeContainer.appendChild(createFileUploadPanel(projectContext));

      const associationIndex = buildDrawingAssociationIndex(projectFile);

      const folderChildrenContainerMap = new Map();
      for (const folder of projectFile.folders || []) {
        const parentChildrenContainer = folder.parentKey ? folderChildrenContainerMap.get(folder.parentKey) : null;
        const folderGroupWrapper = document.createElement('div');
        folderGroupWrapper.className = 'folder-group';
        (parentChildrenContainer || treeContainer).appendChild(folderGroupWrapper);
        const folderUploadStatusText = document.createElement('div');
        folderUploadStatusText.className = 'upload-status';
        folderUploadStatusText.hidden = true;
        const folderUploadProgressBar = document.createElement('progress');
        folderUploadProgressBar.className = 'upload-progress';
        folderUploadProgressBar.max = 100;
        folderUploadProgressBar.hidden = true;
        const onFolderUploadStatus = (message, percent) => {
          if (message !== null) {
            folderUploadStatusText.textContent = message || '';
            folderUploadStatusText.hidden = !message;
          }
          if (typeof percent === 'number' && Number.isFinite(percent)) {
            folderUploadProgressBar.hidden = false;
            folderUploadProgressBar.value = Math.max(0, Math.min(100, percent));
          } else {
            folderUploadProgressBar.hidden = true;
            folderUploadProgressBar.removeAttribute('value');
          }
        };

        const folderRow = document.createElement('div');
        folderRow.className = 'folder-row';
        folderRow.dataset.folderKey = folder.key;
        folderRow.innerHTML = `<span class="folder-title"><span class="icon">üìÅ</span><strong>${folder.label}</strong><span class="muted">${folder.description}</span></span>`;
        folderRow.addEventListener('dragover', (event) => {
          const dragTypes = event.dataTransfer?.types ? Array.from(event.dataTransfer.types) : [];
          if (dragTypes.includes('application/x-surveycad-resource-move')) {
            event.preventDefault();
            folderRow.classList.add('folder-drop-target');
            return;
          }
          if (dragTypes.includes('Files')) {
            event.preventDefault();
            folderRow.classList.add('folder-upload-drop-target');
          }
        });
        folderRow.addEventListener('dragleave', () => {
          folderRow.classList.remove('folder-drop-target');
          folderRow.classList.remove('folder-upload-drop-target');
        });
        folderRow.addEventListener('drop', async (event) => {
          event.preventDefault();
          folderRow.classList.remove('folder-drop-target');
          folderRow.classList.remove('folder-upload-drop-target');
          const payloadRaw = event.dataTransfer?.getData('application/x-surveycad-resource-move');
          if (payloadRaw) {
            let payload = null;
            try {
              payload = JSON.parse(payloadRaw);
            } catch {
              return;
            }
            if (!payload?.resourceId || !payload?.sourceFolderKey || payload.sourceFolderKey === folder.key) return;
            const sourceFolder = projectFile.folders.find((candidate) => candidate.key === payload.sourceFolderKey);
            const draggedEntry = sourceFolder?.index?.find((candidate) => candidate?.id === payload.resourceId);
            if (!sourceFolder || !draggedEntry) return;
            await moveResourceFromEvidenceDesk(sourceFolder, folder, draggedEntry, projectContext);
            return;
          }
          if (event.dataTransfer?.files?.length) {
            await uploadFilesToServer(event.dataTransfer.files, folder.key, projectContext, onFolderUploadStatus);
          }
        });

        if (folder.key === 'cpfs') {
          const printAllButton = document.createElement('button');
          printAllButton.type = 'button';
          printAllButton.className = 'launch-btn';
          printAllButton.textContent = 'Print all';
          printAllButton.title = 'Builds a single print preview containing each CP&F PDF in order';
          printAllButton.addEventListener('click', () => openCpfPrintPreview(folder.index));
          printAllButton.disabled = !folder.index.some((entry) => entry?.exportFormat === 'pdf');
          folderRow.appendChild(printAllButton);
        }

        if (folder.custom) {
          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'remove-folder-btn';
          removeBtn.textContent = 'Remove';
          removeBtn.title = 'Remove this custom folder (only allowed when empty and has no subfolders)';
          removeBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            if (Array.isArray(folder.index) && folder.index.length > 0) {
              projectContext.setUploadStatus(`Cannot remove "${folder.label}" ‚Äî move or delete its files first.`);
              return;
            }
            if (getFolderChildren(projectContext.projectFile, folder.key).length > 0) {
              projectContext.setUploadStatus(`Cannot remove "${folder.label}" ‚Äî remove its subfolders first.`);
              return;
            }
            if (!confirm(`Remove the custom folder "${folder.label}"?`)) return;
            const removed = removeCustomFolder(projectContext.projectFile, folder.key);
            if (!removed) {
              projectContext.setUploadStatus(`Could not remove "${folder.label}".`);
              return;
            }
            saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
            renderTree(projectContext.projectFile, projectContext);
          });
          folderRow.appendChild(removeBtn);
        }

        folderGroupWrapper.appendChild(folderRow);

        const folderUploadFeedback = document.createElement('div');
        folderUploadFeedback.className = 'folder-upload-feedback';
        folderUploadFeedback.appendChild(folderUploadStatusText);
        folderUploadFeedback.appendChild(folderUploadProgressBar);
        folderGroupWrapper.appendChild(folderUploadFeedback);

        if (folder.key === 'point-files') {
          folderGroupWrapper.appendChild(createPointFileUploadPanel(projectContext));
        }

        const fileListContainer = document.createElement('div');
        fileListContainer.className = 'file-list-container';
        fileListContainer.addEventListener('dragover', (event) => {
          const dragTypes = event.dataTransfer?.types ? Array.from(event.dataTransfer.types) : [];
          if (dragTypes.includes('application/x-surveycad-resource-move')) {
            event.preventDefault();
            fileListContainer.classList.add('file-list-drop-target');
            return;
          }
          if (dragTypes.includes('Files')) {
            event.preventDefault();
            fileListContainer.classList.add('file-list-upload-drop-target');
          }
        });
        fileListContainer.addEventListener('dragleave', (event) => {
          if (fileListContainer.contains(event.relatedTarget)) return;
          fileListContainer.classList.remove('file-list-drop-target');
          fileListContainer.classList.remove('file-list-upload-drop-target');
        });
        fileListContainer.addEventListener('drop', async (event) => {
          event.preventDefault();
          fileListContainer.classList.remove('file-list-drop-target');
          fileListContainer.classList.remove('file-list-upload-drop-target');
          const payloadRaw = event.dataTransfer?.getData('application/x-surveycad-resource-move');
          if (payloadRaw) {
            let payload = null;
            try {
              payload = JSON.parse(payloadRaw);
            } catch {
              return;
            }
            if (!payload?.resourceId || !payload?.sourceFolderKey || payload.sourceFolderKey === folder.key) return;
            const sourceFolder = projectFile.folders.find((candidate) => candidate.key === payload.sourceFolderKey);
            const draggedEntry = sourceFolder?.index?.find((candidate) => candidate?.id === payload.resourceId);
            if (!sourceFolder || !draggedEntry) return;
            await moveResourceFromEvidenceDesk(sourceFolder, folder, draggedEntry, projectContext);
            return;
          }
          if (event.dataTransfer?.files?.length) {
            await uploadFilesToServer(event.dataTransfer.files, folder.key, projectContext, onFolderUploadStatus);
          }
        });
        folderGroupWrapper.appendChild(fileListContainer);

        if (!folder.index.length) {
          const empty = document.createElement('div');
          empty.className = 'empty';
          empty.textContent = 'No linked resources yet.';
          fileListContainer.appendChild(empty);
        } else {
        function buildOneFileRow(entry) {
          const resource = document.createElement('div');
          resource.className = 'file-row';

          const canDragToMove = canMoveResourceBetweenFolders(entry, folder.key, '__other__');
          if (canDragToMove) {
            resource.classList.add('file-draggable');
            resource.draggable = true;
            resource.addEventListener('dragstart', (event) => {
              resource.classList.add('file-dragging');
              startDragAutoScroll();
              event.dataTransfer?.setData('application/x-surveycad-resource-move', JSON.stringify({
                resourceId: entry.id,
                sourceFolderKey: folder.key,
              }));
              if (event.dataTransfer) event.dataTransfer.effectAllowed = 'copyMove';
              const dragImage = buildFileDragImage(resource);
              if (dragImage && event.dataTransfer) {
                event.dataTransfer.setDragImage(dragImage, 49, 49);
                requestAnimationFrame(() => dragImage.remove());
              }
              if (entry?.reference?.type === 'server-upload' && event.dataTransfer) {
                const serverDownloadUrl = String(entry.reference.value || '').trim();
                if (serverDownloadUrl) {
                  const mimeType = getMimeTypeFromFormat(entry?.exportFormat || '');
                  const fileName = entry?.title || `${entry.id}.${entry.exportFormat}`;
                  const absoluteUrl = new URL(serverDownloadUrl, window.location.origin).href;
                  event.dataTransfer.setData('DownloadURL', `${mimeType}:${fileName}:${absoluteUrl}`);
                }
              }
            });
            resource.addEventListener('dragend', () => {
              resource.classList.remove('file-dragging');
              stopDragAutoScroll();
            });
          }

          const pointFileFormat = String(entry?.exportFormat || '').toLowerCase();
          const isPointFileFormat = pointFileFormat === 'csv' || pointFileFormat === 'txt';
          const canLaunchPointForge = folder.key === 'point-files'
            && isPointFileFormat
            && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'server-upload' || entry?.reference?.type === 'project-point-file');
          const canOpenLineSmithDrawing = folder.key === 'drawings'
            && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'project-drawing');
          const canOpenCpfPdf = folder.key === 'cpfs' && entry?.exportFormat === 'pdf';
          const isPdfResource = entry?.exportFormat === 'pdf';
          const isImageUpload = isImageResource(entry);
          const showThumbnailSlot = canLaunchPointForge || canOpenLineSmithDrawing || isPdfResource || isImageUpload;
          const actualFileName = `${entry.id}.${entry.exportFormat}`;
          const configuredFileName = entry?.title || actualFileName;
          const leadingIcon = showThumbnailSlot ? '' : '<span class="icon">üìÑ</span>';
          const thumbnailSlotMarkup = showThumbnailSlot ? '<span class="file-preview-slot" aria-hidden="true"></span>' : '';
          const rosNumber = String(entry?.reference?.metadata?.rosNumber || '').trim();
          const pointNumber = String(entry?.reference?.metadata?.pointNumber || '').trim();
          const rosPillMarkup = rosNumber ? `<span class="ros-number-pill" title="Recorded map number for ROS linking">ROS # ${rosNumber}</span>` : '';
          const pointPillMarkup = pointNumber ? `<span class="ros-number-pill" title="Linked photo point number">PT # ${pointNumber}</span>` : '';
          const pointFileSource = String(entry?.reference?.metadata?.source || '').trim();
          const pointFileSourceLabel = String(entry?.reference?.metadata?.sourceLabel || '').trim();
          const equipmentAuditPillMarkup = pointFileSource === 'equipment-log'
            ? `<span class="ros-number-pill" title="${pointFileSourceLabel || 'Attached from Equipment Log'}">Equip Log</span>`
            : '';
          const pointFileAssociations = associationIndex.drawingsByPointFileId.get(
            normalizeAssociationId(entry?.reference?.metadata?.pointFileId || entry?.reference?.value || entry?.id || ''),
          ) || [];
          const drawingAssociationName = associationIndex.pointFileByDrawingId.get(
            normalizeAssociationId(entry?.reference?.metadata?.drawingId || entry?.reference?.value || entry?.id || ''),
          ) || '';
          const pointFileAssociationMarkup = folder.key === 'point-files' && pointFileAssociations.length
            ? `<ul class="association-list" title="LineSmith drawings associated with this point file">${pointFileAssociations.map((title) => `<li class="association-list-item">‚Ü≥ Drawing: ${title}</li>`).join('')}</ul>`
            : '';
          const drawingAssociationMarkup = folder.key === 'drawings' && drawingAssociationName
            ? `<ul class="association-list" title="Point file associated with this drawing"><li class="association-list-item">‚Ü≥ Point file: ${drawingAssociationName}</li></ul>`
            : '';
          resource.innerHTML = `<span class="file-meta">${leadingIcon}${thumbnailSlotMarkup}<span class="file-name"><span class="file-name-primary"><span class="file-name-configured" title="${actualFileName}">${configuredFileName}</span>${rosPillMarkup}${pointPillMarkup}${equipmentAuditPillMarkup}</span>${pointFileAssociationMarkup}${drawingAssociationMarkup}</span></span>`;
          const actionButtons = document.createElement('div');
          actionButtons.className = 'file-actions';
          resource.appendChild(actionButtons);

          if (canLaunchPointForge) {
            attachPointFilePreview(resource, entry).catch(() => {});
          }

          if (canOpenLineSmithDrawing) {
            attachDrawingPreview(resource, entry).catch(() => {});
          }

          if (isPdfResource) {
            attachPdfPreview(resource, folder, entry);
          }

          if (isImageUpload) {
            attachImagePreview(resource, entry);
          }

          if (canLaunchPointForge) {
            resource.classList.add('pointforge-openable');
            resource.setAttribute('role', 'button');
            resource.setAttribute('tabindex', '0');
            resource.title = 'Tap to open this point file in PointForge';
            resource.addEventListener('click', () => launchPointForgeFromResource(entry, projectContext));
            resource.addEventListener('keydown', (event) => {
              if (event.key !== 'Enter' && event.key !== ' ') return;
              event.preventDefault();
              launchPointForgeFromResource(entry, projectContext);
            });

            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'launch-btn';
            openButton.textContent = 'Open in PointForge';
            openButton.title = 'Loads this point file into PointForge input';
            openButton.addEventListener('click', (event) => {
              event.stopPropagation();
              launchPointForgeFromResource(entry, projectContext);
            });
            actionButtons.appendChild(openButton);

            const deletePointFileButton = document.createElement('button');
            deletePointFileButton.type = 'button';
            deletePointFileButton.className = 'launch-btn';
            deletePointFileButton.textContent = 'Delete';
            deletePointFileButton.title = 'Remove this point file from the project';
            deletePointFileButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await deleteResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            actionButtons.appendChild(deletePointFileButton);

            const renamePointFileButton = document.createElement('button');
            renamePointFileButton.type = 'button';
            renamePointFileButton.className = 'launch-btn';
            renamePointFileButton.textContent = 'Rename';
            renamePointFileButton.title = 'Rename this point file across project references';
            renamePointFileButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await renameResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            actionButtons.appendChild(renamePointFileButton);
          }

          if (canOpenLineSmithDrawing) {
            resource.classList.add('pointforge-openable');
            resource.setAttribute('role', 'button');
            resource.setAttribute('tabindex', '0');
            resource.title = 'Tap to open this drawing in LineSmith';
            resource.addEventListener('click', () => launchLineSmithFromDrawingResource(entry, projectContext));
            resource.addEventListener('keydown', (event) => {
              if (event.key !== 'Enter' && event.key !== ' ') return;
              event.preventDefault();
              launchLineSmithFromDrawingResource(entry, projectContext);
            });

            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'launch-btn';
            openButton.textContent = 'Open in LineSmith';
            openButton.title = 'Loads this saved drawing into LineSmith';
            openButton.addEventListener('click', (event) => {
              event.stopPropagation();
              launchLineSmithFromDrawingResource(entry, projectContext);
            });
            actionButtons.appendChild(openButton);

            const renameDrawingButton = document.createElement('button');
            renameDrawingButton.type = 'button';
            renameDrawingButton.className = 'launch-btn';
            renameDrawingButton.textContent = 'Rename';
            renameDrawingButton.title = 'Rename this drawing across project references';
            renameDrawingButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await renameResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            actionButtons.appendChild(renameDrawingButton);

            const deleteDrawingButton = document.createElement('button');
            deleteDrawingButton.type = 'button';
            deleteDrawingButton.className = 'launch-btn';
            deleteDrawingButton.textContent = 'Delete';
            deleteDrawingButton.title = 'Remove this drawing from the project';
            deleteDrawingButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await deleteResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            actionButtons.appendChild(deleteDrawingButton);
          }

          if (canOpenCpfPdf) {
            resource.classList.add('pointforge-openable');
            resource.setAttribute('role', 'button');
            resource.setAttribute('tabindex', '0');
            resource.title = 'Tap to open this CP&F PDF in a new browser window';
            resource.addEventListener('click', () => openCpfPdfFromResource(entry));
            resource.addEventListener('keydown', (event) => {
              if (event.key !== 'Enter' && event.key !== ' ') return;
              event.preventDefault();
              openCpfPdfFromResource(entry);
            });

            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'launch-btn';
            openButton.textContent = 'Open PDF';
            openButton.title = 'Opens this CP&F PDF in a new browser window';
            openButton.addEventListener('click', (event) => {
              event.stopPropagation();
              openCpfPdfFromResource(entry);
            });
            actionButtons.appendChild(openButton);

            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'launch-btn';
            deleteButton.textContent = 'Delete';
            deleteButton.title = 'Delete this CP&F from the project file';
            deleteButton.addEventListener('click', (event) => {
              event.stopPropagation();
              deleteResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            actionButtons.appendChild(deleteButton);

            const renameButton = document.createElement('button');
            renameButton.type = 'button';
            renameButton.className = 'launch-btn';
            renameButton.textContent = 'Rename';
            renameButton.title = 'Rename this file in the project EvidenceDesk index';
            renameButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await renameResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(renameButton);
          }

          const isServerUpload = entry?.reference?.type === 'server-upload' && !canLaunchPointForge;
          if (isServerUpload) {
            const downloadUrl = entry.reference.value;
            const isServerPdf = entry?.exportFormat === 'pdf';
            resource.classList.add('pointforge-openable');
            resource.setAttribute('role', 'button');
            resource.setAttribute('tabindex', '0');
            resource.title = 'Click to open this file';
            resource.addEventListener('click', () => {
              if (isServerPdf) {
                openPdfInNewWindow(downloadUrl);
                return;
              }
              window.open(downloadUrl, '_blank', 'noopener,noreferrer');
            });
            resource.addEventListener('keydown', (event) => {
              if (event.key !== 'Enter' && event.key !== ' ') return;
              event.preventDefault();
              if (isServerPdf) {
                openPdfInNewWindow(downloadUrl);
                return;
              }
              window.open(downloadUrl, '_blank', 'noopener,noreferrer');
            });

            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'launch-btn';
            openButton.textContent = 'Open';
            openButton.title = isServerPdf
              ? 'Opens this PDF in a new browser window'
              : 'Opens this file in a new tab';
            openButton.addEventListener('click', (event) => {
              event.stopPropagation();
              if (isServerPdf) {
                openPdfInNewWindow(downloadUrl);
                return;
              }
              window.open(downloadUrl, '_blank', 'noopener,noreferrer');
            });
            actionButtons.appendChild(openButton);

            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'launch-btn';
            deleteButton.textContent = 'Delete';
            deleteButton.title = 'Remove this file from the project';
            deleteButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await deleteResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            actionButtons.appendChild(deleteButton);

            const renameButton = document.createElement('button');
            renameButton.type = 'button';
            renameButton.className = 'launch-btn';
            renameButton.textContent = 'Rename';
            renameButton.title = 'Rename this file in the project EvidenceDesk index';
            renameButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await renameResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(renameButton);

            if (isServerPdf && folder.key === 'ros') {
              const rosInlineInput = document.createElement('input');
              rosInlineInput.type = 'text';
              rosInlineInput.className = 'launch-btn';
              rosInlineInput.style.minWidth = '120px';
              rosInlineInput.style.textAlign = 'left';
              rosInlineInput.placeholder = 'ROS #';
              rosInlineInput.value = String(entry?.reference?.metadata?.rosNumber || '');
              rosInlineInput.title = 'Set Record Of Survey number for this PDF';
              rosInlineInput.addEventListener('click', (event) => event.stopPropagation());
              rosInlineInput.addEventListener('keydown', (event) => event.stopPropagation());
              resource.appendChild(rosInlineInput);

              const rosButton = document.createElement('button');
              rosButton.type = 'button';
              rosButton.className = 'launch-btn';
              rosButton.textContent = 'Save ROS #';
              rosButton.title = 'Save Record Of Survey number for LineSmith point-inspector linking';
              rosButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                await setRosNumberForUploadedResource(folder, entry, rosInlineInput.value, projectContext);
              });
              resource.appendChild(rosButton);
            }

            if (isImageUpload) {
              const pointInlineInput = document.createElement('input');
              pointInlineInput.type = 'text';
              pointInlineInput.className = 'launch-btn';
              pointInlineInput.style.minWidth = '120px';
              pointInlineInput.style.textAlign = 'left';
              pointInlineInput.placeholder = 'Point #';
              pointInlineInput.value = String(entry?.reference?.metadata?.pointNumber || '');
              pointInlineInput.title = 'Set linked point number for this photo';
              pointInlineInput.addEventListener('click', (event) => event.stopPropagation());
              pointInlineInput.addEventListener('keydown', (event) => event.stopPropagation());
              resource.appendChild(pointInlineInput);

              const pointButton = document.createElement('button');
              pointButton.type = 'button';
              pointButton.className = 'launch-btn';
              pointButton.textContent = 'Save Point #';
              pointButton.title = 'Save linked point number for LineSmith photo lookup';
              pointButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                if (typeof setPointNumberForUploadedResource === 'function') {
                  await setPointNumberForUploadedResource(folder, entry, pointInlineInput.value, projectContext);
                  return;
                }
                projectContext.setUploadStatus('Point-number helper unavailable in this browser session; retry after refresh.');
              });
              resource.appendChild(pointButton);
            }

          }

          if (!canLaunchPointForge && !canOpenLineSmithDrawing && !canOpenCpfPdf && !isServerUpload) {
            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'launch-btn';
            deleteButton.textContent = 'Delete';
            deleteButton.title = 'Remove this file from the project';
            deleteButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await deleteResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            actionButtons.appendChild(deleteButton);

            const renameButton = document.createElement('button');
            renameButton.type = 'button';
            renameButton.className = 'launch-btn';
            renameButton.textContent = 'Rename';
            renameButton.title = 'Rename this file in the project EvidenceDesk index';
            renameButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await renameResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            actionButtons.appendChild(renameButton);
          }

          if (folder.key === 'point-files' && entry?.reference?.type === 'project-point-file') {
            attachProjectPointFileVersionTimeline(resource, entry, projectContext).catch(() => {});
          }

          return resource;
        }
        if (folder.key === 'cpfs' && folder.index.length) {
          const loadingDiv = document.createElement('div');
          loadingDiv.className = 'empty';
          loadingDiv.textContent = 'Grouping CP&Fs by corner‚Ä¶';
          fileListContainer.appendChild(loadingDiv);
          (async () => {
            try {
              const entriesWithCoords = await Promise.all(folder.index.map(async (entry) => {
                const instrument = String(entry?.reference?.value || entry?.reference?.metadata?.instrument || '').trim();
                const links = instrument ? await findCpfPointLinksAsync(projectContext?.projectFile, resolvePointFileText, instrument) : [];
                const first = links.find((l) => l.north != null && l.east != null);
                return { entry, north: first?.north, east: first?.east };
              }));
              const groups = groupCpfsByCorner(entriesWithCoords, CPF_CORNER_GROUP_RADIUS_FEET);
              loadingDiv.remove();
              for (const group of groups) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'corner-group';
                const labelEl = document.createElement('div');
                labelEl.className = 'corner-group-label';
                labelEl.textContent = group.label;
                groupDiv.appendChild(labelEl);
                for (const entry of group.entries) {
                  groupDiv.appendChild(buildOneFileRow(entry));
                }
                fileListContainer.appendChild(groupDiv);
              }
            } catch (e) {
              loadingDiv.textContent = 'Could not group by corner. Showing flat list.';
              loadingDiv.classList.add('err');
              for (const entry of folder.index) {
                fileListContainer.appendChild(buildOneFileRow(entry));
              }
            }
          })();
        } else {
          for (const entry of folder.index) {
            fileListContainer.appendChild(buildOneFileRow(entry));
          }
        }
        } // end else

        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'folder-children';
        folderGroupWrapper.appendChild(childrenContainer);
        folderChildrenContainerMap.set(folder.key, childrenContainer);

        const currentFolderDepth = getFolderDepth(projectFile, folder.key);
        if (currentFolderDepth < MAX_FOLDER_DEPTH) {
          const addSubfolderPanel = document.createElement('div');
          addSubfolderPanel.className = 'add-folder-panel add-subfolder-panel';

          const addSubfolderLabel = document.createElement('span');
          addSubfolderLabel.className = 'muted';
          addSubfolderLabel.textContent = 'Add subfolder:';
          addSubfolderPanel.appendChild(addSubfolderLabel);

          const addSubfolderInput = document.createElement('input');
          addSubfolderInput.type = 'text';
          addSubfolderInput.className = 'add-folder-input';
          addSubfolderInput.placeholder = 'Subfolder name‚Ä¶';
          addSubfolderInput.maxLength = 60;
          addSubfolderInput.addEventListener('keydown', (event) => event.stopPropagation());
          addSubfolderPanel.appendChild(addSubfolderInput);

          const addSubfolderBtn = document.createElement('button');
          addSubfolderBtn.type = 'button';
          addSubfolderBtn.className = 'launch-btn';
          addSubfolderBtn.textContent = 'Add subfolder';
          addSubfolderBtn.addEventListener('click', () => {
            const label = addSubfolderInput.value.trim();
            if (!label) {
              projectContext.setUploadStatus('Enter a subfolder name first.');
              return;
            }
            const subfolder = addCustomFolder(projectContext.projectFile, { label, parentKey: folder.key });
            if (!subfolder) {
              projectContext.setUploadStatus(`Could not create subfolder "${label}" ‚Äî maximum folder depth (${MAX_FOLDER_DEPTH}) reached.`);
              return;
            }
            saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
            renderTree(projectContext.projectFile, projectContext);
          });
          addSubfolderPanel.appendChild(addSubfolderBtn);
          childrenContainer.appendChild(addSubfolderPanel);
        }
      }

      const manifest = document.createElement('div');
      manifest.className = 'file-row';
      manifest.style.marginLeft = '0';
      manifest.innerHTML = '<span class="icon">üìÑ</span>project-file.json';
      treeContainer.appendChild(manifest);

      const addFolderPanel = document.createElement('div');
      addFolderPanel.className = 'add-folder-panel';

      const addFolderLabel = document.createElement('span');
      addFolderLabel.className = 'muted';
      addFolderLabel.textContent = 'Add folder:';
      addFolderPanel.appendChild(addFolderLabel);

      const addFolderInput = document.createElement('input');
      addFolderInput.type = 'text';
      addFolderInput.className = 'add-folder-input';
      addFolderInput.placeholder = 'Folder name‚Ä¶';
      addFolderInput.maxLength = 60;
      addFolderInput.addEventListener('keydown', (event) => event.stopPropagation());
      addFolderPanel.appendChild(addFolderInput);

      const addFolderBtn = document.createElement('button');
      addFolderBtn.type = 'button';
      addFolderBtn.className = 'launch-btn';
      addFolderBtn.textContent = 'Add';
      addFolderBtn.addEventListener('click', () => {
        const label = addFolderInput.value.trim();
        if (!label) {
          projectContext.setUploadStatus('Enter a folder name first.');
          return;
        }
        const folder = addCustomFolder(projectContext.projectFile, { label });
        if (!folder) {
          projectContext.setUploadStatus(`Could not create folder "${label}".`);
          return;
        }
        saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
        renderTree(projectContext.projectFile, projectContext);
      });
      addFolderPanel.appendChild(addFolderBtn);

      treeContainer.appendChild(addFolderPanel);
    }

    function renderError(message) {
      treeContainer.innerHTML = `<div class="error">${message}</div>`;
    }

    async function initialize() {
      const params = new URLSearchParams(window.location.search);
      const activeProjectId = params.get('activeProjectId') || params.get('projectId') || '';
      const activeProjectName = params.get('activeProjectName') || '';
      const activeProject = activeProjectId ? loadActiveProjectContext(activeProjectId) : null;
      const projectName = activeProject?.name || activeProjectName || 'Untitled Project';
      const client = activeProject?.client || '';
      const address = activeProject?.address || '';

      projectLabel.textContent = activeProjectId
        ? `Active project: ${projectName} (${activeProjectId})`
        : 'No active project selected. Showing a template project structure.';

      let uploadStatus = '';
      const projectContext = {
        activeProjectId,
        projectId: activeProjectId,
        projectName,
        projectFile: null,
        uploadStatus: '',
        uploadProgress: null,
        uploadStatusListeners: [],
        setUploadStatus(message) {
          uploadStatus = message;
          this.uploadStatus = message;
          for (const listener of this.uploadStatusListeners) {
            listener(this.uploadStatus, this.uploadProgress);
          }
        },
        setUploadProgress(percent) {
          this.uploadProgress = typeof percent === 'number' && Number.isFinite(percent) ? percent : null;
          for (const listener of this.uploadStatusListeners) {
            listener(this.uploadStatus, this.uploadProgress);
          }
        },
        addUploadStatusListener(listener) {
          if (typeof listener !== 'function') return;
          this.uploadStatusListeners.push(listener);
          listener(this.uploadStatus, this.uploadProgress);
        },
      };

      const storedProjectFile = loadStoredProjectFile(window.localStorage, activeProjectId);
        if (storedProjectFile) {
        projectContext.projectFile = storedProjectFile;
        projectContext.uploadStatus = uploadStatus;
        if (activeProjectId) {
          try {
            await syncProjectDrawingsFromApi(projectContext);
          } catch {}
          try {
            await syncProjectPointFilesFromApi(projectContext);
          } catch {}
          try {
            await syncProjectCpfsFromApi(projectContext);
          } catch {}
        }
        renderTree(storedProjectFile, projectContext);
        return;
      }

      const templateUrl = new URL('/api/project-file/template', window.location.origin);
      templateUrl.searchParams.set('projectId', activeProjectId || 'project-browser-preview');
      templateUrl.searchParams.set('projectName', projectName);
      if (client) templateUrl.searchParams.set('client', client);
      if (address) templateUrl.searchParams.set('address', address);

      try {
        const response = await fetch(templateUrl.toString());
        if (!response.ok) {
          throw new Error(`Unable to load project file (${response.status})`);
        }
        const payload = await response.json();
        if (!payload?.projectFile) {
          throw new Error('Malformed response from project template endpoint.');
        }

        projectContext.projectFile = payload.projectFile;
        projectContext.uploadStatus = uploadStatus;
        if (activeProjectId) {
          try {
            await syncProjectDrawingsFromApi(projectContext);
          } catch {}
          try {
            await syncProjectPointFilesFromApi(projectContext);
          } catch {}
          try {
            await syncProjectCpfsFromApi(projectContext);
          } catch {}
        }
        renderTree(payload.projectFile, projectContext);
      } catch (err) {
        renderError(`Project browser failed to load: ${err.message}`);
      }
    }

    initialize();
  </script>
</body>
</html>
