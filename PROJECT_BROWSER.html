<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EvidenceDesk</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b1220;
      --panel: #172033;
      --panel-alt: #1e293b;
      --border: rgba(148, 163, 184, 0.25);
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #38bdf8;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #1e293b 0%, var(--bg) 60%);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      min-height: 100vh;
      padding: 1rem;
    }

    .app-shell {
      margin: 0 auto;
      max-width: 920px;
      background: rgba(15, 23, 42, 0.72);
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow: hidden;
    }

    header {
      padding: 0.95rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.9);
    }

    h1 {
      margin: 0;
      font-size: 1.05rem;
    }

    .subtitle {
      margin: 0.3rem 0 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .content {
      padding: 1rem;
      display: grid;
      gap: 0.75rem;
    }

    .tree-root,
    .folder-row,
    .file-row {
      display: flex;
      align-items: center;
      gap: 0.55rem;
      border-radius: 8px;
      padding: 0.42rem 0.55rem;
    }

    .upload-panel {
      margin-left: 1.65rem;
      border: 1px dashed rgba(56, 189, 248, 0.45);
      border-radius: 10px;
      padding: 0.75rem;
      background: rgba(15, 23, 42, 0.5);
      display: grid;
      gap: 0.55rem;
    }

    .upload-panel.drag-active {
      border-color: #7dd3fc;
      background: rgba(14, 116, 144, 0.2);
    }

    .upload-actions {
      display: flex;
      gap: 0.55rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .upload-actions input[type="file"] {
      display: none;
    }

    .upload-status {
      font-size: 0.82rem;
      color: var(--muted);
      min-height: 1.1rem;
    }

    .upload-progress {
      width: 100%;
      height: 0.4rem;
      accent-color: #38bdf8;
    }

    .upload-progress[hidden] {
      display: none;
    }

    .tree-root,
    .folder-row {
      background: var(--panel);
      border: 1px solid var(--border);
    }

    .folder-row {
      margin-top: 0.45rem;
      background: var(--panel-alt);
      justify-content: space-between;
    }

    .folder-title {
      display: flex;
      align-items: center;
      gap: 0.55rem;
      min-width: 0;
    }

    .file-row {
      margin-left: 1.65rem;
      color: var(--muted);
      font-size: 0.86rem;
      justify-content: space-between;
      gap: 0.8rem;
    }

    .file-row.pointforge-openable {
      cursor: pointer;
      border: 1px solid transparent;
      transition: border-color 100ms ease, background-color 100ms ease;
    }

    .file-row.pointforge-openable:hover,
    .file-row.pointforge-openable:focus-visible {
      border-color: rgba(56, 189, 248, 0.45);
      background: rgba(30, 41, 59, 0.72);
      color: var(--text);
      outline: none;
    }

    .file-meta {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      min-width: 0;
    }

    .point-file-preview-thumb {
      width: 86px;
      height: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      object-fit: cover;
      background: rgba(2, 6, 23, 0.7);
      flex: none;
    }

    .drawing-preview-thumb {
      width: 86px;
      height: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      object-fit: cover;
      background: rgba(2, 6, 23, 0.7);
      flex: none;
    }

    .pdf-preview-thumb {
      width: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.22);
      pointer-events: none;
      flex: none;
      object-fit: cover;
      background: #ffffff;
    }

    .image-preview-thumb {
      width: 86px;
      height: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      pointer-events: none;
      flex: none;
      object-fit: cover;
      background: rgba(2, 6, 23, 0.7);
    }

    .pdf-preview-placeholder {
      width: 86px;
      height: 50px;
      border-radius: 6px;
      border: 1px dashed rgba(148, 163, 184, 0.45);
      background: linear-gradient(145deg, #f8fafc 0%, #e2e8f0 100%);
      color: #475569;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.58rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      flex: none;
    }

    .pdf-preview-placeholder.pdf-preview-failed {
      border-style: solid;
      border-color: rgba(248, 113, 113, 0.5);
      background: linear-gradient(145deg, rgba(127, 29, 29, 0.45) 0%, rgba(69, 10, 10, 0.6) 100%);
      color: #fecaca;
    }

    .file-name {
      display: flex;
      align-items: baseline;
      gap: 0.3rem;
      min-width: 0;
    }

    .file-preview-slot {
      display: inline-flex;
      align-items: center;
      flex: none;
    }

    .file-name-configured {
      color: #f8fafc;
      font-weight: 600;
      flex: none;
    }

    .file-name-actual {
      color: var(--muted);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      min-width: 0;
    }

    .launch-btn {
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.8);
      color: var(--text);
      border-radius: 8px;
      padding: 0.25rem 0.55rem;
      font-size: 0.78rem;
      cursor: pointer;
      flex: none;
    }

    .launch-btn:hover {
      border-color: rgba(56, 189, 248, 0.5);
      color: #bae6fd;
    }

    .launch-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .icon {
      width: 1.2rem;
      text-align: center;
      flex: none;
    }

    .muted {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .empty {
      margin-left: 1.65rem;
      color: var(--muted);
      font-style: italic;
      font-size: 0.86rem;
    }

    .error {
      border: 1px solid rgba(239, 68, 68, 0.4);
      border-radius: 10px;
      color: #fecaca;
      background: rgba(127, 29, 29, 0.24);
      padding: 0.75rem;
    }
  </style>
  <script type="module" src="/src/browser-localstorage-sync.js"></script>
</head>
<body>
  <div class="app-shell">
    <header>
      <h1>üìÅ SurveyFoundry EvidenceDesk</h1>
      <p class="subtitle" id="projectLabel">Loading active project‚Ä¶</p>
    </header>
    <section class="content" id="treeContainer"></section>
  </div>

  <script type="module">
    import { loadStoredProjectFile, saveStoredProjectFile, appendResourceToFolder, removeResourceById, renameResourceTitle, findCpfPointLinksAsync } from './src/project-browser-state.js';
    import { renderLineworkThumbnailDataUrl, renderPointFileThumbnailDataUrl } from './src/point-thumbnail-client.js';

    const POINTFORGE_PROJECT_BROWSER_IMPORT_STORAGE_KEY = 'pointforgeProjectBrowserImport';
    const LINESMITH_PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY = 'lineSmithProjectBrowserDrawingImport';
    const PROJECT_DRAWING_STORAGE_PREFIX = 'surveyfoundryLineSmithDrawing';
    const ADA_CPF_PDF_BASE = 'https://gisprod.adacounty.id.gov/apps/acdscpf/CpfPdfs/';
    const projectLabel = document.getElementById('projectLabel');
    const treeContainer = document.getElementById('treeContainer');

    function openLinkedApp(path) {
      try {
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({
            type: 'survey-cad:navigate-app',
            path,
          }, window.location.origin);
          return;
        }
      } catch {
        // If parent access is blocked, fallback to same-tab navigation.
      }
      window.location.assign(path);
    }

    function buildProjectPointFileApiUrl(projectId = '', pointFileId = '') {
      if (!projectId) return '';
      const base = `/api/projects/${encodeURIComponent(projectId)}/point-files`;
      return pointFileId ? `${base}/${encodeURIComponent(pointFileId)}` : base;
    }

    function buildProjectDrawingApiUrl(projectId = '', drawingId = '') {
      if (!projectId) return '';
      const base = `/api/projects/${encodeURIComponent(projectId)}/drawings`;
      return drawingId ? `${base}/${encodeURIComponent(drawingId)}` : base;
    }

    function buildProjectDrawingStorageKey(projectId = '', drawingId = '') {
      if (!projectId || !drawingId) return '';
      return `${PROJECT_DRAWING_STORAGE_PREFIX}:${projectId}:${drawingId}`;
    }

    function mapApiPointFileToResource(projectId, pointFile = {}) {
      const pointFileId = String(pointFile.pointFileId || '').trim();
      const pointFileName = String(pointFile.pointFileName || pointFileId || 'Point File').trim();
      return {
        id: pointFileId,
        folder: 'point-files',
        title: pointFileName,
        exportFormat: pointFile.exportFormat || 'csv',
        reference: {
          type: 'project-point-file',
          value: pointFileId,
          resolverHint: 'project-point-file-api',
          metadata: {
            projectId,
            pointFileId,
          },
        },
      };
    }

    async function syncProjectPointFilesFromApi(projectContext = {}) {
      if (!projectContext?.activeProjectId || !projectContext?.projectFile) return;
      const response = await fetch(buildProjectPointFileApiUrl(projectContext.activeProjectId));
      if (!response.ok) throw new Error(`Unable to list project point files (${response.status}).`);
      const payload = await response.json();
      const list = Array.isArray(payload?.pointFiles) ? payload.pointFiles : [];

      const folder = projectContext.projectFile?.folders?.find((entry) => entry.key === 'point-files');
      if (!folder) return;
      folder.index = list.map((entry) => mapApiPointFileToResource(projectContext.activeProjectId, entry));
      saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
    }

    function mapApiDrawingToResource(projectId, drawing = {}) {
      const drawingId = String(drawing.drawingId || '').trim();
      const drawingName = String(drawing.drawingName || drawingId || 'Drawing').trim();
      return {
        id: `linesmith-${drawingId}`,
        folder: 'drawings',
        title: drawingName,
        exportFormat: 'json',
        reference: {
          type: 'project-drawing',
          value: drawingId,
          resolverHint: 'project-drawing-api',
          metadata: {
            projectId,
            drawingId,
            drawingName,
            versionCount: Number(drawing.versionCount) || 0,
            latestVersionId: drawing.latestVersionId || null,
            latestMapGeoreference: drawing.latestMapGeoreference || null,
            updatedAt: drawing.updatedAt || null,
            storageKey: buildProjectDrawingStorageKey(projectId, drawingId),
          },
        },
      };
    }

    async function syncProjectDrawingsFromApi(projectContext = {}) {
      if (!projectContext?.activeProjectId || !projectContext?.projectFile) return;
      const response = await fetch(buildProjectDrawingApiUrl(projectContext.activeProjectId));
      if (!response.ok) throw new Error(`Unable to list project drawings (${response.status}).`);
      const payload = await response.json();
      const list = Array.isArray(payload?.drawings) ? payload.drawings : [];

      const folder = projectContext.projectFile?.folders?.find((entry) => entry.key === 'drawings');
      if (!folder) return;
      folder.index = list.map((entry) => mapApiDrawingToResource(projectContext.activeProjectId, entry));
      saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
    }

    async function cacheProjectDrawingRecord(resource) {
      const ref = resource?.reference;
      const projectId = ref?.metadata?.projectId || '';
      const drawingId = ref?.metadata?.drawingId || ref?.value || '';
      if (!projectId || !drawingId) return '';

      const storageKey = ref?.metadata?.storageKey || buildProjectDrawingStorageKey(projectId, drawingId);
      const response = await fetch(buildProjectDrawingApiUrl(projectId, drawingId));
      if (!response.ok) {
        throw new Error(`Unable to load drawing (${response.status}).`);
      }
      const payload = await response.json();
      const drawing = payload?.drawing;
      if (!drawing?.versions?.length) {
        throw new Error('Drawing payload was missing version history.');
      }
      localStorage.setItem(storageKey, JSON.stringify(drawing));
      return storageKey;
    }

    async function resolvePointFileText(resource) {
      const ref = resource?.reference;
      if (!ref?.value) return null;

      if (ref.type === 'local-storage') {
        const raw = localStorage.getItem(ref.value);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        const text = parsed?.text;
        return typeof text === 'string' ? text : null;
      }

      if (ref.type === 'server-upload') {
        const response = await fetch(ref.value);
        if (!response.ok) return null;
        return await response.text();
      }

      if (ref.type === 'project-point-file') {
        const projectId = ref.metadata?.projectId || resource?.projectId || '';
        const pointFileId = ref.metadata?.pointFileId || ref.value || resource?.id || '';
        if (!projectId || !pointFileId) return null;
        const response = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId));
        if (!response.ok) return null;
        const payload = await response.json();
        return String(payload?.pointFile?.currentState?.text || '');
      }

      return null;
    }



    async function attachPointFilePreview(resource, entry) {
      if (!resource || !entry) return;
      const text = await resolvePointFileText(entry);
      if (!text || !text.trim()) return;
      const previewUrl = renderPointFileThumbnailDataUrl(text, { width: 86, height: 50 });
      if (!previewUrl) return;
      const thumb = document.createElement('img');
      thumb.className = 'point-file-preview-thumb';
      thumb.src = previewUrl;
      thumb.alt = `${entry?.title || entry?.id || 'Point file'} preview`;
      resource.querySelector('.file-preview-slot')?.replaceChildren(thumb);
    }

    async function resolveDrawingPoints(resource) {
      const ref = resource?.reference;
      if (!ref) return [];

      if (ref.type === 'local-storage') {
        const raw = localStorage.getItem(ref.value);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed?.currentState?.points) ? parsed.currentState.points : [];
      }

      if (ref.type === 'project-drawing') {
        const projectId = ref.metadata?.projectId || '';
        const drawingId = ref.metadata?.drawingId || ref.value || '';
        if (!projectId || !drawingId) return [];
        const response = await fetch(buildProjectDrawingApiUrl(projectId, drawingId));
        if (!response.ok) return [];
        const payload = await response.json();
        return Array.isArray(payload?.drawing?.currentState?.points) ? payload.drawing.currentState.points : [];
      }

      return [];
    }

    async function attachDrawingPreview(resource, entry) {
      if (!resource || !entry) return;
      const points = await resolveDrawingPoints(entry);
      if (!Array.isArray(points) || !points.length) return;
      const previewUrl = renderLineworkThumbnailDataUrl(points, { width: 86, height: 50 });
      if (!previewUrl) return;
      const thumb = document.createElement('img');
      thumb.className = 'drawing-preview-thumb';
      thumb.src = previewUrl;
      thumb.alt = `${entry?.title || entry?.id || 'Drawing'} preview`;
      resource.querySelector('.file-preview-slot')?.replaceChildren(thumb);
    }

    async function launchLineSmithFromDrawingResource(resource, projectContext = {}) {
      let storageKey = resource?.reference?.value;
      if (resource?.reference?.type === 'project-drawing') {
        try {
          storageKey = await cacheProjectDrawingRecord(resource);
        } catch (err) {
          renderError(`Selected drawing could not be opened. ${err.message}`);
          return;
        }
      }
      const drawingId = String(resource?.reference?.metadata?.drawingId || resource?.id || '').replace(/^linesmith-/, '').trim();
      if (!storageKey && !drawingId) {

        renderError(`Selected drawing could not be opened. Missing storage key for ${resource?.title || 'resource'}.`);
        return;
      }

      localStorage.setItem(LINESMITH_PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY, JSON.stringify({
        storageKey,
        drawingId,
        drawingName: resource.title || resource.id || 'Drawing',
      }));

      const destination = new URL('/VIEWPORT.HTML', window.location.origin);
      destination.searchParams.set('source', 'project-browser-drawing');
      if (projectContext.projectId) destination.searchParams.set('activeProjectId', projectContext.projectId);
      if (projectContext.projectName) destination.searchParams.set('activeProjectName', projectContext.projectName);
      openLinkedApp(`${destination.pathname}${destination.search}`);
    }

    async function launchPointForgeFromResource(resource, projectContext = {}) {
      const text = await resolvePointFileText(resource);
      if (!text || !text.trim()) {
        renderError(`Selected point file could not be opened. Unable to load text for ${resource?.title || 'resource'}.`);
        return;
      }

      localStorage.setItem(POINTFORGE_PROJECT_BROWSER_IMPORT_STORAGE_KEY, JSON.stringify({
        csv: text,
        title: resource.title || resource.id || 'Point File',
        pointFileId: resource?.reference?.metadata?.pointFileId || resource?.id || '',
      }));

      const destination = new URL('/POINT_TRANSFORMER.HTML', window.location.origin);
      destination.searchParams.set('source', 'project-browser');
      if (projectContext.projectId) destination.searchParams.set('projectId', projectContext.projectId);
      if (projectContext.projectName) destination.searchParams.set('projectName', projectContext.projectName);
      openLinkedApp(`${destination.pathname}${destination.search}`);
    }

    async function renameResourceFromEvidenceDesk(folder, entry, projectContext = {}) {
      const currentTitle = String(entry?.title || '').trim() || 'Untitled';
      const nextTitleRaw = window.prompt('Rename file', currentTitle);
      if (nextTitleRaw == null) return;

      const nextTitle = String(nextTitleRaw || '').trim();
      if (!nextTitle || nextTitle === currentTitle) return;

      const projectId = projectContext?.activeProjectId;
      if (!projectId) {
        renderError('Cannot rename resources without an active project.');
        return;
      }

      try {
        if (entry?.reference?.type === 'project-point-file') {
          const pointFileId = entry?.reference?.metadata?.pointFileId || entry?.reference?.value || entry?.id;
          const detailRes = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId));
          if (!detailRes.ok) throw new Error(`Unable to load point file (${detailRes.status}).`);
          const detail = await detailRes.json();
          const currentState = detail?.pointFile?.currentState;
          if (!currentState || typeof currentState !== 'object') {
            throw new Error('Point file state was missing.');
          }

          const renameRes = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId), {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              pointFileName: nextTitle,
              pointFileState: currentState,
            }),
          });
          if (!renameRes.ok) throw new Error(`Unable to rename point file (${renameRes.status}).`);
          await syncProjectPointFilesFromApi(projectContext);
        } else if (entry?.reference?.type === 'project-drawing') {
          const drawingId = entry?.reference?.metadata?.drawingId || entry?.reference?.value || entry?.id;
          const detailRes = await fetch(buildProjectDrawingApiUrl(projectId, drawingId));
          if (!detailRes.ok) throw new Error(`Unable to load drawing (${detailRes.status}).`);
          const detail = await detailRes.json();
          const currentState = detail?.drawing?.currentState;
          if (!currentState || typeof currentState !== 'object') {
            throw new Error('Drawing state was missing.');
          }

          const renameRes = await fetch(buildProjectDrawingApiUrl(projectId, drawingId), {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              drawingName: nextTitle,
              drawingState: currentState,
            }),
          });
          if (!renameRes.ok) throw new Error(`Unable to rename drawing (${renameRes.status}).`);
          await syncProjectDrawingsFromApi(projectContext);
        } else {
          const renamed = renameResourceTitle(projectContext?.projectFile, folder?.key, entry?.id, nextTitle);
          if (!renamed) throw new Error('File rename could not be applied.');
        }

        saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
        projectContext.setUploadStatus(`Renamed ${currentTitle} to ${nextTitle}.`);
        renderTree(projectContext.projectFile, projectContext);
      } catch (err) {
        renderError(`Could not rename ${currentTitle}. ${err.message}`);
      }
    }

    async function deleteResourceFromEvidenceDesk(folder, entry, projectContext = {}) {
      const currentTitle = String(entry?.title || entry?.id || '').trim() || 'file';

      if (folder?.key === 'cpfs') {
        await deleteCpfResource(folder, entry, projectContext);
        return;
      }

      if (!window.confirm(`Remove "${currentTitle}" from the project?`)) return;

      const projectId = projectContext?.activeProjectId;
      if (!projectId) {
        renderError('Cannot delete resources without an active project.');
        return;
      }

      try {
        if (entry?.reference?.type === 'project-point-file') {
          const pointFileId = entry?.reference?.metadata?.pointFileId || entry?.reference?.value || entry?.id;
          if (!pointFileId) throw new Error('Point file id was missing.');
          const response = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId), { method: 'DELETE' });
          if (!response.ok) throw new Error(`Unable to delete point file (${response.status}).`);
          await syncProjectPointFilesFromApi(projectContext);
        } else if (entry?.reference?.type === 'project-drawing') {
          const drawingId = entry?.reference?.metadata?.drawingId || entry?.reference?.value || entry?.id;
          if (!drawingId) throw new Error('Drawing id was missing.');
          const response = await fetch(buildProjectDrawingApiUrl(projectId, drawingId), { method: 'DELETE' });
          if (!response.ok) throw new Error(`Unable to delete drawing (${response.status}).`);
          await syncProjectDrawingsFromApi(projectContext);
        } else {
          const removed = removeResourceById(projectContext?.projectFile, folder?.key, entry?.id);
          if (!removed) throw new Error('File delete could not be applied.');
        }

        saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
        projectContext.setUploadStatus(`Removed ${currentTitle}.`);
        renderTree(projectContext.projectFile, projectContext);
      } catch (err) {
        renderError(`Could not remove ${currentTitle}. ${err.message}`);
      }
    }

    function getCpfPdfUrl(resource) {
      const reference = resource?.reference || {};
      const metadata = reference.metadata || {};
      const referenceType = String(reference.type || '').trim();
      const referenceValue = String(reference.value || '').trim();
      const metadataPdf = typeof metadata.pdfUrl === 'string' ? metadata.pdfUrl.trim() : '';
      const instrument = String(metadata.instrument || referenceValue).trim();

      if (referenceType === 'server-upload' && referenceValue) {
        return new URL(referenceValue, window.location.origin).toString();
      }

      if (metadataPdf.startsWith('/')) {
        return new URL(metadataPdf, window.location.origin).toString();
      }

      let remoteUrl = '';
      if (/^https?:\/\//i.test(metadataPdf)) {
        remoteUrl = metadataPdf;
      } else if (instrument) {
        remoteUrl = `${ADA_CPF_PDF_BASE}${encodeURIComponent(instrument)}.pdf`;
      }

      if (!remoteUrl) return '';

      const proxyUrl = new URL('/api/ros-pdf', window.location.origin);
      proxyUrl.searchParams.set('url', remoteUrl);
      return proxyUrl.toString();
    }

    function buildPrintPreviewPdfUrl(pdfUrl) {
      if (!pdfUrl) return '';
      // PDF Open Parameters hide most built-in viewer chrome and ask for fit-to-page scaling.
      // Browsers may ignore unsupported flags, but this prevents sidebar/tool UI in engines that support them.
      return `${pdfUrl}#toolbar=0&navpanes=0&scrollbar=0&view=Fit&zoom=page-fit`;
    }

    function openCpfPdfFromResource(resource) {
      const pdfUrl = getCpfPdfUrl(resource);
      if (!pdfUrl) {
        renderError(`Selected CP&F file could not be opened. Missing instrument number for ${resource?.title || 'resource'}.`);
        return;
      }
      openPdfInNewWindow(pdfUrl);
    }

    function openPdfInNewWindow(pdfUrl) {
      if (!pdfUrl) return;
      const popup = window.open('', '_blank', 'popup=yes,width=1200,height=900');
      if (!popup) {
        renderError('Your browser blocked the PDF window. Please allow pop-ups and try again.');
        return;
      }
      popup.opener = null;
      popup.location.replace(pdfUrl);
    }

    function getPdfPreviewUrl(folder, entry) {
      if (folder?.key === 'cpfs') {
        return getCpfPdfUrl(entry);
      }
      if (entry?.reference?.type === 'server-upload') {
        return String(entry.reference.value || '').trim();
      }
      return '';
    }

    function isImageResource(entry) {
      const format = String(entry?.exportFormat || '').toLowerCase();
      return ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'].includes(format);
    }

    function attachImagePreview(resource, entry) {
      if (entry?.reference?.type !== 'server-upload') return;
      if (!isImageResource(entry)) return;

      const previewUrl = String(entry?.reference?.metadata?.thumbnailUrl || entry?.reference?.value || '').trim();
      if (!previewUrl) return;

      const slot = resource.querySelector('.file-preview-slot');
      if (!slot) return;

      const thumb = document.createElement('img');
      thumb.className = 'image-preview-thumb';
      thumb.src = previewUrl;
      thumb.alt = `${entry?.title || entry?.id || 'Image'} preview`;
      thumb.title = `${entry?.title || entry?.id || 'Image'} preview`;
      thumb.decoding = 'async';
      thumb.loading = 'lazy';
      slot.replaceChildren(thumb);
    }

    async function attachPdfPreview(resource, folder, entry) {
      const previewBaseUrl = getPdfPreviewUrl(folder, entry);
      if (!previewBaseUrl) return;

      const slot = resource.querySelector('.file-preview-slot');
      if (!slot) return;

      const placeholder = document.createElement('span');
      placeholder.className = 'pdf-preview-placeholder';
      placeholder.textContent = 'PDF';
      placeholder.title = 'Generating thumbnail‚Ä¶';
      slot.replaceChildren(placeholder);

      const thumbnailApiUrl = new URL('/api/project-files/pdf-thumbnail', window.location.origin);
      thumbnailApiUrl.searchParams.set('source', previewBaseUrl);
      const thumbnailKey = thumbnailApiUrl.toString();

      const applyThumbnail = async () => {
        const response = await fetch(thumbnailKey, { method: 'GET' });
        if (response.status === 202) return false;
        if (!response.ok) throw new Error(`thumbnail request failed (${response.status})`);
        const blob = await response.blob();
        const objectUrl = URL.createObjectURL(blob);
        const thumb = document.createElement('img');
        thumb.className = 'pdf-preview-thumb';
        thumb.src = objectUrl;
        thumb.alt = `${entry?.title || entry?.id || 'PDF'} preview`;
        thumb.title = `${entry?.title || entry?.id || 'PDF'} preview`;
        thumb.decoding = 'async';
        thumb.loading = 'lazy';
        slot.replaceChildren(thumb);
        return true;
      };
      try {
        const maxAttempts = 60;
        for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
          const done = await applyThumbnail();
          if (done) return;
          await new Promise((resolve) => setTimeout(resolve, Math.min(4000, 350 + (attempt * 200))));
        }
        placeholder.classList.add('pdf-preview-failed');
        placeholder.textContent = 'Unavailable';
        placeholder.title = 'Thumbnail preview is unavailable right now. Open the PDF to view it.';
      } catch {
        placeholder.classList.add('pdf-preview-failed');
        placeholder.textContent = 'Unavailable';
        placeholder.title = 'Thumbnail preview failed to load. Open the PDF to view it.';
      }
    }

    function describeCpfPointLinks(links = []) {
      if (!Array.isArray(links) || !links.length) return '';
      return links
        .map((link, index) => `${index + 1}. ${link.pointFileTitle} ‚Üí Point ${link.pointNumber} (${link.pointCode})`)
        .join('\n');
    }

    async function deleteCpfResource(folder, resource, projectContext) {
      const instrument = String(resource?.reference?.value || resource?.reference?.metadata?.instrument || '').trim();
      const links = await findCpfPointLinksAsync(projectContext?.projectFile, resolvePointFileText, instrument);
      let shouldDelete = true;
      if (links.length) {
        const detail = describeCpfPointLinks(links);
        shouldDelete = window.confirm(`This CP&F is linked to ${links.length} point${links.length === 1 ? '' : 's'}:\n\n${detail}\n\nDelete CP&F anyway?`);
      }
      if (!shouldDelete) return;

      const removed = removeResourceById(projectContext?.projectFile, folder?.key, resource?.id);
      if (!removed) {
        renderError(`Could not delete CP&F ${resource?.title || resource?.id || ''}.`);
        return;
      }

      const saved = saveStoredProjectFile(window.localStorage, projectContext?.activeProjectId, projectContext?.projectFile);
      if (!saved) {
        renderError('CP&F was removed in memory, but project snapshot could not be saved.');
        return;
      }

      const deletedTitle = resource?.title || resource?.id || instrument || 'CP&F record';
      projectContext.setUploadStatus(`Deleted ${deletedTitle}.`);
      renderTree(projectContext.projectFile, projectContext);
    }

    function escapeHtml(text = '') {
      return String(text)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function openCpfPrintPreview(resources = []) {
      const printableResources = resources
        .map((entry) => ({
          entry,
          url: getCpfPdfUrl(entry),
        }))
        .filter((item) => item.url);

      if (!printableResources.length) {
        renderError('No printable CP&F PDF records were found for this project.');
        return;
      }

      // Use a plain same-origin popup so browsers return a writable window handle.
      // Some engines return `null` when `noopener` is requested, which incorrectly
      // triggers our popup-blocked error path and leaves a blank preview tab.
      const printWindow = window.open('', '_blank');
      if (!printWindow) {
        renderError('Your browser blocked the print-preview window. Please allow pop-ups and try again.');
        return;
      }

      const pagesMarkup = printableResources.map(({ url }, index) => `
        <section class="page-block">
          <iframe src="${escapeHtml(buildPrintPreviewPdfUrl(url))}" title="CP&amp;F PDF ${index + 1}" class="pdf-frame"></iframe>
        </section>
      `).join('');

      printWindow.document.write(`<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CP&amp;F Print Preview</title>
  <style>
    :root { color-scheme: light; }
    body { font-family: Inter, system-ui, sans-serif; margin: 1rem; color: #0f172a; background: #fff; }
    .toolbar { position: sticky; top: 0; background: #fff; padding: 0.5rem 0; margin-bottom: 1rem; border-bottom: 1px solid #cbd5e1; }
    .print-button { font: inherit; padding: 0.45rem 0.8rem; border-radius: 6px; border: 1px solid #334155; background: #fff; cursor: pointer; }
    .page-block { margin: 0 0 1rem; display: flex; justify-content: center; background: #fff; }
    .pdf-frame { width: min(100%, 8.5in); height: 98vh; border: 1px solid #94a3b8; border-radius: 8px; display: block; margin: 0 auto; background: #fff; }
    @media print {
      @page { margin: 0; }
      .toolbar { display: none; }
      body { margin: 0; background: #fff; }
      .page-block { margin: 0; break-inside: avoid; page-break-inside: avoid; display: flex; justify-content: center; background: #fff; }
      .pdf-frame { width: 100%; border: none; border-radius: 0; height: 100vh; background: #fff; }
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <button type="button" class="print-button" onclick="window.print()">Print all CP&amp;F PDFs</button>
  </div>
  ${pagesMarkup}
</body>
</html>`);
      printWindow.document.close();
      printWindow.focus();
    }

    function loadActiveProjectContext(activeProjectId) {
      try {
        const projects = JSON.parse(localStorage.getItem('surveyfoundryProjects') || '[]');
        if (!Array.isArray(projects)) return null;
        return projects.find((project) => project.id === activeProjectId) || null;
      } catch {
        return null;
      }
    }

    function isSupportedPointFile(file) {
      const name = file?.name || '';
      return /\.(csv|txt)$/i.test(name);
    }

    async function uploadPointFilesToServer(files, context) {
      const accepted = Array.from(files || []).filter(isSupportedPointFile);
      if (!accepted.length) {
        context.setUploadStatus('No supported files found. Use .csv or .txt files.');
        return;
      }

      if (!context.activeProjectId || !context.projectFile) {
        context.setUploadStatus('Select an active project before uploading point files.');
        return;
      }

      let uploadedCount = 0;
      const totalFiles = accepted.length;
      for (let index = 0; index < accepted.length; index += 1) {
        const file = accepted[index];
        const currentFileNumber = index + 1;
        try {
          context.setUploadProgress(null);
          context.setUploadStatus(`Uploading point file ${currentFileNumber}/${totalFiles}: ${file.name}‚Ä¶`);
          const text = await file.text();
          const response = await fetch(buildProjectPointFileApiUrl(context.activeProjectId), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              pointFileName: file.name,
              pointFileState: { text, exportFormat: 'csv' },
              source: 'evidence-desk-upload',
              sourceLabel: file.name,
            }),
          });
          if (!response.ok) {
            const err = await response.json().catch(() => ({ error: 'Upload failed.' }));
            context.setUploadStatus(`Failed to upload ${file.name}: ${err.error}`);
            continue;
          }
          uploadedCount += 1;
          context.setUploadStatus(`Uploaded point file ${uploadedCount}/${totalFiles}: ${file.name}`);
        } catch (err) {
          context.setUploadStatus(`Network error uploading ${file.name}: ${err.message}`);
        }
      }

      if (!uploadedCount) {
        context.setUploadProgress(null);
        context.setUploadStatus('No point files were uploaded successfully.');
        return;
      }

      await syncProjectPointFilesFromApi(context);
      context.setUploadProgress(null);
      context.setUploadStatus(`Uploaded ${uploadedCount} point file${uploadedCount === 1 ? '' : 's'} to this project.`);
      renderTree(context.projectFile, context);
    }

    function uploadFileViaXhr(formData, onProgress) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', '/api/project-files/upload');

        xhr.upload.addEventListener('progress', (event) => {
          if (typeof onProgress === 'function') {
            onProgress(event);
          }
        });

        xhr.addEventListener('load', () => {
          let payload = null;
          try {
            payload = xhr.responseText ? JSON.parse(xhr.responseText) : null;
          } catch {
            payload = null;
          }

          if (xhr.status >= 200 && xhr.status < 300) {
            resolve({ ok: true, payload });
            return;
          }

          resolve({ ok: false, payload });
        });

        xhr.addEventListener('error', () => reject(new Error('Network request failed.')));
        xhr.send(formData);
      });
    }

    async function uploadFilesToServer(files, folderKey, context) {
      const fileList = Array.from(files || []);
      if (!fileList.length) {
        context.setUploadStatus('No files selected.');
        return;
      }
      if (!context.activeProjectId || !context.projectFile) {
        context.setUploadStatus('Select an active project before uploading files.');
        return;
      }
      if (!folderKey) {
        context.setUploadStatus('Please select a folder to upload into.');
        return;
      }

      let uploadedCount = 0;
      const totalFiles = fileList.length;
      for (let index = 0; index < fileList.length; index += 1) {
        const file = fileList[index];
        const currentFileNumber = index + 1;
        const formData = new FormData();
        formData.append('projectId', context.activeProjectId);
        formData.append('folderKey', folderKey);
        formData.append('file', file, file.name);

        try {
          context.setUploadProgress(null);
          const response = await uploadFileViaXhr(formData, (event) => {
            if (event.lengthComputable) {
              const progress = Math.round((event.loaded / event.total) * 100);
              context.setUploadProgress(progress);
              context.setUploadStatus(`Uploading ${currentFileNumber}/${totalFiles}: ${file.name} (${progress}%)`);
              return;
            }
            context.setUploadStatus(`Uploading ${currentFileNumber}/${totalFiles}: ${file.name}‚Ä¶`);
          });
          if (!response.ok) {
            const err = response.payload || { error: 'Upload failed.' };
            context.setUploadStatus(`Failed to upload ${file.name}: ${err.error}`);
            continue;
          }
          const { resource } = response.payload || {};
          const appended = appendResourceToFolder(context.projectFile, folderKey, resource);
          if (appended) {
            uploadedCount += 1;
            context.setUploadStatus(`Uploaded ${uploadedCount}/${totalFiles}: ${file.name}`);
          }
        } catch (err) {
          context.setUploadStatus(`Network error uploading ${file.name}: ${err.message}`);
        }
      }

      if (!uploadedCount) {
        context.setUploadProgress(null);
        context.setUploadStatus('No files were uploaded successfully.');
        return;
      }

      saveStoredProjectFile(window.localStorage, context.activeProjectId, context.projectFile);
      context.setUploadProgress(null);
      context.setUploadStatus(`Uploaded ${uploadedCount} file${uploadedCount === 1 ? '' : 's'} to project.`);
      renderTree(context.projectFile, context);
    }

    function createFileUploadPanel(context) {
      const panel = document.createElement('div');
      panel.className = 'upload-panel';

      const title = document.createElement('div');
      title.className = 'muted';
      title.textContent = 'Upload files to the project: drag files here, or choose files below.';
      panel.appendChild(title);

      const actions = document.createElement('div');
      actions.className = 'upload-actions';

      const folderSelect = document.createElement('select');
      folderSelect.className = 'launch-btn';
      folderSelect.style.padding = '0.3rem 0.45rem';
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = 'Select folder‚Ä¶';
      folderSelect.appendChild(defaultOption);
      for (const folder of context.projectFile?.folders || []) {
        const option = document.createElement('option');
        option.value = folder.key;
        option.textContent = folder.label;
        folderSelect.appendChild(option);
      }
      actions.appendChild(folderSelect);

      const picker = document.createElement('input');
      picker.type = 'file';
      picker.multiple = true;
      picker.style.display = 'none';
      picker.addEventListener('change', () => {
        if (picker.files.length) {
          uploadFilesToServer(picker.files, folderSelect.value, context);
        }
      });

      const pickerButton = document.createElement('button');
      pickerButton.type = 'button';
      pickerButton.className = 'launch-btn';
      pickerButton.textContent = 'Choose Files';
      pickerButton.addEventListener('click', () => {
        if (!folderSelect.value) {
          context.setUploadStatus('Please select a folder first.');
          const statusEl = panel.querySelector('.upload-status');
          if (statusEl) statusEl.textContent = context.uploadStatus;
          return;
        }
        picker.click();
      });

      actions.appendChild(pickerButton);
      actions.appendChild(picker);
      panel.appendChild(actions);

      const status = document.createElement('div');
      status.className = 'upload-status';
      status.textContent = context.uploadStatus || '';
      panel.appendChild(status);

      const progress = document.createElement('progress');
      progress.className = 'upload-progress';
      progress.max = 100;
      progress.hidden = true;
      panel.appendChild(progress);

      if (context?.addUploadStatusListener) {
        context.addUploadStatusListener((message, percent) => {
          status.textContent = message || '';
          if (typeof percent === 'number' && Number.isFinite(percent)) {
            progress.hidden = false;
            progress.value = Math.max(0, Math.min(100, percent));
          } else {
            progress.hidden = true;
            progress.removeAttribute('value');
          }
        });
      }

      panel.addEventListener('dragover', (event) => {
        event.preventDefault();
        panel.classList.add('drag-active');
      });
      panel.addEventListener('dragleave', () => panel.classList.remove('drag-active'));
      panel.addEventListener('drop', (event) => {
        event.preventDefault();
        panel.classList.remove('drag-active');
        if (!folderSelect.value) {
          context.setUploadStatus('Please select a folder before dropping files.');
          const statusEl = panel.querySelector('.upload-status');
          if (statusEl) statusEl.textContent = context.uploadStatus;
          return;
        }
        uploadFilesToServer(event.dataTransfer?.files, folderSelect.value, context);
      });

      return panel;
    }

    function createPointFileUploadPanel(context) {
      const panel = document.createElement('div');
      panel.className = 'upload-panel';

      const title = document.createElement('div');
      title.className = 'muted';
      title.textContent = 'Attach point files (.csv or .txt): drag files here on desktop, or choose files on mobile.';
      panel.appendChild(title);

      const actions = document.createElement('div');
      actions.className = 'upload-actions';

      const picker = document.createElement('input');
      picker.type = 'file';
      picker.accept = '.csv,text/csv,.txt,text/plain';
      picker.multiple = true;
      picker.addEventListener('change', () => uploadPointFilesToServer(picker.files, context));

      const pickerButton = document.createElement('button');
      pickerButton.type = 'button';
      pickerButton.className = 'launch-btn';
      pickerButton.textContent = 'Choose Point Files';
      pickerButton.addEventListener('click', () => picker.click());

      actions.appendChild(pickerButton);
      actions.appendChild(picker);
      panel.appendChild(actions);

      const status = document.createElement('div');
      status.className = 'upload-status';
      status.textContent = context.uploadStatus || '';
      panel.appendChild(status);

      const progress = document.createElement('progress');
      progress.className = 'upload-progress';
      progress.max = 100;
      progress.hidden = true;
      panel.appendChild(progress);

      if (context?.addUploadStatusListener) {
        context.addUploadStatusListener((message, percent) => {
          status.textContent = message || '';
          if (typeof percent === 'number' && Number.isFinite(percent)) {
            progress.hidden = false;
            progress.value = Math.max(0, Math.min(100, percent));
          } else {
            progress.hidden = true;
            progress.removeAttribute('value');
          }
        });
      }

      panel.addEventListener('dragover', (event) => {
        event.preventDefault();
        panel.classList.add('drag-active');
      });
      panel.addEventListener('dragleave', () => panel.classList.remove('drag-active'));
      panel.addEventListener('drop', (event) => {
        event.preventDefault();
        panel.classList.remove('drag-active');
        uploadPointFilesToServer(event.dataTransfer?.files, context);
      });

      return panel;
    }

    function renderTree(projectFile, projectContext = {}) {
      treeContainer.innerHTML = '';
      if (Array.isArray(projectContext.uploadStatusListeners)) {
        projectContext.uploadStatusListeners = [];
      }

      const root = document.createElement('div');
      root.className = 'tree-root';
      root.innerHTML = `<span class="icon">üóÇÔ∏è</span><strong>${projectFile.archive.rootFolderName}</strong><span class="muted">(symbolic root folder)</span>`;
      treeContainer.appendChild(root);

      treeContainer.appendChild(createFileUploadPanel(projectContext));

      for (const folder of projectFile.folders || []) {
        const folderRow = document.createElement('div');
        folderRow.className = 'folder-row';
        folderRow.innerHTML = `<span class="folder-title"><span class="icon">üìÅ</span><strong>${folder.label}</strong><span class="muted">${folder.description}</span></span>`;

        if (folder.key === 'cpfs') {
          const printAllButton = document.createElement('button');
          printAllButton.type = 'button';
          printAllButton.className = 'launch-btn';
          printAllButton.textContent = 'Print all';
          printAllButton.title = 'Builds a single print preview containing each CP&F PDF in order';
          printAllButton.addEventListener('click', () => openCpfPrintPreview(folder.index));
          printAllButton.disabled = !folder.index.some((entry) => entry?.exportFormat === 'pdf');
          folderRow.appendChild(printAllButton);
        }

        treeContainer.appendChild(folderRow);

        if (folder.key === 'point-files') {
          treeContainer.appendChild(createPointFileUploadPanel(projectContext));
        }

        if (!folder.index.length) {
          const empty = document.createElement('div');
          empty.className = 'empty';
          empty.textContent = 'No linked resources yet.';
          treeContainer.appendChild(empty);
          continue;
        }

        for (const entry of folder.index) {
          const resource = document.createElement('div');
          resource.className = 'file-row';

          const pointFileFormat = String(entry?.exportFormat || '').toLowerCase();
          const isPointFileFormat = pointFileFormat === 'csv' || pointFileFormat === 'txt';
          const canLaunchPointForge = folder.key === 'point-files'
            && isPointFileFormat
            && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'server-upload' || entry?.reference?.type === 'project-point-file');
          const canOpenLineSmithDrawing = folder.key === 'drawings'
            && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'project-drawing');
          const canOpenCpfPdf = folder.key === 'cpfs' && entry?.exportFormat === 'pdf';
          const isPdfResource = entry?.exportFormat === 'pdf';
          const isImageUpload = isImageResource(entry);
          const showThumbnailSlot = canLaunchPointForge || canOpenLineSmithDrawing || isPdfResource || isImageUpload;
          const actualFileName = `${entry.id}.${entry.exportFormat}`;
          const configuredFileName = entry?.title || actualFileName;
          const leadingIcon = showThumbnailSlot ? '' : '<span class="icon">üìÑ</span>';
          const thumbnailSlotMarkup = showThumbnailSlot ? '<span class="file-preview-slot" aria-hidden="true"></span>' : '';
          resource.innerHTML = `<span class="file-meta">${leadingIcon}${thumbnailSlotMarkup}<span class="file-name"><span class="file-name-configured">${configuredFileName}</span><span class="file-name-actual" title="${actualFileName}">‚Äî ${actualFileName}</span></span></span>`;

          if (canLaunchPointForge) {
            attachPointFilePreview(resource, entry).catch(() => {});
          }

          if (canOpenLineSmithDrawing) {
            attachDrawingPreview(resource, entry).catch(() => {});
          }

          if (isPdfResource) {
            attachPdfPreview(resource, folder, entry);
          }

          if (isImageUpload) {
            attachImagePreview(resource, entry);
          }

          if (canLaunchPointForge) {
            resource.classList.add('pointforge-openable');
            resource.setAttribute('role', 'button');
            resource.setAttribute('tabindex', '0');
            resource.title = 'Tap to open this point file in PointForge';
            resource.addEventListener('click', () => launchPointForgeFromResource(entry, projectContext));
            resource.addEventListener('keydown', (event) => {
              if (event.key !== 'Enter' && event.key !== ' ') return;
              event.preventDefault();
              launchPointForgeFromResource(entry, projectContext);
            });

            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'launch-btn';
            openButton.textContent = 'Open in PointForge';
            openButton.title = 'Loads this point file into PointForge input';
            openButton.addEventListener('click', (event) => {
              event.stopPropagation();
              launchPointForgeFromResource(entry, projectContext);
            });
            resource.appendChild(openButton);

            const deletePointFileButton = document.createElement('button');
            deletePointFileButton.type = 'button';
            deletePointFileButton.className = 'launch-btn';
            deletePointFileButton.textContent = 'Delete';
            deletePointFileButton.title = 'Remove this point file from the project';
            deletePointFileButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await deleteResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(deletePointFileButton);

            const renamePointFileButton = document.createElement('button');
            renamePointFileButton.type = 'button';
            renamePointFileButton.className = 'launch-btn';
            renamePointFileButton.textContent = 'Rename';
            renamePointFileButton.title = 'Rename this point file across project references';
            renamePointFileButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await renameResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(renamePointFileButton);
          }

          if (canOpenLineSmithDrawing) {
            resource.classList.add('pointforge-openable');
            resource.setAttribute('role', 'button');
            resource.setAttribute('tabindex', '0');
            resource.title = 'Tap to open this drawing in LineSmith';
            resource.addEventListener('click', () => launchLineSmithFromDrawingResource(entry, projectContext));
            resource.addEventListener('keydown', (event) => {
              if (event.key !== 'Enter' && event.key !== ' ') return;
              event.preventDefault();
              launchLineSmithFromDrawingResource(entry, projectContext);
            });

            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'launch-btn';
            openButton.textContent = 'Open in LineSmith';
            openButton.title = 'Loads this saved drawing into LineSmith';
            openButton.addEventListener('click', (event) => {
              event.stopPropagation();
              launchLineSmithFromDrawingResource(entry, projectContext);
            });
            resource.appendChild(openButton);

            const renameDrawingButton = document.createElement('button');
            renameDrawingButton.type = 'button';
            renameDrawingButton.className = 'launch-btn';
            renameDrawingButton.textContent = 'Rename';
            renameDrawingButton.title = 'Rename this drawing across project references';
            renameDrawingButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await renameResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(renameDrawingButton);

            const deleteDrawingButton = document.createElement('button');
            deleteDrawingButton.type = 'button';
            deleteDrawingButton.className = 'launch-btn';
            deleteDrawingButton.textContent = 'Delete';
            deleteDrawingButton.title = 'Remove this drawing from the project';
            deleteDrawingButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await deleteResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(deleteDrawingButton);
          }

          if (canOpenCpfPdf) {
            resource.classList.add('pointforge-openable');
            resource.setAttribute('role', 'button');
            resource.setAttribute('tabindex', '0');
            resource.title = 'Tap to open this CP&F PDF in a new browser window';
            resource.addEventListener('click', () => openCpfPdfFromResource(entry));
            resource.addEventListener('keydown', (event) => {
              if (event.key !== 'Enter' && event.key !== ' ') return;
              event.preventDefault();
              openCpfPdfFromResource(entry);
            });

            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'launch-btn';
            openButton.textContent = 'Open PDF';
            openButton.title = 'Opens this CP&F PDF in a new browser window';
            openButton.addEventListener('click', (event) => {
              event.stopPropagation();
              openCpfPdfFromResource(entry);
            });
            resource.appendChild(openButton);

            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'launch-btn';
            deleteButton.textContent = 'Delete';
            deleteButton.title = 'Delete this CP&F from the project file';
            deleteButton.addEventListener('click', (event) => {
              event.stopPropagation();
              deleteResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(deleteButton);

            const renameButton = document.createElement('button');
            renameButton.type = 'button';
            renameButton.className = 'launch-btn';
            renameButton.textContent = 'Rename';
            renameButton.title = 'Rename this file in the project EvidenceDesk index';
            renameButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await renameResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(renameButton);
          }

          const isServerUpload = entry?.reference?.type === 'server-upload' && !canLaunchPointForge;
          if (isServerUpload) {
            const downloadUrl = entry.reference.value;
            const isServerPdf = entry?.exportFormat === 'pdf';
            resource.classList.add('pointforge-openable');
            resource.setAttribute('role', 'button');
            resource.setAttribute('tabindex', '0');
            resource.title = 'Click to open this file';
            resource.addEventListener('click', () => {
              if (isServerPdf) {
                openPdfInNewWindow(downloadUrl);
                return;
              }
              window.open(downloadUrl, '_blank', 'noopener,noreferrer');
            });
            resource.addEventListener('keydown', (event) => {
              if (event.key !== 'Enter' && event.key !== ' ') return;
              event.preventDefault();
              if (isServerPdf) {
                openPdfInNewWindow(downloadUrl);
                return;
              }
              window.open(downloadUrl, '_blank', 'noopener,noreferrer');
            });

            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'launch-btn';
            openButton.textContent = 'Open';
            openButton.title = isServerPdf
              ? 'Opens this PDF in a new browser window'
              : 'Opens this file in a new tab';
            openButton.addEventListener('click', (event) => {
              event.stopPropagation();
              if (isServerPdf) {
                openPdfInNewWindow(downloadUrl);
                return;
              }
              window.open(downloadUrl, '_blank', 'noopener,noreferrer');
            });
            resource.appendChild(openButton);

            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'launch-btn';
            deleteButton.textContent = 'Delete';
            deleteButton.title = 'Remove this file from the project';
            deleteButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await deleteResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(deleteButton);

            const renameButton = document.createElement('button');
            renameButton.type = 'button';
            renameButton.className = 'launch-btn';
            renameButton.textContent = 'Rename';
            renameButton.title = 'Rename this file in the project EvidenceDesk index';
            renameButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await renameResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(renameButton);
          }

          if (!canLaunchPointForge && !canOpenLineSmithDrawing && !canOpenCpfPdf && !isServerUpload) {
            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'launch-btn';
            deleteButton.textContent = 'Delete';
            deleteButton.title = 'Remove this file from the project';
            deleteButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await deleteResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(deleteButton);

            const renameButton = document.createElement('button');
            renameButton.type = 'button';
            renameButton.className = 'launch-btn';
            renameButton.textContent = 'Rename';
            renameButton.title = 'Rename this file in the project EvidenceDesk index';
            renameButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await renameResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            resource.appendChild(renameButton);
          }

          treeContainer.appendChild(resource);
        }
      }

      const manifest = document.createElement('div');
      manifest.className = 'file-row';
      manifest.style.marginLeft = '0';
      manifest.innerHTML = '<span class="icon">üìÑ</span>project-file.json';
      treeContainer.appendChild(manifest);
    }

    function renderError(message) {
      treeContainer.innerHTML = `<div class="error">${message}</div>`;
    }

    async function initialize() {
      const params = new URLSearchParams(window.location.search);
      const activeProjectId = params.get('activeProjectId') || '';
      const activeProjectName = params.get('activeProjectName') || '';
      const activeProject = activeProjectId ? loadActiveProjectContext(activeProjectId) : null;
      const projectName = activeProject?.name || activeProjectName || 'Untitled Project';
      const client = activeProject?.client || '';
      const address = activeProject?.address || '';

      projectLabel.textContent = activeProjectId
        ? `Active project: ${projectName} (${activeProjectId})`
        : 'No active project selected. Showing a template project structure.';

      let uploadStatus = '';
      const projectContext = {
        activeProjectId,
        projectId: activeProjectId,
        projectName,
        projectFile: null,
        uploadStatus: '',
        uploadProgress: null,
        uploadStatusListeners: [],
        setUploadStatus(message) {
          uploadStatus = message;
          this.uploadStatus = message;
          for (const listener of this.uploadStatusListeners) {
            listener(this.uploadStatus, this.uploadProgress);
          }
        },
        setUploadProgress(percent) {
          this.uploadProgress = typeof percent === 'number' && Number.isFinite(percent) ? percent : null;
          for (const listener of this.uploadStatusListeners) {
            listener(this.uploadStatus, this.uploadProgress);
          }
        },
        addUploadStatusListener(listener) {
          if (typeof listener !== 'function') return;
          this.uploadStatusListeners.push(listener);
          listener(this.uploadStatus, this.uploadProgress);
        },
      };

      const storedProjectFile = loadStoredProjectFile(window.localStorage, activeProjectId);
        if (storedProjectFile) {
        projectContext.projectFile = storedProjectFile;
        projectContext.uploadStatus = uploadStatus;
        if (activeProjectId) {
          try {
            await syncProjectDrawingsFromApi(projectContext);
          } catch {}
          try {
            await syncProjectPointFilesFromApi(projectContext);
          } catch {}
        }
        renderTree(storedProjectFile, projectContext);
        return;
      }

      const templateUrl = new URL('/api/project-file/template', window.location.origin);
      templateUrl.searchParams.set('projectId', activeProjectId || 'project-browser-preview');
      templateUrl.searchParams.set('projectName', projectName);
      if (client) templateUrl.searchParams.set('client', client);
      if (address) templateUrl.searchParams.set('address', address);

      try {
        const response = await fetch(templateUrl.toString());
        if (!response.ok) {
          throw new Error(`Unable to load project file (${response.status})`);
        }
        const payload = await response.json();
        if (!payload?.projectFile) {
          throw new Error('Malformed response from project template endpoint.');
        }

        projectContext.projectFile = payload.projectFile;
        projectContext.uploadStatus = uploadStatus;
        if (activeProjectId) {
          try {
            await syncProjectDrawingsFromApi(projectContext);
          } catch {}
          try {
            await syncProjectPointFilesFromApi(projectContext);
          } catch {}
        }
        renderTree(payload.projectFile, projectContext);
      } catch (err) {
        renderError(`Project browser failed to load: ${err.message}`);
      }
    }

    initialize();
  </script>
</body>
</html>
