<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EvidenceDesk</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b1220;
      --panel: #172033;
      --panel-alt: #1e293b;
      --border: rgba(148, 163, 184, 0.25);
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #38bdf8;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #1e293b 0%, var(--bg) 60%);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      min-height: 100vh;
      padding: 1rem;
      box-sizing: border-box;
    }

    .app-shell {
      width: 100%;
      box-sizing: border-box;
      background: rgba(15, 23, 42, 0.72);
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow: hidden;
    }

    header {
      padding: 0.95rem 1rem;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.9);
    }

    h1 {
      margin: 0;
      font-size: 1.05rem;
    }

    .subtitle {
      margin: 0.3rem 0 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .content {
      padding: 1rem;
      display: grid;
      gap: 0.75rem;
    }

    .tree-root,
    .folder-row,
    .file-row {
      display: flex;
      align-items: center;
      gap: 0.55rem;
      border-radius: 8px;
      padding: 0.42rem 0.55rem;
    }

    .upload-panel {
      margin-left: 1.65rem;
      border: 1px dashed rgba(56, 189, 248, 0.45);
      border-radius: 10px;
      padding: 0.75rem;
      background: rgba(15, 23, 42, 0.5);
      display: grid;
      gap: 0.55rem;
    }

    .upload-panel.drag-active {
      border-color: #7dd3fc;
      background: rgba(14, 116, 144, 0.2);
    }

    .upload-actions {
      display: flex;
      gap: 0.55rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .upload-actions input[type="file"] {
      display: none;
    }

    .upload-status {
      font-size: 0.82rem;
      color: var(--muted);
      min-height: 1.1rem;
    }

    .upload-progress {
      width: 100%;
      height: 0.4rem;
      accent-color: #38bdf8;
    }

    .upload-progress[hidden] {
      display: none;
    }

    .folder-upload-feedback {
      margin-left: 1.65rem;
      padding: 0 0.75rem;
      display: grid;
      gap: 0.3rem;
    }

    .tree-root,
    .folder-row {
      background: var(--panel);
      border: 1px solid var(--border);
    }

    .folder-row {
      margin-top: 0.45rem;
      background: var(--panel-alt);
      justify-content: space-between;
    }

    .folder-title {
      display: flex;
      align-items: center;
      gap: 0.55rem;
      min-width: 0;
    }

    .file-row {
      margin-left: 1.65rem;
      color: var(--muted);
      font-size: 0.86rem;
      justify-content: space-between;
      gap: 0.8rem;
      flex-wrap: wrap;
      position: relative;
    }

    .cpf-star-btn {
      position: absolute;
      top: 0.3rem;
      right: 0.45rem;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.05rem;
      line-height: 1;
      padding: 2px;
      color: #64748b;
      opacity: 0.65;
      transition: color 150ms ease, opacity 150ms ease;
    }

    .cpf-star-btn:hover:not(:disabled) {
      opacity: 1;
      color: #e2e8f0;
    }

    .cpf-star-btn[aria-pressed="true"] {
      color: #eab308;
      opacity: 1;
    }

    .cpf-star-btn:disabled {
      cursor: not-allowed;
      opacity: 0.35;
    }

    .icon {
      width: 1.2rem;
      text-align: center;
      flex: none;
    }

    .muted {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .error {
      padding: 0.85rem;
      border-radius: 10px;
      border: 1px solid rgba(248, 113, 113, 0.45);
      background: rgba(127, 29, 29, 0.22);
      color: #fecaca;
    }

    .empty {
      padding: 0.65rem 0.75rem;
      margin-left: 1.65rem;
      border-radius: 10px;
      border: 1px dashed rgba(148, 163, 184, 0.35);
      color: var(--muted);
      font-size: 0.85rem;
    }

    .tree-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
    }

    .add-folder-icon-btn {
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.65);
      color: var(--text);
      border-radius: 10px;
      width: 34px;
      height: 34px;
      cursor: pointer;
      flex: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
    }

    .add-folder-icon-btn:hover {
      border-color: rgba(56, 189, 248, 0.6);
      color: #bae6fd;
    }

    .add-folder-inline {
      margin-left: 1.65rem;
      padding: 0.6rem 0.75rem;
      border: 1px solid rgba(56, 189, 248, 0.35);
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.7);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .add-folder-input {
      flex: 1 1 auto;
      min-width: 120px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(2, 6, 23, 0.5);
      color: var(--text);
      padding: 0.38rem 0.55rem;
      outline: none;
    }

    .add-folder-input:focus {
      border-color: rgba(56, 189, 248, 0.7);
      box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.16);
    }

    .add-folder-input::placeholder {
      color: var(--muted);
    }

    .add-folder-cancel-btn {
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.7);
      color: var(--muted);
      border-radius: 10px;
      width: 34px;
      height: 34px;
      cursor: pointer;
      flex: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .add-folder-cancel-btn:hover {
      border-color: rgba(248, 113, 113, 0.55);
      color: #fecaca;
    }

    .remove-folder-btn {
      border: 1px solid rgba(239, 68, 68, 0.45);
      background: rgba(127, 29, 29, 0.18);
      color: #fca5a5;
      border-radius: 7px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      flex: none;
    }

    .remove-folder-btn:hover {
      border-color: rgba(239, 68, 68, 0.75);
      background: rgba(127, 29, 29, 0.35);
    }

    .folder-children {
      margin-left: 1.25rem;
      padding-left: 0.75rem;
      border-left: 2px solid rgba(148, 163, 184, 0.12);
    }

    /* Folder collapse/expand toggle */
    .folder-row {
      cursor: pointer;
      user-select: none;
    }
    .folder-collapse-chevron {
      font-size: 0.65rem;
      display: inline-block;
      transition: transform 180ms ease;
      flex: none;
      color: var(--muted);
      width: 0.85rem;
      text-align: center;
    }
    .folder-row[data-collapsed="false"] .folder-collapse-chevron {
      transform: rotate(90deg);
    }

    /* Thumbnail strip shown when folder is collapsed */
    .folder-thumbnail-strip {
      display: flex;
      flex-direction: row;
      gap: 0.5rem;
      overflow-x: auto;
      padding: 0.35rem 0.5rem 0.45rem 1.65rem;
      scrollbar-width: thin;
      scrollbar-color: rgba(148, 163, 184, 0.25) transparent;
      align-items: flex-start;
    }
    .folder-thumbnail-strip::-webkit-scrollbar {
      height: 4px;
    }
    .folder-thumbnail-strip::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.25);
      border-radius: 2px;
    }
    .folder-thumb-item {
      flex: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
      cursor: pointer;
      border-radius: 7px;
      padding: 4px;
      border: 1px solid transparent;
      transition: border-color 100ms ease, background-color 100ms ease;
    }
    .folder-thumb-item:hover {
      border-color: rgba(56, 189, 248, 0.5);
      background: rgba(30, 41, 59, 0.72);
    }
    .folder-thumb-img {
      width: 58px;
      height: 58px;
      border-radius: 5px;
      object-fit: cover;
      display: block;
      background: rgba(2, 6, 23, 0.7);
      border: 1px solid var(--border);
      flex: none;
    }
    .folder-thumb-img.pdf-thumb-bg {
      background: #ffffff;
    }
    .folder-thumb-label {
      font-size: 0.6rem;
      color: var(--muted);
      max-width: 58px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      text-align: center;
    }
    .folder-thumb-empty {
      color: var(--muted);
      font-size: 0.78rem;
      padding: 0.15rem 0.25rem;
    }
    .folder-thumb-placeholder {
      width: 58px;
      height: 58px;
      border-radius: 6px;
      border: 1px dashed rgba(148, 163, 184, 0.38);
      display: grid;
      place-items: center;
      color: rgba(148, 163, 184, 0.8);
      background: rgba(2, 6, 23, 0.35);
      font-size: 1.1rem;
    }

    .folder-drop-target {
      outline: 2px dashed rgba(56, 189, 248, 0.7);
      outline-offset: 2px;
      background: rgba(14, 116, 144, 0.25);
    }

    .folder-upload-drop-target {
      outline: 2px dashed rgba(74, 222, 128, 0.7);
      outline-offset: 2px;
      background: rgba(74, 222, 128, 0.08);
    }

    .file-list-container {
      margin-left: 1.65rem;
      display: grid;
      gap: 0.45rem;
      padding-bottom: 0.25rem;
    }

    .file-list-container.file-list-drop-target {
      border-radius: 8px;
      background: rgba(56, 189, 248, 0.06);
      outline: 1px dashed rgba(56, 189, 248, 0.45);
      outline-offset: 2px;
    }

    .file-list-container.file-list-upload-drop-target {
      border-radius: 8px;
      background: rgba(74, 222, 128, 0.06);
      outline: 1px dashed rgba(74, 222, 128, 0.45);
      outline-offset: 2px;
    }

    .file-meta {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      min-width: 0;
      flex: 1 1 auto;
    }

    .ros-number-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      margin-left: 0.45rem;
      padding: 0.12rem 0.45rem;
      border-radius: 999px;
      border: 1px solid rgba(125, 211, 252, 0.55);
      color: #bae6fd;
      background: rgba(8, 47, 73, 0.7);
      font-size: 0.72rem;
      white-space: nowrap;
    }

    .point-file-preview-thumb {
      width: 86px;
      height: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      object-fit: cover;
      background: rgba(2, 6, 23, 0.7);
      flex: none;
    }

    .drawing-preview-thumb {
      width: 86px;
      height: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      object-fit: cover;
      background: rgba(2, 6, 23, 0.7);
      flex: none;
    }

    .pdf-preview-thumb {
      width: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.22);
      flex: none;
      object-fit: cover;
      background: #ffffff;
      cursor: zoom-in;
    }

    .cpf-hover-preview-tooltip {
      position: fixed;
      z-index: 1400;
      padding: 0.5rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(2, 6, 23, 0.95);
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.6);
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 120ms ease;
    }

    .cpf-hover-preview-tooltip.visible {
      opacity: 1;
      visibility: visible;
    }

    .cpf-hover-preview-image {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 6px;
      background: #ffffff;
    }

    .image-preview-thumb {
      width: 86px;
      height: 86px;
      border-radius: 6px;
      border: 1px solid var(--border);
      pointer-events: none;
      flex: none;
      object-fit: cover;
      background: rgba(2, 6, 23, 0.7);
    }

    .pdf-preview-placeholder {
      width: 86px;
      height: 50px;
      border-radius: 6px;
      border: 1px dashed rgba(148, 163, 184, 0.45);
      background: linear-gradient(145deg, #f8fafc 0%, #e2e8f0 100%);
      color: #475569;
      display: grid;
      place-items: center;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .pdf-preview-placeholder.pdf-preview-failed {
      background: rgba(148, 163, 184, 0.1);
      color: rgba(148, 163, 184, 0.65);
    }

    .file-name {
      display: grid;
      gap: 0.15rem;
      min-width: 0;
    }

    .file-name-primary {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      flex-wrap: wrap;
      min-width: 0;
    }

    .file-name-configured {
      color: #f8fafc;
      font-weight: 600;
      min-width: 0;
      flex: 1 1 auto;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-actions {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 0.4rem;
      margin-left: auto;
      flex-wrap: wrap;
    }

    .point-file-version-details {
      width: 100%;
      margin-top: 0.35rem;
      margin-left: 2.05rem;
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 8px;
      background: rgba(15, 23, 42, 0.45);
      color: #cbd5e1;
      font-size: 0.76rem;
    }

    .point-file-version-summary {
      cursor: pointer;
      padding: 0.35rem 0.55rem;
      user-select: none;
      color: #e2e8f0;
      font-weight: 600;
    }

    .point-file-version-summary:hover {
      color: #f8fafc;
    }

    .point-file-version-list {
      margin: 0;
      padding: 0 0.55rem 0.55rem 1.1rem;
      list-style: decimal;
      display: grid;
      gap: 0.28rem;
    }

    .point-file-version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.45rem;
      flex-wrap: wrap;
    }

    .point-file-version-label {
      color: #cbd5e1;
    }

    .point-file-version-open {
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.85);
      color: #e2e8f0;
      border-radius: 6px;
      padding: 0.15rem 0.45rem;
      font-size: 0.72rem;
      cursor: pointer;
    }

    .launch-btn {
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.8);
      color: var(--text);
      border-radius: 8px;
      padding: 0.25rem 0.55rem;
      font-size: 0.78rem;
      cursor: pointer;
      flex: none;
    }

    .launch-btn:hover {
      border-color: rgba(56, 189, 248, 0.5);
      color: #bae6fd;
    }

    .launch-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .file-draggable {
      cursor: grab;
    }

    .file-dragging {
      opacity: 0.5;
    }

    .file-drag-ghost img {
      display: block;
      width: 86px;
      height: 86px;
      border-radius: 6px;
      object-fit: cover;
    }

    .association-list {
      margin: 0.15rem 0 0;
      padding: 0 0 0 1.05rem;
      list-style: none;
      color: rgba(148, 163, 184, 0.92);
      font-size: 0.76rem;
      display: grid;
      gap: 0.08rem;
    }

    .association-list-item {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .corner-group {
      border: 1px solid rgba(148, 163, 184, 0.18);
      background: rgba(15, 23, 42, 0.3);
      border-radius: 10px;
      padding: 0.4rem;
      display: grid;
      gap: 0.25rem;
    }

    .corner-group-label {
      font-size: 0.78rem;
      color: #cbd5e1;
      font-weight: 700;
      padding: 0.15rem 0.45rem 0.25rem;
    }

    .corner-group-more {
      margin-left: 2.05rem;
      padding-bottom: 0.25rem;
    }

    .corner-group-more > summary {
      list-style: none;
    }

    .corner-group-more > summary::-webkit-details-marker {
      display: none;
    }

    .pointforge-openable {
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <h1>EvidenceDesk</h1>
      <p class="subtitle">Project browser (folders collapse by default; thumbnails shown under collapsed folders)</p>
    </header>
    <main class="content">
      <div id="tree"></div>
    </main>
  </div>

  <script>
    /* --------------------- minimal scaffolding / helpers --------------------- */

    const treeContainer = document.getElementById('tree');

    const MAX_FOLDER_DEPTH = 6;

    // Collapse state: default collapsed (true). Expanded only when explicitly set to false.
    const folderCollapseState = new Map();

    function escapeHtml(text = '') {
      return String(text)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function openLinkedApp(path) {
      window.location.href = path;
    }

    /* --------------------- Project data IO (local storage snapshot) --------------------- */

    function loadStoredProjectFile(storage, projectId) {
      if (!storage || !projectId) return null;
      const key = `surveycad:projectfile:${projectId}`;
      const raw = storage.getItem(key);
      if (!raw) return null;
      try { return JSON.parse(raw); } catch { return null; }
    }

    function saveStoredProjectFile(storage, projectId, projectFile) {
      if (!storage || !projectId || !projectFile) return false;
      const key = `surveycad:projectfile:${projectId}`;
      try {
        storage.setItem(key, JSON.stringify(projectFile));
        return true;
      } catch {
        return false;
      }
    }

    /* --------------------- Project file model helpers --------------------- */

    function getFolderChildren(projectFile, parentKey) {
      const folders = Array.isArray(projectFile?.folders) ? projectFile.folders : [];
      return folders.filter((f) => String(f?.parentKey || '') === String(parentKey || ''));
    }

    function getFolderDepth(projectFile, folderKey) {
      const folders = Array.isArray(projectFile?.folders) ? projectFile.folders : [];
      let depth = 0;
      let current = folders.find((f) => f.key === folderKey);
      while (current && current.parentKey) {
        depth += 1;
        current = folders.find((f) => f.key === current.parentKey);
        if (depth > 50) break;
      }
      return depth;
    }

    function addCustomFolder(projectFile, { label, parentKey = '' } = {}) {
      if (!projectFile || !label) return null;
      const folders = Array.isArray(projectFile.folders) ? projectFile.folders : [];
      const parentDepth = parentKey ? getFolderDepth(projectFile, parentKey) : 0;
      if (parentKey && parentDepth >= MAX_FOLDER_DEPTH) return null;

      const nextKeyBase = String(label || '').trim().toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
      let nextKey = nextKeyBase || `folder-${Math.floor(Math.random() * 1e9)}`;
      let attempt = 0;
      while (folders.some((f) => f.key === nextKey) && attempt < 50) {
        attempt += 1;
        nextKey = `${nextKeyBase || 'folder'}-${attempt}`;
      }
      const folder = {
        key: nextKey,
        label: String(label || '').trim(),
        description: '',
        parentKey: parentKey || '',
        custom: true,
        index: [],
      };
      folders.push(folder);
      projectFile.folders = folders;
      return folder;
    }

    function removeCustomFolder(projectFile, folderKey) {
      if (!projectFile || !folderKey) return false;
      const folders = Array.isArray(projectFile.folders) ? projectFile.folders : [];
      const folder = folders.find((f) => f.key === folderKey);
      if (!folder?.custom) return false;
      projectFile.folders = folders.filter((f) => f.key !== folderKey);
      return true;
    }

    function removeResourceById(projectFile, folderKey, resourceId) {
      if (!projectFile || !folderKey || !resourceId) return false;
      const folder = (projectFile.folders || []).find((f) => f.key === folderKey);
      if (!folder || !Array.isArray(folder.index)) return false;
      const before = folder.index.length;
      folder.index = folder.index.filter((e) => e?.id !== resourceId);
      return folder.index.length !== before;
    }

    function appendResourceToFolder(projectFile, folderKey, resource) {
      if (!projectFile || !folderKey || !resource) return false;
      const folder = (projectFile.folders || []).find((f) => f.key === folderKey);
      if (!folder) return false;
      if (!Array.isArray(folder.index)) folder.index = [];
      folder.index.push(resource);
      return true;
    }

    function moveResourceById(projectFile, sourceFolderKey, targetFolderKey, resourceId) {
      if (!projectFile) return false;
      const sourceFolder = (projectFile.folders || []).find((f) => f.key === sourceFolderKey);
      const targetFolder = (projectFile.folders || []).find((f) => f.key === targetFolderKey);
      if (!sourceFolder || !targetFolder) return false;
      const entry = (sourceFolder.index || []).find((e) => e?.id === resourceId);
      if (!entry) return false;
      sourceFolder.index = (sourceFolder.index || []).filter((e) => e?.id !== resourceId);
      if (!Array.isArray(targetFolder.index)) targetFolder.index = [];
      targetFolder.index.push(entry);
      return true;
    }

    function renameResourceTitle(projectFile, folderKey, resourceId, nextTitle) {
      if (!projectFile || !folderKey || !resourceId) return false;
      const folder = (projectFile.folders || []).find((f) => f.key === folderKey);
      if (!folder || !Array.isArray(folder.index)) return false;
      const entry = folder.index.find((e) => e?.id === resourceId);
      if (!entry) return false;
      entry.title = nextTitle;
      return true;
    }

    /* --------------------- API helpers (server endpoints referenced by other apps) --------------------- */

    function buildProjectPointFileApiUrl(projectId, pointFileId) {
      const url = new URL('/api/project-point-files', window.location.origin);
      url.searchParams.set('projectId', projectId);
      if (pointFileId) url.searchParams.set('pointFileId', pointFileId);
      return url.toString();
    }

    function buildProjectDrawingApiUrl(projectId, drawingId) {
      const url = new URL('/api/project-drawings', window.location.origin);
      url.searchParams.set('projectId', projectId);
      if (drawingId) url.searchParams.set('drawingId', drawingId);
      return url.toString();
    }

    function buildProjectCpfApiUrl(projectId, cpfId) {
      const url = new URL('/api/project-cpfs', window.location.origin);
      url.searchParams.set('projectId', projectId);
      if (cpfId) url.searchParams.set('cpfId', cpfId);
      return url.toString();
    }

    /* --------------------- Thumbnails (point file + drawing) --------------------- */

    function renderPointFileThumbnailDataUrl(csvText, { width = 58, height = 58 } = {}) {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        if (!ctx) return '';
        ctx.clearRect(0, 0, width, height);

        ctx.fillStyle = 'rgba(2, 6, 23, 0.0)';
        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = 'rgba(125, 211, 252, 0.9)';
        ctx.lineWidth = 1.5;

        const lines = String(csvText || '').trim().split(/\r?\n/).slice(0, 60);
        const points = [];
        for (const line of lines) {
          const parts = line.split(',').map((v) => v.trim());
          if (parts.length < 3) continue;
          const east = Number(parts[1]);
          const north = Number(parts[2]);
          if (!Number.isFinite(east) || !Number.isFinite(north)) continue;
          points.push({ east, north });
        }
        if (points.length < 2) return '';

        const minE = Math.min(...points.map((p) => p.east));
        const maxE = Math.max(...points.map((p) => p.east));
        const minN = Math.min(...points.map((p) => p.north));
        const maxN = Math.max(...points.map((p) => p.north));
        const spanE = Math.max(1, maxE - minE);
        const spanN = Math.max(1, maxN - minN);

        const pad = 6;
        const sx = (width - pad * 2) / spanE;
        const sy = (height - pad * 2) / spanN;

        ctx.beginPath();
        for (let i = 0; i < points.length; i += 1) {
          const x = pad + (points[i].east - minE) * sx;
          const y = height - pad - (points[i].north - minN) * sy;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        return canvas.toDataURL('image/png');
      } catch {
        return '';
      }
    }

    function renderLineworkThumbnailDataUrl(points, { width = 58, height = 58 } = {}) {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        if (!ctx) return '';
        ctx.clearRect(0, 0, width, height);

        ctx.strokeStyle = 'rgba(134, 239, 172, 0.95)';
        ctx.lineWidth = 1.5;

        const xs = points.map((p) => Number(p?.x));
        const ys = points.map((p) => Number(p?.y));
        const finite = points.filter((p) => Number.isFinite(p?.x) && Number.isFinite(p?.y));
        if (finite.length < 2) return '';

        const minX = Math.min(...finite.map((p) => p.x));
        const maxX = Math.max(...finite.map((p) => p.x));
        const minY = Math.min(...finite.map((p) => p.y));
        const maxY = Math.max(...finite.map((p) => p.y));
        const spanX = Math.max(1, maxX - minX);
        const spanY = Math.max(1, maxY - minY);

        const pad = 6;
        const sx = (width - pad * 2) / spanX;
        const sy = (height - pad * 2) / spanY;

        ctx.beginPath();
        for (let i = 0; i < finite.length; i += 1) {
          const x = pad + (finite[i].x - minX) * sx;
          const y = height - pad - (finite[i].y - minY) * sy;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        return canvas.toDataURL('image/png');
      } catch {
        return '';
      }
    }

    /* --------------------- CP&F thumb & preview (hover tooltip) --------------------- */

    const ADA_CPF_PDF_BASE = 'https://adacountyassessor.org/ce/historicmaps/cpf/';
    const CPH_TOOLTIP_MARGIN = 16;
    const CPH_GAP = 14;
    let cpfHoverPreviewTooltip = null;

    function ensureCpfHoverPreviewTooltip() {
      if (cpfHoverPreviewTooltip) return cpfHoverPreviewTooltip;
      const tooltip = document.createElement('div');
      tooltip.className = 'cpf-hover-preview-tooltip';
      const image = document.createElement('img');
      image.className = 'cpf-hover-preview-image';
      image.alt = '';
      tooltip.appendChild(image);
      document.body.appendChild(tooltip);
      cpfHoverPreviewTooltip = tooltip;
      return tooltip;
    }

    function hideCpfHoverPreviewTooltip() {
      if (!cpfHoverPreviewTooltip) return;
      cpfHoverPreviewTooltip.classList.remove('visible');
      cpfHoverPreviewTooltip.style.width = '';
      cpfHoverPreviewTooltip.style.height = '';
      cpfHoverPreviewTooltip.style.left = '';
      cpfHoverPreviewTooltip.style.top = '';
    }

    function showCpfHoverPreviewTooltip(anchor, imageSrc, altText = 'Preview', sourceDimensions = null) {
      // Generic hover-preview tooltip (used for CP&F + folder thumbnail strips)
      if (!anchor || !imageSrc) return;

      const tooltip = ensureCpfHoverPreviewTooltip();
      const previewImage = tooltip.querySelector('.cpf-hover-preview-image');
      if (!previewImage) return;

      previewImage.src = imageSrc;
      previewImage.alt = altText;

      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const anchorRect = anchor.getBoundingClientRect();

      const naturalW = Number(sourceDimensions?.width || previewImage.naturalWidth || anchor.naturalWidth || 0);
      const naturalH = Number(sourceDimensions?.height || previewImage.naturalHeight || anchor.naturalHeight || 0);
      const safeH = naturalH > 0 ? naturalH : 1;
      const aspect = naturalW > 0 ? (naturalW / safeH) : (8.5 / 11);

      // Candidate regions (each guarantees the tooltip will not overlap the anchor).
      const margin = CPH_TOOLTIP_MARGIN;
      const gap = CPH_GAP;

      const candidates = [
        { side: 'right', maxW: viewportWidth - anchorRect.right - gap - margin, maxH: viewportHeight - (margin * 2) },
        { side: 'left',  maxW: anchorRect.left - gap - margin,                 maxH: viewportHeight - (margin * 2) },
        { side: 'bottom',maxW: viewportWidth - (margin * 2),                   maxH: viewportHeight - anchorRect.bottom - gap - margin },
        { side: 'top',   maxW: viewportWidth - (margin * 2),                   maxH: anchorRect.top - gap - margin },
      ];

      function fitToBox(maxW, maxH) {
        if (!Number.isFinite(maxW) || !Number.isFinite(maxH)) return null;
        if (maxW <= 0 || maxH <= 0) return null;
        // Size the preview to use as much of the available space as possible while preserving aspect.
        let w = maxW;
        let h = w / aspect;
        if (h > maxH) {
          h = maxH;
          w = h * aspect;
        }
        // Enforce a small practical minimum; if we can't hit it, don't show a tooltip (avoids covering the anchor).
        const minSide = 120;
        if (w < minSide || h < minSide) return null;
        return { w, h };
      }

      const scored = [];
      for (const c of candidates) {
        // Keep previews from becoming comically wide on ultrawide screens.
        const capW = c.side === 'left' || c.side === 'right'
          ? Math.min(c.maxW, Math.floor(viewportWidth * 0.72))
          : Math.min(c.maxW, Math.floor(viewportWidth * 0.92));
        const capH = Math.min(c.maxH, Math.floor(viewportHeight * 0.92));
        const fit = fitToBox(capW, capH);
        if (!fit) continue;
        scored.push({ side: c.side, ...fit, area: fit.w * fit.h });
      }

      if (!scored.length) {
        hideCpfHoverPreviewTooltip();
        return;
      }

      // Prefer the placement that yields the largest visible preview area.
      scored.sort((a, b) => b.area - a.area);
      const best = scored[0];

      let left = margin;
      let top = margin;

      if (best.side === 'right') {
        left = Math.round(anchorRect.right + gap);
        top = Math.round(anchorRect.top + (anchorRect.height / 2) - (best.h / 2));
        top = Math.min(Math.max(margin, top), viewportHeight - best.h - margin);
      } else if (best.side === 'left') {
        left = Math.round(anchorRect.left - gap - best.w);
        top = Math.round(anchorRect.top + (anchorRect.height / 2) - (best.h / 2));
        top = Math.min(Math.max(margin, top), viewportHeight - best.h - margin);
      } else if (best.side === 'bottom') {
        top = Math.round(anchorRect.bottom + gap);
        left = Math.round(anchorRect.left + (anchorRect.width / 2) - (best.w / 2));
        left = Math.min(Math.max(margin, left), viewportWidth - best.w - margin);
      } else { // top
        top = Math.round(anchorRect.top - gap - best.h);
        left = Math.round(anchorRect.left + (anchorRect.width / 2) - (best.w / 2));
        left = Math.min(Math.max(margin, left), viewportWidth - best.w - margin);
      }

      tooltip.style.width = `${Math.round(best.w)}px`;
      tooltip.style.height = `${Math.round(best.h)}px`;
      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;
      tooltip.classList.add('visible');
    }

    function bindCpfHoverPreview(thumb, entry) {
      if (!thumb) return;
      thumb.addEventListener('mouseenter', () => {
        showCpfHoverPreviewTooltip(
          thumb,
          thumb.src,
          `${entry?.title || entry?.id || 'CP&F'} enlarged preview`,
          {
            width: thumb.naturalWidth,
            height: thumb.naturalHeight,
          },
        );
      });
      thumb.addEventListener('mouseleave', () => hideCpfHoverPreviewTooltip());
      thumb.addEventListener('focus', () => {
        showCpfHoverPreviewTooltip(
          thumb,
          thumb.src,
          `${entry?.title || entry?.id || 'CP&F'} enlarged preview`,
          {
            width: thumb.naturalWidth,
            height: thumb.naturalHeight,
          },
        );
      });
      thumb.addEventListener('blur', () => hideCpfHoverPreviewTooltip());
    }

    window.addEventListener('scroll', () => hideCpfHoverPreviewTooltip(), { passive: true });
    window.addEventListener('resize', () => hideCpfHoverPreviewTooltip());

    /* --------------------- Resource open + preview resolution --------------------- */

    function getCpfPdfUrl(resource) {
      const reference = resource?.reference || {};
      const metadata = reference.metadata || {};
      const referenceType = String(reference.type || '').trim();
      const referenceValue = String(reference.value || '').trim();
      const metadataPdf = typeof metadata.pdfUrl === 'string' ? metadata.pdfUrl.trim() : '';
      const instrument = String(metadata.instrument || referenceValue).trim();

      if (referenceType === 'server-upload' && referenceValue) {
        return new URL(referenceValue, window.location.origin).toString();
      }

      if (metadataPdf.startsWith('/')) {
        return new URL(metadataPdf, window.location.origin).toString();
      }

      let remoteUrl = '';
      if (/^https?:\/\//i.test(metadataPdf)) {
        remoteUrl = metadataPdf;
      } else if (instrument) {
        remoteUrl = `${ADA_CPF_PDF_BASE}${encodeURIComponent(instrument)}.pdf`;
      }

      if (!remoteUrl) return '';

      const proxyUrl = new URL('/api/ros-pdf', window.location.origin);
      proxyUrl.searchParams.set('url', remoteUrl);
      return proxyUrl.toString();
    }

    function openPdfInNewWindow(pdfUrl) {
      if (!pdfUrl) return;
      const popup = window.open('', '_blank', 'popup=yes,width=1200,height=900');
      if (!popup) {
        renderError('Your browser blocked the PDF window. Please allow pop-ups and try again.');
        return;
      }
      popup.opener = null;
      popup.location.replace(pdfUrl);
    }

    function openCpfPdfFromResource(resource) {
      const pdfUrl = getCpfPdfUrl(resource);
      if (!pdfUrl) {
        renderError(`Selected CP&F file could not be opened. Missing instrument number for ${resource?.title || 'resource'}.`);
        return;
      }
      openPdfInNewWindow(pdfUrl);
    }

    function isImageResource(entry) {
      const format = String(entry?.exportFormat || '').toLowerCase();
      return ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'].includes(format);
    }

    function getPdfPreviewUrl(folder, entry) {
      if (folder?.key === 'cpfs') {
        return getCpfPdfUrl(entry);
      }
      if (entry?.reference?.type === 'server-upload') {
        return String(entry.reference.value || '').trim();
      }
      return '';
    }

    function getMimeTypeFromFormat(format) {
      const mimeMap = {
        pdf: 'application/pdf',
        png: 'image/png',
        jpg: 'image/jpeg',
        jpeg: 'image/jpeg',
        gif: 'image/gif',
        webp: 'image/webp',
        bmp: 'image/bmp',
        svg: 'image/svg+xml',
        csv: 'text/csv',
        txt: 'text/plain',
        json: 'application/json',
      };
      return mimeMap[String(format).toLowerCase()] || 'application/octet-stream';
    }

    function canMoveResourceBetweenFolders(entry, sourceFolderKey = '', targetFolderKey = '') {
      if (!entry || !sourceFolderKey || !targetFolderKey || sourceFolderKey === targetFolderKey) return false;
      const referenceType = String(entry?.reference?.type || '').trim();
      if (referenceType === 'project-point-file' || referenceType === 'project-drawing') return false;
      return true;
    }

    function resolveServerUploadLocation(entry, fallbackFolderKey = '') {
      const metadata = entry?.reference?.metadata || {};
      let folderKey = String(fallbackFolderKey || '').trim();
      let storedName = String(metadata?.storedName || '').trim();
      const referenceValue = String(entry?.reference?.value || '').trim();
      if (!referenceValue) return { folderKey, storedName };

      let parsed = null;
      try {
        parsed = new URL(referenceValue, window.location.origin);
      } catch {
        return { folderKey, storedName };
      }

      const queryFolderKey = String(parsed.searchParams.get('folderKey') || '').trim();
      const queryFileName = String(parsed.searchParams.get('fileName') || '').trim();
      if (queryFolderKey) folderKey = queryFolderKey;
      if (queryFileName) storedName = queryFileName;
      return { folderKey, storedName };
    }

    async function moveServerUploadResource(projectContext, sourceFolderKey, targetFolderKey, entry) {
      const projectId = String(projectContext?.activeProjectId || '').trim();
      const initialLocation = resolveServerUploadLocation(entry, sourceFolderKey);
      if (!projectId || !initialLocation?.storedName) throw new Error('Missing project upload metadata for move operation.');

      const sendMoveRequest = async (folderKey, fileName) => {
        const moveUrl = new URL('/api/project-files/file', window.location.origin);
        moveUrl.searchParams.set('projectId', projectId);
        moveUrl.searchParams.set('folderKey', folderKey);
        moveUrl.searchParams.set('fileName', fileName);

        const response = await fetch(moveUrl.toString(), {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ targetFolderKey }),
        });
        const payload = await response.json().catch(() => ({}));
        return { response, payload };
      };

      const firstAttempt = await sendMoveRequest(initialLocation.folderKey || sourceFolderKey, initialLocation.storedName);
      if (firstAttempt.response.ok) return firstAttempt.payload?.resource || null;

      // Retry with the rendered source folder key, in case older metadata encoded a different folder.
      const secondAttempt = await sendMoveRequest(sourceFolderKey, initialLocation.storedName);
      if (secondAttempt.response.ok) return secondAttempt.payload?.resource || null;

      throw new Error(secondAttempt.payload?.error || `Server returned ${secondAttempt.response.status}`);
    }

    async function deleteServerUploadResource(projectContext, folderKey, entry) {
      const projectId = String(projectContext?.activeProjectId || '').trim();
      const metadata = entry?.reference?.metadata || {};
      const storedFileName = String(metadata?.storedName || '').trim();
      if (!projectId || !folderKey || !storedFileName) throw new Error('Missing upload metadata for delete operation.');
      const url = new URL('/api/project-files/file', window.location.origin);
      url.searchParams.set('projectId', projectId);
      url.searchParams.set('folderKey', folderKey);
      url.searchParams.set('fileName', storedFileName);
      const response = await fetch(url.toString(), { method: 'DELETE' });
      const payload = await response.json().catch(() => ({}));
      if (!response.ok) throw new Error(payload?.error || `Server returned ${response.status}`);
      return payload;
    }

    async function fetchPdfThumbnailDataUrl(pdfUrl, {
      maxAttempts = 60,
      initialDelayMs = 350,
      maxDelayMs = 4000,
    } = {}) {
      if (!pdfUrl) return '';
      const thumbnailApiUrl = new URL('/api/project-files/pdf-thumbnail', window.location.origin);
      thumbnailApiUrl.searchParams.set('source', pdfUrl);
      const thumbnailKey = thumbnailApiUrl.toString();

      for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
        const response = await fetch(thumbnailKey, { method: 'GET' });
        if (response.status === 202) {
          await new Promise((resolve) => setTimeout(resolve, Math.min(maxDelayMs, initialDelayMs + (attempt * 200))));
          continue;
        }
        if (!response.ok) {
          throw new Error(`thumbnail request failed (${response.status})`);
        }
        const blob = await response.blob();
        if (typeof blob.arrayBuffer !== 'function') return '';
        const bytes = new Uint8Array(await blob.arrayBuffer());
        let binary = '';
        const chunkSize = 0x8000;
        for (let index = 0; index < bytes.length; index += chunkSize) {
          binary += String.fromCharCode(...bytes.subarray(index, index + chunkSize));
        }
        return `data:${blob.type || 'image/png'};base64,${btoa(binary)}`;
      }
      throw new Error('thumbnail generation timed out');
    }

    async function attachImagePreview(resource, entry) {
      if (entry?.reference?.type !== 'server-upload') return;
      if (!isImageResource(entry)) return;

      const previewUrl = String(entry?.reference?.metadata?.thumbnailUrl || entry?.reference?.value || '').trim();
      if (!previewUrl) return;

      const slot = resource.querySelector('.file-preview-slot');
      if (!slot) return;

      const thumb = document.createElement('img');
      thumb.className = 'image-preview-thumb';
      thumb.src = previewUrl;
      thumb.alt = `${entry?.title || entry?.id || 'Image'} preview`;
      thumb.title = `${entry?.title || entry?.id || 'Image'} preview`;
      thumb.decoding = 'async';
      thumb.loading = 'lazy';
      slot.replaceChildren(thumb);
    }

    async function attachPdfPreview(resource, folder, entry) {
      const previewBaseUrl = getPdfPreviewUrl(folder, entry);
      if (!previewBaseUrl) return;

      const slot = resource.querySelector('.file-preview-slot');
      if (!slot) return;

      const placeholder = document.createElement('span');
      placeholder.className = 'pdf-preview-placeholder';
      placeholder.textContent = 'PDF';
      placeholder.title = 'Generating thumbnailâ€¦';
      slot.replaceChildren(placeholder);

      const applyThumbnail = async () => {
        const thumbnailDataUrl = await fetchPdfThumbnailDataUrl(previewBaseUrl);
        if (!thumbnailDataUrl) return false;
        const thumb = document.createElement('img');
        thumb.className = 'pdf-preview-thumb';
        thumb.src = thumbnailDataUrl;
        thumb.alt = `${entry?.title || entry?.id || 'PDF'} preview`;
        thumb.title = `${entry?.title || entry?.id || 'PDF'} preview`;
        thumb.decoding = 'async';
        thumb.loading = 'lazy';
        if (folder?.key === 'cpfs') {
          thumb.tabIndex = 0;
          bindCpfHoverPreview(thumb, entry);
        }
        slot.replaceChildren(thumb);
        return true;
      };
      try {
        const done = await applyThumbnail();
        if (done) return;
        placeholder.classList.add('pdf-preview-failed');
        placeholder.textContent = 'Unavailable';
        placeholder.title = 'Thumbnail preview is unavailable right now. Open the PDF to view it.';
      } catch {
        placeholder.classList.add('pdf-preview-failed');
        placeholder.textContent = 'Unavailable';
        placeholder.title = 'Thumbnail preview failed to load. Open the PDF to view it.';
      }
    }

    /* --------------------- Point file + drawing open/preview helpers (stubs to match existing UI) --------------------- */

    const POINTFORGE_PROJECT_BROWSER_IMPORT_STORAGE_KEY = 'pointforge:project-browser:import';
    const LINESMITH_PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY = 'linesmith:project-browser:drawing';

    async function resolvePointFileText(resource) {
      // Prefer server record
      if (resource?.reference?.type === 'server-upload') {
        const url = String(resource?.reference?.value || '').trim();
        if (!url) return '';
        const res = await fetch(url);
        return await res.text();
      }
      if (resource?.reference?.type === 'local-storage') {
        const storageKey = String(resource?.reference?.value || '').trim();
        if (!storageKey) return '';
        return String(localStorage.getItem(storageKey) || '');
      }
      if (resource?.reference?.type === 'project-point-file') {
        const projectId = String(projectContext?.activeProjectId || '').trim();
        const pointFileId = String(resource?.reference?.metadata?.pointFileId || resource?.reference?.value || resource?.id || '').trim();
        if (!projectId || !pointFileId) return '';
        const res = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId));
        const payload = await res.json().catch(() => ({}));
        return String(payload?.pointFile?.csv || payload?.pointFile?.text || '');
      }
      return '';
    }

    async function resolveDrawingPoints(resource) {
      // Very lightweight: pull currentState points if present
      if (resource?.reference?.type === 'local-storage') {
        const storageKey = String(resource?.reference?.value || '').trim();
        if (!storageKey) return [];
        try {
          const raw = localStorage.getItem(storageKey);
          const parsed = raw ? JSON.parse(raw) : null;
          const pts = parsed?.points || parsed?.currentState?.points || [];
          return Array.isArray(pts) ? pts : [];
        } catch {
          return [];
        }
      }
      if (resource?.reference?.type === 'project-drawing') {
        // If you have a server drawing endpoint, fetch and extract points.
        return [];
      }
      return [];
    }

    async function attachPointFilePreview(resource, entry) {
      const slot = resource.querySelector('.file-preview-slot');
      if (!slot) return;
      try {
        const text = await resolvePointFileText(entry);
        const url = renderPointFileThumbnailDataUrl(text, { width: 86, height: 86 });
        if (!url) return;
        const img = document.createElement('img');
        img.className = 'point-file-preview-thumb';
        img.src = url;
        img.alt = `${entry?.title || entry?.id || 'Point File'} preview`;
        img.decoding = 'async';
        slot.replaceChildren(img);
      } catch {}
    }

    async function attachDrawingPreview(resource, entry) {
      const slot = resource.querySelector('.file-preview-slot');
      if (!slot) return;
      try {
        const pts = await resolveDrawingPoints(entry);
        const url = renderLineworkThumbnailDataUrl(pts, { width: 86, height: 86 });
        if (!url) return;
        const img = document.createElement('img');
        img.className = 'drawing-preview-thumb';
        img.src = url;
        img.alt = `${entry?.title || entry?.id || 'Drawing'} preview`;
        img.decoding = 'async';
        slot.replaceChildren(img);
      } catch {}
    }

    async function cacheProjectDrawingRecord(resource) {
      // Stub: return storage key if already present.
      if (resource?.reference?.type === 'local-storage') return resource?.reference?.value;
      return resource?.reference?.value || '';
    }

    async function launchLineSmithFromDrawingResource(resource, projectContext = {}) {
      let storageKey = resource?.reference?.value;
      if (resource?.reference?.type === 'project-drawing') {
        try {
          storageKey = await cacheProjectDrawingRecord(resource);
        } catch (err) {
          renderError(`Selected drawing could not be opened. ${err.message}`);
          return;
        }
      }
      const drawingId = String(resource?.reference?.metadata?.drawingId || resource?.id || '').replace(/^linesmith-/, '').trim();
      if (!storageKey && !drawingId) {
        renderError(`Selected drawing could not be opened. Missing storage key for ${resource?.title || 'resource'}.`);
        return;
      }

      localStorage.setItem(LINESMITH_PROJECT_BROWSER_DRAWING_IMPORT_STORAGE_KEY, JSON.stringify({
        storageKey,
        drawingId,
        drawingName: resource.title || resource.id || 'Drawing',
      }));

      const destination = new URL('/VIEWPORT.HTML', window.location.origin);
      destination.searchParams.set('source', 'project-browser-drawing');
      if (projectContext.projectId) destination.searchParams.set('activeProjectId', projectContext.projectId);
      if (projectContext.projectName) destination.searchParams.set('activeProjectName', projectContext.projectName);
      openLinkedApp(`${destination.pathname}${destination.search}`);
    }

    async function launchPointForgeFromResource(resource, projectContext = {}) {
      const text = await resolvePointFileText(resource);
      if (!text || !text.trim()) {
        renderError(`Selected point file could not be opened. Unable to load text for ${resource?.title || 'resource'}.`);
        return;
      }

      localStorage.setItem(POINTFORGE_PROJECT_BROWSER_IMPORT_STORAGE_KEY, JSON.stringify({
        csv: text,
        title: resource.title || resource.id || 'Point File',
        pointFileId: resource?.reference?.metadata?.pointFileId || resource?.id || '',
      }));

      const destination = new URL('/POINT_TRANSFORMER.HTML', window.location.origin);
      destination.searchParams.set('source', 'project-browser');
      if (projectContext.projectId) destination.searchParams.set('projectId', projectContext.projectId);
      if (projectContext.projectName) destination.searchParams.set('projectName', projectContext.projectName);
      openLinkedApp(`${destination.pathname}${destination.search}`);
    }

    /* --------------------- EvidenceDesk actions (rename/delete) --------------------- */

    function normalizeRosNumber(value = '') {
      return String(value || '').trim();
    }

    function normalizePointNumber(value = '') {
      return String(value || '').trim();
    }

    function buildPointFileActorMetadata(changeContext = '') {
      // Small helper for servers that require actor metadata.
      return {
        changeContext: String(changeContext || '').trim(),
        headers: {},
      };
    }

    async function syncProjectPointFilesFromApi(projectContext) {
      // Optional. Left as no-op if server doesn't support.
    }

    async function syncProjectDrawingsFromApi(projectContext) {
      // Optional. Left as no-op if server doesn't support.
    }

    async function syncProjectCpfsFromApi(projectContext) {
      // Optional. Left as no-op if server doesn't support.
    }

    async function fetchProjectPointFileRecord(entry) {
      // Optional; used only if version timeline exists server-side.
      return {};
    }

    function formatVersionTimelineStamp(value) {
      try {
        if (!value) return 'unknown';
        const d = new Date(value);
        if (Number.isNaN(d.getTime())) return String(value);
        return d.toLocaleString();
      } catch {
        return String(value || 'unknown');
      }
    }

    async function openProjectPointFileVersionInPointForge(entry, versionId, projectContext = {}) {
      // Optional stub
    }

    function attachPointFileVersionTimeline(details, entry, projectContext) {
      details.addEventListener('click', (event) => event.stopPropagation());
      details.addEventListener('keydown', (event) => event.stopPropagation());

      details.addEventListener('toggle', async () => {
        if (!details.open || details.dataset.loaded === 'true' || details.dataset.loading === 'true') return;
        details.dataset.loading = 'true';

        const summary = details.querySelector('.point-file-version-summary');
        try {
          const record = await fetchProjectPointFileRecord(entry);
          const versions = Array.isArray(record?.versions) ? [...record.versions].reverse() : [];
          summary.textContent = `Version timeline (${versions.length})`;

          const list = document.createElement('ol');
          list.className = 'point-file-version-list';
          for (const version of versions) {
            const actor = version?.actor || {};
            const actorUser = String(actor?.user || 'unknown-user').trim() || 'unknown-user';
            const actorTool = String(actor?.app || 'unknown-app').trim() || 'unknown-app';
            const savedAt = formatVersionTimelineStamp(version?.savedAt);

            const item = document.createElement('li');
            item.className = 'point-file-version-item';

            const label = document.createElement('span');
            label.className = 'point-file-version-label';
            label.textContent = `${savedAt} â€” ${actorUser} via ${actorTool}`;

            const openButton = document.createElement('button');
            openButton.type = 'button';
            openButton.className = 'point-file-version-open';
            openButton.textContent = 'Open in PointForge';
            openButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await openProjectPointFileVersionInPointForge(entry, version?.versionId, projectContext);
            });

            item.append(label, openButton);
            list.appendChild(item);
          }

          details.appendChild(list);
          details.dataset.loaded = 'true';
        } catch (err) {
          summary.textContent = 'Version timeline (failed to load)';
          const error = document.createElement('div');
          error.className = 'muted';
          error.style.padding = '0 0.55rem 0.55rem';
          error.textContent = err?.message || 'Unable to load version timeline.';
          details.appendChild(error);
        } finally {
          delete details.dataset.loading;
        }
      });
    }

    async function renameResourceFromEvidenceDesk(folder, entry, projectContext = {}) {
      const currentTitle = String(entry?.title || '').trim() || 'Untitled';
      const nextTitleRaw = window.prompt('Rename file', currentTitle);
      if (nextTitleRaw == null) return;

      const nextTitle = String(nextTitleRaw || '').trim();
      if (!nextTitle || nextTitle === currentTitle) return;

      const projectId = projectContext?.activeProjectId;
      if (!projectId) {
        renderError('Cannot rename resources without an active project.');
        return;
      }

      try {
        if (entry?.reference?.type === 'project-point-file') {
          const pointFileId = entry?.reference?.metadata?.pointFileId || entry?.reference?.value || entry?.id;
          const detailRes = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId));
          if (!detailRes.ok) throw new Error(`Unable to load point file (${detailRes.status}).`);
          const detail = await detailRes.json();
          const currentState = detail?.pointFile?.currentState;
          if (!currentState || typeof currentState !== 'object') {
            throw new Error('Point file state was missing.');
          }

          const actorMetadata = buildPointFileActorMetadata('project-browser');
          const renameRes = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId), {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json', ...actorMetadata.headers },
            body: JSON.stringify({
              pointFileName: nextTitle,
              pointFileState: currentState,
              source: 'project-browser',
              changeContext: actorMetadata.changeContext,
            }),
          });
          if (!renameRes.ok) throw new Error(`Unable to rename point file (${renameRes.status}).`);
          await syncProjectPointFilesFromApi(projectContext);
        } else if (entry?.reference?.type === 'project-drawing') {
          const drawingId = entry?.reference?.metadata?.drawingId || entry?.reference?.value || entry?.id;
          const detailRes = await fetch(buildProjectDrawingApiUrl(projectId, drawingId));
          if (!detailRes.ok) throw new Error(`Unable to load drawing (${detailRes.status}).`);
          const detail = await detailRes.json();
          const currentState = detail?.drawing?.currentState;
          if (!currentState || typeof currentState !== 'object') {
            throw new Error('Drawing state was missing.');
          }

          const renameRes = await fetch(buildProjectDrawingApiUrl(projectId, drawingId), {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              drawingName: nextTitle,
              drawingState: currentState,
            }),
          });
          if (!renameRes.ok) throw new Error(`Unable to rename drawing (${renameRes.status}).`);
          await syncProjectDrawingsFromApi(projectContext);
        } else {
          const renamed = renameResourceTitle(projectContext?.projectFile, folder?.key, entry?.id, nextTitle);
          if (!renamed) throw new Error('File rename could not be applied.');
        }

        saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
        projectContext.setUploadStatus(`Renamed ${currentTitle} to ${nextTitle}.`);
        renderTree(projectContext.projectFile, projectContext);
      } catch (err) {
        renderError(`Could not rename ${currentTitle}. ${err.message}`);
      }
    }

    async function deleteResourceFromEvidenceDesk(folder, entry, projectContext = {}) {
      const currentTitle = String(entry?.title || entry?.id || '').trim() || 'file';
      try {
        if (folder?.key === 'cpfs') {
          // Keep CP&F delete logic minimal here (confirm + remove).
          if (!window.confirm(`Remove "${currentTitle}" from the project?`)) return;
          const removed = removeResourceById(projectContext?.projectFile, folder?.key, entry?.id);
          if (!removed) throw new Error('File delete could not be applied.');
          saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
          projectContext.setUploadStatus(`Removed ${currentTitle}.`);
          renderTree(projectContext.projectFile, projectContext);
          return;
        }

        if (!window.confirm(`Remove "${currentTitle}" from the project?`)) return;

        const projectId = projectContext?.activeProjectId;
        if (!projectId) {
          renderError('Cannot delete resources without an active project.');
          return;
        }

        if (entry?.reference?.type === 'project-point-file') {
          const pointFileId = entry?.reference?.metadata?.pointFileId || entry?.reference?.value || entry?.id;
          if (!pointFileId) throw new Error('Point file id was missing.');
          const response = await fetch(buildProjectPointFileApiUrl(projectId, pointFileId), { method: 'DELETE' });
          if (!response.ok) throw new Error(`Unable to delete point file (${response.status}).`);
          await syncProjectPointFilesFromApi(projectContext);
        } else if (entry?.reference?.type === 'project-drawing') {
          const drawingId = entry?.reference?.metadata?.drawingId || entry?.reference?.value || entry?.id;
          if (!drawingId) throw new Error('Drawing id was missing.');
          const response = await fetch(buildProjectDrawingApiUrl(projectId, drawingId), { method: 'DELETE' });
          if (!response.ok) throw new Error(`Unable to delete drawing (${response.status}).`);
          await syncProjectDrawingsFromApi(projectContext);
        } else if (entry?.reference?.type === 'server-upload') {
          await deleteServerUploadResource(projectContext, folder?.key, entry);
          const removed = removeResourceById(projectContext?.projectFile, folder?.key, entry?.id);
          if (!removed) throw new Error('File delete could not be applied.');
        } else {
          const removed = removeResourceById(projectContext?.projectFile, folder?.key, entry?.id);
          if (!removed) throw new Error('File delete could not be applied.');
        }

        saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
        projectContext.setUploadStatus(`Removed ${currentTitle}.`);
        renderTree(projectContext.projectFile, projectContext);
      } catch (err) {
        renderError(`Could not remove ${currentTitle}. ${err.message}`);
      }
    }

    /* --------------------- Upload panel (basic, supports folder drop zone behavior) --------------------- */

    function createFileUploadPanel(projectContext) {
      const panel = document.createElement('div');
      panel.className = 'upload-panel';
      panel.innerHTML = `
        <div class="upload-actions">
          <label class="launch-btn">
            Upload filesâ€¦
            <input type="file" multiple />
          </label>
          <span class="muted">Drop files/folders here to upload into the selected folder.</span>
        </div>
        <div class="upload-status"></div>
        <progress class="upload-progress" max="100" hidden></progress>
      `;

      const fileInput = panel.querySelector('input[type="file"]');
      const statusEl = panel.querySelector('.upload-status');
      const progressEl = panel.querySelector('.upload-progress');

      projectContext.setUploadStatus = (msg) => { if (statusEl) statusEl.textContent = msg || ''; };
      projectContext.setUploadProgress = (pct) => {
        if (!progressEl) return;
        if (typeof pct === 'number' && Number.isFinite(pct)) {
          progressEl.hidden = false;
          progressEl.value = Math.max(0, Math.min(100, pct));
        } else {
          progressEl.hidden = true;
          progressEl.removeAttribute('value');
        }
      };

      const setDragActive = (active) => panel.classList.toggle('drag-active', Boolean(active));

      panel.addEventListener('dragover', (ev) => {
        ev.preventDefault();
        setDragActive(true);
      });
      panel.addEventListener('dragleave', (ev) => {
        if (panel.contains(ev.relatedTarget)) return;
        setDragActive(false);
      });
      panel.addEventListener('drop', async (ev) => {
        ev.preventDefault();
        setDragActive(false);
        // This app's root drop doesn't infer folder target; it relies on folder-row drops.
        projectContext.setUploadStatus('Drop files onto a folder to upload into that folder.');
      });

      fileInput?.addEventListener('change', () => {
        if (!fileInput.files?.length) return;
        projectContext.setUploadStatus('Drop files onto a folder to choose where to upload.');
        fileInput.value = '';
      });

      return panel;
    }

    function createPointFileUploadPanel(projectContext) {
      const panel = document.createElement('div');
      panel.className = 'upload-panel';
      panel.style.marginTop = '0.5rem';
      panel.innerHTML = `
        <div class="upload-actions">
          <span class="muted">Point files: upload CSV/TXT here (or drop onto the folder).</span>
        </div>
      `;
      return panel;
    }

    /* --------------------- Folder strip thumbnail builder --------------------- */

    function isFolderCollapsed(folderKey) {
      // Default: collapsed (true). Only expanded if explicitly set to false.
      return folderCollapseState.get(folderKey) !== false;
    }

    function openEntryFromFolder(folder, entry, projectContext) {
      const pointFileFormat = String(entry?.exportFormat || '').toLowerCase();
      const isPointFileFormat = pointFileFormat === 'csv' || pointFileFormat === 'txt';
      const canLaunchPointForge = folder.key === 'point-files'
        && isPointFileFormat
        && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'server-upload' || entry?.reference?.type === 'project-point-file');
      const canOpenLineSmithDrawing = folder.key === 'drawings'
        && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'project-drawing');
      const canOpenCpfPdf = folder.key === 'cpfs' && entry?.exportFormat === 'pdf';
      if (canLaunchPointForge) {
        launchPointForgeFromResource(entry, projectContext).catch(() => {});
      } else if (canOpenLineSmithDrawing) {
        launchLineSmithFromDrawingResource(entry, projectContext).catch(() => {});
      } else if (canOpenCpfPdf) {
        openCpfPdfFromResource(entry);
      } else if (entry?.reference?.type === 'server-upload') {
        const downloadUrl = String(entry.reference.value || '').trim();
        if (entry?.exportFormat === 'pdf') {
          openPdfInNewWindow(downloadUrl);
        } else if (downloadUrl) {
          window.open(downloadUrl, '_blank', 'noopener,noreferrer');
        }
      }
    }

    async function attachThumbStripItemPreview(thumbImg, folder, entry) {
      const pointFileFormat = String(entry?.exportFormat || '').toLowerCase();
      const isPointFileFormat = pointFileFormat === 'csv' || pointFileFormat === 'txt';
      const canLaunchPointForge = folder.key === 'point-files' && isPointFileFormat
        && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'server-upload' || entry?.reference?.type === 'project-point-file');
      const canOpenLineSmithDrawing = folder.key === 'drawings'
        && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'project-drawing');
      const isPdfResource = entry?.exportFormat === 'pdf';
      if (canLaunchPointForge) {
        const text = await resolvePointFileText(entry);
        if (!text?.trim()) return;
        const url = renderPointFileThumbnailDataUrl(text, { width: 58, height: 58 });
        if (url) { thumbImg.src = url; thumbImg.dataset.thumbLoaded = 'true'; }
      } else if (canOpenLineSmithDrawing) {
        const points = await resolveDrawingPoints(entry);
        if (!Array.isArray(points) || !points.length) return;
        const url = renderLineworkThumbnailDataUrl(points, { width: 58, height: 58 });
        if (url) { thumbImg.src = url; thumbImg.dataset.thumbLoaded = 'true'; }
      } else if (isPdfResource) {
        const pdfUrl = getPdfPreviewUrl(folder, entry);
        if (!pdfUrl) return;
        try {
          const dataUrl = await fetchPdfThumbnailDataUrl(pdfUrl);
          if (dataUrl) {
            thumbImg.src = dataUrl;
            thumbImg.classList.add('pdf-thumb-bg');
            thumbImg.dataset.thumbLoaded = 'true';
          }
        } catch { /* thumbnail unavailable */ }
      } else if (isImageResource(entry)) {
        const previewUrl = String(entry?.reference?.metadata?.thumbnailUrl || entry?.reference?.value || '').trim();
        if (previewUrl) {
          thumbImg.src = previewUrl;
          thumbImg.dataset.thumbLoaded = 'true';
        }
      }
    }

    function buildFolderThumbnailStrip(folder, projectContext) {
      const strip = document.createElement('div');
      strip.className = 'folder-thumbnail-strip';
      const entries = Array.isArray(folder.index) ? folder.index : [];
      if (!entries.length) {
        const emptyMsg = document.createElement('span');
        emptyMsg.className = 'folder-thumb-empty';
        emptyMsg.textContent = 'No files';
        strip.appendChild(emptyMsg);
        return strip;
      }
      for (const entry of entries) {
        const pointFileFormat = String(entry?.exportFormat || '').toLowerCase();
        const isPointFileFormat = pointFileFormat === 'csv' || pointFileFormat === 'txt';
        const canLaunchPointForge = folder.key === 'point-files' && isPointFileFormat
          && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'server-upload' || entry?.reference?.type === 'project-point-file');
        const canOpenLineSmithDrawing = folder.key === 'drawings'
          && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'project-drawing');
        const hasThumbnail = canLaunchPointForge || canOpenLineSmithDrawing
          || entry?.exportFormat === 'pdf' || isImageResource(entry);
        const item = document.createElement('div');
        item.className = 'folder-thumb-item';
        item.title = entry?.title || entry?.id || 'File';
        if (hasThumbnail) {
          const thumbImg = document.createElement('img');
          thumbImg.className = 'folder-thumb-img';
          thumbImg.alt = entry?.title || entry?.id || 'File';
          thumbImg.decoding = 'async';
          attachThumbStripItemPreview(thumbImg, folder, entry).catch(() => {});
          thumbImg.addEventListener('mouseenter', () => {
            if (thumbImg.dataset.thumbLoaded !== 'true') return;
            showCpfHoverPreviewTooltip(
              thumbImg,
              thumbImg.src,
              entry?.title || entry?.id || 'File preview',
              { width: thumbImg.naturalWidth, height: thumbImg.naturalHeight },
            );
          });
          thumbImg.addEventListener('mouseleave', () => hideCpfHoverPreviewTooltip());
          item.appendChild(thumbImg);
        } else {
          const placeholder = document.createElement('div');
          placeholder.className = 'folder-thumb-placeholder';
          placeholder.textContent = 'ðŸ“„';
          item.appendChild(placeholder);
        }
        const label = document.createElement('div');
        label.className = 'folder-thumb-label';
        label.textContent = entry?.title || entry?.id || 'File';
        item.appendChild(label);
        item.addEventListener('click', () => openEntryFromFolder(folder, entry, projectContext));
        strip.appendChild(item);
      }
      return strip;
    }

    /* --------------------- Drag support (ghost image + autoscroll) --------------------- */

    let dragAutoScrollTimer = null;

    function startDragAutoScroll() {
      if (dragAutoScrollTimer) return;
      dragAutoScrollTimer = setInterval(() => {
        // noop placeholder; keep for compatibility with earlier UI
      }, 125);
    }

    function stopDragAutoScroll() {
      if (dragAutoScrollTimer) clearInterval(dragAutoScrollTimer);
      dragAutoScrollTimer = null;
    }

    function buildFileDragImage(resource) {
      const thumbImg = resource.querySelector('.file-preview-slot img');
      if (!thumbImg || !thumbImg.src) return null;
      const ghost = document.createElement('div');
      ghost.className = 'file-drag-ghost';
      ghost.style.cssText = 'position:fixed;left:-9999px;top:-9999px;';
      const img = document.createElement('img');
      img.src = thumbImg.src;
      img.width = 86;
      img.height = 86;
      ghost.appendChild(img);
      document.body.appendChild(ghost);
      return ghost;
    }

    async function moveResourceFromEvidenceDesk(sourceFolder, targetFolder, entry, projectContext = {}) {
      const sourceFolderKey = String(sourceFolder?.key || '').trim();
      const targetFolderKey = String(targetFolder?.key || '').trim();
      if (!canMoveResourceBetweenFolders(entry, sourceFolderKey, targetFolderKey)) {
        projectContext.setUploadStatus('Only uploaded/local project-file entries can be moved between folders.');
        return false;
      }

      let moved = false;
      try {
        if (entry?.reference?.type === 'server-upload') {
          const movedResource = await moveServerUploadResource(projectContext, sourceFolderKey, targetFolderKey, entry);
          if (!movedResource) throw new Error('Move response was missing resource data.');
          removeResourceById(projectContext?.projectFile, sourceFolderKey, entry?.id);
          moved = appendResourceToFolder(projectContext?.projectFile, targetFolderKey, movedResource);
        } else {
          moved = moveResourceById(projectContext?.projectFile, sourceFolderKey, targetFolderKey, entry?.id);
        }

        if (!moved) {
          projectContext.setUploadStatus('Unable to move this file.');
          return false;
        }

        saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
        projectContext.setUploadStatus(`Moved ${entry?.title || entry?.id || 'file'} to ${targetFolder?.label || targetFolderKey}.`);
        renderTree(projectContext.projectFile, projectContext);
        return true;
      } catch (error) {
        projectContext.setUploadStatus(`Move failed: ${error.message || 'Unable to move this file.'}`);
        renderTree(projectContext.projectFile, projectContext);
        return false;
      }
    }

    /* --------------------- Association index (minimal stubs, preserves UI fields) --------------------- */

    function normalizeAssociationId(value) {
      return String(value || '').trim();
    }

    function buildDrawingAssociationIndex(projectFile) {
      const drawingsByPointFileId = new Map();
      const pointFileByDrawingId = new Map();

      const folders = Array.isArray(projectFile?.folders) ? projectFile.folders : [];
      const pointFilesFolder = folders.find((f) => f.key === 'point-files');
      const drawingsFolder = folders.find((f) => f.key === 'drawings');

      const pointFileNameById = new Map();
      for (const pf of (pointFilesFolder?.index || [])) {
        const id = normalizeAssociationId(pf?.reference?.metadata?.pointFileId || pf?.reference?.value || pf?.id || '');
        if (id) pointFileNameById.set(id, pf?.title || pf?.id || id);
      }

      for (const drawing of (drawingsFolder?.index || [])) {
        const metadata = drawing?.reference?.metadata || {};
        const drawingId = normalizeAssociationId(metadata?.drawingId || drawing?.reference?.value || drawing?.id || '');
        const linkedPointFileId = normalizeAssociationId(metadata?.linkedPointFileId || '');
        if (!drawingId || !linkedPointFileId) continue;
        const drawingTitle = drawing?.title || drawing?.id || 'Drawing';
        const linkedPointFileName = drawing?.reference?.metadata?.linkedPointFileName
          || pointFileNameById.get(linkedPointFileId)
          || linkedPointFileId;
        const associatedDrawings = drawingsByPointFileId.get(linkedPointFileId) || [];
        associatedDrawings.push(drawingTitle);
        drawingsByPointFileId.set(linkedPointFileId, associatedDrawings);
        pointFileByDrawingId.set(drawingId, linkedPointFileName);
      }

      return { drawingsByPointFileId, pointFileByDrawingId };
    }

    /* --------------------- Tree rendering --------------------- */

    function renderTree(projectFile, projectContext = {}) {
      treeContainer.innerHTML = '';
      if (Array.isArray(projectContext.uploadStatusListeners)) {
        projectContext.uploadStatusListeners = [];
      }

      const root = document.createElement('div');
      root.className = 'tree-root';
      root.innerHTML = `<span class="icon">ðŸ—‚ï¸</span><strong>${escapeHtml(projectFile.archive.rootFolderName)}</strong><span class="muted">(symbolic root folder)</span>`;

      const addRootFolderIconBtn = document.createElement('button');
      addRootFolderIconBtn.type = 'button';
      addRootFolderIconBtn.className = 'add-folder-icon-btn';
      addRootFolderIconBtn.title = 'New folder';
      addRootFolderIconBtn.textContent = '+';
      addRootFolderIconBtn.addEventListener('click', () => {
        const existing = treeContainer.querySelector('.add-root-folder-inline');
        if (existing) { existing.querySelector('input').focus(); return; }

        const inlineForm = document.createElement('div');
        inlineForm.className = 'add-folder-inline add-root-folder-inline';

        const folderIcon = document.createElement('span');
        folderIcon.className = 'icon';
        folderIcon.textContent = 'ðŸ“';

        const inlineInput = document.createElement('input');
        inlineInput.type = 'text';
        inlineInput.className = 'add-folder-input';
        inlineInput.placeholder = 'Folder nameâ€¦';
        inlineInput.maxLength = 60;

        const saveBtn = document.createElement('button');
        saveBtn.type = 'button';
        saveBtn.className = 'launch-btn';
        saveBtn.textContent = 'Add';

        const cancelBtn = document.createElement('button');
        cancelBtn.type = 'button';
        cancelBtn.className = 'add-folder-cancel-btn';
        cancelBtn.textContent = 'âœ•';
        cancelBtn.title = 'Cancel';

        inlineInput.addEventListener('keydown', (ev) => {
          ev.stopPropagation();
          if (ev.key === 'Enter') saveBtn.click();
          if (ev.key === 'Escape') inlineForm.remove();
        });
        saveBtn.addEventListener('click', () => {
          const label = inlineInput.value.trim();
          if (!label) { inlineInput.focus(); return; }
          const newFolder = addCustomFolder(projectContext.projectFile, { label });
          if (!newFolder) {
            projectContext.setUploadStatus(`Could not create folder "${label}".`);
            inlineForm.remove();
            return;
          }
          saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
          renderTree(projectContext.projectFile, projectContext);
        });
        cancelBtn.addEventListener('click', () => inlineForm.remove());

        inlineForm.appendChild(folderIcon);
        inlineForm.appendChild(inlineInput);
        inlineForm.appendChild(saveBtn);
        inlineForm.appendChild(cancelBtn);

        treeContainer.insertBefore(inlineForm, manifest);
        inlineInput.focus();
      });

      const treeHeaderRow = document.createElement('div');
      treeHeaderRow.className = 'tree-header-row';
      treeHeaderRow.appendChild(root);
      treeHeaderRow.appendChild(addRootFolderIconBtn);
      treeContainer.appendChild(treeHeaderRow);

      treeContainer.appendChild(createFileUploadPanel(projectContext));

      const associationIndex = buildDrawingAssociationIndex(projectFile);

      const folderChildrenContainerMap = new Map();
      for (const folder of projectFile.folders || []) {
        const parentChildrenContainer = folder.parentKey ? folderChildrenContainerMap.get(folder.parentKey) : null;
        let thumbnailStrip = null;
        let pointFileUploadPanel = null;
        const isCollapsed = isFolderCollapsed(folder.key);
        const folderGroupWrapper = document.createElement('div');
        folderGroupWrapper.className = 'folder-group';
        (parentChildrenContainer || treeContainer).appendChild(folderGroupWrapper);

        const folderUploadStatusText = document.createElement('div');
        folderUploadStatusText.className = 'upload-status';
        folderUploadStatusText.hidden = true;

        const folderUploadProgressBar = document.createElement('progress');
        folderUploadProgressBar.className = 'upload-progress';
        folderUploadProgressBar.max = 100;
        folderUploadProgressBar.hidden = true;

        const onFolderUploadStatus = (message, percent) => {
          if (message !== null) {
            folderUploadStatusText.textContent = message || '';
            folderUploadStatusText.hidden = !message;
          }
          if (typeof percent === 'number' && Number.isFinite(percent)) {
            folderUploadProgressBar.hidden = false;
            folderUploadProgressBar.value = Math.max(0, Math.min(100, percent));
          } else {
            folderUploadProgressBar.hidden = true;
            folderUploadProgressBar.removeAttribute('value');
          }
        };

        const folderRow = document.createElement('div');
        folderRow.className = 'folder-row';
        folderRow.dataset.folderKey = folder.key;
        folderRow.dataset.collapsed = isCollapsed ? 'true' : 'false';
        folderRow.innerHTML = `<span class="folder-collapse-chevron" aria-hidden="true">â–¶</span><span class="folder-title"><span class="icon">ðŸ“</span><strong>${escapeHtml(folder.label)}</strong><span class="muted">${escapeHtml(folder.description || '')}</span></span>`;

        folderRow.addEventListener('click', (event) => {
          if (event.target.closest('button, input, select, a')) return;
          const nowCollapsed = !isFolderCollapsed(folder.key);
          folderCollapseState.set(folder.key, nowCollapsed);
          folderRow.dataset.collapsed = nowCollapsed ? 'true' : 'false';
          if (thumbnailStrip) thumbnailStrip.hidden = !nowCollapsed;
          folderUploadFeedback.hidden = nowCollapsed;
          fileListContainer.hidden = nowCollapsed;
          if (pointFileUploadPanel) pointFileUploadPanel.hidden = nowCollapsed;
          childrenContainer.hidden = nowCollapsed;
        });

        folderRow.addEventListener('dragover', (event) => {
          const dragTypes = event.dataTransfer?.types ? Array.from(event.dataTransfer.types) : [];
          if (dragTypes.includes('application/x-surveycad-resource-move')) {
            event.preventDefault();
            folderRow.classList.add('folder-drop-target');
            return;
          }
          if (dragTypes.includes('Files')) {
            event.preventDefault();
            folderRow.classList.add('folder-upload-drop-target');
          }
        });

        folderRow.addEventListener('dragleave', () => {
          folderRow.classList.remove('folder-drop-target');
          folderRow.classList.remove('folder-upload-drop-target');
        });

        folderRow.addEventListener('drop', async (event) => {
          event.preventDefault();
          folderRow.classList.remove('folder-drop-target');
          folderRow.classList.remove('folder-upload-drop-target');
          const payloadRaw = event.dataTransfer?.getData('application/x-surveycad-resource-move');
          if (payloadRaw) {
            let payload = null;
            try {
              payload = JSON.parse(payloadRaw);
            } catch {
              return;
            }
            if (!payload?.resourceId || !payload?.sourceFolderKey || payload.sourceFolderKey === folder.key) return;
            const sourceFolder = projectFile.folders.find((candidate) => candidate.key === payload.sourceFolderKey);
            const draggedEntry = sourceFolder?.index?.find((candidate) => candidate?.id === payload.resourceId);
            if (!sourceFolder || !draggedEntry) return;
            await moveResourceFromEvidenceDesk(sourceFolder, folder, draggedEntry, projectContext);
            return;
          }
          if (event.dataTransfer?.files?.length) {
            // Upload via server API if present; otherwise fall back to local-only.
            projectContext.setUploadStatus('Upload endpoint not wired in this standalone build.');
            onFolderUploadStatus('Upload endpoint not wired in this standalone build.', null);
          }
        });

        if (folder.custom) {
          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'remove-folder-btn';
          removeBtn.textContent = 'Remove';
          removeBtn.title = 'Remove this custom folder (only allowed when empty and has no subfolders)';
          removeBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            if (Array.isArray(folder.index) && folder.index.length > 0) {
              projectContext.setUploadStatus(`Cannot remove "${folder.label}" â€” move or delete its files first.`);
              return;
            }
            if (getFolderChildren(projectContext.projectFile, folder.key).length > 0) {
              projectContext.setUploadStatus(`Cannot remove "${folder.label}" â€” remove its subfolders first.`);
              return;
            }
            if (!confirm(`Remove the custom folder "${folder.label}"?`)) return;
            const removed = removeCustomFolder(projectContext.projectFile, folder.key);
            if (!removed) {
              projectContext.setUploadStatus(`Could not remove "${folder.label}".`);
              return;
            }
            saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
            renderTree(projectContext.projectFile, projectContext);
          });
          folderRow.appendChild(removeBtn);
        }

        folderGroupWrapper.appendChild(folderRow);

        // When collapsed, show a horizontal thumbnail strip so you can skim the folder contents at a glance.
        thumbnailStrip = buildFolderThumbnailStrip(folder, projectContext);
        thumbnailStrip.hidden = !isCollapsed;
        folderGroupWrapper.appendChild(thumbnailStrip);

        const folderUploadFeedback = document.createElement('div');
        folderUploadFeedback.className = 'folder-upload-feedback';
        folderUploadFeedback.appendChild(folderUploadStatusText);
        folderUploadFeedback.appendChild(folderUploadProgressBar);
        folderGroupWrapper.appendChild(folderUploadFeedback);
        folderUploadFeedback.hidden = isCollapsed;

        if (folder.key === 'point-files') {
          pointFileUploadPanel = createPointFileUploadPanel(projectContext);
          pointFileUploadPanel.hidden = isCollapsed;
          folderGroupWrapper.appendChild(pointFileUploadPanel);
        }

        const fileListContainer = document.createElement('div');
        fileListContainer.className = 'file-list-container';
        fileListContainer.hidden = isCollapsed;

        folderGroupWrapper.appendChild(fileListContainer);

        if (!folder.index?.length) {
          const empty = document.createElement('div');
          empty.className = 'empty';
          empty.textContent = 'No linked resources yet.';
          fileListContainer.appendChild(empty);
        } else {
          function buildOneFileRow(entry) {
            const resource = document.createElement('div');
            resource.className = 'file-row';

            const canDragToMove = canMoveResourceBetweenFolders(entry, folder.key, '__other__');
            if (canDragToMove) {
              resource.classList.add('file-draggable');
              resource.draggable = true;
              resource.addEventListener('dragstart', (event) => {
                resource.classList.add('file-dragging');
                startDragAutoScroll();
                event.dataTransfer?.setData('application/x-surveycad-resource-move', JSON.stringify({
                  resourceId: entry.id,
                  sourceFolderKey: folder.key,
                }));
                if (event.dataTransfer) event.dataTransfer.effectAllowed = 'copyMove';
                const dragImage = buildFileDragImage(resource);
                if (dragImage && event.dataTransfer) {
                  event.dataTransfer.setDragImage(dragImage, 49, 49);
                  requestAnimationFrame(() => dragImage.remove());
                }
                if (entry?.reference?.type === 'server-upload' && event.dataTransfer) {
                  const serverDownloadUrl = String(entry.reference.value || '').trim();
                  if (serverDownloadUrl) {
                    const mimeType = getMimeTypeFromFormat(entry?.exportFormat || '');
                    const fileName = entry?.title || `${entry.id}.${entry.exportFormat}`;
                    const absoluteUrl = new URL(serverDownloadUrl, window.location.origin).href;
                    event.dataTransfer.setData('DownloadURL', `${mimeType}:${fileName}:${absoluteUrl}`);
                  }
                }
              });
              resource.addEventListener('dragend', () => {
                resource.classList.remove('file-dragging');
                stopDragAutoScroll();
              });
            }

            const pointFileFormat = String(entry?.exportFormat || '').toLowerCase();
            const isPointFileFormat = pointFileFormat === 'csv' || pointFileFormat === 'txt';
            const canLaunchPointForge = folder.key === 'point-files'
              && isPointFileFormat
              && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'server-upload' || entry?.reference?.type === 'project-point-file');
            const canOpenLineSmithDrawing = folder.key === 'drawings'
              && (entry?.reference?.type === 'local-storage' || entry?.reference?.type === 'project-drawing');
            const isPdfResource = entry?.exportFormat === 'pdf';
            const isImageUpload = isImageResource(entry);
            const showThumbnailSlot = canLaunchPointForge || canOpenLineSmithDrawing || isPdfResource || isImageUpload;
            const actualFileName = `${entry.id}.${entry.exportFormat}`;
            const configuredFileName = entry?.title || actualFileName;
            const leadingIcon = showThumbnailSlot ? '' : '<span class="icon">ðŸ“„</span>';
            const thumbnailSlotMarkup = showThumbnailSlot ? '<span class="file-preview-slot" aria-hidden="true"></span>' : '';
            const rosNumber = String(entry?.reference?.metadata?.rosNumber || '').trim();
            const pointNumber = String(entry?.reference?.metadata?.pointNumber || '').trim();
            const rosPillMarkup = rosNumber ? `<span class="ros-number-pill" title="Recorded map number for ROS linking">ROS # ${escapeHtml(rosNumber)}</span>` : '';
            const pointPillMarkup = pointNumber ? `<span class="ros-number-pill" title="Linked photo point number">PT # ${escapeHtml(pointNumber)}</span>` : '';
            const pointFileAssociations = associationIndex.drawingsByPointFileId.get(
              normalizeAssociationId(entry?.reference?.metadata?.pointFileId || entry?.reference?.value || entry?.id || ''),
            ) || [];
            const drawingAssociationName = associationIndex.pointFileByDrawingId.get(
              normalizeAssociationId(entry?.reference?.metadata?.drawingId || entry?.reference?.value || entry?.id || ''),
            ) || '';
            const pointFileAssociationMarkup = folder.key === 'point-files' && pointFileAssociations.length
              ? `<ul class="association-list" title="LineSmith drawings associated with this point file">${pointFileAssociations.map((title) => `<li class="association-list-item">â†³ Drawing: ${escapeHtml(title)}</li>`).join('')}</ul>`
              : '';
            const drawingAssociationMarkup = folder.key === 'drawings' && drawingAssociationName
              ? `<ul class="association-list" title="Point file associated with this drawing"><li class="association-list-item">â†³ Point file: ${escapeHtml(drawingAssociationName)}</li></ul>`
              : '';

            resource.innerHTML = `<span class="file-meta">${leadingIcon}${thumbnailSlotMarkup}<span class="file-name"><span class="file-name-primary"><span class="file-name-configured" title="${escapeHtml(actualFileName)}">${escapeHtml(configuredFileName)}</span>${rosPillMarkup}${pointPillMarkup}</span>${pointFileAssociationMarkup}${drawingAssociationMarkup}</span></span>`;

            const actionButtons = document.createElement('div');
            actionButtons.className = 'file-actions';
            resource.appendChild(actionButtons);

            if (canLaunchPointForge) {
              attachPointFilePreview(resource, entry).catch(() => {});
              resource.classList.add('pointforge-openable');
              resource.setAttribute('role', 'button');
              resource.setAttribute('tabindex', '0');
              resource.title = 'Tap to open this point file in PointForge';
              resource.addEventListener('click', () => launchPointForgeFromResource(entry, projectContext));
              resource.addEventListener('keydown', (event) => {
                if (event.key !== 'Enter' && event.key !== ' ') return;
                event.preventDefault();
                launchPointForgeFromResource(entry, projectContext);
              });

              const openButton = document.createElement('button');
              openButton.type = 'button';
              openButton.className = 'launch-btn';
              openButton.textContent = 'Open in PointForge';
              openButton.title = 'Loads this point file into PointForge input';
              openButton.addEventListener('click', (event) => {
                event.stopPropagation();
                launchPointForgeFromResource(entry, projectContext);
              });
              actionButtons.appendChild(openButton);
            }

            if (canOpenLineSmithDrawing) {
              attachDrawingPreview(resource, entry).catch(() => {});
              const openButton = document.createElement('button');
              openButton.type = 'button';
              openButton.className = 'launch-btn';
              openButton.textContent = 'Open in LineSmith';
              openButton.addEventListener('click', (event) => {
                event.stopPropagation();
                launchLineSmithFromDrawingResource(entry, projectContext);
              });
              actionButtons.appendChild(openButton);
            }

            if (isPdfResource) {
              attachPdfPreview(resource, folder, entry);
              const openButton = document.createElement('button');
              openButton.type = 'button';
              openButton.className = 'launch-btn';
              openButton.textContent = 'Open';
              openButton.addEventListener('click', (event) => {
                event.stopPropagation();
                openEntryFromFolder(folder, entry, projectContext);
              });
              actionButtons.appendChild(openButton);
            }

            if (isImageUpload) {
              attachImagePreview(resource, entry);
              const openButton = document.createElement('button');
              openButton.type = 'button';
              openButton.className = 'launch-btn';
              openButton.textContent = 'Open';
              openButton.addEventListener('click', (event) => {
                event.stopPropagation();
                openEntryFromFolder(folder, entry, projectContext);
              });
              actionButtons.appendChild(openButton);
            }

            const renameButton = document.createElement('button');
            renameButton.type = 'button';
            renameButton.className = 'launch-btn';
            renameButton.textContent = 'Rename';
            renameButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await renameResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            actionButtons.appendChild(renameButton);

            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'launch-btn';
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', async (event) => {
              event.stopPropagation();
              await deleteResourceFromEvidenceDesk(folder, entry, projectContext);
            });
            actionButtons.appendChild(deleteButton);

            return resource;
          }

          for (const entry of folder.index) {
            fileListContainer.appendChild(buildOneFileRow(entry));
          }
        }

        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'folder-children';
        childrenContainer.hidden = isCollapsed;
        folderGroupWrapper.appendChild(childrenContainer);
        folderChildrenContainerMap.set(folder.key, childrenContainer);

        const currentFolderDepth = getFolderDepth(projectFile, folder.key);
        if (currentFolderDepth < MAX_FOLDER_DEPTH) {
          const addSubfolderIconBtn = document.createElement('button');
          addSubfolderIconBtn.type = 'button';
          addSubfolderIconBtn.className = 'add-folder-icon-btn';
          addSubfolderIconBtn.title = 'Add subfolder';
          addSubfolderIconBtn.textContent = '+';
          addSubfolderIconBtn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const existing = childrenContainer.querySelector('.add-folder-inline');
            if (existing) { existing.querySelector('input').focus(); return; }

            const inlineForm = document.createElement('div');
            inlineForm.className = 'add-folder-inline';

            const folderIcon = document.createElement('span');
            folderIcon.className = 'icon';
            folderIcon.textContent = 'ðŸ“';

            const inlineInput = document.createElement('input');
            inlineInput.type = 'text';
            inlineInput.className = 'add-folder-input';
            inlineInput.placeholder = 'Subfolder nameâ€¦';
            inlineInput.maxLength = 60;

            const saveBtn = document.createElement('button');
            saveBtn.type = 'button';
            saveBtn.className = 'launch-btn';
            saveBtn.textContent = 'Add';

            const cancelBtn = document.createElement('button');
            cancelBtn.type = 'button';
            cancelBtn.className = 'add-folder-cancel-btn';
            cancelBtn.textContent = 'âœ•';
            cancelBtn.title = 'Cancel';

            inlineInput.addEventListener('keydown', (event) => {
              event.stopPropagation();
              if (event.key === 'Enter') saveBtn.click();
              if (event.key === 'Escape') inlineForm.remove();
            });
            saveBtn.addEventListener('click', () => {
              const label = inlineInput.value.trim();
              if (!label) { inlineInput.focus(); return; }
              const subfolder = addCustomFolder(projectContext.projectFile, { label, parentKey: folder.key });
              if (!subfolder) {
                projectContext.setUploadStatus(`Could not create subfolder â€” max depth (${MAX_FOLDER_DEPTH}) reached.`);
                inlineForm.remove();
                return;
              }
              saveStoredProjectFile(window.localStorage, projectContext.activeProjectId, projectContext.projectFile);
              renderTree(projectContext.projectFile, projectContext);
            });
            cancelBtn.addEventListener('click', () => inlineForm.remove());

            inlineForm.appendChild(folderIcon);
            inlineForm.appendChild(inlineInput);
            inlineForm.appendChild(saveBtn);
            inlineForm.appendChild(cancelBtn);
            childrenContainer.prepend(inlineForm);
            inlineInput.focus();
          });
          folderRow.appendChild(addSubfolderIconBtn);
        }
      }

      const manifest = document.createElement('div');
      manifest.className = 'file-row';
      manifest.style.marginLeft = '0';
      manifest.innerHTML = '<span class="icon">ðŸ“„</span>project-file.json';
      treeContainer.appendChild(manifest);
    }

    function renderError(message) {
      treeContainer.innerHTML = `<div class="error">${escapeHtml(message)}</div>`;
    }

    /* --------------------- Initialize with either server project-file or local fallback --------------------- */

    async function initialize() {
      // Minimal bootstrap: try to GET /api/project-files?projectId=... if present, else local fallback.
      const params = new URLSearchParams(window.location.search);
      const activeProjectId = params.get('projectId') || params.get('activeProjectId') || 'demo';
      const activeProjectName = params.get('projectName') || params.get('activeProjectName') || 'Demo Project';

      const projectContext = {
        activeProjectId,
        projectId: activeProjectId,
        projectName: activeProjectName,
        projectFile: null,
        uploadStatusListeners: [],
        setUploadStatus: () => {},
        setUploadProgress: () => {},
      };

      try {
        let projectFile = loadStoredProjectFile(window.localStorage, activeProjectId);

        if (!projectFile) {
          // Minimal default skeleton
          projectFile = {
            archive: { rootFolderName: activeProjectName },
            folders: [
              { key: 'cpfs', label: 'CP&Fs', description: 'Corner perpetuation & filing PDFs', parentKey: '', index: [] },
              { key: 'point-files', label: 'Point Files', description: 'CSV/TXT point files', parentKey: '', index: [] },
              { key: 'drawings', label: 'Drawings', description: 'LineSmith drawings', parentKey: '', index: [] },
              { key: '__other__', label: 'Other', description: 'Everything else', parentKey: '', index: [] },
            ],
          };
          saveStoredProjectFile(window.localStorage, activeProjectId, projectFile);
        }

        projectContext.projectFile = projectFile;
        renderTree(projectFile, projectContext);
      } catch (err) {
        renderError(`Project browser failed to load: ${err.message}`);
      }
    }

    initialize();
  </script>
</body>
</html>
