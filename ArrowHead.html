<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>ArrowHead — Mobile AR Overlay</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin: 0; height: 100%; background: #020617; color: #e2e8f0; font-family: Inter, system-ui, sans-serif; }
    .app { position: fixed; inset: 0; overflow: hidden; }
    video, canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }
    canvas { pointer-events: none; }
    .hud { position: absolute; left: 0; right: 0; top: 0; padding: 0.7rem; display: grid; gap: 0.45rem; background: linear-gradient(180deg, rgba(2,6,23,.84), rgba(2,6,23,.2)); }
    .row { display: flex; gap: 0.45rem; flex-wrap: wrap; }
    button { border: 1px solid rgba(148,163,184,.45); border-radius: 10px; background: rgba(15,23,42,.9); color: #e2e8f0; padding: 0.45rem 0.65rem; font-weight: 600; }
    .status { font-size: 0.82rem; color: #cbd5e1; text-shadow: 0 1px 2px #000; }
    .warn { color: #fbbf24; }
  </style>
</head>
<body>
  <div class="app">
    <video id="camera" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
    <div class="hud">
      <div class="row">
        <button id="startSensors">Start AR Sensors</button>
        <button id="recenter">Recenter</button>
      </div>
      <div id="status" class="status">Ready. Open from LineSmith to load overlay geometry.</div>
    </div>
  </div>
<script type="module">
import { deriveDevicePoseRadians, normalizeRadians } from "./src/arrowhead-math.js";
import { shouldApplyOrientationEvent } from "./src/arrowhead-math.js";
import { computeForwardDistanceMeters, computeRelativeBearingRad, resolvePointElevationFeet } from "./src/arrowhead-projection.js";
import { latLngToWorldAffine, worldToLatLngAffine } from "./src/georeference-transform.js";

(() => {
  const ARROWHEAD_IMPORT_STORAGE_KEY = 'lineSmithArrowHeadImport';
  const FEET_TO_METERS = 0.3048006096012192;
  const METERS_TO_FEET = 1 / FEET_TO_METERS;
  const ON_TARGET_CENTER_FRACTION = 0.1;

  const video = document.getElementById('camera');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');

  const state = {
    payload: null,
    userLat: NaN,
    userLon: NaN,
    userAltFeet: 0,
    headingRad: 0,
    pitchRad: 0,
    rollRad: 0,
    headingOffsetRad: 0,
    started: false,
    collabRoomId: "",
    collabSocket: null,
    remoteCursors: new Map(),
    remotePresence: new Map(),
    ownWorld: null,
    hasAbsoluteHeadingLock: false,
  };

  function setStatus(message, warn = false) {
    statusEl.textContent = message;
    statusEl.classList.toggle('warn', warn);
  }

  function resize() {
    canvas.width = Math.max(1, Math.floor(window.innerWidth * window.devicePixelRatio));
    canvas.height = Math.max(1, Math.floor(window.innerHeight * window.devicePixelRatio));
  }

  function worldToLatLng(x, y, georef) {
    return worldToLatLngAffine(x, y, georef);
  }

  function loadPayload() {
    const params = new URLSearchParams(window.location.search);
    if (params.get('source') !== 'linesmith') {
      setStatus('Launch ArrowHead from LineSmith to import points and lines.', true);
      return false;
    }
    const raw = localStorage.getItem(ARROWHEAD_IMPORT_STORAGE_KEY);
    if (!raw) {
      setStatus('LineSmith payload missing in local storage.', true);
      return false;
    }
    try {
      const payload = JSON.parse(raw);
      const points = payload && Array.isArray(payload.points) ? payload.points : [];
      const lines = payload && Array.isArray(payload.lines) ? payload.lines : [];
      const georef = payload ? payload.georeference : null;
      const roomId = payload ? payload.collabRoomId : "";
      const hasGeoref = georef && georef.lat && georef.lng;
      if (!points.length || !hasGeoref) {
        setStatus('LineSmith payload missing points or georeference.', true);
        return false;
      }
      state.payload = { points, lines, georef };
      state.collabRoomId = String(roomId || "").trim();
      return true;
    } catch {
      setStatus('Could not parse LineSmith payload.', true);
      return false;
    }
  }

  async function startCamera() {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } }, audio: false });
    video.srcObject = stream;
  }

  async function requestOrientationPermissionIfNeeded() {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      const result = await DeviceOrientationEvent.requestPermission();
      if (result !== 'granted') throw new Error('Device orientation permission denied.');
    }
  }

  function watchGeolocation() {
    navigator.geolocation.watchPosition((pos) => {
      state.userLat = pos.coords.latitude;
      state.userLon = pos.coords.longitude;
      const altitudeMeters = Number(pos.coords.altitude);
      if (Number.isFinite(altitudeMeters)) {
        state.userAltFeet = altitudeMeters * METERS_TO_FEET;
      }
      if (state.payload && state.payload.georef) {
        state.ownWorld = latLngToWorldAffine(state.userLat, state.userLon, state.payload.georef);
      }
      sendArPresence();
    }, () => {
      setStatus('GPS unavailable. Enable location for AR placement.', true);
    }, { enableHighAccuracy: true, timeout: 8000, maximumAge: 1000 });
  }

  function connectCollaboration() {
    if (!state.collabRoomId) return;
    const scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${scheme}://${window.location.host}/ws/lineforge?room=${encodeURIComponent(state.collabRoomId)}`;
    const socket = new WebSocket(wsUrl);
    state.collabSocket = socket;

    socket.addEventListener('close', () => {
      state.remoteCursors.clear();
      state.remotePresence.clear();
    });

    socket.addEventListener('message', (event) => {
      let message;
      try {
        message = JSON.parse(event.data);
      } catch {
        return;
      }
      if (message.type === 'cursor') {
        state.remoteCursors.set(message.clientId, {
          x: Number(message.cursor && message.cursor.x),
          y: Number(message.cursor && message.cursor.y),
          color: String(message.color || '#22d3ee'),
          at: Number(message.at) || Date.now(),
        });
        return;
      }
      if (message.type === 'peer-left') {
        state.remoteCursors.delete(message.clientId);
        state.remotePresence.delete(message.clientId);
        return;
      }
      if (message.type === 'ar-presence') {
        state.remotePresence.set(message.clientId, {
          x: Number(message.presence && message.presence.x),
          y: Number(message.presence && message.presence.y),
          headingRad: Number(message.presence && message.presence.headingRad),
          color: String(message.color || '#f97316'),
          at: Number(message.at) || Date.now(),
        });
      }
    });
  }

  function sendArPresence() {
    if (!state.collabSocket || state.collabSocket.readyState !== WebSocket.OPEN) return;
    state.collabSocket.send(JSON.stringify({
      type: 'ar-presence',
      presence: {
        x: Number(state.ownWorld && state.ownWorld.x),
        y: Number(state.ownWorld && state.ownWorld.y),
        lat: Number(state.userLat),
        lon: Number(state.userLon),
        altFeet: Number(state.userAltFeet),
        headingRad: Number(state.headingRad),
        pitchRad: Number(state.pitchRad),
        rollRad: Number(state.rollRad),
      },
    }));
  }

  function currentScreenAngle() {
    if (screen.orientation && Number.isFinite(Number(screen.orientation.angle))) {
      return Number(screen.orientation.angle);
    }
    if (Number.isFinite(Number(window.orientation))) {
      return Number(window.orientation);
    }
    return 0;
  }

  function attachOrientationSensors() {
    const applyOrientationEvent = (event) => {
      if (!shouldApplyOrientationEvent(event.type, event, state.hasAbsoluteHeadingLock)) return;
      const isAbsoluteEvent =
        String(event.type || '').toLowerCase() === 'deviceorientationabsolute'
        || event.absolute === true
        || Number.isFinite(Number(event.webkitCompassHeading));
      if (isAbsoluteEvent) state.hasAbsoluteHeadingLock = true;
      const pose = deriveDevicePoseRadians(event, currentScreenAngle(), state.headingOffsetRad);
      if (Number.isFinite(pose.headingRad)) state.headingRad = pose.headingRad;
      state.pitchRad = pose.pitchRad;
      state.rollRad = pose.rollRad;
      sendArPresence();
    };

    window.addEventListener('deviceorientationabsolute', applyOrientationEvent, true);
    window.addEventListener('deviceorientation', applyOrientationEvent, true);
    window.addEventListener('devicemotion', () => {
      // Subscribe so accelerometer/gyroscope streams are explicitly used by the app.
    });
  }

  function latLonDeltaMeters(lat0, lon0, lat1, lon1) {
    const dLat = (lat1 - lat0) * Math.PI / 180;
    const dLon = (lon1 - lon0) * Math.PI / 180;
    const meanLat = ((lat0 + lat1) * 0.5) * Math.PI / 180;
    const north = dLat * 6378137;
    const east = dLon * 6378137 * Math.cos(meanLat);
    return { east, north };
  }

  function projectWorldToScreen(pointLat, pointLon, pointZFeet) {
    if (!Number.isFinite(state.userLat) || !Number.isFinite(state.userLon)) return null;

    const { east, north } = latLonDeltaMeters(state.userLat, state.userLon, pointLat, pointLon);
    const up = (pointZFeet - state.userAltFeet) * FEET_TO_METERS;

    const horizontalDistance = Math.hypot(east, north);
    if (horizontalDistance < 0.01) return null;

    const targetBearingRad = Math.atan2(east, north);
    const relativeBearingRad = computeRelativeBearingRad(targetBearingRad, state.headingRad);
    const targetElevationRad = Math.atan2(up, horizontalDistance);
    const relativeElevationRad = targetElevationRad - state.pitchRad;

    const forwardDistance = computeForwardDistanceMeters(horizontalDistance, relativeBearingRad) * Math.cos(relativeElevationRad);
    if (forwardDistance <= 0.5) return null;

    const w = canvas.width;
    const h = canvas.height;
    const verticalFov = 68 * Math.PI / 180;
    const horizontalFov = 2 * Math.atan((w / h) * Math.tan(verticalFov * 0.5));
    const xFromBearing = (Math.tan(relativeBearingRad) / Math.tan(horizontalFov * 0.5)) * (w * 0.5);
    const yFromElevation = (Math.tan(relativeElevationRad) / Math.tan(verticalFov * 0.5)) * (h * 0.5);

    const cosRoll = Math.cos(state.rollRad);
    const sinRoll = Math.sin(state.rollRad);
    const xRotated = xFromBearing * cosRoll - yFromElevation * sinRoll;
    const yRotated = xFromBearing * sinRoll + yFromElevation * cosRoll;

    return {
      x: (w * 0.5) + xRotated,
      y: (h * 0.5) - yRotated,
      distanceM: Math.hypot(east, north, up),
    };
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!state.payload) return;

    const byId = new Map();
    const projected = [];
    for (const p of state.payload.points) {
      const ll = worldToLatLng(Number(p.x), Number(p.y), state.payload.georef);
      if (!ll) continue;
      const zFeet = resolvePointElevationFeet(p.z, state.userAltFeet);
      const scr = projectWorldToScreen(ll.lat, ll.lng, zFeet);
      if (!scr) continue;
      byId.set(p.id, scr);
      const pointNum = p && p.num != null ? p.num : '';
      projected.push({ x: scr.x, y: scr.y, distanceM: scr.distanceM, num: String(pointNum) });
    }

    ctx.lineWidth = Math.max(2, window.devicePixelRatio * 1.8);
    ctx.strokeStyle = 'rgba(56,189,248,0.9)';
    for (const line of state.payload.lines) {
      const a = byId.get(line.a);
      const b = byId.get(line.b);
      if (!a || !b) continue;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    }

    for (const p of projected) {
      ctx.fillStyle = 'rgba(248,250,252,0.95)';
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(4, window.devicePixelRatio * 3), 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(14,165,233,0.98)';
      ctx.font = `${Math.max(15, 13 * window.devicePixelRatio)}px Inter, system-ui, sans-serif`;
      ctx.fillText(`#${p.num}`, p.x + 10, p.y - 10);
    }

    const staleCutoff = Date.now() - 10000;
    for (const [clientId, cursor] of state.remoteCursors.entries()) {
      if (cursor.at < staleCutoff) {
        state.remoteCursors.delete(clientId);
        continue;
      }
      const ll = worldToLatLng(cursor.x, cursor.y, state.payload.georef);
      if (!ll) continue;
      const scr = projectWorldToScreen(ll.lat, ll.lng, state.userAltFeet);
      if (!scr) continue;
      ctx.strokeStyle = cursor.color;
      ctx.lineWidth = Math.max(2, window.devicePixelRatio * 2);
      ctx.beginPath();
      ctx.moveTo(scr.x - 8, scr.y);
      ctx.lineTo(scr.x + 8, scr.y);
      ctx.moveTo(scr.x, scr.y - 8);
      ctx.lineTo(scr.x, scr.y + 8);
      ctx.stroke();
      ctx.fillStyle = cursor.color;
      ctx.fillText(`LS ${String(clientId || '').slice(0, 6)}`, scr.x + 10, scr.y + 14);
    }

    for (const [clientId, peer] of state.remotePresence.entries()) {
      if (peer.at < staleCutoff) {
        state.remotePresence.delete(clientId);
        continue;
      }
      if (!Number.isFinite(peer.x) || !Number.isFinite(peer.y)) continue;
      const ll = worldToLatLng(peer.x, peer.y, state.payload.georef);
      if (!ll) continue;
      const scr = projectWorldToScreen(ll.lat, ll.lng, state.userAltFeet);
      if (!scr) continue;
      const headingDelta = Number.isFinite(peer.headingRad) ? normalizeRadians(peer.headingRad - state.headingRad) : 0;
      const radius = Math.max(10, window.devicePixelRatio * 8);
      ctx.fillStyle = peer.color;
      ctx.beginPath();
      ctx.moveTo(scr.x + Math.sin(headingDelta) * radius, scr.y - Math.cos(headingDelta) * radius);
      ctx.lineTo(scr.x + Math.sin(headingDelta + 2.5) * radius * 0.7, scr.y - Math.cos(headingDelta + 2.5) * radius * 0.7);
      ctx.lineTo(scr.x + Math.sin(headingDelta - 2.5) * radius * 0.7, scr.y - Math.cos(headingDelta - 2.5) * radius * 0.7);
      ctx.closePath();
      ctx.fill();
      ctx.fillText(`AR ${String(clientId || '').slice(0, 6)}`, scr.x + 10, scr.y - 12);
    }
    const centerX = canvas.width * 0.5;
    const centerY = canvas.height * 0.5;
    const centerHalfWidth = canvas.width * ON_TARGET_CENTER_FRACTION * 0.5;
    const centerHalfHeight = canvas.height * ON_TARGET_CENTER_FRACTION * 0.5;
    let onTargetPoint = null;
    for (const p of projected) {
      const inCenterX = Math.abs(p.x - centerX) <= centerHalfWidth;
      const inCenterY = Math.abs(p.y - centerY) <= centerHalfHeight;
      if (!inCenterX || !inCenterY) continue;
      if (!onTargetPoint || p.distanceM < onTargetPoint.distanceM) {
        onTargetPoint = p;
      }
    }

    if (onTargetPoint) {
      const ringRadius = Math.max(28, window.devicePixelRatio * 18);
      const distanceFeet = onTargetPoint.distanceM * METERS_TO_FEET;
      const onTargetLabel = `On target • ${onTargetPoint.distanceM.toFixed(1)} m (${distanceFeet.toFixed(1)} ft)`;
      ctx.lineWidth = Math.max(3, window.devicePixelRatio * 2.4);
      ctx.strokeStyle = 'rgba(34,197,94,0.95)';
      ctx.beginPath();
      ctx.arc(onTargetPoint.x, onTargetPoint.y, ringRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = 'rgba(34,197,94,0.98)';
      ctx.font = `${Math.max(16, 14 * window.devicePixelRatio)}px Inter, system-ui, sans-serif`;
      ctx.fillText(onTargetLabel, onTargetPoint.x + ringRadius + 10, onTargetPoint.y + 6);

    }

    setStatus(`AR live. Points: ${projected.length}/${state.payload.points.length}. Heading ${(state.headingRad * 180 / Math.PI).toFixed(1)}°`);
  }

  function renderLoop() {
    draw();
    requestAnimationFrame(renderLoop);
  }

  async function start() {
    if (state.started) return;
    if (!('mediaDevices' in navigator) || !navigator.mediaDevices.getUserMedia) {
      setStatus('Camera API unavailable on this device/browser.', true);
      return;
    }
    if (!('geolocation' in navigator)) {
      setStatus('Geolocation API unavailable on this device/browser.', true);
      return;
    }
    if (!loadPayload()) return;

    try {
      await requestOrientationPermissionIfNeeded();
      await startCamera();
      watchGeolocation();
      attachOrientationSensors();
      connectCollaboration();
      state.started = true;
      setStatus('Sensors enabled. Move your phone to align geometry with the field view.');
    } catch (error) {
      const errorMessage = error && error.message ? error.message : 'Could not start ArrowHead AR.';
      setStatus(String(errorMessage), true);
    }
  }

  document.getElementById('startSensors').addEventListener('click', start);
  document.getElementById('recenter').addEventListener('click', () => {
    state.headingOffsetRad = normalizeRadians(-state.headingRad);
    setStatus('Recentered current heading as forward.');
  });

  window.addEventListener('resize', resize);
  resize();
  renderLoop();
})();
</script>
</body>
</html>
