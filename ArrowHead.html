<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>ArrowHead — Mobile AR Overlay</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin: 0; height: 100%; background: #020617; color: #e2e8f0; font-family: Inter, system-ui, sans-serif; }
    .app {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      inset: 0;
      overflow: hidden;
    }
    video, canvas {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    canvas { pointer-events: none; }
    .hud { position: absolute; left: 0; right: 0; top: 0; padding: 0.7rem; display: grid; gap: 0.45rem; background: linear-gradient(180deg, rgba(2,6,23,.84), rgba(2,6,23,.2)); }
    .row { display: flex; gap: 0.45rem; flex-wrap: wrap; }
    button { border: 1px solid rgba(148,163,184,.45); border-radius: 10px; background: rgba(15,23,42,.9); color: #e2e8f0; padding: 0.45rem 0.65rem; font-weight: 600; }
    .status { font-size: 0.82rem; color: #cbd5e1; text-shadow: 0 1px 2px #000; }
    .debug { margin: 0; font-size: 0.74rem; line-height: 1.35; color: #93c5fd; text-shadow: 0 1px 2px #000; white-space: pre-wrap; }
    .warn { color: #fbbf24; }
  </style>
</head>
<body>
  <div class="app">
    <video id="camera" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
    <div class="hud">
      <div class="row">
        <button id="startSensors">Start AR Sensors</button>
        <button id="useGyro">Use Gyroscope Heading: Off</button>
        <button id="useMouseLook">Use Mouse Look: Off</button>
        <button id="recenter">Center</button>
      </div>
      <div id="status" class="status">Ready. Open from LineSmith to load overlay geometry.</div>
      <pre id="debugInfo" class="debug">Debug info will appear after sensors start.</pre>
    </div>
  </div>
<script type="module">
import { deriveDevicePoseRadians, integrateGyroscopeHeadingRadians, normalizeRadians } from "./src/arrowhead-math.js";
import { shouldApplyOrientationEvent } from "./src/arrowhead-math.js";
import { computeForwardDistanceMeters, computeObserverElevationFeet, computeRelativeBearingRad, projectEnuPointToScreen, resolvePointElevationFeet } from "./src/arrowhead-projection.js";
import { latLngToWorldAffine, worldToLatLngAffine } from "./src/georeference-transform.js";

(() => {
  const ARROWHEAD_IMPORT_STORAGE_KEY = 'lineSmithArrowHeadImport';
  const PROJECT_LAST_DRAWING_STORAGE_PREFIX = 'surveyfoundryLastLineSmithDrawing';
  const FEET_TO_METERS = 0.3048006096012192;
  const METERS_TO_FEET = 1 / FEET_TO_METERS;
  const DEFAULT_OBSERVER_HEIGHT_OFFSET_FEET = 3;
  const OPEN_ELEVATION_ENDPOINT = 'https://api.open-meteo.com/v1/elevation';
  const ON_TARGET_CENTER_FRACTION = 0.1;
  const GEOLOCATION_OPTIONS = { enableHighAccuracy: true, timeout: 30000, maximumAge: 1000 };
  const GEOLOCATION_RELAXED_OPTIONS = { enableHighAccuracy: false, maximumAge: 15000 };

  function isPotentiallyTrustworthyLocalHost(hostname) {
    return hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '[::1]';
  }

  function isSecureContextForDevicePermissions() {
    if (window.isSecureContext) return true;
    return isPotentiallyTrustworthyLocalHost(String(window.location.hostname || '').toLowerCase());
  }

  const video = document.getElementById('camera');
  const canvas = document.getElementById('overlay');
  const appEl = document.querySelector('.app');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const debugEl = document.getElementById('debugInfo');

  const state = {
    payload: null,
    userLat: NaN,
    userLon: NaN,
    userAltFeet: 0,
    rawUserAltFeet: NaN,
    headingRad: 0,
    pitchRad: 0,
    rollRad: 0,
    headingOffsetRad: 0,
    started: false,
    collabRoomId: "",
    collabSocket: null,
    remoteCursors: new Map(),
    remotePresence: new Map(),
    ownWorld: null,
    hasAbsoluteHeadingLock: false,
    lastAbsoluteOrientationEventMs: 0,
    lastPayloadRaw: '',
    payloadSyncIntervalId: 0,
    useGyroscopeHeading: false,
    gyroHeadingRawRad: 0,
    gyroHeadingOffsetRad: 0,
    lastGyroMotionMs: 0,
    useMouseLook: false,
    mouseLookActive: false,
    mouseLookPointerId: null,
    mouseLookLastX: 0,
    mouseLookLastY: 0,
    mouseLookSensitivity: 0.003,
    pointElevationFallbackFeetById: new Map(),
    elevationRequestSequence: 0,
  };

  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }

  function setStatus(message, warn = false) {
    statusEl.textContent = message;
    statusEl.classList.toggle('warn', warn);
  }

  function formatSigned(value, digits = 6) {
    if (!Number.isFinite(value)) return 'n/a';
    const abs = Math.abs(value).toFixed(digits);
    return value >= 0 ? `+${abs}` : `-${abs}`;
  }

  function formatDeg(rad) {
    if (!Number.isFinite(rad)) return 'n/a';
    return `${(rad * 180 / Math.PI).toFixed(1)}°`;
  }

  function formatMeters(value) {
    if (!Number.isFinite(value)) return 'n/a';
    return `${value.toFixed(2)} m`;
  }

  function updateDebugInfo(stats = null) {
    const lines = [];
    lines.push(`GPS lat/lon/alt(ft): ${formatSigned(state.userLat)} / ${formatSigned(state.userLon)} / ${Number.isFinite(state.userAltFeet) ? state.userAltFeet.toFixed(2) : 'n/a'}`);
    lines.push(`Altitude source (gps/raw+offset): ${Number.isFinite(state.rawUserAltFeet) ? state.rawUserAltFeet.toFixed(2) : 'n/a'} + ${DEFAULT_OBSERVER_HEIGHT_OFFSET_FEET.toFixed(1)} ft`);
    lines.push(`Pose heading/pitch/roll: ${formatDeg(state.headingRad)} / ${formatDeg(state.pitchRad)} / ${formatDeg(state.rollRad)}`);

    if (!state.payload) {
      lines.push('Payload: missing');
      debugEl.textContent = lines.join('\n');
      return;
    }

    const pointsTotal = state.payload.points.length;
    const linesTotal = state.payload.lines.length;
    lines.push(`Payload points/lines: ${pointsTotal} / ${linesTotal}`);

    if (stats) {
      lines.push(`Projection projected/total: ${stats.projectedCount}/${pointsTotal}`);
      lines.push(`Projection drops (bad geo | too close | behind): ${stats.dropBadGeoref} | ${stats.dropTooClose} | ${stats.dropBehind}`);
      if (stats.nearestPoint) {
        lines.push(`Nearest point #${stats.nearestPoint.num} (${stats.nearestPoint.id})`);
        lines.push(`Nearest distance (horizontal/3D): ${formatMeters(stats.nearestPoint.horizontalDistanceM)} / ${formatMeters(stats.nearestPoint.distanceM)}`);
        lines.push(`Nearest bearing abs/relative: ${formatDeg(stats.nearestPoint.absoluteBearingRad)} / ${formatDeg(stats.nearestPoint.relativeBearingRad)}`);
      } else {
        lines.push('Nearest point: unavailable (GPS or georef not ready)');
      }
    }

    debugEl.textContent = lines.join('\n');
  }

  function resize() {
    canvas.width = Math.max(1, Math.floor(window.innerWidth * window.devicePixelRatio));
    canvas.height = Math.max(1, Math.floor(window.innerHeight * window.devicePixelRatio));
  }

  function worldToLatLng(x, y, georef) {
    return worldToLatLngAffine(x, y, georef);
  }

  function parsePayloadRaw(raw) {
    try {
      const payload = JSON.parse(raw);
      const points = payload && Array.isArray(payload.points) ? payload.points : [];
      const lines = payload && Array.isArray(payload.lines) ? payload.lines : [];
      const georef = payload ? payload.georeference : null;
      const roomId = payload ? payload.collabRoomId : "";
      const hasGeoref = georef && georef.lat && georef.lng;
      if (!points.length || !hasGeoref) return null;
      return {
        payload: { points, lines, georef },
        roomId: String(roomId || "").trim()
      };
    } catch {
      return null;
    }
  }

  function projectLastDrawingStorageKey(projectId) {
    return `${PROJECT_LAST_DRAWING_STORAGE_PREFIX}:${projectId}`;
  }

  function loadLastOpenedProjectDrawing(projectId) {
    if (!projectId) return '';
    return String(localStorage.getItem(projectLastDrawingStorageKey(projectId)) || '').trim();
  }

  function loadStoredDrawingRecord(storageKey) {
    if (!storageKey) return null;
    try {
      const raw = localStorage.getItem(storageKey);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed && parsed.versions)) return null;
      return parsed;
    } catch {
      return null;
    }
  }

  function deepClone(value) {
    return JSON.parse(JSON.stringify(value));
  }

  function isPlainObject(value) {
    return !!value && typeof value === 'object' && !Array.isArray(value);
  }

  function applyStateDiff(base, diff) {
    if (diff === undefined) return deepClone(base);
    if (Array.isArray(diff)) {
      const source = Array.isArray(base) ? base : [];
      return diff.map((part, index) => applyStateDiff(source[index], part));
    }
    if (isPlainObject(diff)) {
      if (diff.__deleted) return undefined;
      const source = isPlainObject(base) ? base : {};
      const out = {};
      const keys = new Set(Object.keys(source).concat(Object.keys(diff)));
      for (const key of keys) {
        if (!(key in diff)) {
          out[key] = deepClone(source[key]);
          continue;
        }
        const merged = applyStateDiff(source[key], diff[key]);
        if (merged !== undefined) out[key] = merged;
      }
      return out;
    }
    return deepClone(diff);
  }

  function materializeDrawingVersion(record, versionIndex = -1) {
    if (!record || !Array.isArray(record.versions) || !record.versions.length) return null;
    const targetIndex = versionIndex >= 0 ? Math.min(versionIndex, record.versions.length - 1) : record.versions.length - 1;
    let state = deepClone(record.versions[0] && record.versions[0].baseState);
    if (!state) return null;
    for (let i = 1; i <= targetIndex; i += 1) {
      state = applyStateDiff(state, record.versions[i] && record.versions[i].diffFromPrevious);
    }
    if (!state.mapGeoreference && record.latestMapGeoreference) {
      state.mapGeoreference = deepClone(record.latestMapGeoreference);
    }
    return state;
  }

  function parsePayloadFromDrawingRecord(storageKey) {
    const record = loadStoredDrawingRecord(storageKey);
    if (!record) return null;
    const drawingState = materializeDrawingVersion(record, -1);
    if (!drawingState) return null;
    const points = Array.isArray(drawingState.points) ? drawingState.points : [];
    const lines = Array.isArray(drawingState.lines) ? drawingState.lines : [];
    const georef = drawingState.mapGeoreference;
    const hasGeoref = georef && georef.lat && georef.lng;
    if (!points.length || !hasGeoref) return null;
    return {
      createdAt: new Date().toISOString(),
      source: 'linesmith-last-opened-drawing',
      points: points.map((point) => ({
        id: point.id,
        num: String(point.num == null ? '' : point.num),
        x: Number(point.x),
        y: Number(point.y),
        z: Number(point.z),
        code: String(point.code == null ? '' : point.code),
        notes: String(point.notes == null ? '' : point.notes)
      })),
      lines: lines.map((line) => ({
        id: line.id,
        a: line.a,
        b: line.b
      })),
      georeference: {
        lat: { ax: Number(georef.lat.ax), by: Number(georef.lat.by), c: Number(georef.lat.c) },
        lng: { ax: Number(georef.lng.ax), by: Number(georef.lng.by), c: Number(georef.lng.c) }
      },
      collabRoomId: ''
    };
  }

  function tryLoadPayloadFromLastOpenedDrawing() {
    const params = new URLSearchParams(window.location.search);
    const activeProjectId = String(params.get('activeProjectId') || '').trim();
    if (!activeProjectId) return false;
    const storageKey = loadLastOpenedProjectDrawing(activeProjectId);
    if (!storageKey) return false;
    const payload = parsePayloadFromDrawingRecord(storageKey);
    if (!payload) return false;
    const payloadRaw = JSON.stringify(payload);
    localStorage.setItem(ARROWHEAD_IMPORT_STORAGE_KEY, payloadRaw);
    return refreshPayloadFromStorage({ raw: payloadRaw });
  }

  function refreshPayloadFromStorage(options = {}) {
    const raw = typeof options.raw === 'string' ? options.raw : localStorage.getItem(ARROWHEAD_IMPORT_STORAGE_KEY);
    if (!raw) {
      if (!state.payload) setStatus('LineSmith payload missing in local storage.', true);
      return false;
    }
    if (raw === state.lastPayloadRaw) return false;
    const parsed = parsePayloadRaw(raw);
    if (!parsed) {
      if (!state.payload) setStatus('LineSmith payload missing points or georeference.', true);
      return false;
    }
    state.payload = parsed.payload;
    state.pointElevationFallbackFeetById.clear();
    refreshObserverElevation();
    refreshPointElevationsFromOpenDataset();
    state.collabRoomId = parsed.roomId;
    state.lastPayloadRaw = raw;
    return true;
  }

  function buildPointElevationRequestBatch() {
    if (!state.payload || !state.payload.georef || !Array.isArray(state.payload.points)) return [];
    const pending = [];
    for (const point of state.payload.points) {
      const pointId = String(point && point.id || '');
      const zFeet = Number(point && point.z);
      if (Math.abs(zFeet) >= 1e-9) continue;
      if (!pointId || state.pointElevationFallbackFeetById.has(pointId)) continue;
      const ll = worldToLatLng(Number(point.x), Number(point.y), state.payload.georef);
      if (!ll) continue;
      pending.push({ pointId, lat: Number(ll.lat), lon: Number(ll.lng) });
    }
    return pending;
  }

  async function requestOpenElevationMeters(points) {
    if (!Array.isArray(points) || !points.length) return [];
    const latitude = points.map((point) => point.lat.toFixed(6)).join(',');
    const longitude = points.map((point) => point.lon.toFixed(6)).join(',');
    const response = await fetch(`${OPEN_ELEVATION_ENDPOINT}?latitude=${encodeURIComponent(latitude)}&longitude=${encodeURIComponent(longitude)}`);
    if (!response.ok) {
      throw new Error(`Open elevation request failed (${response.status})`);
    }
    const payload = await response.json();
    if (!payload || !Array.isArray(payload.elevation)) {
      throw new Error('Open elevation response missing elevation array.');
    }
    return payload.elevation;
  }

  function refreshObserverElevation() {
    let baselinePointElevationFeet = NaN;
    if (state.payload && Array.isArray(state.payload.points) && state.payload.points.length) {
      const firstPoint = state.payload.points[0];
      baselinePointElevationFeet = resolvePayloadPointElevationFeet(firstPoint);
    }
    state.userAltFeet = computeObserverElevationFeet(state.rawUserAltFeet, baselinePointElevationFeet, DEFAULT_OBSERVER_HEIGHT_OFFSET_FEET);
  }

  async function refreshPointElevationsFromOpenDataset() {
    const pending = buildPointElevationRequestBatch();
    if (!pending.length) return;

    const sequence = state.elevationRequestSequence + 1;
    state.elevationRequestSequence = sequence;

    const chunkSize = 100;
    try {
      for (let i = 0; i < pending.length; i += chunkSize) {
        const chunk = pending.slice(i, i + chunkSize);
        const elevationsMeters = await requestOpenElevationMeters(chunk);
        if (state.elevationRequestSequence !== sequence) return;
        for (let j = 0; j < chunk.length; j += 1) {
          const elevationMeters = Number(elevationsMeters[j]);
          if (!Number.isFinite(elevationMeters)) continue;
          state.pointElevationFallbackFeetById.set(chunk[j].pointId, elevationMeters * METERS_TO_FEET);
        }
      }
      refreshObserverElevation();
    } catch {
      setStatus('Unable to load open elevation data for zero-elevation points; using device altitude fallback.', true);
    }
  }

  function resolvePayloadPointElevationFeet(point) {
    const pointId = String(point && point.id || '');
    const fallbackElevationFeet = pointId ? Number(state.pointElevationFallbackFeetById.get(pointId)) : NaN;
    const defaultElevationFeet = Number.isFinite(fallbackElevationFeet) ? fallbackElevationFeet : state.userAltFeet;
    return resolvePointElevationFeet(point && point.z, defaultElevationFeet);
  }

  function loadPayload() {
    if (refreshPayloadFromStorage()) return true;
    if (tryLoadPayloadFromLastOpenedDrawing()) {
      setStatus('Loaded last-opened LineSmith drawing for this active project.');
      return true;
    }
    setStatus('No LineSmith payload found. Open LineSmith or launch ArrowHead with an active project that has a saved drawing.', true);
    return false;
  }

  function getCameraRequestor() {
    if (navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === 'function') {
      return (constraints) => navigator.mediaDevices.getUserMedia(constraints);
    }

    const legacyOwner =
      (typeof navigator.getUserMedia === 'function' && navigator) ||
      (typeof navigator.webkitGetUserMedia === 'function' && navigator) ||
      (typeof navigator.mozGetUserMedia === 'function' && navigator) ||
      (typeof navigator.msGetUserMedia === 'function' && navigator) ||
      (navigator.mediaDevices && typeof navigator.mediaDevices.webkitGetUserMedia === 'function' && navigator.mediaDevices) ||
      (navigator.mediaDevices && typeof navigator.mediaDevices.mozGetUserMedia === 'function' && navigator.mediaDevices);

    const legacyGetUserMedia = legacyOwner && (
      legacyOwner.getUserMedia ||
      legacyOwner.webkitGetUserMedia ||
      legacyOwner.mozGetUserMedia ||
      legacyOwner.msGetUserMedia
    );

    if (typeof legacyGetUserMedia !== 'function') return null;

    return (constraints) => new Promise((resolve, reject) => {
      legacyGetUserMedia.call(legacyOwner, constraints, resolve, reject);
    });
  }

  function hasCameraApi() {
    return typeof getCameraRequestor() === 'function';
  }

  function requestCameraStream(constraints) {
    const requestCamera = getCameraRequestor();
    if (typeof requestCamera !== 'function') {
      return Promise.reject(new Error('Camera API unavailable on this device/browser.'));
    }
    return requestCamera(constraints);
  }

  function describeError(error, fallbackMessage) {
    const fallback = String(fallbackMessage || 'Unknown error');
    if (!error) return fallback;
    const name = error && error.name ? String(error.name) : '';
    const message = error && error.message ? String(error.message) : '';
    if (name && message) return `${name}: ${message}`;
    if (message) return message;
    if (name) return name;
    return fallback;
  }

  function alertCameraStartError(error, contextMessage) {
    const base = describeError(error, contextMessage || 'Could not start camera.');
    const detail = contextMessage ? `${contextMessage}\n${base}` : base;
    const alertText = `ArrowHead camera start failed.\n${detail}`;
    if (typeof window !== 'undefined' && typeof window.alert === 'function') {
      window.alert(alertText);
    }
    return alertText;
  }

  async function startCamera() {
    let stream;
    let primaryError = null;
    try {
      stream = await requestCameraStream({ video: { facingMode: { ideal: 'environment' } }, audio: false });
    } catch (error) {
      primaryError = error;
      const errorName = String(error && error.name ? error.name : '');
      const needsFallback =
        errorName === 'OverconstrainedError' ||
        errorName === 'ConstraintNotSatisfiedError' ||
        errorName === 'NotFoundError' ||
        errorName === 'TypeError';
      if (!needsFallback) {
        alertCameraStartError(error);
        throw error;
      }
      try {
        stream = await requestCameraStream({ video: true, audio: false });
      } catch (fallbackError) {
        const context = `Primary request failed (${describeError(primaryError, 'Camera constraint error')}). Fallback request failed.`;
        alertCameraStartError(fallbackError, context);
        throw fallbackError;
      }
    }
    video.srcObject = stream;
  }

  async function requestOrientationPermissionIfNeeded() {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      const result = await DeviceOrientationEvent.requestPermission();
      return result === 'granted';
    }
    return true;
  }

  async function requestMotionPermissionIfNeeded() {
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      const result = await DeviceMotionEvent.requestPermission();
      return result === 'granted';
    }
    return true;
  }

  function enableMouseLookFallback(message) {
    state.useMouseLook = true;
    state.mouseLookActive = false;
    state.mouseLookPointerId = null;
    const mouseLookButton = document.getElementById('useMouseLook');
    if (mouseLookButton) mouseLookButton.textContent = 'Use Mouse Look: On';
    setStatus(message);
  }

  function applyGeolocationPosition(pos) {
    state.userLat = pos.coords.latitude;
    state.userLon = pos.coords.longitude;
    const altitudeMeters = Number(pos.coords.altitude);
    let nextRawAltFeet = state.rawUserAltFeet;
    if (Number.isFinite(altitudeMeters)) {
      nextRawAltFeet = altitudeMeters * METERS_TO_FEET;
    }
    state.rawUserAltFeet = nextRawAltFeet;
    refreshObserverElevation();
    if (state.payload && state.payload.georef) {
      state.ownWorld = latLngToWorldAffine(state.userLat, state.userLon, state.payload.georef);
    }
    sendArPresence();
  }

  function requestInitialGeolocationPermissionIfNeeded() {
    return new Promise((resolve) => {
      navigator.geolocation.getCurrentPosition((pos) => {
        applyGeolocationPosition(pos);
        resolve(true);
      }, () => {
        resolve(false);
      }, GEOLOCATION_OPTIONS);
    });
  }

  function watchGeolocation() {
    let hasFreshFix = false;
    const startWatch = (options) => navigator.geolocation.watchPosition((pos) => {
      hasFreshFix = true;
      applyGeolocationPosition(pos);
    }, (error) => {
      if (error && error.code === error.TIMEOUT && !hasFreshFix && options === GEOLOCATION_OPTIONS) {
        startWatch(GEOLOCATION_RELAXED_OPTIONS);
        return;
      }
      setStatus('GPS unavailable. Enable location for AR placement.', true);
    }, options);
    startWatch(GEOLOCATION_OPTIONS);
  }

  function connectCollaboration() {
    if (!state.collabRoomId) return;
    const scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${scheme}://${window.location.host}/ws/lineforge?room=${encodeURIComponent(state.collabRoomId)}`;
    const socket = new WebSocket(wsUrl);
    state.collabSocket = socket;

    socket.addEventListener('close', () => {
      state.remoteCursors.clear();
      state.remotePresence.clear();
    });

    socket.addEventListener('message', (event) => {
      let message;
      try {
        message = JSON.parse(event.data);
      } catch {
        return;
      }
      if (message.type === 'cursor') {
        state.remoteCursors.set(message.clientId, {
          x: Number(message.cursor && message.cursor.x),
          y: Number(message.cursor && message.cursor.y),
          color: String(message.color || '#22d3ee'),
          at: Number(message.at) || Date.now(),
        });
        return;
      }
      if (message.type === 'peer-left') {
        state.remoteCursors.delete(message.clientId);
        state.remotePresence.delete(message.clientId);
        return;
      }
      if (message.type === 'ar-presence') {
        state.remotePresence.set(message.clientId, {
          x: Number(message.presence && message.presence.x),
          y: Number(message.presence && message.presence.y),
          headingRad: Number(message.presence && message.presence.headingRad),
          color: String(message.color || '#f97316'),
          at: Number(message.at) || Date.now(),
        });
      }
    });
  }

  function sendArPresence() {
    if (!state.collabSocket || state.collabSocket.readyState !== WebSocket.OPEN) return;
    state.collabSocket.send(JSON.stringify({
      type: 'ar-presence',
      presence: {
        x: Number(state.ownWorld && state.ownWorld.x),
        y: Number(state.ownWorld && state.ownWorld.y),
        lat: Number(state.userLat),
        lon: Number(state.userLon),
        altFeet: Number(state.userAltFeet),
        headingRad: Number(state.headingRad),
        pitchRad: Number(state.pitchRad),
        rollRad: Number(state.rollRad),
      },
    }));
  }

  function currentScreenAngle() {
    if (screen.orientation && Number.isFinite(Number(screen.orientation.angle))) {
      return Number(screen.orientation.angle);
    }
    if (Number.isFinite(Number(window.orientation))) {
      return Number(window.orientation);
    }
    return 0;
  }

  function attachOrientationSensors() {
    const applyOrientationEvent = (event) => {
      const now = Date.now();
      if (!shouldApplyOrientationEvent(
        event.type,
        event,
        state.hasAbsoluteHeadingLock,
        state.lastAbsoluteOrientationEventMs,
        now,
      )) return;
      const isAbsoluteEvent =
        String(event.type || '').toLowerCase() === 'deviceorientationabsolute'
        || event.absolute === true
        || Number.isFinite(Number(event.webkitCompassHeading));
      if (isAbsoluteEvent) {
        state.hasAbsoluteHeadingLock = true;
        state.lastAbsoluteOrientationEventMs = now;
      }
      const pose = deriveDevicePoseRadians(event, currentScreenAngle(), state.headingOffsetRad);
      if (!state.useGyroscopeHeading && Number.isFinite(pose.headingRad)) state.headingRad = pose.headingRad;
      state.pitchRad = pose.pitchRad;
      state.rollRad = pose.rollRad;
      sendArPresence();
    };

    window.addEventListener('deviceorientationabsolute', applyOrientationEvent, true);
    window.addEventListener('deviceorientation', applyOrientationEvent, true);
    window.addEventListener('devicemotion', (event) => {
      // Subscribe so accelerometer/gyroscope streams are explicitly used by the app.
      if (!state.useGyroscopeHeading) return;
      const now = Date.now();
      if (!state.lastGyroMotionMs) {
        state.lastGyroMotionMs = now;
        return;
      }
      const dtMs = now - state.lastGyroMotionMs;
      state.lastGyroMotionMs = now;
      const rotationRateAlpha = Number(event && event.rotationRate && event.rotationRate.alpha);
      state.gyroHeadingRawRad = integrateGyroscopeHeadingRadians(state.gyroHeadingRawRad, rotationRateAlpha, dtMs);
      state.headingRad = normalizeRadians(state.gyroHeadingRawRad + state.gyroHeadingOffsetRad);
      sendArPresence();
    });
  }

  function attachMouseLookControls() {
    if (!appEl) return;
    appEl.addEventListener('pointerdown', (event) => {
      if (!state.useMouseLook) return;
      state.mouseLookActive = true;
      state.mouseLookPointerId = event.pointerId;
      state.mouseLookLastX = Number(event.clientX);
      state.mouseLookLastY = Number(event.clientY);
      if (typeof appEl.setPointerCapture === 'function') {
        appEl.setPointerCapture(event.pointerId);
      }
    });

    appEl.addEventListener('pointermove', (event) => {
      if (!state.useMouseLook || !state.mouseLookActive) return;
      if (state.mouseLookPointerId !== event.pointerId) return;
      const x = Number(event.clientX);
      const y = Number(event.clientY);
      const dx = x - state.mouseLookLastX;
      const dy = y - state.mouseLookLastY;
      state.mouseLookLastX = x;
      state.mouseLookLastY = y;

      state.headingRad = normalizeRadians(state.headingRad - (dx * state.mouseLookSensitivity));
      const pitchLimit = 80 * Math.PI / 180;
      state.pitchRad = clamp(state.pitchRad + (dy * state.mouseLookSensitivity), -pitchLimit, pitchLimit);
      sendArPresence();
    });

    const endMouseLook = (event) => {
      if (state.mouseLookPointerId !== event.pointerId) return;
      state.mouseLookActive = false;
      state.mouseLookPointerId = null;
      if (typeof appEl.releasePointerCapture === 'function') {
        appEl.releasePointerCapture(event.pointerId);
      }
    };

    appEl.addEventListener('pointerup', endMouseLook);
    appEl.addEventListener('pointercancel', endMouseLook);
  }

  function autoEnableMouseLookWhenSensorsUnavailable() {
    const hasOrientationEvents = 'ondeviceorientation' in window || 'ondeviceorientationabsolute' in window;
    if (hasOrientationEvents) return;
    state.useMouseLook = true;
    const mouseLookButton = document.getElementById('useMouseLook');
    if (mouseLookButton) mouseLookButton.textContent = 'Use Mouse Look: On';
    setStatus('Device orientation unavailable. Mouse look enabled; drag to look around.');
  }

  function latLonDeltaMeters(lat0, lon0, lat1, lon1) {
    const dLat = (lat1 - lat0) * Math.PI / 180;
    const dLon = (lon1 - lon0) * Math.PI / 180;
    const meanLat = ((lat0 + lat1) * 0.5) * Math.PI / 180;
    const north = dLat * 6378137;
    const east = dLon * 6378137 * Math.cos(meanLat);
    return { east, north };
  }

  function projectWorldToScreen(pointLat, pointLon, pointZFeet) {
    if (!Number.isFinite(state.userLat) || !Number.isFinite(state.userLon)) return null;

    const { east, north } = latLonDeltaMeters(state.userLat, state.userLon, pointLat, pointLon);
    const up = (pointZFeet - state.userAltFeet) * FEET_TO_METERS;

    const horizontalDistance = Math.hypot(east, north);
    if (horizontalDistance < 0.01) return null;

    const w = canvas.width;
    const h = canvas.height;
    const verticalFov = 68 * Math.PI / 180;
    const projection = projectEnuPointToScreen({
      eastMeters: east,
      northMeters: north,
      upMeters: up,
      headingRad: state.headingRad,
      pitchRad: state.pitchRad,
      rollRad: state.rollRad,
      viewportWidthPx: w,
      viewportHeightPx: h,
      verticalFovRad: verticalFov,
      nearClipMeters: 0.5,
    });
    if (!projection) return null;

    return {
      x: projection.x,
      y: projection.y,
      distanceM: Math.hypot(east, north, up),
    };
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!state.payload) {
      updateDebugInfo(null);
      return;
    }

    const byId = new Map();
    const projected = [];
    const drawStats = {
      projectedCount: 0,
      dropBadGeoref: 0,
      dropTooClose: 0,
      dropBehind: 0,
      nearestPoint: null,
    };
    const hasUserLocation = Number.isFinite(state.userLat) && Number.isFinite(state.userLon);

    for (const p of state.payload.points) {
      const ll = worldToLatLng(Number(p.x), Number(p.y), state.payload.georef);
      if (!ll) {
        drawStats.dropBadGeoref += 1;
        continue;
      }
      const zFeet = resolvePayloadPointElevationFeet(p);

      if (hasUserLocation) {
        const delta = latLonDeltaMeters(state.userLat, state.userLon, ll.lat, ll.lng);
        const upMeters = (zFeet - state.userAltFeet) * FEET_TO_METERS;
        const horizontalDistanceM = Math.hypot(delta.east, delta.north);
        const absoluteBearingRad = Math.atan2(delta.east, delta.north);
        const relativeBearingRad = computeRelativeBearingRad(absoluteBearingRad, state.headingRad);
        const distanceM = Math.hypot(delta.east, delta.north, upMeters);
        if (!drawStats.nearestPoint || horizontalDistanceM < drawStats.nearestPoint.horizontalDistanceM) {
          const pointNum = p && p.num != null ? p.num : '';
          drawStats.nearestPoint = {
            id: String(p.id || ''),
            num: String(pointNum),
            horizontalDistanceM,
            distanceM,
            absoluteBearingRad,
            relativeBearingRad,
          };
        }
      }

      const scr = projectWorldToScreen(ll.lat, ll.lng, zFeet);
      if (!scr) {
        if (hasUserLocation) {
          const delta = latLonDeltaMeters(state.userLat, state.userLon, ll.lat, ll.lng);
          const horizontalDistanceM = Math.hypot(delta.east, delta.north);
          if (horizontalDistanceM < 0.01) drawStats.dropTooClose += 1;
          else {
            const targetBearingRad = Math.atan2(delta.east, delta.north);
            const relativeBearingRad = computeRelativeBearingRad(targetBearingRad, state.headingRad);
            const forwardDistance = computeForwardDistanceMeters(horizontalDistanceM, relativeBearingRad);
            if (forwardDistance <= 0.5) drawStats.dropBehind += 1;
          }
        }
        continue;
      }
      byId.set(p.id, scr);
      const pointNum = p && p.num != null ? p.num : '';
      projected.push({ x: scr.x, y: scr.y, distanceM: scr.distanceM, num: String(pointNum) });
      drawStats.projectedCount += 1;
    }

    ctx.lineWidth = Math.max(2, window.devicePixelRatio * 1.8);
    ctx.strokeStyle = 'rgba(56,189,248,0.9)';
    for (const line of state.payload.lines) {
      const a = byId.get(line.a);
      const b = byId.get(line.b);
      if (!a || !b) continue;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    }

    for (const p of projected) {
      ctx.fillStyle = 'rgba(248,250,252,0.95)';
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(4, window.devicePixelRatio * 3), 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(14,165,233,0.98)';
      ctx.font = `${Math.max(15, 13 * window.devicePixelRatio)}px Inter, system-ui, sans-serif`;
      ctx.fillText(`#${p.num}`, p.x + 10, p.y - 10);
    }

    const staleCutoff = Date.now() - 10000;
    for (const [clientId, cursor] of state.remoteCursors.entries()) {
      if (cursor.at < staleCutoff) {
        state.remoteCursors.delete(clientId);
        continue;
      }
      const ll = worldToLatLng(cursor.x, cursor.y, state.payload.georef);
      if (!ll) continue;
      const scr = projectWorldToScreen(ll.lat, ll.lng, state.userAltFeet);
      if (!scr) continue;
      ctx.strokeStyle = cursor.color;
      ctx.lineWidth = Math.max(2, window.devicePixelRatio * 2);
      ctx.beginPath();
      ctx.moveTo(scr.x - 8, scr.y);
      ctx.lineTo(scr.x + 8, scr.y);
      ctx.moveTo(scr.x, scr.y - 8);
      ctx.lineTo(scr.x, scr.y + 8);
      ctx.stroke();
      ctx.fillStyle = cursor.color;
      ctx.fillText(`LS ${String(clientId || '').slice(0, 6)}`, scr.x + 10, scr.y + 14);
    }

    for (const [clientId, peer] of state.remotePresence.entries()) {
      if (peer.at < staleCutoff) {
        state.remotePresence.delete(clientId);
        continue;
      }
      if (!Number.isFinite(peer.x) || !Number.isFinite(peer.y)) continue;
      const ll = worldToLatLng(peer.x, peer.y, state.payload.georef);
      if (!ll) continue;
      const scr = projectWorldToScreen(ll.lat, ll.lng, state.userAltFeet);
      if (!scr) continue;
      const headingDelta = Number.isFinite(peer.headingRad) ? normalizeRadians(peer.headingRad - state.headingRad) : 0;
      const radius = Math.max(10, window.devicePixelRatio * 8);
      ctx.fillStyle = peer.color;
      ctx.beginPath();
      ctx.moveTo(scr.x + Math.sin(headingDelta) * radius, scr.y - Math.cos(headingDelta) * radius);
      ctx.lineTo(scr.x + Math.sin(headingDelta + 2.5) * radius * 0.7, scr.y - Math.cos(headingDelta + 2.5) * radius * 0.7);
      ctx.lineTo(scr.x + Math.sin(headingDelta - 2.5) * radius * 0.7, scr.y - Math.cos(headingDelta - 2.5) * radius * 0.7);
      ctx.closePath();
      ctx.fill();
      ctx.fillText(`AR ${String(clientId || '').slice(0, 6)}`, scr.x + 10, scr.y - 12);
    }
    const centerX = canvas.width * 0.5;
    const centerY = canvas.height * 0.5;
    const centerHalfWidth = canvas.width * ON_TARGET_CENTER_FRACTION * 0.5;
    const centerHalfHeight = canvas.height * ON_TARGET_CENTER_FRACTION * 0.5;
    let onTargetPoint = null;
    for (const p of projected) {
      const inCenterX = Math.abs(p.x - centerX) <= centerHalfWidth;
      const inCenterY = Math.abs(p.y - centerY) <= centerHalfHeight;
      if (!inCenterX || !inCenterY) continue;
      if (!onTargetPoint || p.distanceM < onTargetPoint.distanceM) {
        onTargetPoint = p;
      }
    }

    if (onTargetPoint) {
      const ringRadius = Math.max(28, window.devicePixelRatio * 18);
      const distanceFeet = onTargetPoint.distanceM * METERS_TO_FEET;
      const onTargetLabel = `On target • ${onTargetPoint.distanceM.toFixed(1)} m (${distanceFeet.toFixed(1)} ft)`;
      ctx.lineWidth = Math.max(3, window.devicePixelRatio * 2.4);
      ctx.strokeStyle = 'rgba(34,197,94,0.95)';
      ctx.beginPath();
      ctx.arc(onTargetPoint.x, onTargetPoint.y, ringRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = 'rgba(34,197,94,0.98)';
      ctx.font = `${Math.max(16, 14 * window.devicePixelRatio)}px Inter, system-ui, sans-serif`;
      ctx.fillText(onTargetLabel, onTargetPoint.x + ringRadius + 10, onTargetPoint.y + 6);

    }

    const headingSource = state.useGyroscopeHeading ? 'Gyro' : 'Mag';
    updateDebugInfo(drawStats);
    setStatus(`AR live (${headingSource}). Points: ${projected.length}/${state.payload.points.length}. Heading ${(state.headingRad * 180 / Math.PI).toFixed(1)}°`);
  }

  function startPayloadSyncWatchers() {
    if (state.payloadSyncIntervalId) window.clearInterval(state.payloadSyncIntervalId);
    window.addEventListener('storage', (event) => {
      if (event.key !== ARROWHEAD_IMPORT_STORAGE_KEY) return;
      refreshPayloadFromStorage({ raw: event.newValue });
    });
    state.payloadSyncIntervalId = window.setInterval(() => {
      refreshPayloadFromStorage();
    }, 1000);
  }

  function renderLoop() {
    draw();
    requestAnimationFrame(renderLoop);
  }

  async function start() {
    if (state.started) return;
    if (!isSecureContextForDevicePermissions()) {
      setStatus('ArrowHead sensor, location, and camera permissions require HTTPS on iOS Safari. Re-open this page over https:// (or localhost during development).', true);
      return;
    }
    if (!('geolocation' in navigator)) {
      setStatus('Geolocation API unavailable on this device/browser.', true);
      return;
    }
    if (!loadPayload()) return;
    startPayloadSyncWatchers();

    try {
      const cameraStartPromise = startCamera();
      const geolocationPermissionPromise = requestInitialGeolocationPermissionIfNeeded();
      const orientationPermissionPromise = requestOrientationPermissionIfNeeded();
      const motionPermissionPromise = requestMotionPermissionIfNeeded();
      await cameraStartPromise;
      const geolocationPermissionGranted = await geolocationPermissionPromise;
      const orientationPermissionGranted = await orientationPermissionPromise;
      const motionPermissionGranted = await motionPermissionPromise;
      watchGeolocation();
      attachOrientationSensors();
      connectCollaboration();
      state.started = true;
      if (!orientationPermissionGranted || !motionPermissionGranted) {
        enableMouseLookFallback('Camera + GPS enabled. iOS sensor access denied, so mouse look is enabled as a fallback.');
        return;
      }
      if (!geolocationPermissionGranted) {
        setStatus('Camera enabled. GPS permission denied, so points may not align until location access is granted.', true);
        return;
      }
      setStatus('Sensors enabled. Move your phone to align geometry with the field view.');
    } catch (error) {
      const errorMessage = describeError(error, 'Could not start ArrowHead AR.');
      if (/getUserMedia|camera/i.test(String(errorMessage)) && !hasCameraApi()) {
        setStatus('Camera API unavailable on this device/browser.', true);
        return;
      }
      setStatus(String(errorMessage), true);
    }
  }

  document.getElementById('startSensors').addEventListener('click', start);
  const gyroButton = document.getElementById('useGyro');
  const mouseLookButton = document.getElementById('useMouseLook');
  gyroButton.addEventListener('click', () => {
    state.useGyroscopeHeading = !state.useGyroscopeHeading;
    state.lastGyroMotionMs = 0;
    if (state.useGyroscopeHeading) {
      state.gyroHeadingRawRad = Number.isFinite(state.headingRad) ? state.headingRad : 0;
      state.gyroHeadingOffsetRad = 0;
      gyroButton.textContent = 'Use Gyroscope Heading: On';
      setStatus('Gyroscope heading enabled. Tap Center while level and facing due north to calibrate heading.');
      return;
    }
    gyroButton.textContent = 'Use Gyroscope Heading: Off';
    setStatus('Magnetometer heading enabled.');
  });
  mouseLookButton.addEventListener('click', () => {
    state.useMouseLook = !state.useMouseLook;
    state.mouseLookActive = false;
    state.mouseLookPointerId = null;
    if (state.useMouseLook) {
      mouseLookButton.textContent = 'Use Mouse Look: On';
      setStatus('Mouse look enabled. Drag anywhere on the view to look around the sphere.');
      return;
    }
    mouseLookButton.textContent = 'Use Mouse Look: Off';
    setStatus('Mouse look disabled.');
  });
  document.getElementById('recenter').addEventListener('click', () => {
    if (state.useGyroscopeHeading) {
      state.gyroHeadingOffsetRad = normalizeRadians(-state.gyroHeadingRawRad);
      state.headingRad = normalizeRadians(state.gyroHeadingRawRad + state.gyroHeadingOffsetRad);
      setStatus('Gyroscope centered. Keep phone level and face due north while calibrating.');
      return;
    }
    if (state.useMouseLook) {
      state.pitchRad = 0;
    }
    state.headingOffsetRad = normalizeRadians(-state.headingRad);
    setStatus('Recentered current heading as forward.');
  });

  window.addEventListener('resize', resize);
  attachMouseLookControls();
  autoEnableMouseLookWhenSensorsUnavailable();
  resize();
  renderLoop();
})();
</script>
</body>
</html>
